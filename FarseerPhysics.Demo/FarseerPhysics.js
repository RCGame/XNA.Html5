/**
 * @version 1.0.0.0
 * @copyright Copyright Â©  2018
 * @compiler Bridge.NET 17.2.0
 */
Bridge.assembly("FarseerPhysics", function ($asm, globals) {
    "use strict";

    Bridge.define("Element$1", function (T) { return {
        fields: {
            Parent: null,
            Span: null,
            Value: Bridge.getDefaultValue(T)
        },
        ctors: {
            init: function () {
                this.Span = new FarseerPhysics.Collision.AABB();
            },
            ctor: function (value, span) {
                this.$initialize();
                this.Span = span.$clone();
                this.Value = value;
                this.Parent = null;
            }
        }
    }; });

    /** @namespace FarseerPhysics.Collision */

    /**
     * An axis aligned bounding box.
     *
     * @public
     * @class FarseerPhysics.Collision.AABB
     */
    Bridge.define("FarseerPhysics.Collision.AABB", {
        $kind: "struct",
        statics: {
            fields: {
                _input: null
            },
            ctors: {
                init: function () {
                    this._input = new FarseerPhysics.Collision.DistanceInput();
                }
            },
            methods: {
                TestOverlap: function (a, b) {
                    a = {v:a};
                    b = {v:b};
                    return FarseerPhysics.Collision.AABB.TestOverlap$1(a, b);
                },
                TestOverlap$1: function (a, b) {
                    var d1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(b.v.LowerBound.$clone(), a.v.UpperBound.$clone());
                    var d2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(a.v.LowerBound.$clone(), b.v.UpperBound.$clone());

                    if (d1.X > 0.0 || d1.Y > 0.0) {
                        return false;
                    }

                    if (d2.X > 0.0 || d2.Y > 0.0) {
                        return false;
                    }

                    return true;
                },
                TestOverlap$2: function (shapeA, indexA, shapeB, indexB, xfA, xfB) {
                    FarseerPhysics.Collision.AABB._input.ProxyA.Set(shapeA, indexA);
                    FarseerPhysics.Collision.AABB._input.ProxyB.Set(shapeB, indexB);
                    FarseerPhysics.Collision.AABB._input.TransformA = xfA.v.$clone();
                    FarseerPhysics.Collision.AABB._input.TransformB = xfB.v.$clone();
                    FarseerPhysics.Collision.AABB._input.UseRadii = true;

                    var cache = { v : new FarseerPhysics.Collision.SimplexCache() };
                    var output = { v : new FarseerPhysics.Collision.DistanceOutput() };
                    FarseerPhysics.Collision.Distance.ComputeDistance(output, cache, FarseerPhysics.Collision.AABB._input);

                    return output.v.Distance < 1.1920929E-06;
                },
                getDefaultValue: function () { return new FarseerPhysics.Collision.AABB(); }
            }
        },
        fields: {
            /**
             * The lower vertex
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.AABB
             * @type Microsoft.Xna.Framework.Vector2
             */
            LowerBound: null,
            /**
             * The upper vertex
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.AABB
             * @type Microsoft.Xna.Framework.Vector2
             */
            UpperBound: null
        },
        props: {
            /**
             * Get the center of the AABB.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Center
             * @type Microsoft.Xna.Framework.Vector2
             */
            Center: {
                get: function () {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(this.LowerBound.$clone(), this.UpperBound.$clone())));
                }
            },
            /**
             * Get the extents of the AABB (half-widths).
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Extents
             * @type Microsoft.Xna.Framework.Vector2
             */
            Extents: {
                get: function () {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Subtraction(this.UpperBound.$clone(), this.LowerBound.$clone())));
                }
            },
            /**
             * Get the perimeter length
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Perimeter
             * @type number
             */
            Perimeter: {
                get: function () {
                    var wx = this.UpperBound.X - this.LowerBound.X;
                    var wy = this.UpperBound.Y - this.LowerBound.Y;
                    return 2.0 * (wx + wy);
                }
            },
            /**
             * Gets the vertices of the AABB.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Vertices
             * @type FarseerPhysics.Common.Vertices
             */
            Vertices: {
                get: function () {
                    var vertices = new FarseerPhysics.Common.Vertices.ctor();
                    vertices.add(this.LowerBound.$clone());
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(this.LowerBound.X, this.UpperBound.Y));
                    vertices.add(this.UpperBound.$clone());
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(this.UpperBound.X, this.LowerBound.Y));
                    return vertices;
                }
            },
            /**
             * first quadrant
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Q1
             * @type FarseerPhysics.Collision.AABB
             */
            Q1: {
                get: function () {
                    return new FarseerPhysics.Collision.AABB.$ctor1(this.Center.$clone(), this.UpperBound.$clone());
                }
            },
            Q2: {
                get: function () {
                    return new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(this.LowerBound.X, this.Center.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X, this.UpperBound.Y));
                }
            },
            Q3: {
                get: function () {
                    return new FarseerPhysics.Collision.AABB.$ctor1(this.LowerBound.$clone(), this.Center.$clone());
                }
            },
            Q4: {
                get: function () {
                    return new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X, this.LowerBound.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(this.UpperBound.X, this.Center.Y));
                }
            }
        },
        ctors: {
            init: function () {
                this.LowerBound = new Microsoft.Xna.Framework.Vector2();
                this.UpperBound = new Microsoft.Xna.Framework.Vector2();
            },
            $ctor1: function (min, max) {
                FarseerPhysics.Collision.AABB.$ctor3.call(this, min, max);
            },
            $ctor3: function (min, max) {
                this.$initialize();
                this.LowerBound = min.v.$clone();
                this.UpperBound = max.v.$clone();
            },
            $ctor2: function (center, width, height) {
                this.$initialize();
                this.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(center.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(width / 2, height / 2));
                this.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(width / 2, height / 2));
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            GetVertices: function () {
                var p1 = this.UpperBound.$clone();
                var p2 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.UpperBound.X, this.LowerBound.Y);
                var p3 = this.LowerBound.$clone();
                var p4 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.LowerBound.X, this.UpperBound.Y);
                return System.Array.init([p1.$clone(), p2.$clone(), p3.$clone(), p4.$clone()], Microsoft.Xna.Framework.Vector2);
            },
            /**
             * Verify that the bounds are sorted.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @return  {boolean}        <pre><code>true</code></pre> if this instance is valid; otherwise, <pre><code>false</code></pre>.
             */
            IsValid: function () {
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.UpperBound.$clone(), this.LowerBound.$clone());
                var valid = d.X >= 0.0 && d.Y >= 0.0;
                valid = valid && FarseerPhysics.Common.MathUtils.IsValid(this.LowerBound) && FarseerPhysics.Common.MathUtils.IsValid(this.UpperBound);
                return valid;
            },
            /**
             * Combine an AABB into this one.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @param   {FarseerPhysics.Collision.AABB}    aabb    The aabb.
             * @return  {void}
             */
            Combine: function (aabb) {
                this.LowerBound = Microsoft.Xna.Framework.Vector2.Min(this.LowerBound.$clone(), aabb.v.LowerBound.$clone());
                this.UpperBound = Microsoft.Xna.Framework.Vector2.Max(this.UpperBound.$clone(), aabb.v.UpperBound.$clone());
            },
            /**
             * Combine two AABBs into this one.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @param   {FarseerPhysics.Collision.AABB}    aabb1    The aabb1.
             * @param   {FarseerPhysics.Collision.AABB}    aabb2    The aabb2.
             * @return  {void}
             */
            Combine$1: function (aabb1, aabb2) {
                this.LowerBound = Microsoft.Xna.Framework.Vector2.Min(aabb1.v.LowerBound.$clone(), aabb2.v.LowerBound.$clone());
                this.UpperBound = Microsoft.Xna.Framework.Vector2.Max(aabb1.v.UpperBound.$clone(), aabb2.v.UpperBound.$clone());
            },
            /**
             * Does this aabb contain the provided AABB.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @param   {FarseerPhysics.Collision.AABB}    aabb    The aabb.
             * @return  {boolean}                                  <pre><code>true</code></pre> if it contains the specified aabb; otherwise, <pre><code>false</code></pre>.
             */
            Contains: function (aabb) {
                var result = true;
                result = result && this.LowerBound.X <= aabb.v.LowerBound.X;
                result = result && this.LowerBound.Y <= aabb.v.LowerBound.Y;
                result = result && aabb.v.UpperBound.X <= this.UpperBound.X;
                result = result && aabb.v.UpperBound.Y <= this.UpperBound.Y;
                return result;
            },
            /**
             * Determines whether the AAABB contains the specified point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @param   {Microsoft.Xna.Framework.Vector2}    point    The point.
             * @return  {boolean}                                     <pre><code>true</code></pre> if it contains the specified point; otherwise, <pre><code>false</code></pre>.
             */
            Contains$1: function (point) {
                if ((point.v.X > (this.LowerBound.X + FarseerPhysics.Settings.Epsilon) && point.v.X < (this.UpperBound.X - FarseerPhysics.Settings.Epsilon) && (point.v.Y > (this.LowerBound.Y + FarseerPhysics.Settings.Epsilon) && point.v.Y < (this.UpperBound.Y - FarseerPhysics.Settings.Epsilon)))) {
                    return true;
                }
                return false;
            },
            RayCast: function (output, input) {
                output.v = new FarseerPhysics.Collision.RayCastOutput();

                var tmin = -3.40282347E+38;
                var tmax = FarseerPhysics.Settings.MaxFloat;

                var p = input.v.Point1.$clone();
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), input.v.Point1.$clone());
                var absD = FarseerPhysics.Common.MathUtils.Abs(d.$clone());

                var normal = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                for (var i = 0; i < 2; i = (i + 1) | 0) {
                    var absD_i = i === 0 ? absD.X : absD.Y;
                    var lowerBound_i = i === 0 ? this.LowerBound.X : this.LowerBound.Y;
                    var upperBound_i = i === 0 ? this.UpperBound.X : this.UpperBound.Y;
                    var p_i = i === 0 ? p.X : p.Y;

                    if (absD_i < FarseerPhysics.Settings.Epsilon) {
                        if (p_i < lowerBound_i || upperBound_i < p_i) {
                            return false;
                        }
                    } else {
                        var d_i = i === 0 ? d.X : d.Y;

                        var inv_d = 1.0 / d_i;
                        var t1 = { v : (lowerBound_i - p_i) * inv_d };
                        var t2 = { v : (upperBound_i - p_i) * inv_d };

                        var s = -1.0;

                        if (t1.v > t2.v) {
                            FarseerPhysics.Common.MathUtils.Swap(System.Single, t1, t2);
                            s = 1.0;
                        }

                        if (t1.v > tmin) {
                            if (i === 0) {
                                normal.X = s;
                            } else {
                                normal.Y = s;
                            }

                            tmin = t1.v;
                        }

                        tmax = Math.min(tmax, t2.v);

                        if (tmin > tmax) {
                            return false;
                        }
                    }
                }

                if (tmin < 0.0 || input.v.MaxFraction < tmin) {
                    return false;
                }

                output.v.Fraction = tmin;
                output.v.Normal = normal.$clone();
                return true;
            },
            getHashCode: function () {
                var h = Bridge.addHash([1111638337, this.LowerBound, this.UpperBound]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.AABB)) {
                    return false;
                }
                return Bridge.equals(this.LowerBound, o.LowerBound) && Bridge.equals(this.UpperBound, o.UpperBound);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.AABB();
                s.LowerBound = this.LowerBound.$clone();
                s.UpperBound = this.UpperBound.$clone();
                return s;
            }
        }
    });

    /**
     * Used for computing contact manifolds.
     *
     * @public
     * @class FarseerPhysics.Collision.ClipVertex
     */
    Bridge.define("FarseerPhysics.Collision.ClipVertex", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.ClipVertex(); }
            }
        },
        fields: {
            ID: null,
            V: null
        },
        ctors: {
            init: function () {
                this.ID = new FarseerPhysics.Collision.ContactID();
                this.V = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3839642110, this.ID, this.V]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.ClipVertex)) {
                    return false;
                }
                return Bridge.equals(this.ID, o.ID) && Bridge.equals(this.V, o.V);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.ClipVertex();
                s.ID = this.ID.$clone();
                s.V = this.V.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Collision", {
        statics: {
            fields: {
                _edgeA: null,
                _proxyA: null,
                _proxyB: null,
                _xf: null,
                _limit11: null,
                _limit12: null,
                _limit21: null,
                _limit22: null,
                _radius: 0,
                _tmpNormals: null
            },
            ctors: {
                init: function () {
                    this._edgeA = new FarseerPhysics.Collision.FatEdge();
                    this._xf = new FarseerPhysics.Common.Transform();
                    this._limit11 = new Microsoft.Xna.Framework.Vector2();
                    this._limit12 = new Microsoft.Xna.Framework.Vector2();
                    this._limit21 = new Microsoft.Xna.Framework.Vector2();
                    this._limit22 = new Microsoft.Xna.Framework.Vector2();
                    this._proxyA = new FarseerPhysics.Collision.EPProxy();
                    this._proxyB = new FarseerPhysics.Collision.EPProxy();
                    this._tmpNormals = System.Array.init(2, function (){
                        return new Microsoft.Xna.Framework.Vector2();
                    }, Microsoft.Xna.Framework.Vector2);
                }
            },
            methods: {
                /**
                 * Evaluate the manifold with supplied transforms. This assumes
                 modest motion from the original state. This does not change the
                 point count, impulses, etc. The radii must come from the Shapes
                 that generated the manifold.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}    manifold      The manifold.
                 * @param   {FarseerPhysics.Common.Transform}      transformA    The transform for A.
                 * @param   {number}                               radiusA       The radius for A.
                 * @param   {FarseerPhysics.Common.Transform}      transformB    The transform for B.
                 * @param   {number}                               radiusB       The radius for B.
                 * @param   {Microsoft.Xna.Framework.Vector2}      normal        World vector pointing from A to B
                 * @param   {FarseerPhysics.Common.FixedArray2}    points        Torld contact point (point of intersection).
                 * @return  {void}
                 */
                GetWorldManifold: function (manifold, transformA, radiusA, transformB, radiusB, normal, points) {
                    points.v = new (FarseerPhysics.Common.FixedArray2$1(Microsoft.Xna.Framework.Vector2))();
                    normal.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                    if (manifold.v.PointCount === 0) {
                        normal.v = Microsoft.Xna.Framework.Vector2.UnitY.$clone();
                        return;
                    }

                    switch (manifold.v.Type) {
                        case FarseerPhysics.Collision.ManifoldType.Circles: 
                            {
                                var tmp = manifold.v.Points.getItem(0).$clone().LocalPoint.$clone();
                                var pointAx = transformA.v.Position.X + transformA.v.R.Col1.X * manifold.v.LocalPoint.X + transformA.v.R.Col2.X * manifold.v.LocalPoint.Y;

                                var pointAy = transformA.v.Position.Y + transformA.v.R.Col1.Y * manifold.v.LocalPoint.X + transformA.v.R.Col2.Y * manifold.v.LocalPoint.Y;

                                var pointBx = transformB.v.Position.X + transformB.v.R.Col1.X * tmp.X + transformB.v.R.Col2.X * tmp.Y;

                                var pointBy = transformB.v.Position.Y + transformB.v.R.Col1.Y * tmp.X + transformB.v.R.Col2.Y * tmp.Y;

                                normal.v.X = 1;
                                normal.v.Y = 0;

                                var result = (pointAx - pointBx) * (pointAx - pointBx) + (pointAy - pointBy) * (pointAy - pointBy);
                                if (result > 1.42108547E-14) {
                                    var tmpNormalx = pointBx - pointAx;
                                    var tmpNormaly = pointBy - pointAy;
                                    var factor = 1.0 / Math.sqrt(tmpNormalx * tmpNormalx + tmpNormaly * tmpNormaly);
                                    normal.v.X = tmpNormalx * factor;
                                    normal.v.Y = tmpNormaly * factor;
                                }

                                var c = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                                c.X = (pointAx + radiusA * normal.v.X) + (pointBx - radiusB * normal.v.X);
                                c.Y = (pointAy + radiusA * normal.v.Y) + (pointBy - radiusB * normal.v.Y);

                                points.v.setItem(0, Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, c.$clone()));
                            }
                            break;
                        case FarseerPhysics.Collision.ManifoldType.FaceA: 
                            {
                                normal.v.X = transformA.v.R.Col1.X * manifold.v.LocalNormal.X + transformA.v.R.Col2.X * manifold.v.LocalNormal.Y;
                                normal.v.Y = transformA.v.R.Col1.Y * manifold.v.LocalNormal.X + transformA.v.R.Col2.Y * manifold.v.LocalNormal.Y;

                                var planePointx = transformA.v.Position.X + transformA.v.R.Col1.X * manifold.v.LocalPoint.X + transformA.v.R.Col2.X * manifold.v.LocalPoint.Y;

                                var planePointy = transformA.v.Position.Y + transformA.v.R.Col1.Y * manifold.v.LocalPoint.X + transformA.v.R.Col2.Y * manifold.v.LocalPoint.Y;

                                for (var i = 0; i < manifold.v.PointCount; i = (i + 1) | 0) {
                                    var tmp1 = manifold.v.Points.getItem(i).$clone().LocalPoint.$clone();

                                    var clipPointx = transformB.v.Position.X + transformB.v.R.Col1.X * tmp1.X + transformB.v.R.Col2.X * tmp1.Y;

                                    var clipPointy = transformB.v.Position.Y + transformB.v.R.Col1.Y * tmp1.X + transformB.v.R.Col2.Y * tmp1.Y;

                                    var value = (clipPointx - planePointx) * normal.v.X + (clipPointy - planePointy) * normal.v.Y;

                                    var c1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                                    c1.X = (clipPointx + (radiusA - value) * normal.v.X) + (clipPointx - radiusB * normal.v.X);
                                    c1.Y = (clipPointy + (radiusA - value) * normal.v.Y) + (clipPointy - radiusB * normal.v.Y);

                                    points.v.setItem(i, Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, c1.$clone()));
                                }
                            }
                            break;
                        case FarseerPhysics.Collision.ManifoldType.FaceB: 
                            {
                                normal.v.X = transformB.v.R.Col1.X * manifold.v.LocalNormal.X + transformB.v.R.Col2.X * manifold.v.LocalNormal.Y;
                                normal.v.Y = transformB.v.R.Col1.Y * manifold.v.LocalNormal.X + transformB.v.R.Col2.Y * manifold.v.LocalNormal.Y;

                                var planePointx1 = transformB.v.Position.X + transformB.v.R.Col1.X * manifold.v.LocalPoint.X + transformB.v.R.Col2.X * manifold.v.LocalPoint.Y;

                                var planePointy1 = transformB.v.Position.Y + transformB.v.R.Col1.Y * manifold.v.LocalPoint.X + transformB.v.R.Col2.Y * manifold.v.LocalPoint.Y;

                                for (var i1 = 0; i1 < manifold.v.PointCount; i1 = (i1 + 1) | 0) {
                                    var tmp2 = manifold.v.Points.getItem(i1).$clone().LocalPoint.$clone();

                                    var clipPointx1 = transformA.v.Position.X + transformA.v.R.Col1.X * tmp2.X + transformA.v.R.Col2.X * tmp2.Y;

                                    var clipPointy1 = transformA.v.Position.Y + transformA.v.R.Col1.Y * tmp2.X + transformA.v.R.Col2.Y * tmp2.Y;

                                    var value1 = (clipPointx1 - planePointx1) * normal.v.X + (clipPointy1 - planePointy1) * normal.v.Y;

                                    var c2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                                    c2.X = (clipPointx1 - radiusA * normal.v.X) + (clipPointx1 + (radiusB - value1) * normal.v.X);
                                    c2.Y = (clipPointy1 - radiusA * normal.v.Y) + (clipPointy1 + (radiusB - value1) * normal.v.Y);

                                    points.v.setItem(i1, Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, c2.$clone()));
                                }
                                normal.v = Microsoft.Xna.Framework.Vector2.op_Multiply$1(normal.v.$clone(), -1);
                            }
                            break;
                        default: 
                            normal.v = Microsoft.Xna.Framework.Vector2.UnitY.$clone();
                            break;
                    }
                },
                GetPointStates: function (state1, state2, manifold1, manifold2) {
                    state1.v = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.PointState))();
                    state2.v = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.PointState))();

                    for (var i = 0; i < manifold1.v.PointCount; i = (i + 1) | 0) {
                        var id = manifold1.v.Points.getItem(i).$clone().Id.$clone();

                        state1.v.setItem(i, FarseerPhysics.Collision.PointState.Remove);

                        for (var j = 0; j < manifold2.v.PointCount; j = (j + 1) | 0) {
                            if (manifold2.v.Points.getItem(j).$clone().Id.Key === id.Key) {
                                state1.v.setItem(i, FarseerPhysics.Collision.PointState.Persist);
                                break;
                            }
                        }
                    }

                    for (var i1 = 0; i1 < manifold2.v.PointCount; i1 = (i1 + 1) | 0) {
                        var id1 = manifold2.v.Points.getItem(i1).$clone().Id.$clone();

                        state2.v.setItem(i1, FarseerPhysics.Collision.PointState.Add);

                        for (var j1 = 0; j1 < manifold1.v.PointCount; j1 = (j1 + 1) | 0) {
                            if (manifold1.v.Points.getItem(j1).$clone().Id.Key === id1.Key) {
                                state2.v.setItem(i1, FarseerPhysics.Collision.PointState.Persist);
                                break;
                            }
                        }
                    }
                },
                /**
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}              manifold    
                 * @param   {FarseerPhysics.Collision.Shapes.CircleShape}    circleA     
                 * @param   {FarseerPhysics.Common.Transform}                xfA         
                 * @param   {FarseerPhysics.Collision.Shapes.CircleShape}    circleB     
                 * @param   {FarseerPhysics.Common.Transform}                xfB
                 * @return  {void}
                 */
                CollideCircles: function (manifold, circleA, xfA, circleB, xfB) {
                    manifold.v.PointCount = 0;

                    var pAx = xfA.v.Position.X + xfA.v.R.Col1.X * circleA.Position.X + xfA.v.R.Col2.X * circleA.Position.Y;
                    var pAy = xfA.v.Position.Y + xfA.v.R.Col1.Y * circleA.Position.X + xfA.v.R.Col2.Y * circleA.Position.Y;
                    var pBx = xfB.v.Position.X + xfB.v.R.Col1.X * circleB.Position.X + xfB.v.R.Col2.X * circleB.Position.Y;
                    var pBy = xfB.v.Position.Y + xfB.v.R.Col1.Y * circleB.Position.X + xfB.v.R.Col2.Y * circleB.Position.Y;

                    var distSqr = (pBx - pAx) * (pBx - pAx) + (pBy - pAy) * (pBy - pAy);
                    var radius = circleA.Radius + circleB.Radius;
                    if (distSqr > radius * radius) {
                        return;
                    }

                    manifold.v.Type = FarseerPhysics.Collision.ManifoldType.Circles;
                    manifold.v.LocalPoint = circleA.Position.$clone();
                    manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    manifold.v.PointCount = 1;

                    var p0 = manifold.v.Points.getItem(0).$clone();

                    p0.LocalPoint = circleB.Position.$clone();
                    p0.Id.Key = 0;

                    manifold.v.Points.setItem(0, p0.$clone());
                },
                /**
                 * Compute the collision manifold between a polygon and a circle.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}               manifold      The manifold.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    polygonA      The polygon A.
                 * @param   {FarseerPhysics.Common.Transform}                 transformA    The transform of A.
                 * @param   {FarseerPhysics.Collision.Shapes.CircleShape}     circleB       The circle B.
                 * @param   {FarseerPhysics.Common.Transform}                 transformB    The transform of B.
                 * @return  {void}
                 */
                CollidePolygonAndCircle: function (manifold, polygonA, transformA, circleB, transformB) {
                    manifold.v.PointCount = 0;

                    var c = new Microsoft.Xna.Framework.Vector2.$ctor2(transformB.v.Position.X + transformB.v.R.Col1.X * circleB.Position.X + transformB.v.R.Col2.X * circleB.Position.Y, transformB.v.Position.Y + transformB.v.R.Col1.Y * circleB.Position.X + transformB.v.R.Col2.Y * circleB.Position.Y);
                    var cLocal = new Microsoft.Xna.Framework.Vector2.$ctor2((c.X - transformA.v.Position.X) * transformA.v.R.Col1.X + (c.Y - transformA.v.Position.Y) * transformA.v.R.Col1.Y, (c.X - transformA.v.Position.X) * transformA.v.R.Col2.X + (c.Y - transformA.v.Position.Y) * transformA.v.R.Col2.Y);

                    var normalIndex = 0;
                    var separation = -3.40282347E+38;
                    var radius = polygonA.Radius + circleB.Radius;
                    var vertexCount = polygonA.Vertices.Count;

                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var value1 = polygonA.Normals.getItem(i).$clone();
                        var value2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(), polygonA.Vertices.getItem(i).$clone());
                        var s = value1.X * value2.X + value1.Y * value2.Y;

                        if (s > radius) {
                            return;
                        }

                        if (s > separation) {
                            separation = s;
                            normalIndex = i;
                        }
                    }

                    var vertIndex1 = normalIndex;
                    var vertIndex2 = ((vertIndex1 + 1) | 0) < vertexCount ? ((vertIndex1 + 1) | 0) : 0;
                    var v1 = polygonA.Vertices.getItem(vertIndex1).$clone();
                    var v2 = polygonA.Vertices.getItem(vertIndex2).$clone();

                    if (separation < FarseerPhysics.Settings.Epsilon) {
                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        manifold.v.LocalNormal = polygonA.Normals.getItem(normalIndex).$clone();
                        manifold.v.LocalPoint = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(v1.$clone(), v2.$clone())));

                        var p0 = manifold.v.Points.getItem(0).$clone();

                        p0.LocalPoint = circleB.Position.$clone();
                        p0.Id.Key = 0;

                        manifold.v.Points.setItem(0, p0.$clone());

                        return;
                    }

                    var u1 = (cLocal.X - v1.X) * (v2.X - v1.X) + (cLocal.Y - v1.Y) * (v2.Y - v1.Y);
                    var u2 = (cLocal.X - v2.X) * (v1.X - v2.X) + (cLocal.Y - v2.Y) * (v1.Y - v2.Y);

                    if (u1 <= 0.0) {
                        var r = (cLocal.X - v1.X) * (cLocal.X - v1.X) + (cLocal.Y - v1.Y) * (cLocal.Y - v1.Y);
                        if (r > radius * radius) {
                            return;
                        }

                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(), v1.$clone());
                        var factor = 1.0 / Math.sqrt(manifold.v.LocalNormal.X * manifold.v.LocalNormal.X + manifold.v.LocalNormal.Y * manifold.v.LocalNormal.Y);
                        manifold.v.LocalNormal.X = manifold.v.LocalNormal.X * factor;
                        manifold.v.LocalNormal.Y = manifold.v.LocalNormal.Y * factor;
                        manifold.v.LocalPoint = v1.$clone();

                        var p0b = manifold.v.Points.getItem(0).$clone();

                        p0b.LocalPoint = circleB.Position.$clone();
                        p0b.Id.Key = 0;

                        manifold.v.Points.setItem(0, p0b.$clone());
                    } else if (u2 <= 0.0) {
                        var r1 = (cLocal.X - v2.X) * (cLocal.X - v2.X) + (cLocal.Y - v2.Y) * (cLocal.Y - v2.Y);
                        if (r1 > radius * radius) {
                            return;
                        }

                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(), v2.$clone());
                        var factor1 = 1.0 / Math.sqrt(manifold.v.LocalNormal.X * manifold.v.LocalNormal.X + manifold.v.LocalNormal.Y * manifold.v.LocalNormal.Y);
                        manifold.v.LocalNormal.X = manifold.v.LocalNormal.X * factor1;
                        manifold.v.LocalNormal.Y = manifold.v.LocalNormal.Y * factor1;
                        manifold.v.LocalPoint = v2.$clone();

                        var p0c = manifold.v.Points.getItem(0).$clone();

                        p0c.LocalPoint = circleB.Position.$clone();
                        p0c.Id.Key = 0;

                        manifold.v.Points.setItem(0, p0c.$clone());
                    } else {
                        var faceCenter = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(v1.$clone(), v2.$clone())));
                        var value11 = Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(), faceCenter.$clone());
                        var value21 = polygonA.Normals.getItem(vertIndex1).$clone();
                        var separation2 = value11.X * value21.X + value11.Y * value21.Y;
                        if (separation2 > radius) {
                            return;
                        }

                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        manifold.v.LocalNormal = polygonA.Normals.getItem(vertIndex1).$clone();
                        manifold.v.LocalPoint = faceCenter.$clone();

                        var p0d = manifold.v.Points.getItem(0).$clone();

                        p0d.LocalPoint = circleB.Position.$clone();
                        p0d.Id.Key = 0;

                        manifold.v.Points.setItem(0, p0d.$clone());
                    }
                },
                /**
                 * Compute the collision manifold between two polygons.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}               manifold      The manifold.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    polyA         The poly A.
                 * @param   {FarseerPhysics.Common.Transform}                 transformA    The transform A.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    polyB         The poly B.
                 * @param   {FarseerPhysics.Common.Transform}                 transformB    The transform B.
                 * @return  {void}
                 */
                CollidePolygons: function (manifold, polyA, transformA, polyB, transformB) {
                    manifold.v.PointCount = 0;
                    var totalRadius = polyA.Radius + polyB.Radius;

                    var edgeA = { v : 0 };
                    var separationA = FarseerPhysics.Collision.Collision.FindMaxSeparation(edgeA, polyA, transformA, polyB, transformB);
                    if (separationA > totalRadius) {
                        return;
                    }

                    var edgeB = { v : 0 };
                    var separationB = FarseerPhysics.Collision.Collision.FindMaxSeparation(edgeB, polyB, transformB, polyA, transformA);
                    if (separationB > totalRadius) {
                        return;
                    }

                    var poly1;
                    var poly2;
                    var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                    var edge1;
                    var flip;
                    var k_relativeTol = 0.98;
                    var k_absoluteTol = 0.001;

                    if (separationB > k_relativeTol * separationA + k_absoluteTol) {
                        poly1 = polyB;
                        poly2 = polyA;
                        xf1.v = transformB.v.$clone();
                        xf2.v = transformA.v.$clone();
                        edge1 = edgeB.v;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceB;
                        flip = true;
                    } else {
                        poly1 = polyA;
                        poly2 = polyB;
                        xf1.v = transformA.v.$clone();
                        xf2.v = transformB.v.$clone();
                        edge1 = edgeA.v;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        flip = false;
                    }

                    var incidentEdge = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    FarseerPhysics.Collision.Collision.FindIncidentEdge$1(incidentEdge, poly1, xf1, edge1, poly2, xf2);

                    var count1 = poly1.Vertices.Count;

                    var iv1 = edge1;
                    var iv2 = ((edge1 + 1) | 0) < count1 ? ((edge1 + 1) | 0) : 0;

                    var v11 = poly1.Vertices.getItem(iv1).$clone();
                    var v12 = poly1.Vertices.getItem(iv2).$clone();

                    var localTangentX = v12.X - v11.X;
                    var localTangentY = v12.Y - v11.Y;

                    var factor = 1.0 / Math.sqrt(localTangentX * localTangentX + localTangentY * localTangentY);
                    localTangentX = localTangentX * factor;
                    localTangentY = localTangentY * factor;

                    var localNormal = new Microsoft.Xna.Framework.Vector2.$ctor2(localTangentY, -localTangentX);
                    var planePoint = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(v11.$clone(), v12.$clone())));

                    var tangent = new Microsoft.Xna.Framework.Vector2.$ctor2(xf1.v.R.Col1.X * localTangentX + xf1.v.R.Col2.X * localTangentY, xf1.v.R.Col1.Y * localTangentX + xf1.v.R.Col2.Y * localTangentY);
                    var normalx = tangent.Y;
                    var normaly = -tangent.X;

                    v11 = new Microsoft.Xna.Framework.Vector2.$ctor2(xf1.v.Position.X + xf1.v.R.Col1.X * v11.X + xf1.v.R.Col2.X * v11.Y, xf1.v.Position.Y + xf1.v.R.Col1.Y * v11.X + xf1.v.R.Col2.Y * v11.Y);
                    v12 = new Microsoft.Xna.Framework.Vector2.$ctor2(xf1.v.Position.X + xf1.v.R.Col1.X * v12.X + xf1.v.R.Col2.X * v12.Y, xf1.v.Position.Y + xf1.v.R.Col1.Y * v12.X + xf1.v.R.Col2.Y * v12.Y);

                    var frontOffset = normalx * v11.X + normaly * v11.Y;

                    var sideOffset1 = -(tangent.X * v11.X + tangent.Y * v11.Y) + totalRadius;
                    var sideOffset2 = tangent.X * v12.X + tangent.Y * v12.Y + totalRadius;

                    var clipPoints1 = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    var clipPoints2 = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };

                    var np = FarseerPhysics.Collision.Collision.ClipSegmentToLine(clipPoints1, incidentEdge, Microsoft.Xna.Framework.Vector2.op_UnaryNegation(tangent.$clone()), sideOffset1, iv1);

                    if (np < 2) {
                        return;
                    }

                    np = FarseerPhysics.Collision.Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent.$clone(), sideOffset2, iv2);

                    if (np < 2) {
                        return;
                    }

                    manifold.v.LocalNormal = localNormal.$clone();
                    manifold.v.LocalPoint = planePoint.$clone();

                    var pointCount = 0;
                    for (var i = 0; i < FarseerPhysics.Settings.MaxManifoldPoints; i = (i + 1) | 0) {
                        var value = clipPoints2.v.getItem(i).$clone().V.$clone();
                        var separation = normalx * value.X + normaly * value.Y - frontOffset;

                        if (separation <= totalRadius) {
                            var cp = manifold.v.Points.getItem(pointCount).$clone();
                            var tmp = clipPoints2.v.getItem(i).$clone().V.$clone();
                            var tmp1X = tmp.X - xf2.v.Position.X;
                            var tmp1Y = tmp.Y - xf2.v.Position.Y;
                            cp.LocalPoint.X = tmp1X * xf2.v.R.Col1.X + tmp1Y * xf2.v.R.Col1.Y;
                            cp.LocalPoint.Y = tmp1X * xf2.v.R.Col2.X + tmp1Y * xf2.v.R.Col2.Y;
                            cp.Id = clipPoints2.v.getItem(i).$clone().ID.$clone();

                            if (flip) {
                                var cf = cp.Id.Features.$clone();
                                cp.Id.Features.IndexA = cf.IndexB;
                                cp.Id.Features.IndexB = cf.IndexA;
                                cp.Id.Features.TypeA = cf.TypeB;
                                cp.Id.Features.TypeB = cf.TypeA;
                            }

                            manifold.v.Points.setItem(pointCount, cp.$clone());

                            pointCount = (pointCount + 1) | 0;
                        }
                    }

                    manifold.v.PointCount = pointCount;
                },
                /**
                 * Compute contact points for edge versus circle.
                 This accounts for edge connectivity.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}              manifold      The manifold.
                 * @param   {FarseerPhysics.Collision.Shapes.EdgeShape}      edgeA         The edge A.
                 * @param   {FarseerPhysics.Common.Transform}                transformA    The transform A.
                 * @param   {FarseerPhysics.Collision.Shapes.CircleShape}    circleB       The circle B.
                 * @param   {FarseerPhysics.Common.Transform}                transformB    The transform B.
                 * @return  {void}
                 */
                CollideEdgeAndCircle: function (manifold, edgeA, transformA, circleB, transformB) {
                    manifold.v.PointCount = 0;

                    var Q = FarseerPhysics.Common.MathUtils.MultiplyT$2(transformA, FarseerPhysics.Common.MathUtils.Multiply$3(transformB, Bridge.ref(circleB, "_position")));

                    var A = edgeA.Vertex1.$clone(), B = edgeA.Vertex2.$clone();
                    var e = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(B.$clone(), A.$clone()) };

                    var u = Microsoft.Xna.Framework.Vector2.Dot(e.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(B.$clone(), Q.$clone()));
                    var v = Microsoft.Xna.Framework.Vector2.Dot(e.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), A.$clone()));

                    var radius = edgeA.Radius + circleB.Radius;

                    var cf = new FarseerPhysics.Collision.ContactFeature();
                    cf.IndexB = 0;
                    cf.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;

                    var P = new Microsoft.Xna.Framework.Vector2(), d = { v : new Microsoft.Xna.Framework.Vector2() };

                    if (v <= 0.0) {
                        P = A.$clone();
                        d.v = Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), P.$clone());
                        var dd = { };
                        Microsoft.Xna.Framework.Vector2.Dot$1(d, d, dd);
                        if (dd.v > radius * radius) {
                            return;
                        }

                        if (edgeA.HasVertex0) {
                            var A1 = edgeA.Vertex0.$clone();
                            var B1 = A.$clone();
                            var e1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(B1.$clone(), A1.$clone());
                            var u1 = Microsoft.Xna.Framework.Vector2.Dot(e1.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(B1.$clone(), Q.$clone()));

                            if (u1 > 0.0) {
                                return;
                            }
                        }

                        cf.IndexA = 0;
                        cf.TypeA = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.Circles;
                        manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        manifold.v.LocalPoint = P.$clone();
                        var mp = new FarseerPhysics.Collision.ManifoldPoint();
                        mp.Id.Key = 0;
                        mp.Id.Features = cf.$clone();
                        mp.LocalPoint = circleB.Position.$clone();
                        manifold.v.Points.setItem(0, mp.$clone());
                        return;
                    }

                    if (u <= 0.0) {
                        P = B.$clone();
                        d.v = Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), P.$clone());
                        var dd1 = { };
                        Microsoft.Xna.Framework.Vector2.Dot$1(d, d, dd1);
                        if (dd1.v > radius * radius) {
                            return;
                        }

                        if (edgeA.HasVertex3) {
                            var B2 = edgeA.Vertex3.$clone();
                            var A2 = B.$clone();
                            var e2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(B2.$clone(), A2.$clone());
                            var v2 = Microsoft.Xna.Framework.Vector2.Dot(e2.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), A2.$clone()));

                            if (v2 > 0.0) {
                                return;
                            }
                        }

                        cf.IndexA = 1;
                        cf.TypeA = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.Circles;
                        manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        manifold.v.LocalPoint = P.$clone();
                        var mp1 = new FarseerPhysics.Collision.ManifoldPoint();
                        mp1.Id.Key = 0;
                        mp1.Id.Features = cf.$clone();
                        mp1.LocalPoint = circleB.Position.$clone();
                        manifold.v.Points.setItem(0, mp1.$clone());
                        return;
                    }

                    var den = { };
                    Microsoft.Xna.Framework.Vector2.Dot$1(e, e, den);
                    System.Diagnostics.Debug.Assert(den.v > 0.0);
                    P = Microsoft.Xna.Framework.Vector2.op_Multiply$2((1.0 / den.v), (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(u, A.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(v, B.$clone()))));
                    d.v = Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), P.$clone());
                    var dd2 = { };
                    Microsoft.Xna.Framework.Vector2.Dot$1(d, d, dd2);
                    if (dd2.v > radius * radius) {
                        return;
                    }

                    var n = new Microsoft.Xna.Framework.Vector2.$ctor2(-e.v.Y, e.v.X);
                    if (Microsoft.Xna.Framework.Vector2.Dot(n.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), A.$clone())) < 0.0) {
                        n = new Microsoft.Xna.Framework.Vector2.$ctor2(-n.X, -n.Y);
                    }
                    n.Normalize();

                    cf.IndexA = 0;
                    cf.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    manifold.v.PointCount = 1;
                    manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                    manifold.v.LocalNormal = n.$clone();
                    manifold.v.LocalPoint = A.$clone();
                    var mp2 = new FarseerPhysics.Collision.ManifoldPoint();
                    mp2.Id.Key = 0;
                    mp2.Id.Features = cf.$clone();
                    mp2.LocalPoint = circleB.Position.$clone();
                    manifold.v.Points.setItem(0, mp2.$clone());
                },
                /**
                 * Collides and edge and a polygon, taking into account edge adjacency.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}               manifold    The manifold.
                 * @param   {FarseerPhysics.Collision.Shapes.EdgeShape}       edgeA       The edge A.
                 * @param   {FarseerPhysics.Common.Transform}                 xfA         The xf A.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    polygonB    The polygon B.
                 * @param   {FarseerPhysics.Common.Transform}                 xfB         The xf B.
                 * @return  {void}
                 */
                CollideEdgeAndPolygon: function (manifold, edgeA, xfA, polygonB, xfB) {
                    var $t, $t1, $t2, $t3, $t4, $t5;
                    FarseerPhysics.Common.MathUtils.MultiplyT$5(xfA, xfB, Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"));

                    FarseerPhysics.Collision.Collision._edgeA.V0 = edgeA.Vertex0.$clone();
                    FarseerPhysics.Collision.Collision._edgeA.V1 = edgeA.Vertex1.$clone();
                    FarseerPhysics.Collision.Collision._edgeA.V2 = edgeA.Vertex2.$clone();
                    FarseerPhysics.Collision.Collision._edgeA.V3 = edgeA.Vertex3.$clone();
                    var e = Microsoft.Xna.Framework.Vector2.op_Subtraction(FarseerPhysics.Collision.Collision._edgeA.V2.$clone(), FarseerPhysics.Collision.Collision._edgeA.V1.$clone());

                    FarseerPhysics.Collision.Collision._edgeA.Normal = new Microsoft.Xna.Framework.Vector2.$ctor2(e.Y, -e.X);
                    FarseerPhysics.Collision.Collision._edgeA.Normal.Normalize();
                    FarseerPhysics.Collision.Collision._edgeA.HasVertex0 = edgeA.HasVertex0;
                    FarseerPhysics.Collision.Collision._edgeA.HasVertex3 = edgeA.HasVertex3;

                    ($t = FarseerPhysics.Collision.Collision._proxyA.Vertices)[System.Array.index(0, $t)] = FarseerPhysics.Collision.Collision._edgeA.V1.$clone();
                    ($t1 = FarseerPhysics.Collision.Collision._proxyA.Vertices)[System.Array.index(1, $t1)] = FarseerPhysics.Collision.Collision._edgeA.V2.$clone();
                    ($t2 = FarseerPhysics.Collision.Collision._proxyA.Normals)[System.Array.index(0, $t2)] = FarseerPhysics.Collision.Collision._edgeA.Normal.$clone();
                    ($t3 = FarseerPhysics.Collision.Collision._proxyA.Normals)[System.Array.index(1, $t3)] = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.Collision._edgeA.Normal.$clone());
                    FarseerPhysics.Collision.Collision._proxyA.Centroid = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(FarseerPhysics.Collision.Collision._edgeA.V1.$clone(), FarseerPhysics.Collision.Collision._edgeA.V2.$clone())));
                    FarseerPhysics.Collision.Collision._proxyA.Count = 2;

                    FarseerPhysics.Collision.Collision._proxyB.Count = polygonB.Vertices.Count;
                    FarseerPhysics.Collision.Collision._proxyB.Centroid = FarseerPhysics.Common.MathUtils.Multiply$3(Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"), Bridge.ref(polygonB.MassData, "Centroid"));
                    for (var i = 0; i < polygonB.Vertices.Count; i = (i + 1) | 0) {
                        ($t4 = FarseerPhysics.Collision.Collision._proxyB.Vertices)[System.Array.index(i, $t4)] = FarseerPhysics.Common.MathUtils.Multiply$2(Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"), polygonB.Vertices.getItem(i).$clone());
                        ($t5 = FarseerPhysics.Collision.Collision._proxyB.Normals)[System.Array.index(i, $t5)] = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(FarseerPhysics.Collision.Collision._xf, "R"), polygonB.Normals.getItem(i).$clone());
                    }

                    FarseerPhysics.Collision.Collision._radius = 0.02;

                    FarseerPhysics.Collision.Collision._limit11 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    FarseerPhysics.Collision.Collision._limit12 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    FarseerPhysics.Collision.Collision._limit21 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    FarseerPhysics.Collision.Collision._limit22 = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                    manifold.v.PointCount = 0;

                    var v0 = FarseerPhysics.Collision.Collision._edgeA.V0.$clone();
                    var v1 = FarseerPhysics.Collision.Collision._edgeA.V1.$clone();
                    var v2 = FarseerPhysics.Collision.Collision._edgeA.V2.$clone();
                    var v3 = FarseerPhysics.Collision.Collision._edgeA.V3.$clone();

                    var centerB = FarseerPhysics.Collision.Collision._proxyB.Centroid.$clone();
                    if (FarseerPhysics.Collision.Collision._edgeA.HasVertex0) {
                        var e0 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), v0.$clone());
                        var e1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone());
                        var n0 = new Microsoft.Xna.Framework.Vector2.$ctor2(e0.Y, -e0.X);
                        var n1 = new Microsoft.Xna.Framework.Vector2.$ctor2(e1.Y, -e1.X);
                        n0.Normalize();
                        n1.Normalize();

                        var convex = FarseerPhysics.Common.MathUtils.Cross$2(n0.$clone(), n1.$clone()) >= 0.0;
                        var front0 = Microsoft.Xna.Framework.Vector2.Dot(n0.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(centerB.$clone(), v0.$clone())) >= 0.0;
                        var front1 = Microsoft.Xna.Framework.Vector2.Dot(n1.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(centerB.$clone(), v1.$clone())) >= 0.0;

                        if (convex) {
                            if (front0 || front1) {
                                FarseerPhysics.Collision.Collision._limit11 = n1.$clone();
                                FarseerPhysics.Collision.Collision._limit12 = n0.$clone();
                            } else {
                                FarseerPhysics.Collision.Collision._limit11 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n1.$clone());
                                FarseerPhysics.Collision.Collision._limit12 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n0.$clone());
                            }
                        } else {
                            if (front0 && front1) {
                                FarseerPhysics.Collision.Collision._limit11 = n0.$clone();
                                FarseerPhysics.Collision.Collision._limit12 = n1.$clone();
                            } else {
                                FarseerPhysics.Collision.Collision._limit11 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n0.$clone());
                                FarseerPhysics.Collision.Collision._limit12 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n1.$clone());
                            }
                        }
                    } else {
                        FarseerPhysics.Collision.Collision._limit11 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        FarseerPhysics.Collision.Collision._limit12 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    if (FarseerPhysics.Collision.Collision._edgeA.HasVertex3) {
                        var e11 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone());
                        var e2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v3.$clone(), v2.$clone());
                        var n11 = new Microsoft.Xna.Framework.Vector2.$ctor2(e11.Y, -e11.X);
                        var n2 = new Microsoft.Xna.Framework.Vector2.$ctor2(e2.Y, -e2.X);
                        n11.Normalize();
                        n2.Normalize();

                        var convex1 = FarseerPhysics.Common.MathUtils.Cross$2(n11.$clone(), n2.$clone()) >= 0.0;
                        var front11 = Microsoft.Xna.Framework.Vector2.Dot(n11.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(centerB.$clone(), v1.$clone())) >= 0.0;
                        var front2 = Microsoft.Xna.Framework.Vector2.Dot(n2.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(centerB.$clone(), v2.$clone())) >= 0.0;

                        if (convex1) {
                            if (front11 || front2) {
                                FarseerPhysics.Collision.Collision._limit21 = n2.$clone();
                                FarseerPhysics.Collision.Collision._limit22 = n11.$clone();
                            } else {
                                FarseerPhysics.Collision.Collision._limit21 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n2.$clone());
                                FarseerPhysics.Collision.Collision._limit22 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n11.$clone());
                            }
                        } else {
                            if (front11 && front2) {
                                FarseerPhysics.Collision.Collision._limit21 = n11.$clone();
                                FarseerPhysics.Collision.Collision._limit22 = n2.$clone();
                            } else {
                                FarseerPhysics.Collision.Collision._limit21 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n11.$clone());
                                FarseerPhysics.Collision.Collision._limit22 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n2.$clone());
                            }
                        }
                    } else {
                        FarseerPhysics.Collision.Collision._limit21 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        FarseerPhysics.Collision.Collision._limit22 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }


                    var edgeAxis = FarseerPhysics.Collision.Collision.ComputeEdgeSeparation();

                    if (edgeAxis.Type === FarseerPhysics.Collision.EPAxisType.Unknown) {
                        return;
                    }

                    if (edgeAxis.Separation > FarseerPhysics.Collision.Collision._radius) {
                        return;
                    }

                    var polygonAxis = FarseerPhysics.Collision.Collision.ComputePolygonSeparation();
                    if (polygonAxis.Type !== FarseerPhysics.Collision.EPAxisType.Unknown && polygonAxis.Separation > FarseerPhysics.Collision.Collision._radius) {
                        return;
                    }

                    var k_relativeTol = 0.98;
                    var k_absoluteTol = 0.001;

                    var primaryAxis = new FarseerPhysics.Collision.EPAxis();
                    if (polygonAxis.Type === FarseerPhysics.Collision.EPAxisType.Unknown) {
                        primaryAxis = edgeAxis.$clone();
                    } else if (polygonAxis.Separation > k_relativeTol * edgeAxis.Separation + k_absoluteTol) {
                        primaryAxis = polygonAxis.$clone();
                    } else {
                        primaryAxis = edgeAxis.$clone();
                    }

                    var proxy1;
                    var proxy2;
                    var incidentEdge = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    if (primaryAxis.Type === FarseerPhysics.Collision.EPAxisType.EdgeA) {
                        proxy1 = FarseerPhysics.Collision.Collision._proxyA;
                        proxy2 = FarseerPhysics.Collision.Collision._proxyB;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                    } else {
                        proxy1 = FarseerPhysics.Collision.Collision._proxyB;
                        proxy2 = FarseerPhysics.Collision.Collision._proxyA;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceB;
                    }

                    var edge1 = primaryAxis.Index;

                    FarseerPhysics.Collision.Collision.FindIncidentEdge(incidentEdge, proxy1, primaryAxis.Index, proxy2);
                    var count1 = proxy1.Count;

                    var iv1 = edge1;
                    var iv2 = ((edge1 + 1) | 0) < count1 ? ((edge1 + 1) | 0) : 0;

                    var v11 = proxy1.Vertices[System.Array.index(iv1, proxy1.Vertices)].$clone();
                    var v12 = proxy1.Vertices[System.Array.index(iv2, proxy1.Vertices)].$clone();

                    var tangent = Microsoft.Xna.Framework.Vector2.op_Subtraction(v12.$clone(), v11.$clone());
                    tangent.Normalize();

                    var normal = { v : FarseerPhysics.Common.MathUtils.Cross(tangent.$clone(), 1.0) };
                    var planePoint = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(v11.$clone(), v12.$clone()))) };

                    var frontOffset = Microsoft.Xna.Framework.Vector2.Dot(normal.v.$clone(), v11.$clone());

                    var sideOffset1 = -Microsoft.Xna.Framework.Vector2.Dot(tangent.$clone(), v11.$clone()) + FarseerPhysics.Collision.Collision._radius;
                    var sideOffset2 = Microsoft.Xna.Framework.Vector2.Dot(tangent.$clone(), v12.$clone()) + FarseerPhysics.Collision.Collision._radius;

                    var clipPoints1 = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    var clipPoints2 = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    var np;

                    np = FarseerPhysics.Collision.Collision.ClipSegmentToLine(clipPoints1, incidentEdge, Microsoft.Xna.Framework.Vector2.op_UnaryNegation(tangent.$clone()), sideOffset1, iv1);

                    if (np < FarseerPhysics.Settings.MaxManifoldPoints) {
                        return;
                    }

                    np = FarseerPhysics.Collision.Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent.$clone(), sideOffset2, iv2);

                    if (np < FarseerPhysics.Settings.MaxManifoldPoints) {
                        return;
                    }

                    if (primaryAxis.Type === FarseerPhysics.Collision.EPAxisType.EdgeA) {
                        manifold.v.LocalNormal = normal.v.$clone();
                        manifold.v.LocalPoint = planePoint.v.$clone();
                    } else {
                        manifold.v.LocalNormal = FarseerPhysics.Common.MathUtils.MultiplyT$1(Bridge.ref(FarseerPhysics.Collision.Collision._xf, "R"), normal);
                        manifold.v.LocalPoint = FarseerPhysics.Common.MathUtils.MultiplyT$3(Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"), planePoint);
                    }

                    var pointCount = 0;
                    for (var i1 = 0; i1 < FarseerPhysics.Settings.MaxManifoldPoints; i1 = (i1 + 1) | 0) {
                        var separation = Microsoft.Xna.Framework.Vector2.Dot(normal.v.$clone(), clipPoints2.v.getItem(i1).$clone().V.$clone()) - frontOffset;

                        if (separation <= FarseerPhysics.Collision.Collision._radius) {
                            var cp = manifold.v.Points.getItem(pointCount).$clone();

                            if (primaryAxis.Type === FarseerPhysics.Collision.EPAxisType.EdgeA) {
                                cp.LocalPoint = FarseerPhysics.Common.MathUtils.MultiplyT$2(Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"), clipPoints2.v.getItem(i1).$clone().V.$clone());
                                cp.Id = clipPoints2.v.getItem(i1).$clone().ID.$clone();
                            } else {
                                cp.LocalPoint = clipPoints2.v.getItem(i1).$clone().V.$clone();
                                cp.Id.Features.TypeA = clipPoints2.v.getItem(i1).$clone().ID.Features.TypeB;
                                cp.Id.Features.TypeB = clipPoints2.v.getItem(i1).$clone().ID.Features.TypeA;
                                cp.Id.Features.IndexA = clipPoints2.v.getItem(i1).$clone().ID.Features.IndexB;
                                cp.Id.Features.IndexB = clipPoints2.v.getItem(i1).$clone().ID.Features.IndexA;
                            }

                            manifold.v.Points.setItem(pointCount, cp.$clone());

                            pointCount = (pointCount + 1) | 0;
                        }
                    }

                    manifold.v.PointCount = pointCount;

                },
                ComputeEdgeSeparation: function () {
                    var $t;
                    var bestAxis = new FarseerPhysics.Collision.EPAxis();
                    bestAxis.Type = FarseerPhysics.Collision.EPAxisType.Unknown;
                    bestAxis.Index = -1;
                    bestAxis.Separation = -3.40282347E+38;
                    FarseerPhysics.Collision.Collision._tmpNormals[System.Array.index(0, FarseerPhysics.Collision.Collision._tmpNormals)] = FarseerPhysics.Collision.Collision._edgeA.Normal.$clone();
                    FarseerPhysics.Collision.Collision._tmpNormals[System.Array.index(1, FarseerPhysics.Collision.Collision._tmpNormals)] = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.Collision._edgeA.Normal.$clone());

                    for (var i = 0; i < 2; i = (i + 1) | 0) {
                        var n = FarseerPhysics.Collision.Collision._tmpNormals[System.Array.index(i, FarseerPhysics.Collision.Collision._tmpNormals)].$clone();

                        var valid1 = FarseerPhysics.Common.MathUtils.Cross$2(n.$clone(), FarseerPhysics.Collision.Collision._limit11.$clone()) >= -0.03490659 && FarseerPhysics.Common.MathUtils.Cross$2(FarseerPhysics.Collision.Collision._limit12.$clone(), n.$clone()) >= -0.03490659;
                        var valid2 = FarseerPhysics.Common.MathUtils.Cross$2(n.$clone(), FarseerPhysics.Collision.Collision._limit21.$clone()) >= -0.03490659 && FarseerPhysics.Common.MathUtils.Cross$2(FarseerPhysics.Collision.Collision._limit22.$clone(), n.$clone()) >= -0.03490659;

                        if (valid1 === false || valid2 === false) {
                            continue;
                        }

                        var axis = new FarseerPhysics.Collision.EPAxis();
                        axis.Type = FarseerPhysics.Collision.EPAxisType.EdgeA;
                        axis.Index = i;
                        axis.Separation = FarseerPhysics.Settings.MaxFloat;

                        for (var j = 0; j < FarseerPhysics.Collision.Collision._proxyB.Count; j = (j + 1) | 0) {
                            var s = Microsoft.Xna.Framework.Vector2.Dot(n.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(($t = FarseerPhysics.Collision.Collision._proxyB.Vertices)[System.Array.index(j, $t)].$clone(), FarseerPhysics.Collision.Collision._edgeA.V1.$clone()));
                            if (s < axis.Separation) {
                                axis.Separation = s;
                            }
                        }

                        if (axis.Separation > FarseerPhysics.Collision.Collision._radius) {
                            return axis.$clone();
                        }

                        if (axis.Separation > bestAxis.Separation) {
                            bestAxis = axis.$clone();
                        }
                    }

                    return bestAxis.$clone();
                },
                ComputePolygonSeparation: function () {
                    var $t, $t1, $t2;
                    var axis = new FarseerPhysics.Collision.EPAxis();
                    axis.Type = FarseerPhysics.Collision.EPAxisType.Unknown;
                    axis.Index = -1;
                    axis.Separation = -3.40282347E+38;
                    for (var i = 0; i < FarseerPhysics.Collision.Collision._proxyB.Count; i = (i + 1) | 0) {
                        var n = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(($t = FarseerPhysics.Collision.Collision._proxyB.Normals)[System.Array.index(i, $t)].$clone());

                        var valid1 = FarseerPhysics.Common.MathUtils.Cross$2(n.$clone(), FarseerPhysics.Collision.Collision._limit11.$clone()) >= -0.03490659 && FarseerPhysics.Common.MathUtils.Cross$2(FarseerPhysics.Collision.Collision._limit12.$clone(), n.$clone()) >= -0.03490659;
                        var valid2 = FarseerPhysics.Common.MathUtils.Cross$2(n.$clone(), FarseerPhysics.Collision.Collision._limit21.$clone()) >= -0.03490659 && FarseerPhysics.Common.MathUtils.Cross$2(FarseerPhysics.Collision.Collision._limit22.$clone(), n.$clone()) >= -0.03490659;

                        if (valid1 === false && valid2 === false) {
                            continue;
                        }

                        var s1 = Microsoft.Xna.Framework.Vector2.Dot(n.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(($t1 = FarseerPhysics.Collision.Collision._proxyB.Vertices)[System.Array.index(i, $t1)].$clone(), FarseerPhysics.Collision.Collision._edgeA.V1.$clone()));
                        var s2 = Microsoft.Xna.Framework.Vector2.Dot(n.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(($t2 = FarseerPhysics.Collision.Collision._proxyB.Vertices)[System.Array.index(i, $t2)].$clone(), FarseerPhysics.Collision.Collision._edgeA.V2.$clone()));
                        var s = Math.min(s1, s2);

                        if (s > FarseerPhysics.Collision.Collision._radius) {
                            axis.Type = FarseerPhysics.Collision.EPAxisType.EdgeB;
                            axis.Index = i;
                            axis.Separation = s;
                        }

                        if (s > axis.Separation) {
                            axis.Type = FarseerPhysics.Collision.EPAxisType.EdgeB;
                            axis.Index = i;
                            axis.Separation = s;
                        }
                    }

                    return axis.$clone();
                },
                FindIncidentEdge: function (c, proxy1, edge1, proxy2) {
                    var count2 = proxy2.Count;

                    System.Diagnostics.Debug.Assert(0 <= edge1 && edge1 < proxy1.Count);

                    var normal1 = proxy1.Normals[System.Array.index(edge1, proxy1.Normals)].$clone();

                    var index = 0;
                    var minDot = 3.40282347E+38;
                    for (var i = 0; i < count2; i = (i + 1) | 0) {
                        var dot = Microsoft.Xna.Framework.Vector2.Dot(normal1.$clone(), proxy2.Normals[System.Array.index(i, proxy2.Normals)].$clone());
                        if (dot < minDot) {
                            minDot = dot;
                            index = i;
                        }
                    }

                    var i1 = index;
                    var i2 = ((i1 + 1) | 0) < count2 ? ((i1 + 1) | 0) : 0;

                    var cTemp = new FarseerPhysics.Collision.ClipVertex();
                    cTemp.V = proxy2.Vertices[System.Array.index(i1, proxy2.Vertices)].$clone();
                    cTemp.ID.Features.IndexA = edge1 & 255;
                    cTemp.ID.Features.IndexB = i1 & 255;
                    cTemp.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    cTemp.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                    c.v.setItem(0, cTemp.$clone());

                    cTemp.V = proxy2.Vertices[System.Array.index(i2, proxy2.Vertices)].$clone();
                    cTemp.ID.Features.IndexA = edge1 & 255;
                    cTemp.ID.Features.IndexB = i2 & 255;
                    cTemp.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    cTemp.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                    c.v.setItem(1, cTemp.$clone());
                },
                FindIncidentEdge$1: function (c, poly1, xf1, edge1, poly2, xf2) {
                    c.v = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))();

                    var count2 = poly2.Vertices.Count;

                    System.Diagnostics.Debug.Assert(0 <= edge1 && edge1 < poly1.Vertices.Count);

                    var v = poly1.Normals.getItem(edge1).$clone();
                    var tmpx = xf1.v.R.Col1.X * v.X + xf1.v.R.Col2.X * v.Y;
                    var tmpy = xf1.v.R.Col1.Y * v.X + xf1.v.R.Col2.Y * v.Y;
                    var normal1 = new Microsoft.Xna.Framework.Vector2.$ctor2(tmpx * xf2.v.R.Col1.X + tmpy * xf2.v.R.Col1.Y, tmpx * xf2.v.R.Col2.X + tmpy * xf2.v.R.Col2.Y);

                    var index = 0;
                    var minDot = FarseerPhysics.Settings.MaxFloat;
                    for (var i = 0; i < count2; i = (i + 1) | 0) {
                        var dot = Microsoft.Xna.Framework.Vector2.Dot(normal1.$clone(), poly2.Normals.getItem(i).$clone());
                        if (dot < minDot) {
                            minDot = dot;
                            index = i;
                        }
                    }

                    var i1 = index;
                    var i2 = ((i1 + 1) | 0) < count2 ? ((i1 + 1) | 0) : 0;

                    var cv0 = c.v.getItem(0).$clone();

                    var v1 = poly2.Vertices.getItem(i1).$clone();
                    cv0.V.X = xf2.v.Position.X + xf2.v.R.Col1.X * v1.X + xf2.v.R.Col2.X * v1.Y;
                    cv0.V.Y = xf2.v.Position.Y + xf2.v.R.Col1.Y * v1.X + xf2.v.R.Col2.Y * v1.Y;
                    cv0.ID.Features.IndexA = edge1 & 255;
                    cv0.ID.Features.IndexB = i1 & 255;
                    cv0.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    cv0.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;

                    c.v.setItem(0, cv0.$clone());

                    var cv1 = c.v.getItem(1).$clone();
                    var v2 = poly2.Vertices.getItem(i2).$clone();
                    cv1.V.X = xf2.v.Position.X + xf2.v.R.Col1.X * v2.X + xf2.v.R.Col2.X * v2.Y;
                    cv1.V.Y = xf2.v.Position.Y + xf2.v.R.Col1.Y * v2.X + xf2.v.R.Col2.Y * v2.Y;
                    cv1.ID.Features.IndexA = edge1 & 255;
                    cv1.ID.Features.IndexB = i2 & 255;
                    cv1.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    cv1.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;

                    c.v.setItem(1, cv1.$clone());
                },
                /**
                 * Clipping for contact manifolds.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Common.FixedArray2}    vOut            The v out.
                 * @param   {FarseerPhysics.Common.FixedArray2}    vIn             The v in.
                 * @param   {Microsoft.Xna.Framework.Vector2}      normal          The normal.
                 * @param   {number}                               offset          The offset.
                 * @param   {number}                               vertexIndexA    The vertex index A.
                 * @return  {number}
                 */
                ClipSegmentToLine: function (vOut, vIn, normal, offset, vertexIndexA) {
                    vOut.v = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))();

                    var v0 = vIn.v.getItem(0).$clone();
                    var v1 = vIn.v.getItem(1).$clone();

                    var numOut = 0;

                    var distance0 = normal.X * v0.V.X + normal.Y * v0.V.Y - offset;
                    var distance1 = normal.X * v1.V.X + normal.Y * v1.V.Y - offset;

                    if (distance0 <= 0.0) {
                        vOut.v.setItem(Bridge.identity(numOut, (numOut = (numOut + 1) | 0)), v0.$clone());
                    }
                    if (distance1 <= 0.0) {
                        vOut.v.setItem(Bridge.identity(numOut, (numOut = (numOut + 1) | 0)), v1.$clone());
                    }

                    if (distance0 * distance1 < 0.0) {
                        var interp = distance0 / (distance0 - distance1);

                        var cv = vOut.v.getItem(numOut).$clone();

                        cv.V.X = v0.V.X + interp * (v1.V.X - v0.V.X);
                        cv.V.Y = v0.V.Y + interp * (v1.V.Y - v0.V.Y);

                        cv.ID.Features.IndexA = vertexIndexA & 255;
                        cv.ID.Features.IndexB = v0.ID.Features.IndexB;
                        cv.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                        cv.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Face;

                        vOut.v.setItem(numOut, cv.$clone());

                        numOut = (numOut + 1) | 0;
                    }

                    return numOut;
                },
                /**
                 * Find the separation between poly1 and poly2 for a give edge normal on poly1.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    poly1    The poly1.
                 * @param   {FarseerPhysics.Common.Transform}                 xf1      The XF1.
                 * @param   {number}                                          edge1    The edge1.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    poly2    The poly2.
                 * @param   {FarseerPhysics.Common.Transform}                 xf2      The XF2.
                 * @return  {number}
                 */
                EdgeSeparation: function (poly1, xf1, edge1, poly2, xf2) {
                    var count2 = poly2.Vertices.Count;

                    System.Diagnostics.Debug.Assert(0 <= edge1 && edge1 < poly1.Vertices.Count);

                    var p1n = poly1.Normals.getItem(edge1).$clone();

                    var normalWorldx = xf1.v.R.Col1.X * p1n.X + xf1.v.R.Col2.X * p1n.Y;
                    var normalWorldy = xf1.v.R.Col1.Y * p1n.X + xf1.v.R.Col2.Y * p1n.Y;

                    var normal = new Microsoft.Xna.Framework.Vector2.$ctor2(normalWorldx * xf2.v.R.Col1.X + normalWorldy * xf2.v.R.Col1.Y, normalWorldx * xf2.v.R.Col2.X + normalWorldy * xf2.v.R.Col2.Y);

                    var index = 0;
                    var minDot = FarseerPhysics.Settings.MaxFloat;

                    for (var i = 0; i < count2; i = (i + 1) | 0) {
                        var dot = Microsoft.Xna.Framework.Vector2.Dot(poly2.Vertices.getItem(i).$clone(), normal.$clone());

                        if (dot < minDot) {
                            minDot = dot;
                            index = i;
                        }
                    }

                    var p1ve = poly1.Vertices.getItem(edge1).$clone();
                    var p2vi = poly2.Vertices.getItem(index).$clone();

                    return ((xf2.v.Position.X + xf2.v.R.Col1.X * p2vi.X + xf2.v.R.Col2.X * p2vi.Y) - (xf1.v.Position.X + xf1.v.R.Col1.X * p1ve.X + xf1.v.R.Col2.X * p1ve.Y)) * normalWorldx + ((xf2.v.Position.Y + xf2.v.R.Col1.Y * p2vi.X + xf2.v.R.Col2.Y * p2vi.Y) - (xf1.v.Position.Y + xf1.v.R.Col1.Y * p1ve.X + xf1.v.R.Col2.Y * p1ve.Y)) * normalWorldy;
                },
                /**
                 * Find the max separation between poly1 and poly2 using edge normals from poly1.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {System.Int32}                                    edgeIndex    Index of the edge.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    poly1        The poly1.
                 * @param   {FarseerPhysics.Common.Transform}                 xf1          The XF1.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    poly2        The poly2.
                 * @param   {FarseerPhysics.Common.Transform}                 xf2          The XF2.
                 * @return  {number}
                 */
                FindMaxSeparation: function (edgeIndex, poly1, xf1, poly2, xf2) {
                    var count1 = poly1.Vertices.Count;

                    var dx = (xf2.v.Position.X + xf2.v.R.Col1.X * poly2.MassData.Centroid.X + xf2.v.R.Col2.X * poly2.MassData.Centroid.Y) - (xf1.v.Position.X + xf1.v.R.Col1.X * poly1.MassData.Centroid.X + xf1.v.R.Col2.X * poly1.MassData.Centroid.Y);
                    var dy = (xf2.v.Position.Y + xf2.v.R.Col1.Y * poly2.MassData.Centroid.X + xf2.v.R.Col2.Y * poly2.MassData.Centroid.Y) - (xf1.v.Position.Y + xf1.v.R.Col1.Y * poly1.MassData.Centroid.X + xf1.v.R.Col2.Y * poly1.MassData.Centroid.Y);
                    var dLocal1 = new Microsoft.Xna.Framework.Vector2.$ctor2(dx * xf1.v.R.Col1.X + dy * xf1.v.R.Col1.Y, dx * xf1.v.R.Col2.X + dy * xf1.v.R.Col2.Y);

                    var edge = 0;
                    var maxDot = -3.40282347E+38;
                    for (var i = 0; i < count1; i = (i + 1) | 0) {
                        var dot = Microsoft.Xna.Framework.Vector2.Dot(poly1.Normals.getItem(i).$clone(), dLocal1.$clone());
                        if (dot > maxDot) {
                            maxDot = dot;
                            edge = i;
                        }
                    }

                    var s = FarseerPhysics.Collision.Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);

                    var prevEdge = ((edge - 1) | 0) >= 0 ? ((edge - 1) | 0) : ((count1 - 1) | 0);
                    var sPrev = FarseerPhysics.Collision.Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);

                    var nextEdge = ((edge + 1) | 0) < count1 ? ((edge + 1) | 0) : 0;
                    var sNext = FarseerPhysics.Collision.Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);

                    var bestEdge;
                    var bestSeparation;
                    var increment;
                    if (sPrev > s && sPrev > sNext) {
                        increment = -1;
                        bestEdge = prevEdge;
                        bestSeparation = sPrev;
                    } else if (sNext > s) {
                        increment = 1;
                        bestEdge = nextEdge;
                        bestSeparation = sNext;
                    } else {
                        edgeIndex.v = edge;
                        return s;
                    }

                    for (; ; ) {
                        if (increment === -1) {
                            edge = ((bestEdge - 1) | 0) >= 0 ? ((bestEdge - 1) | 0) : ((count1 - 1) | 0);
                        } else {
                            edge = ((bestEdge + 1) | 0) < count1 ? ((bestEdge + 1) | 0) : 0;
                        }

                        s = FarseerPhysics.Collision.Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);

                        if (s > bestSeparation) {
                            bestEdge = edge;
                            bestSeparation = s;
                        } else {
                            break;
                        }
                    }

                    edgeIndex.v = bestEdge;
                    return bestSeparation;
                }
            }
        }
    });

    /**
     * The features that intersect to form the contact point
     This must be 4 bytes or less.
     *
     * @public
     * @class FarseerPhysics.Collision.ContactFeature
     */
    Bridge.define("FarseerPhysics.Collision.ContactFeature", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.ContactFeature(); }
            }
        },
        fields: {
            /**
             * Feature index on ShapeA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactFeature
             * @type number
             */
            IndexA: 0,
            /**
             * Feature index on ShapeB
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactFeature
             * @type number
             */
            IndexB: 0,
            /**
             * The feature type on ShapeA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactFeature
             * @type number
             */
            TypeA: 0,
            /**
             * The feature type on ShapeB
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactFeature
             * @type number
             */
            TypeB: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5106014587, this.IndexA, this.IndexB, this.TypeA, this.TypeB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.ContactFeature)) {
                    return false;
                }
                return Bridge.equals(this.IndexA, o.IndexA) && Bridge.equals(this.IndexB, o.IndexB) && Bridge.equals(this.TypeA, o.TypeA) && Bridge.equals(this.TypeB, o.TypeB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.ContactFeature();
                s.IndexA = this.IndexA;
                s.IndexB = this.IndexB;
                s.TypeA = this.TypeA;
                s.TypeB = this.TypeB;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.ContactFeatureType", {
        $kind: "enum",
        statics: {
            fields: {
                Vertex: 0,
                Face: 1
            }
        },
        $utype: System.Byte
    });

    /**
     * Contact ids to facilitate warm starting.
     *
     * @public
     * @class FarseerPhysics.Collision.ContactID
     */
    Bridge.define("FarseerPhysics.Collision.ContactID", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.ContactID(); }
            }
        },
        fields: {
            /**
             * The features that intersect to form the contact point
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactID
             * @type FarseerPhysics.Collision.ContactFeature
             */
            Features: null,
            /**
             * Used to quickly compare contact ids.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactID
             * @type number
             */
            Key: 0
        },
        ctors: {
            init: function () {
                this.Features = new FarseerPhysics.Collision.ContactFeature();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3185758952, this.Features, this.Key]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.ContactID)) {
                    return false;
                }
                return Bridge.equals(this.Features, o.Features) && Bridge.equals(this.Key, o.Key);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.ContactID();
                s.Features = this.Features.$clone();
                s.Key = this.Key;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Distance", {
        statics: {
            fields: {
                GJKCalls: 0,
                GJKIters: 0,
                GJKMaxIters: 0
            },
            methods: {
                ComputeDistance: function (output, cache, input) {
                    cache.v = new FarseerPhysics.Collision.SimplexCache();
                    FarseerPhysics.Collision.Distance.GJKCalls = (FarseerPhysics.Collision.Distance.GJKCalls + 1) | 0;

                    var simplex = new FarseerPhysics.Collision.Simplex();
                    simplex.ReadCache(cache, input.ProxyA, Bridge.ref(input, "TransformA"), input.ProxyB, Bridge.ref(input, "TransformB"));

                    var k_maxIters = 20;

                    var saveA = new (FarseerPhysics.Common.FixedArray3$1(System.Int32))();
                    var saveB = new (FarseerPhysics.Common.FixedArray3$1(System.Int32))();

                    var closestPoint = simplex.GetClosestPoint();
                    var distanceSqr1 = closestPoint.LengthSquared();
                    var distanceSqr2 = distanceSqr1;

                    var iter = 0;
                    while (iter < k_maxIters) {
                        var saveCount = simplex.Count;
                        for (var i = 0; i < saveCount; i = (i + 1) | 0) {
                            saveA.setItem(i, simplex.V.getItem(i).$clone().IndexA);
                            saveB.setItem(i, simplex.V.getItem(i).$clone().IndexB);
                        }

                        switch (simplex.Count) {
                            case 1: 
                                break;
                            case 2: 
                                simplex.Solve2();
                                break;
                            case 3: 
                                simplex.Solve3();
                                break;
                            default: 
                                System.Diagnostics.Debug.Assert(false);
                                break;
                        }

                        if (simplex.Count === 3) {
                            break;
                        }

                        var p = simplex.GetClosestPoint();
                        distanceSqr2 = p.LengthSquared();

                        if (distanceSqr2 >= distanceSqr1) {
                        }
                        distanceSqr1 = distanceSqr2;

                        var d = simplex.GetSearchDirection();

                        if (d.LengthSquared() < 1.42108547E-14) {

                            break;
                        }

                        var vertex = simplex.V.getItem(simplex.Count).$clone();
                        vertex.IndexA = input.ProxyA.GetSupport(FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(input.TransformA, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(d.$clone())));
                        vertex.WA = FarseerPhysics.Common.MathUtils.Multiply$2(Bridge.ref(input, "TransformA"), input.ProxyA.Vertices.getItem(vertex.IndexA).$clone());

                        vertex.IndexB = input.ProxyB.GetSupport(FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(input.TransformB, "R"), d.$clone()));
                        vertex.WB = FarseerPhysics.Common.MathUtils.Multiply$2(Bridge.ref(input, "TransformB"), input.ProxyB.Vertices.getItem(vertex.IndexB).$clone());
                        vertex.W = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex.WB.$clone(), vertex.WA.$clone());
                        simplex.V.setItem(simplex.Count, vertex.$clone());

                        iter = (iter + 1) | 0;
                        FarseerPhysics.Collision.Distance.GJKIters = (FarseerPhysics.Collision.Distance.GJKIters + 1) | 0;

                        var duplicate = false;
                        for (var i1 = 0; i1 < saveCount; i1 = (i1 + 1) | 0) {
                            if (vertex.IndexA === saveA.getItem(i1) && vertex.IndexB === saveB.getItem(i1)) {
                                duplicate = true;
                                break;
                            }
                        }

                        if (duplicate) {
                            break;
                        }

                        simplex.Count = (simplex.Count + 1) | 0;
                    }

                    FarseerPhysics.Collision.Distance.GJKMaxIters = Math.max(FarseerPhysics.Collision.Distance.GJKMaxIters, iter);

                    simplex.GetWitnessPoints(Bridge.ref(output.v, "PointA"), Bridge.ref(output.v, "PointB"));
                    output.v.Distance = (Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointA.$clone(), output.v.PointB.$clone())).Length();
                    output.v.Iterations = iter;

                    simplex.WriteCache(cache);

                    if (input.UseRadii) {
                        var rA = input.ProxyA.Radius;
                        var rB = input.ProxyB.Radius;

                        if (output.v.Distance > rA + rB && output.v.Distance > FarseerPhysics.Settings.Epsilon) {
                            output.v.Distance -= rA + rB;
                            var normal = Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointB.$clone(), output.v.PointA.$clone());
                            normal.Normalize();
                            output.v.PointA = Microsoft.Xna.Framework.Vector2.op_Addition(output.v.PointA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(rA, normal.$clone()));
                            output.v.PointB = Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(rB, normal.$clone()));
                        } else {
                            var p1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(output.v.PointA.$clone(), output.v.PointB.$clone())));
                            output.v.PointA = p1.$clone();
                            output.v.PointB = p1.$clone();
                            output.v.Distance = 0.0;
                        }
                    }
                }
            }
        }
    });

    /**
     * Input for ComputeDistance.
     You have to option to use the shape radii
     in the computation.
     *
     * @public
     * @class FarseerPhysics.Collision.DistanceInput
     */
    Bridge.define("FarseerPhysics.Collision.DistanceInput", {
        fields: {
            ProxyA: null,
            ProxyB: null,
            TransformA: null,
            TransformB: null,
            UseRadii: false
        },
        ctors: {
            init: function () {
                this.TransformA = new FarseerPhysics.Common.Transform();
                this.TransformB = new FarseerPhysics.Common.Transform();
                this.ProxyA = new FarseerPhysics.Collision.DistanceProxy();
                this.ProxyB = new FarseerPhysics.Collision.DistanceProxy();
            }
        }
    });

    /**
     * Output for ComputeDistance.
     *
     * @public
     * @class FarseerPhysics.Collision.DistanceOutput
     */
    Bridge.define("FarseerPhysics.Collision.DistanceOutput", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.DistanceOutput(); }
            }
        },
        fields: {
            Distance: 0,
            /**
             * Number of GJK iterations used
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.DistanceOutput
             * @type number
             */
            Iterations: 0,
            /**
             * Closest point on shapeA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.DistanceOutput
             * @type Microsoft.Xna.Framework.Vector2
             */
            PointA: null,
            /**
             * Closest point on shapeB
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.DistanceOutput
             * @type Microsoft.Xna.Framework.Vector2
             */
            PointB: null
        },
        ctors: {
            init: function () {
                this.PointA = new Microsoft.Xna.Framework.Vector2();
                this.PointB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5541445993, this.Distance, this.Iterations, this.PointA, this.PointB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.DistanceOutput)) {
                    return false;
                }
                return Bridge.equals(this.Distance, o.Distance) && Bridge.equals(this.Iterations, o.Iterations) && Bridge.equals(this.PointA, o.PointA) && Bridge.equals(this.PointB, o.PointB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.DistanceOutput();
                s.Distance = this.Distance;
                s.Iterations = this.Iterations;
                s.PointA = this.PointA.$clone();
                s.PointB = this.PointB.$clone();
                return s;
            }
        }
    });

    /**
     * A distance proxy is used by the GJK algorithm.
     It encapsulates any shape.
     *
     * @public
     * @class FarseerPhysics.Collision.DistanceProxy
     */
    Bridge.define("FarseerPhysics.Collision.DistanceProxy", {
        fields: {
            Radius: 0,
            Vertices: null
        },
        ctors: {
            init: function () {
                this.Vertices = new FarseerPhysics.Common.Vertices.ctor();
            }
        },
        methods: {
            /**
             * Initialize the proxy using the given shape. The shape
             must remain in scope while the proxy is in use.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DistanceProxy
             * @memberof FarseerPhysics.Collision.DistanceProxy
             * @param   {FarseerPhysics.Collision.Shapes.Shape}    shape    The shape.
             * @param   {number}                                   index    The index.
             * @return  {void}
             */
            Set: function (shape, index) {
                switch (shape.ShapeType) {
                    case FarseerPhysics.Collision.Shapes.ShapeType.Circle: 
                        {
                            var circle = Bridge.cast(shape, FarseerPhysics.Collision.Shapes.CircleShape);
                            this.Vertices.clear();
                            this.Vertices.add(circle.Position.$clone());
                            this.Radius = circle.Radius;
                        }
                        break;
                    case FarseerPhysics.Collision.Shapes.ShapeType.Polygon: 
                        {
                            var polygon = Bridge.cast(shape, FarseerPhysics.Collision.Shapes.PolygonShape);
                            this.Vertices.clear();
                            for (var i = 0; i < polygon.Vertices.Count; i = (i + 1) | 0) {
                                this.Vertices.add(polygon.Vertices.getItem(i).$clone());
                            }
                            this.Radius = polygon.Radius;
                        }
                        break;
                    case FarseerPhysics.Collision.Shapes.ShapeType.Loop: 
                        {
                            var loop = Bridge.cast(shape, FarseerPhysics.Collision.Shapes.LoopShape);
                            System.Diagnostics.Debug.Assert(0 <= index && index < loop.Vertices.Count);
                            this.Vertices.clear();
                            this.Vertices.add(loop.Vertices.getItem(index).$clone());
                            this.Vertices.add(((index + 1) | 0) < loop.Vertices.Count ? loop.Vertices.getItem(((index + 1) | 0)).$clone() : loop.Vertices.getItem(0).$clone());

                            this.Radius = loop.Radius;
                        }
                        break;
                    case FarseerPhysics.Collision.Shapes.ShapeType.Edge: 
                        {
                            var edge = Bridge.cast(shape, FarseerPhysics.Collision.Shapes.EdgeShape);
                            this.Vertices.clear();
                            this.Vertices.add(edge.Vertex1.$clone());
                            this.Vertices.add(edge.Vertex2.$clone());
                            this.Radius = edge.Radius;
                        }
                        break;
                    default: 
                        System.Diagnostics.Debug.Assert(false);
                        break;
                }
            },
            /**
             * Get the supporting vertex index in the given direction.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DistanceProxy
             * @memberof FarseerPhysics.Collision.DistanceProxy
             * @param   {Microsoft.Xna.Framework.Vector2}    direction    The direction.
             * @return  {number}
             */
            GetSupport: function (direction) {
                var bestIndex = 0;
                var bestValue = Microsoft.Xna.Framework.Vector2.Dot(this.Vertices.getItem(0).$clone(), direction.$clone());
                for (var i = 1; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var value = Microsoft.Xna.Framework.Vector2.Dot(this.Vertices.getItem(i).$clone(), direction.$clone());
                    if (value > bestValue) {
                        bestIndex = i;
                        bestValue = value;
                    }
                }

                return bestIndex;
            },
            /**
             * Get the supporting vertex in the given direction.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DistanceProxy
             * @memberof FarseerPhysics.Collision.DistanceProxy
             * @param   {Microsoft.Xna.Framework.Vector2}    direction    The direction.
             * @return  {Microsoft.Xna.Framework.Vector2}
             */
            GetSupportVertex: function (direction) {
                var bestIndex = 0;
                var bestValue = Microsoft.Xna.Framework.Vector2.Dot(this.Vertices.getItem(0).$clone(), direction.$clone());
                for (var i = 1; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var value = Microsoft.Xna.Framework.Vector2.Dot(this.Vertices.getItem(i).$clone(), direction.$clone());
                    if (value > bestValue) {
                        bestIndex = i;
                        bestValue = value;
                    }
                }

                return this.Vertices.getItem(bestIndex).$clone();
            }
        }
    });

    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {number}     arg
     * @return  {boolean}
     */

    /**
     * A dynamic tree arranges data in a binary tree to accelerate
     queries such as volume queries and ray casts. Leafs are proxies
     with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor
     so that the proxy AABB is bigger than the client object. This allows the client
     object to move by small amounts without triggering a tree update.
     Nodes are pooled and relocatable, so we use node indices rather than pointers.
     *
     * @public
     * @class FarseerPhysics.Collision.DynamicTree$1
     */
    Bridge.define("FarseerPhysics.Collision.DynamicTree$1", function (T) { return {
        statics: {
            fields: {
                NullNode: 0,
                _stack: null
            },
            ctors: {
                init: function () {
                    this.NullNode = -1;
                    this._stack = new (System.Collections.Generic.Stack$1(System.Int32)).$ctor2(256);
                }
            }
        },
        fields: {
            _freeList: 0,
            _insertionCount: 0,
            _nodeCapacity: 0,
            _nodeCount: 0,
            _nodes: null,
            /**
             * This is used incrementally traverse the tree for re-balancing.
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @type number
             */
            _path: 0,
            _root: 0
        },
        ctors: {
            /**
             * Constructing the tree initializes the node pool.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @return  {void}
             */
            ctor: function () {
                this.$initialize();
                this._root = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;

                this._nodeCapacity = 16;
                this._nodes = System.Array.init(this._nodeCapacity, function (){
                    return new (FarseerPhysics.Collision.DynamicTreeNode$1(T))();
                }, FarseerPhysics.Collision.DynamicTreeNode$1(T));

                for (var i = 0; i < ((this._nodeCapacity - 1) | 0); i = (i + 1) | 0) {
                    this._nodes[System.Array.index(i, this._nodes)].ParentOrNext = (i + 1) | 0;
                }
                this._nodes[System.Array.index(((this._nodeCapacity - 1) | 0), this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
            }
        },
        methods: {
            /**
             * Create a proxy in the tree as a leaf node. We return the index
             of the node instead of a pointer so that we can grow
             the node pool.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {FarseerPhysics.Collision.AABB}    aabb        The aabb.
             * @param   {T}                                userData    The user data.
             * @return  {number}                                       Index of the created proxy
             */
            AddProxy: function (aabb, userData) {
                var proxyId = this.AllocateNode();

                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.AABBExtension, FarseerPhysics.Settings.AABBExtension);
                this._nodes[System.Array.index(proxyId, this._nodes)].AABB.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(aabb.v.LowerBound.$clone(), r.$clone());
                this._nodes[System.Array.index(proxyId, this._nodes)].AABB.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(aabb.v.UpperBound.$clone(), r.$clone());
                this._nodes[System.Array.index(proxyId, this._nodes)].UserData = userData;
                this._nodes[System.Array.index(proxyId, this._nodes)].LeafCount = 1;

                this.InsertLeaf(proxyId);

                return proxyId;
            },
            /**
             * Destroy a proxy. This asserts if the id is invalid.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}    proxyId    The proxy id.
             * @return  {void}
             */
            RemoveProxy: function (proxyId) {
                System.Diagnostics.Debug.Assert(0 <= proxyId && proxyId < this._nodeCapacity);
                System.Diagnostics.Debug.Assert(this._nodes[System.Array.index(proxyId, this._nodes)].IsLeaf());

                this.RemoveLeaf(proxyId);
                this.FreeNode(proxyId);
            },
            /**
             * Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
             then the proxy is removed from the tree and re-inserted. Otherwise
             the function returns immediately.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}                             proxyId         The proxy id.
             * @param   {FarseerPhysics.Collision.AABB}      aabb            The aabb.
             * @param   {Microsoft.Xna.Framework.Vector2}    displacement    The displacement.
             * @return  {boolean}                                            true if the proxy was re-inserted.
             */
            MoveProxy: function (proxyId, aabb, displacement) {
                System.Diagnostics.Debug.Assert(0 <= proxyId && proxyId < this._nodeCapacity);

                System.Diagnostics.Debug.Assert(this._nodes[System.Array.index(proxyId, this._nodes)].IsLeaf());

                if (this._nodes[System.Array.index(proxyId, this._nodes)].AABB.Contains(aabb)) {
                    return false;
                }

                this.RemoveLeaf(proxyId);

                var b = aabb.v.$clone();
                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.AABBExtension, FarseerPhysics.Settings.AABBExtension);
                b.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(b.LowerBound.$clone(), r.$clone());
                b.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(b.UpperBound.$clone(), r.$clone());

                var d = Microsoft.Xna.Framework.Vector2.op_Multiply$2(FarseerPhysics.Settings.AABBMultiplier, displacement.$clone());

                if (d.X < 0.0) {
                    b.LowerBound.X += d.X;
                } else {
                    b.UpperBound.X += d.X;
                }

                if (d.Y < 0.0) {
                    b.LowerBound.Y += d.Y;
                } else {
                    b.UpperBound.Y += d.Y;
                }

                this._nodes[System.Array.index(proxyId, this._nodes)].AABB = b.$clone();

                this.InsertLeaf(proxyId);
                return true;
            },
            /**
             * Perform some iterations to re-balance the tree.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}    iterations    The iterations.
             * @return  {void}
             */
            Rebalance: function (iterations) {
                if (this._root === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    return;
                }

                for (var i = 0; i < iterations; i = (i + 1) | 0) {
                    var node = this._root;

                    var bit = 0;
                    while (this._nodes[System.Array.index(node, this._nodes)].IsLeaf() === false) {
                        var selector = (this._path >> bit) & 1;

                        node = (selector === 0) ? this._nodes[System.Array.index(node, this._nodes)].Child1 : this._nodes[System.Array.index(node, this._nodes)].Child2;

                        bit = (((bit + 1) | 0)) & 31;
                    }
                    this._path = (this._path + 1) | 0;

                    this.RemoveLeaf(node);
                    this.InsertLeaf(node);
                }
            },
            /**
             * Get proxy user data.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}      proxyId    The proxy id.
             * @param   {Function}    [name]
             * @return  {T}                      the proxy user data or 0 if the id is invalid.
             */
            GetUserData: function (proxyId) {
                System.Diagnostics.Debug.Assert(0 <= proxyId && proxyId < this._nodeCapacity);
                return this._nodes[System.Array.index(proxyId, this._nodes)].UserData;
            },
            /**
             * Get the fat AABB for a proxy.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}                           proxyId    The proxy id.
             * @param   {FarseerPhysics.Collision.AABB}    fatAABB    The fat AABB.
             * @return  {void}
             */
            GetFatAABB: function (proxyId, fatAABB) {
                System.Diagnostics.Debug.Assert(0 <= proxyId && proxyId < this._nodeCapacity);
                fatAABB.v = this._nodes[System.Array.index(proxyId, this._nodes)].AABB.$clone();
            },
            /**
             * Compute the height of the binary tree in O(N) time. Should not be
             called often.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @return  {number}
             */
            ComputeHeight: function () {
                return this.ComputeHeight$1(this._root);
            },
            ComputeHeight$1: function (nodeId) {
                if (nodeId === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    return 0;
                }

                System.Diagnostics.Debug.Assert(0 <= nodeId && nodeId < this._nodeCapacity);
                var node = this._nodes[System.Array.index(nodeId, this._nodes)].$clone();
                var height1 = this.ComputeHeight$1(node.Child1);
                var height2 = this.ComputeHeight$1(node.Child2);
                return ((1 + Math.max(height1, height2)) | 0);
            },
            /**
             * Query an AABB for overlapping proxies. The callback class
             is called for each proxy that overlaps the supplied AABB.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {System.Func}                      callback    The callback.
             * @param   {FarseerPhysics.Collision.AABB}    aabb        The aabb.
             * @return  {void}
             */
            Query: function (callback, aabb) {
                FarseerPhysics.Collision.DynamicTree$1(T)._stack.Clear();
                FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(this._root);

                while (FarseerPhysics.Collision.DynamicTree$1(T)._stack.Count > 0) {
                    var nodeId = FarseerPhysics.Collision.DynamicTree$1(T)._stack.Pop();
                    if (nodeId === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                        continue;
                    }

                    var node = this._nodes[System.Array.index(nodeId, this._nodes)].$clone();

                    if (FarseerPhysics.Collision.AABB.TestOverlap$1(Bridge.ref(node, "AABB"), aabb)) {
                        if (node.IsLeaf()) {
                            var proceed = callback(nodeId);
                            if (proceed === false) {
                                return;
                            }
                        } else {
                            FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(node.Child1);
                            FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(node.Child2);
                        }
                    }
                }
            },
            /**
             * Ray-cast against the proxies in the tree. This relies on the callback
             to perform a exact ray-cast in the case were the proxy contains a Shape.
             The callback also performs the any collision filtering. This has performance
             roughly equal to k * log(n), where k is the number of collisions and n is the
             number of proxies in the tree.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {System.Func}                              callback    A callback class that is called for each proxy that is hit by the ray.
             * @param   {FarseerPhysics.Collision.RayCastInput}    input       The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
             * @return  {void}
             */
            RayCast: function (callback, input) {
                var p1 = { v : input.v.Point1.$clone() };
                var p2 = input.v.Point2.$clone();
                var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.v.$clone());
                System.Diagnostics.Debug.Assert(r.LengthSquared() > 0.0);
                r.Normalize();

                var absV = FarseerPhysics.Common.MathUtils.Abs(new Microsoft.Xna.Framework.Vector2.$ctor2(-r.Y, r.X));


                var maxFraction = input.v.MaxFraction;

                var segmentAABB = { v : new FarseerPhysics.Collision.AABB.ctor() };
                {
                    var t = { v : Microsoft.Xna.Framework.Vector2.op_Addition(p1.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(maxFraction, (Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.v.$clone())))) };
                    Microsoft.Xna.Framework.Vector2.Min$1(p1, t, Bridge.ref(segmentAABB.v, "LowerBound"));
                    Microsoft.Xna.Framework.Vector2.Max$1(p1, t, Bridge.ref(segmentAABB.v, "UpperBound"));
                }

                FarseerPhysics.Collision.DynamicTree$1(T)._stack.Clear();
                FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(this._root);

                while (FarseerPhysics.Collision.DynamicTree$1(T)._stack.Count > 0) {
                    var nodeId = FarseerPhysics.Collision.DynamicTree$1(T)._stack.Pop();
                    if (nodeId === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                        continue;
                    }

                    var node = this._nodes[System.Array.index(nodeId, this._nodes)].$clone();

                    if (FarseerPhysics.Collision.AABB.TestOverlap$1(Bridge.ref(node, "AABB"), segmentAABB) === false) {
                        continue;
                    }

                    var c = node.AABB.Center.$clone();
                    var h = node.AABB.Extents.$clone();
                    var separation = Math.abs(Microsoft.Xna.Framework.Vector2.Dot(new Microsoft.Xna.Framework.Vector2.$ctor2(-r.Y, r.X), Microsoft.Xna.Framework.Vector2.op_Subtraction(p1.v.$clone(), c.$clone()))) - Microsoft.Xna.Framework.Vector2.Dot(absV.$clone(), h.$clone());
                    if (separation > 0.0) {
                        continue;
                    }

                    if (node.IsLeaf()) {
                        var subInput = new FarseerPhysics.Collision.RayCastInput();
                        subInput.Point1 = input.v.Point1.$clone();
                        subInput.Point2 = input.v.Point2.$clone();
                        subInput.MaxFraction = maxFraction;

                        var value = callback(subInput.$clone(), nodeId);

                        if (value === 0.0) {
                            return;
                        }

                        if (value > 0.0) {
                            maxFraction = value;
                            var t1 = Microsoft.Xna.Framework.Vector2.op_Addition(p1.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(maxFraction, (Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.v.$clone()))));
                            segmentAABB.v.LowerBound = Microsoft.Xna.Framework.Vector2.Min(p1.v.$clone(), t1.$clone());
                            segmentAABB.v.UpperBound = Microsoft.Xna.Framework.Vector2.Max(p1.v.$clone(), t1.$clone());
                        }
                    } else {
                        FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(node.Child1);
                        FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(node.Child2);
                    }
                }
            },
            CountLeaves: function (nodeId) {
                if (nodeId === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    return 0;
                }

                System.Diagnostics.Debug.Assert(0 <= nodeId && nodeId < this._nodeCapacity);
                var node = this._nodes[System.Array.index(nodeId, this._nodes)].$clone();

                if (node.IsLeaf()) {
                    System.Diagnostics.Debug.Assert(node.LeafCount === 1);
                    return 1;
                }

                var count1 = this.CountLeaves(node.Child1);
                var count2 = this.CountLeaves(node.Child2);
                var count = (count1 + count2) | 0;
                System.Diagnostics.Debug.Assert(count === node.LeafCount);
                return count;
            },
            Validate: function () {
                this.CountLeaves(this._root);
            },
            AllocateNode: function () {
                if (this._freeList === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    System.Diagnostics.Debug.Assert(this._nodeCount === this._nodeCapacity);

                    var oldNodes = this._nodes;
                    this._nodeCapacity = Bridge.Int.mul(this._nodeCapacity, 2);
                    this._nodes = System.Array.init(this._nodeCapacity, function (){
                        return new (FarseerPhysics.Collision.DynamicTreeNode$1(T))();
                    }, FarseerPhysics.Collision.DynamicTreeNode$1(T));
                    System.Array.copy(oldNodes, 0, this._nodes, 0, this._nodeCount);

                    for (var i = this._nodeCount; i < ((this._nodeCapacity - 1) | 0); i = (i + 1) | 0) {
                        this._nodes[System.Array.index(i, this._nodes)].ParentOrNext = (i + 1) | 0;
                    }
                    this._nodes[System.Array.index(((this._nodeCapacity - 1) | 0), this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                    this._freeList = this._nodeCount;
                }

                var nodeId = this._freeList;
                this._freeList = this._nodes[System.Array.index(nodeId, this._nodes)].ParentOrNext;
                this._nodes[System.Array.index(nodeId, this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                this._nodes[System.Array.index(nodeId, this._nodes)].Child1 = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                this._nodes[System.Array.index(nodeId, this._nodes)].Child2 = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                this._nodes[System.Array.index(nodeId, this._nodes)].LeafCount = 0;
                this._nodeCount = (this._nodeCount + 1) | 0;
                return nodeId;
            },
            FreeNode: function (nodeId) {
                System.Diagnostics.Debug.Assert(0 <= nodeId && nodeId < this._nodeCapacity);
                System.Diagnostics.Debug.Assert(0 < this._nodeCount);
                this._nodes[System.Array.index(nodeId, this._nodes)].ParentOrNext = this._freeList;
                this._freeList = nodeId;
                this._nodeCount = (this._nodeCount - 1) | 0;
            },
            InsertLeaf: function (leaf) {
                this._insertionCount = (this._insertionCount + 1) | 0;

                if (this._root === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    this._root = leaf;
                    this._nodes[System.Array.index(this._root, this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                    return;
                }

                var leafAABB = { v : this._nodes[System.Array.index(leaf, this._nodes)].AABB.$clone() };
                var sibling = this._root;
                while (this._nodes[System.Array.index(sibling, this._nodes)].IsLeaf() === false) {
                    var child1 = this._nodes[System.Array.index(sibling, this._nodes)].Child1;
                    var child2 = this._nodes[System.Array.index(sibling, this._nodes)].Child2;

                    this._nodes[System.Array.index(sibling, this._nodes)].AABB.Combine(leafAABB);
                    this._nodes[System.Array.index(sibling, this._nodes)].LeafCount = (this._nodes[System.Array.index(sibling, this._nodes)].LeafCount + 1) | 0;

                    var siblingArea = this._nodes[System.Array.index(sibling, this._nodes)].AABB.Perimeter;
                    var parentAABB = new FarseerPhysics.Collision.AABB.ctor();
                    parentAABB.Combine$1(Bridge.ref(this._nodes[System.Array.index(sibling, this._nodes)], "AABB"), leafAABB);
                    var parentArea = parentAABB.Perimeter;
                    var cost1 = 2.0 * parentArea;

                    var inheritanceCost = 2.0 * (parentArea - siblingArea);

                    var cost2;
                    if (this._nodes[System.Array.index(child1, this._nodes)].IsLeaf()) {
                        var aabb = new FarseerPhysics.Collision.AABB.ctor();
                        aabb.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(child1, this._nodes)], "AABB"));
                        cost2 = aabb.Perimeter + inheritanceCost;
                    } else {
                        var aabb1 = new FarseerPhysics.Collision.AABB.ctor();
                        aabb1.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(child1, this._nodes)], "AABB"));
                        var oldArea = this._nodes[System.Array.index(child1, this._nodes)].AABB.Perimeter;
                        var newArea = aabb1.Perimeter;
                        cost2 = (newArea - oldArea) + inheritanceCost;
                    }

                    var cost3;
                    if (this._nodes[System.Array.index(child2, this._nodes)].IsLeaf()) {
                        var aabb2 = new FarseerPhysics.Collision.AABB.ctor();
                        aabb2.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(child2, this._nodes)], "AABB"));
                        cost3 = aabb2.Perimeter + inheritanceCost;
                    } else {
                        var aabb3 = new FarseerPhysics.Collision.AABB.ctor();
                        aabb3.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(child2, this._nodes)], "AABB"));
                        var oldArea1 = this._nodes[System.Array.index(child2, this._nodes)].AABB.Perimeter;
                        var newArea1 = aabb3.Perimeter;
                        cost3 = newArea1 - oldArea1 + inheritanceCost;
                    }

                    if (cost1 < cost2 && cost1 < cost3) {
                        break;
                    }

                    this._nodes[System.Array.index(sibling, this._nodes)].AABB.Combine(leafAABB);

                    if (cost2 < cost3) {
                        sibling = child1;
                    } else {
                        sibling = child2;
                    }
                }

                var oldParent = this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext;
                var newParent = this.AllocateNode();
                this._nodes[System.Array.index(newParent, this._nodes)].ParentOrNext = oldParent;
                this._nodes[System.Array.index(newParent, this._nodes)].UserData = Bridge.getDefaultValue(T);
                this._nodes[System.Array.index(newParent, this._nodes)].AABB.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(sibling, this._nodes)], "AABB"));
                this._nodes[System.Array.index(newParent, this._nodes)].LeafCount = (this._nodes[System.Array.index(sibling, this._nodes)].LeafCount + 1) | 0;

                if (oldParent !== FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    if (this._nodes[System.Array.index(oldParent, this._nodes)].Child1 === sibling) {
                        this._nodes[System.Array.index(oldParent, this._nodes)].Child1 = newParent;
                    } else {
                        this._nodes[System.Array.index(oldParent, this._nodes)].Child2 = newParent;
                    }

                    this._nodes[System.Array.index(newParent, this._nodes)].Child1 = sibling;
                    this._nodes[System.Array.index(newParent, this._nodes)].Child2 = leaf;
                    this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext = newParent;
                    this._nodes[System.Array.index(leaf, this._nodes)].ParentOrNext = newParent;
                } else {
                    this._nodes[System.Array.index(newParent, this._nodes)].Child1 = sibling;
                    this._nodes[System.Array.index(newParent, this._nodes)].Child2 = leaf;
                    this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext = newParent;
                    this._nodes[System.Array.index(leaf, this._nodes)].ParentOrNext = newParent;
                    this._root = newParent;
                }
            },
            RemoveLeaf: function (leaf) {
                if (leaf === this._root) {
                    this._root = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                    return;
                }

                var parent = this._nodes[System.Array.index(leaf, this._nodes)].ParentOrNext;
                var grandParent = this._nodes[System.Array.index(parent, this._nodes)].ParentOrNext;
                var sibling;
                if (this._nodes[System.Array.index(parent, this._nodes)].Child1 === leaf) {
                    sibling = this._nodes[System.Array.index(parent, this._nodes)].Child2;
                } else {
                    sibling = this._nodes[System.Array.index(parent, this._nodes)].Child1;
                }

                if (grandParent !== FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    if (this._nodes[System.Array.index(grandParent, this._nodes)].Child1 === parent) {
                        this._nodes[System.Array.index(grandParent, this._nodes)].Child1 = sibling;
                    } else {
                        this._nodes[System.Array.index(grandParent, this._nodes)].Child2 = sibling;
                    }
                    this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext = grandParent;
                    this.FreeNode(parent);

                    parent = grandParent;
                    while (parent !== FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                        this._nodes[System.Array.index(parent, this._nodes)].AABB.Combine$1(Bridge.ref(this._nodes[System.Array.index(this._nodes[System.Array.index(parent, this._nodes)].Child1, this._nodes)], "AABB"), Bridge.ref(this._nodes[System.Array.index(this._nodes[System.Array.index(parent, this._nodes)].Child2, this._nodes)], "AABB"));

                        System.Diagnostics.Debug.Assert(this._nodes[System.Array.index(parent, this._nodes)].LeafCount > 0);
                        this._nodes[System.Array.index(parent, this._nodes)].LeafCount = (this._nodes[System.Array.index(parent, this._nodes)].LeafCount - 1) | 0;

                        parent = this._nodes[System.Array.index(parent, this._nodes)].ParentOrNext;
                    }
                } else {
                    this._root = sibling;
                    this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                    this.FreeNode(parent);
                }
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Collision.IBroadPhase", {
        $kind: "interface"
    });

    /**
     * A node in the dynamic tree. The client does not interact with this directly.
     *
     * @class FarseerPhysics.Collision.DynamicTreeNode$1
     */
    Bridge.define("FarseerPhysics.Collision.DynamicTreeNode$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Collision.DynamicTreeNode$1(T))(); }
            }
        },
        fields: {
            /**
             * This is the fattened AABB.
             *
             * @instance
             * @memberof FarseerPhysics.Collision.DynamicTreeNode$1
             * @type FarseerPhysics.Collision.AABB
             */
            AABB: null,
            Child1: 0,
            Child2: 0,
            LeafCount: 0,
            ParentOrNext: 0,
            UserData: Bridge.getDefaultValue(T)
        },
        ctors: {
            init: function () {
                this.AABB = new FarseerPhysics.Collision.AABB();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            IsLeaf: function () {
                return this.Child1 === FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
            },
            getHashCode: function () {
                var h = Bridge.addHash([4372343954, this.AABB, this.Child1, this.Child2, this.LeafCount, this.ParentOrNext, this.UserData]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.DynamicTreeNode$1(T))) {
                    return false;
                }
                return Bridge.equals(this.AABB, o.AABB) && Bridge.equals(this.Child1, o.Child1) && Bridge.equals(this.Child2, o.Child2) && Bridge.equals(this.LeafCount, o.LeafCount) && Bridge.equals(this.ParentOrNext, o.ParentOrNext) && Bridge.equals(this.UserData, o.UserData);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Collision.DynamicTreeNode$1(T))();
                s.AABB = this.AABB.$clone();
                s.Child1 = this.Child1;
                s.Child2 = this.Child2;
                s.LeafCount = this.LeafCount;
                s.ParentOrNext = this.ParentOrNext;
                s.UserData = this.UserData;
                return s;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Collision.EPAxis", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.EPAxis(); }
            }
        },
        fields: {
            Index: 0,
            Separation: 0,
            Type: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([2017575854, this.Index, this.Separation, this.Type]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.EPAxis)) {
                    return false;
                }
                return Bridge.equals(this.Index, o.Index) && Bridge.equals(this.Separation, o.Separation) && Bridge.equals(this.Type, o.Type);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.EPAxis();
                s.Index = this.Index;
                s.Separation = this.Separation;
                s.Type = this.Type;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.EPAxisType", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: 0,
                EdgeA: 1,
                EdgeB: 2
            }
        }
    });

    /**
     * This lets us treate and edge shape and a polygon in the same
     way in the SAT collider.
     *
     * @public
     * @class FarseerPhysics.Collision.EPProxy
     */
    Bridge.define("FarseerPhysics.Collision.EPProxy", {
        fields: {
            Centroid: null,
            Count: 0,
            Normals: null,
            Vertices: null
        },
        ctors: {
            init: function () {
                this.Centroid = new Microsoft.Xna.Framework.Vector2();
                this.Normals = System.Array.init(FarseerPhysics.Settings.MaxPolygonVertices, function (){
                    return new Microsoft.Xna.Framework.Vector2();
                }, Microsoft.Xna.Framework.Vector2);
                this.Vertices = System.Array.init(FarseerPhysics.Settings.MaxPolygonVertices, function (){
                    return new Microsoft.Xna.Framework.Vector2();
                }, Microsoft.Xna.Framework.Vector2);
            }
        }
    });

    /**
     * Edge shape plus more stuff.
     *
     * @public
     * @class FarseerPhysics.Collision.FatEdge
     */
    Bridge.define("FarseerPhysics.Collision.FatEdge", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.FatEdge(); }
            }
        },
        fields: {
            HasVertex0: false,
            HasVertex3: false,
            Normal: null,
            V0: null,
            V1: null,
            V2: null,
            V3: null
        },
        ctors: {
            init: function () {
                this.Normal = new Microsoft.Xna.Framework.Vector2();
                this.V0 = new Microsoft.Xna.Framework.Vector2();
                this.V1 = new Microsoft.Xna.Framework.Vector2();
                this.V2 = new Microsoft.Xna.Framework.Vector2();
                this.V3 = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([1171900586, this.HasVertex0, this.HasVertex3, this.Normal, this.V0, this.V1, this.V2, this.V3]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.FatEdge)) {
                    return false;
                }
                return Bridge.equals(this.HasVertex0, o.HasVertex0) && Bridge.equals(this.HasVertex3, o.HasVertex3) && Bridge.equals(this.Normal, o.Normal) && Bridge.equals(this.V0, o.V0) && Bridge.equals(this.V1, o.V1) && Bridge.equals(this.V2, o.V2) && Bridge.equals(this.V3, o.V3);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.FatEdge();
                s.HasVertex0 = this.HasVertex0;
                s.HasVertex3 = this.HasVertex3;
                s.Normal = this.Normal.$clone();
                s.V0 = this.V0.$clone();
                s.V1 = this.V1.$clone();
                s.V2 = this.V2.$clone();
                s.V3 = this.V3.$clone();
                return s;
            }
        }
    });

    /**
     * A manifold for two touching convex Shapes.
     Box2D supports multiple types of contact:
     - clip point versus plane with radius
     - point versus point with radius (circles)
     The local point usage depends on the manifold type:
     -ShapeType.Circles: the local center of circleA
     -SeparationFunction.FaceA: the center of faceA
     -SeparationFunction.FaceB: the center of faceB
     Similarly the local normal usage:
     -ShapeType.Circles: not used
     -SeparationFunction.FaceA: the normal on polygonA
     -SeparationFunction.FaceB: the normal on polygonB
     We store contacts in this way so that position correction can
     account for movement, which is critical for continuous physics.
     All contact scenarios must be expressed in one of these types.
     This structure is stored across time steps, so we keep it small.
     *
     * @public
     * @class FarseerPhysics.Collision.Manifold
     */
    Bridge.define("FarseerPhysics.Collision.Manifold", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.Manifold(); }
            }
        },
        fields: {
            /**
             * Not use for Type.SeparationFunction.Points
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Manifold
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalNormal: null,
            /**
             * Usage depends on manifold type
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Manifold
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalPoint: null,
            /**
             * The number of manifold points
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Manifold
             * @type number
             */
            PointCount: 0,
            /**
             * The points of contact
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Manifold
             * @type FarseerPhysics.Common.FixedArray2$1
             */
            Points: null,
            Type: 0
        },
        ctors: {
            init: function () {
                this.LocalNormal = new Microsoft.Xna.Framework.Vector2();
                this.LocalPoint = new Microsoft.Xna.Framework.Vector2();
                this.Points = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ManifoldPoint))();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3453669555, this.LocalNormal, this.LocalPoint, this.PointCount, this.Points, this.Type]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.Manifold)) {
                    return false;
                }
                return Bridge.equals(this.LocalNormal, o.LocalNormal) && Bridge.equals(this.LocalPoint, o.LocalPoint) && Bridge.equals(this.PointCount, o.PointCount) && Bridge.equals(this.Points, o.Points) && Bridge.equals(this.Type, o.Type);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.Manifold();
                s.LocalNormal = this.LocalNormal.$clone();
                s.LocalPoint = this.LocalPoint.$clone();
                s.PointCount = this.PointCount;
                s.Points = this.Points.$clone();
                s.Type = this.Type;
                return s;
            }
        }
    });

    /**
     * A manifold point is a contact point belonging to a contact
     manifold. It holds details related to the geometry and dynamics
     of the contact points.
     The local point usage depends on the manifold type:
     -ShapeType.Circles: the local center of circleB
     -SeparationFunction.FaceA: the local center of cirlceB or the clip point of polygonB
     -SeparationFunction.FaceB: the clip point of polygonA
     This structure is stored across time steps, so we keep it small.
     Note: the impulses are used for internal caching and may not
     provide reliable contact forces, especially for high speed collisions.
     *
     * @public
     * @class FarseerPhysics.Collision.ManifoldPoint
     */
    Bridge.define("FarseerPhysics.Collision.ManifoldPoint", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.ManifoldPoint(); }
            }
        },
        fields: {
            /**
             * Uniquely identifies a contact point between two Shapes
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ManifoldPoint
             * @type FarseerPhysics.Collision.ContactID
             */
            Id: null,
            LocalPoint: null,
            NormalImpulse: 0,
            TangentImpulse: 0
        },
        ctors: {
            init: function () {
                this.Id = new FarseerPhysics.Collision.ContactID();
                this.LocalPoint = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5306073207, this.Id, this.LocalPoint, this.NormalImpulse, this.TangentImpulse]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.ManifoldPoint)) {
                    return false;
                }
                return Bridge.equals(this.Id, o.Id) && Bridge.equals(this.LocalPoint, o.LocalPoint) && Bridge.equals(this.NormalImpulse, o.NormalImpulse) && Bridge.equals(this.TangentImpulse, o.TangentImpulse);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.ManifoldPoint();
                s.Id = this.Id.$clone();
                s.LocalPoint = this.LocalPoint.$clone();
                s.NormalImpulse = this.NormalImpulse;
                s.TangentImpulse = this.TangentImpulse;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.ManifoldType", {
        $kind: "enum",
        statics: {
            fields: {
                Circles: 0,
                FaceA: 1,
                FaceB: 2
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Pair", {
        inherits: function () { return [System.IComparable$1(FarseerPhysics.Collision.Pair)]; },
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.Pair(); }
            }
        },
        fields: {
            ProxyIdA: 0,
            ProxyIdB: 0
        },
        alias: ["compareTo", ["System$IComparable$1$FarseerPhysics$Collision$Pair$compareTo", "System$IComparable$1$compareTo"]],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            compareTo: function (other) {
                if (this.ProxyIdA < other.ProxyIdA) {
                    return -1;
                }
                if (this.ProxyIdA === other.ProxyIdA) {
                    if (this.ProxyIdB < other.ProxyIdB) {
                        return -1;
                    }
                    if (this.ProxyIdB === other.ProxyIdB) {
                        return 0;
                    }
                }

                return 1;
            },
            getHashCode: function () {
                var h = Bridge.addHash([1919508816, this.ProxyIdA, this.ProxyIdB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.Pair)) {
                    return false;
                }
                return Bridge.equals(this.ProxyIdA, o.ProxyIdA) && Bridge.equals(this.ProxyIdB, o.ProxyIdB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.Pair();
                s.ProxyIdA = this.ProxyIdA;
                s.ProxyIdB = this.ProxyIdB;
                return s;
            }
        }
    });

    /**
     * This is used for determining the state of contact points.
     *
     * @public
     * @class FarseerPhysics.Collision.PointState
     */
    Bridge.define("FarseerPhysics.Collision.PointState", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Point does not exist
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Collision.PointState
                 * @constant
                 * @default 0
                 * @type FarseerPhysics.Collision.PointState
                 */
                Null: 0,
                /**
                 * Point was added in the update
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Collision.PointState
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Collision.PointState
                 */
                Add: 1,
                /**
                 * Point persisted across the update
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Collision.PointState
                 * @constant
                 * @default 2
                 * @type FarseerPhysics.Collision.PointState
                 */
                Persist: 2,
                /**
                 * Point was removed in the update
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Collision.PointState
                 * @constant
                 * @default 3
                 * @type FarseerPhysics.Collision.PointState
                 */
                Remove: 3
            }
        }
    });

    /**
     * Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
     *
     * @public
     * @class FarseerPhysics.Collision.RayCastInput
     */
    Bridge.define("FarseerPhysics.Collision.RayCastInput", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.RayCastInput(); }
            }
        },
        fields: {
            MaxFraction: 0,
            Point1: null,
            Point2: null
        },
        ctors: {
            init: function () {
                this.Point1 = new Microsoft.Xna.Framework.Vector2();
                this.Point2 = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([4318250273, this.MaxFraction, this.Point1, this.Point2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.RayCastInput)) {
                    return false;
                }
                return Bridge.equals(this.MaxFraction, o.MaxFraction) && Bridge.equals(this.Point1, o.Point1) && Bridge.equals(this.Point2, o.Point2);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.RayCastInput();
                s.MaxFraction = this.MaxFraction;
                s.Point1 = this.Point1.$clone();
                s.Point2 = this.Point2.$clone();
                return s;
            }
        }
    });

    /**
     * Ray-cast output data.  The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
     come from RayCastInput.
     *
     * @public
     * @class FarseerPhysics.Collision.RayCastOutput
     */
    Bridge.define("FarseerPhysics.Collision.RayCastOutput", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.RayCastOutput(); }
            }
        },
        fields: {
            Fraction: 0,
            Normal: null
        },
        ctors: {
            init: function () {
                this.Normal = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([4435364252, this.Fraction, this.Normal]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.RayCastOutput)) {
                    return false;
                }
                return Bridge.equals(this.Fraction, o.Fraction) && Bridge.equals(this.Normal, o.Normal);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.RayCastOutput();
                s.Fraction = this.Fraction;
                s.Normal = this.Normal.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.SeparationFunction", {
        statics: {
            fields: {
                _axis: null,
                _localPoint: null,
                _proxyA: null,
                _proxyB: null,
                _sweepA: null,
                _sweepB: null,
                _type: 0
            },
            ctors: {
                init: function () {
                    this._axis = new Microsoft.Xna.Framework.Vector2();
                    this._localPoint = new Microsoft.Xna.Framework.Vector2();
                    this._sweepA = new FarseerPhysics.Common.Sweep();
                    this._sweepB = new FarseerPhysics.Common.Sweep();
                    this._proxyA = new FarseerPhysics.Collision.DistanceProxy();
                    this._proxyB = new FarseerPhysics.Collision.DistanceProxy();
                }
            },
            methods: {
                Set: function (cache, proxyA, sweepA, proxyB, sweepB, t1) {
                    FarseerPhysics.Collision.SeparationFunction._localPoint = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    FarseerPhysics.Collision.SeparationFunction._proxyA = proxyA;
                    FarseerPhysics.Collision.SeparationFunction._proxyB = proxyB;
                    var count = cache.v.Count;
                    System.Diagnostics.Debug.Assert(0 < count && count < 3);

                    FarseerPhysics.Collision.SeparationFunction._sweepA = sweepA.v.$clone();
                    FarseerPhysics.Collision.SeparationFunction._sweepB = sweepB.v.$clone();

                    var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                    FarseerPhysics.Collision.SeparationFunction._sweepA.GetTransform(xfA, t1);
                    FarseerPhysics.Collision.SeparationFunction._sweepB.GetTransform(xfB, t1);

                    if (count === 1) {
                        FarseerPhysics.Collision.SeparationFunction._type = FarseerPhysics.Collision.SeparationFunctionType.Points;
                        var localPointA = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(cache.v.IndexA.getItem(0)).$clone();
                        var localPointB = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(cache.v.IndexB.getItem(0)).$clone();
                        var pointA = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA.$clone());
                        var pointB = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB.$clone());
                        FarseerPhysics.Collision.SeparationFunction._axis = Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(), pointA.$clone());
                        FarseerPhysics.Collision.SeparationFunction._axis.Normalize();
                        return;
                    } else if (cache.v.IndexA.getItem(0) === cache.v.IndexA.getItem(1)) {
                        FarseerPhysics.Collision.SeparationFunction._type = FarseerPhysics.Collision.SeparationFunctionType.FaceB;
                        var localPointB1 = proxyB.Vertices.getItem(cache.v.IndexB.getItem(0)).$clone();
                        var localPointB2 = proxyB.Vertices.getItem(cache.v.IndexB.getItem(1)).$clone();

                        var a = Microsoft.Xna.Framework.Vector2.op_Subtraction(localPointB2.$clone(), localPointB1.$clone());
                        FarseerPhysics.Collision.SeparationFunction._axis = new Microsoft.Xna.Framework.Vector2.$ctor2(a.Y, -a.X);
                        FarseerPhysics.Collision.SeparationFunction._axis.Normalize();
                        var normal = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());

                        FarseerPhysics.Collision.SeparationFunction._localPoint = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(localPointB1.$clone(), localPointB2.$clone())));
                        var pointB1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                        var localPointA1 = proxyA.Vertices.getItem(cache.v.IndexA.getItem(0)).$clone();
                        var pointA1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA1.$clone());

                        var s = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA1.$clone(), pointB1.$clone()), normal.$clone());
                        if (s < 0.0) {
                            FarseerPhysics.Collision.SeparationFunction._axis = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                            s = -s;
                        }
                        return;
                    } else {
                        FarseerPhysics.Collision.SeparationFunction._type = FarseerPhysics.Collision.SeparationFunctionType.FaceA;
                        var localPointA11 = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(cache.v.IndexA.getItem(0)).$clone();
                        var localPointA2 = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(cache.v.IndexA.getItem(1)).$clone();

                        var a1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(localPointA2.$clone(), localPointA11.$clone());
                        FarseerPhysics.Collision.SeparationFunction._axis = new Microsoft.Xna.Framework.Vector2.$ctor2(a1.Y, -a1.X);
                        FarseerPhysics.Collision.SeparationFunction._axis.Normalize();
                        var normal1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());

                        FarseerPhysics.Collision.SeparationFunction._localPoint = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(localPointA11.$clone(), localPointA2.$clone())));
                        var pointA2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                        var localPointB3 = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(cache.v.IndexB.getItem(0)).$clone();
                        var pointB2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB3.$clone());

                        var s1 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB2.$clone(), pointA2.$clone()), normal1.$clone());
                        if (s1 < 0.0) {
                            FarseerPhysics.Collision.SeparationFunction._axis = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                            s1 = -s1;
                        }
                        return;
                    }
                },
                FindMinSeparation: function (indexA, indexB, t) {
                    var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                    FarseerPhysics.Collision.SeparationFunction._sweepA.GetTransform(xfA, t);
                    FarseerPhysics.Collision.SeparationFunction._sweepB.GetTransform(xfB, t);

                    switch (FarseerPhysics.Collision.SeparationFunction._type) {
                        case FarseerPhysics.Collision.SeparationFunctionType.Points: 
                            {
                                var axisA = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var axisB = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.SeparationFunction._axis.$clone()));

                                indexA.v = FarseerPhysics.Collision.SeparationFunction._proxyA.GetSupport(axisA.$clone());
                                indexB.v = FarseerPhysics.Collision.SeparationFunction._proxyB.GetSupport(axisB.$clone());

                                var localPointA = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(indexA.v).$clone();
                                var localPointB = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(indexB.v).$clone();

                                var pointA = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA.$clone());
                                var pointB = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB.$clone());

                                var separation = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(), pointA.$clone()), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                return separation;
                            }
                        case FarseerPhysics.Collision.SeparationFunctionType.FaceA: 
                            {
                                var normal = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var pointA1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                                var axisB1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.$clone()));

                                indexA.v = -1;
                                indexB.v = FarseerPhysics.Collision.SeparationFunction._proxyB.GetSupport(axisB1.$clone());

                                var localPointB1 = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(indexB.v).$clone();
                                var pointB1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB1.$clone());

                                var separation1 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB1.$clone(), pointA1.$clone()), normal.$clone());
                                return separation1;
                            }
                        case FarseerPhysics.Collision.SeparationFunctionType.FaceB: 
                            {
                                var normal1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var pointB2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                                var axisA1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()));

                                indexB.v = -1;
                                indexA.v = FarseerPhysics.Collision.SeparationFunction._proxyA.GetSupport(axisA1.$clone());

                                var localPointA1 = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(indexA.v).$clone();
                                var pointA2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA1.$clone());

                                var separation2 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA2.$clone(), pointB2.$clone()), normal1.$clone());
                                return separation2;
                            }
                        default: 
                            System.Diagnostics.Debug.Assert(false);
                            indexA.v = -1;
                            indexB.v = -1;
                            return 0.0;
                    }
                },
                Evaluate: function (indexA, indexB, t) {
                    var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                    FarseerPhysics.Collision.SeparationFunction._sweepA.GetTransform(xfA, t);
                    FarseerPhysics.Collision.SeparationFunction._sweepB.GetTransform(xfB, t);

                    switch (FarseerPhysics.Collision.SeparationFunction._type) {
                        case FarseerPhysics.Collision.SeparationFunctionType.Points: 
                            {
                                var axisA = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var axisB = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.SeparationFunction._axis.$clone()));

                                var localPointA = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(indexA).$clone();
                                var localPointB = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(indexB).$clone();

                                var pointA = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA.$clone());
                                var pointB = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB.$clone());
                                var separation = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(), pointA.$clone()), FarseerPhysics.Collision.SeparationFunction._axis.$clone());

                                return separation;
                            }
                        case FarseerPhysics.Collision.SeparationFunctionType.FaceA: 
                            {
                                var normal = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var pointA1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                                var axisB1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.$clone()));

                                var localPointB1 = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(indexB).$clone();
                                var pointB1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB1.$clone());

                                var separation1 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB1.$clone(), pointA1.$clone()), normal.$clone());
                                return separation1;
                            }
                        case FarseerPhysics.Collision.SeparationFunctionType.FaceB: 
                            {
                                var normal1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var pointB2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                                var axisA1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()));

                                var localPointA1 = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(indexA).$clone();
                                var pointA2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA1.$clone());

                                var separation2 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA2.$clone(), pointB2.$clone()), normal1.$clone());
                                return separation2;
                            }
                        default: 
                            System.Diagnostics.Debug.Assert(false);
                            return 0.0;
                    }
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.SeparationFunctionType", {
        $kind: "enum",
        statics: {
            fields: {
                Points: 0,
                FaceA: 1,
                FaceB: 2
            }
        }
    });

    /** @namespace FarseerPhysics.Collision.Shapes */

    /**
     * A shape is used for collision detection. You can create a shape however you like.
     Shapes used for simulation in World are created automatically when a Fixture
     is created. Shapes may encapsulate a one or more child shapes.
     *
     * @abstract
     * @public
     * @class FarseerPhysics.Collision.Shapes.Shape
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.Shape", {
        statics: {
            fields: {
                _shapeIdCounter: 0
            }
        },
        fields: {
            MassData: null,
            ShapeId: 0,
            _density: 0,
            _radius: 0,
            /**
             * Get the type of this shape.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.Shape
             * @function ShapeType
             * @type FarseerPhysics.Collision.Shapes.ShapeType
             */
            ShapeType: 0
        },
        props: {
            /**
             * Gets or sets the density.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.Shape
             * @function Density
             * @type number
             */
            Density: {
                get: function () {
                    return this._density;
                },
                set: function (value) {
                    this._density = value;
                    this.ComputeProperties();
                }
            },
            /**
             * Radius of the Shape
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.Shape
             * @function Radius
             * @type number
             */
            Radius: {
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.ComputeProperties();
                }
            }
        },
        ctors: {
            init: function () {
                this.MassData = new FarseerPhysics.Collision.Shapes.MassData();
            },
            ctor: function (density) {
                var $t;
                this.$initialize();
                this._density = density;
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Unknown;
                this.ShapeId = Bridge.identity(FarseerPhysics.Collision.Shapes.Shape._shapeIdCounter, ($t = (FarseerPhysics.Collision.Shapes.Shape._shapeIdCounter + 1) | 0, FarseerPhysics.Collision.Shapes.Shape._shapeIdCounter = $t, $t));
            }
        },
        methods: {
            CompareTo: function (shape) {
                if (Bridge.is(shape, FarseerPhysics.Collision.Shapes.PolygonShape) && Bridge.is(this, FarseerPhysics.Collision.Shapes.PolygonShape)) {
                    return Bridge.cast(this, FarseerPhysics.Collision.Shapes.PolygonShape).CompareTo$1(Bridge.cast(shape, FarseerPhysics.Collision.Shapes.PolygonShape));
                }

                if (Bridge.is(shape, FarseerPhysics.Collision.Shapes.CircleShape) && Bridge.is(this, FarseerPhysics.Collision.Shapes.CircleShape)) {
                    return Bridge.cast(this, FarseerPhysics.Collision.Shapes.CircleShape).CompareTo$1(Bridge.cast(shape, FarseerPhysics.Collision.Shapes.CircleShape));
                }

                if (Bridge.is(shape, FarseerPhysics.Collision.Shapes.EdgeShape) && Bridge.is(this, FarseerPhysics.Collision.Shapes.EdgeShape)) {
                    return Bridge.cast(this, FarseerPhysics.Collision.Shapes.EdgeShape).CompareTo$1(Bridge.cast(shape, FarseerPhysics.Collision.Shapes.EdgeShape));
                }

                return false;
            }
        }
    });

    /**
     * This holds the mass data computed for a shape.
     *
     * @public
     * @class FarseerPhysics.Collision.Shapes.MassData
     * @implements  System.IEquatable$1
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.MassData", {
        inherits: function () { return [System.IEquatable$1(FarseerPhysics.Collision.Shapes.MassData)]; },
        $kind: "struct",
        statics: {
            methods: {
                op_Equality: function (left, right) {
                    return (left.Area === right.Area && left.Mass === right.Mass && Microsoft.Xna.Framework.Vector2.op_Equality(left.Centroid.$clone(), right.Centroid.$clone()) && left.Inertia === right.Inertia);
                },
                op_Inequality: function (left, right) {
                    return !(FarseerPhysics.Collision.Shapes.MassData.op_Equality(left.$clone(), right.$clone()));
                },
                getDefaultValue: function () { return new FarseerPhysics.Collision.Shapes.MassData(); }
            }
        },
        fields: {
            /**
             * The area of the shape
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.MassData
             * @type number
             */
            Area: 0,
            /**
             * The position of the shape's centroid relative to the shape's origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.MassData
             * @type Microsoft.Xna.Framework.Vector2
             */
            Centroid: null,
            /**
             * The rotational inertia of the shape about the local origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.MassData
             * @type number
             */
            Inertia: 0,
            /**
             * The mass of the shape, usually in kilograms.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.MassData
             * @type number
             */
            Mass: 0
        },
        alias: ["equalsT", "System$IEquatable$1$FarseerPhysics$Collision$Shapes$MassData$equalsT"],
        ctors: {
            init: function () {
                this.Centroid = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equalsT: function (other) {
                return FarseerPhysics.Collision.Shapes.MassData.op_Equality(this, other.$clone());
            },
            equals: function (obj) {
                if (Bridge.referenceEquals(null, obj)) {
                    return false;
                }
                if (!Bridge.referenceEquals(Bridge.getType(obj), FarseerPhysics.Collision.Shapes.MassData)) {
                    return false;
                }
                return this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, FarseerPhysics.Collision.Shapes.MassData), FarseerPhysics.Collision.Shapes.MassData)));
            },
            getHashCode: function () {
                var result = System.Single.getHashCode(this.Area);
                result = (Bridge.Int.mul(result, 397)) ^ this.Centroid.getHashCode();
                result = (Bridge.Int.mul(result, 397)) ^ System.Single.getHashCode(this.Inertia);
                result = (Bridge.Int.mul(result, 397)) ^ System.Single.getHashCode(this.Mass);
                return result;
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.Shapes.MassData();
                s.Area = this.Area;
                s.Centroid = this.Centroid.$clone();
                s.Inertia = this.Inertia;
                s.Mass = this.Mass;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Shapes.ShapeType", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: -1,
                Circle: 0,
                Edge: 1,
                Polygon: 2,
                Loop: 3,
                TypeCount: 4
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Simplex", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.Simplex(); }
            }
        },
        fields: {
            Count: 0,
            V: null
        },
        ctors: {
            init: function () {
                this.V = new (FarseerPhysics.Common.FixedArray3$1(FarseerPhysics.Collision.SimplexVertex))();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            ReadCache: function (cache, proxyA, transformA, proxyB, transformB) {
                System.Diagnostics.Debug.Assert(cache.v.Count <= 3);

                this.Count = cache.v.Count;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var v = this.V.getItem(i).$clone();
                    v.IndexA = cache.v.IndexA.getItem(i);
                    v.IndexB = cache.v.IndexB.getItem(i);
                    var wALocal = proxyA.Vertices.getItem(v.IndexA).$clone();
                    var wBLocal = proxyB.Vertices.getItem(v.IndexB).$clone();
                    v.WA = FarseerPhysics.Common.MathUtils.Multiply$2(transformA, wALocal.$clone());
                    v.WB = FarseerPhysics.Common.MathUtils.Multiply$2(transformB, wBLocal.$clone());
                    v.W = Microsoft.Xna.Framework.Vector2.op_Subtraction(v.WB.$clone(), v.WA.$clone());
                    v.A = 0.0;
                    this.V.setItem(i, v.$clone());
                }

                if (this.Count > 1) {
                    var metric1 = cache.v.Metric;
                    var metric2 = this.GetMetric();
                    if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2 || metric2 < FarseerPhysics.Settings.Epsilon) {
                        this.Count = 0;
                    }
                }

                if (this.Count === 0) {
                    var v1 = this.V.getItem(0).$clone();
                    v1.IndexA = 0;
                    v1.IndexB = 0;
                    var wALocal1 = proxyA.Vertices.getItem(0).$clone();
                    var wBLocal1 = proxyB.Vertices.getItem(0).$clone();
                    v1.WA = FarseerPhysics.Common.MathUtils.Multiply$2(transformA, wALocal1.$clone());
                    v1.WB = FarseerPhysics.Common.MathUtils.Multiply$2(transformB, wBLocal1.$clone());
                    v1.W = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.WB.$clone(), v1.WA.$clone());
                    this.V.setItem(0, v1.$clone());
                    this.Count = 1;
                }
            },
            WriteCache: function (cache) {
                cache.v.Metric = this.GetMetric();
                cache.v.Count = this.Count & 65535;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    cache.v.IndexA.setItem(i, (this.V.getItem(i).$clone().IndexA) & 255);
                    cache.v.IndexB.setItem(i, (this.V.getItem(i).$clone().IndexB) & 255);
                }
            },
            GetSearchDirection: function () {
                switch (this.Count) {
                    case 1: 
                        return Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this.V.getItem(0).$clone().W.$clone());
                    case 2: 
                        {
                            var e12 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(1).$clone().W.$clone(), this.V.getItem(0).$clone().W.$clone());
                            var sgn = FarseerPhysics.Common.MathUtils.Cross$2(e12.$clone(), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this.V.getItem(0).$clone().W.$clone()));
                            if (sgn > 0.0) {
                                return new Microsoft.Xna.Framework.Vector2.$ctor2(-e12.Y, e12.X);
                            } else {
                                return new Microsoft.Xna.Framework.Vector2.$ctor2(e12.Y, -e12.X);
                            }
                        }
                    default: 
                        System.Diagnostics.Debug.Assert(false);
                        return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }
            },
            GetClosestPoint: function () {
                switch (this.Count) {
                    case 0: 
                        System.Diagnostics.Debug.Assert(false);
                        return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    case 1: 
                        return this.V.getItem(0).$clone().W.$clone();
                    case 2: 
                        return Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A, this.V.getItem(0).$clone().W.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A, this.V.getItem(1).$clone().W.$clone()));
                    case 3: 
                        return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    default: 
                        System.Diagnostics.Debug.Assert(false);
                        return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }
            },
            GetWitnessPoints: function (pA, pB) {
                switch (this.Count) {
                    case 0: 
                        pA.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        pB.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        System.Diagnostics.Debug.Assert(false);
                        break;
                    case 1: 
                        pA.v = this.V.getItem(0).$clone().WA.$clone();
                        pB.v = this.V.getItem(0).$clone().WB.$clone();
                        break;
                    case 2: 
                        pA.v = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A, this.V.getItem(0).$clone().WA.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A, this.V.getItem(1).$clone().WA.$clone()));
                        pB.v = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A, this.V.getItem(0).$clone().WB.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A, this.V.getItem(1).$clone().WB.$clone()));
                        break;
                    case 3: 
                        pA.v = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A, this.V.getItem(0).$clone().WA.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A, this.V.getItem(1).$clone().WA.$clone())), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(2).$clone().A, this.V.getItem(2).$clone().WA.$clone()));
                        pB.v = pA.v.$clone();
                        break;
                    default: 
                        throw new System.Exception();
                }
            },
            GetMetric: function () {
                switch (this.Count) {
                    case 0: 
                        System.Diagnostics.Debug.Assert(false);
                        return 0.0;
                    case 1: 
                        return 0.0;
                    case 2: 
                        return (Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(0).$clone().W.$clone(), this.V.getItem(1).$clone().W.$clone())).Length();
                    case 3: 
                        return FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(1).$clone().W.$clone(), this.V.getItem(0).$clone().W.$clone()), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(2).$clone().W.$clone(), this.V.getItem(0).$clone().W.$clone()));
                    default: 
                        System.Diagnostics.Debug.Assert(false);
                        return 0.0;
                }
            },
            Solve2: function () {
                var w1 = this.V.getItem(0).$clone().W.$clone();
                var w2 = this.V.getItem(1).$clone().W.$clone();
                var e12 = Microsoft.Xna.Framework.Vector2.op_Subtraction(w2.$clone(), w1.$clone());

                var d12_2 = -Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(), e12.$clone());
                if (d12_2 <= 0.0) {
                    var v0 = this.V.getItem(0).$clone();
                    v0.A = 1.0;
                    this.V.setItem(0, v0.$clone());
                    this.Count = 1;
                    return;
                }

                var d12_1 = Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(), e12.$clone());
                if (d12_1 <= 0.0) {
                    var v1 = this.V.getItem(1).$clone();
                    v1.A = 1.0;
                    this.V.setItem(1, v1.$clone());
                    this.Count = 1;
                    this.V.setItem(0, this.V.getItem(1).$clone());
                    return;
                }

                var inv_d12 = 1.0 / (d12_1 + d12_2);
                var v0_2 = this.V.getItem(0).$clone();
                var v1_2 = this.V.getItem(1).$clone();
                v0_2.A = d12_1 * inv_d12;
                v1_2.A = d12_2 * inv_d12;
                this.V.setItem(0, v0_2.$clone());
                this.V.setItem(1, v1_2.$clone());
                this.Count = 2;
            },
            Solve3: function () {
                var w1 = this.V.getItem(0).$clone().W.$clone();
                var w2 = this.V.getItem(1).$clone().W.$clone();
                var w3 = this.V.getItem(2).$clone().W.$clone();

                var e12 = Microsoft.Xna.Framework.Vector2.op_Subtraction(w2.$clone(), w1.$clone());
                var w1e12 = Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(), e12.$clone());
                var w2e12 = Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(), e12.$clone());
                var d12_1 = w2e12;
                var d12_2 = -w1e12;

                var e13 = Microsoft.Xna.Framework.Vector2.op_Subtraction(w3.$clone(), w1.$clone());
                var w1e13 = Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(), e13.$clone());
                var w3e13 = Microsoft.Xna.Framework.Vector2.Dot(w3.$clone(), e13.$clone());
                var d13_1 = w3e13;
                var d13_2 = -w1e13;

                var e23 = Microsoft.Xna.Framework.Vector2.op_Subtraction(w3.$clone(), w2.$clone());
                var w2e23 = Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(), e23.$clone());
                var w3e23 = Microsoft.Xna.Framework.Vector2.Dot(w3.$clone(), e23.$clone());
                var d23_1 = w3e23;
                var d23_2 = -w2e23;

                var n123 = FarseerPhysics.Common.MathUtils.Cross$2(e12.$clone(), e13.$clone());

                var d123_1 = n123 * FarseerPhysics.Common.MathUtils.Cross$2(w2.$clone(), w3.$clone());
                var d123_2 = n123 * FarseerPhysics.Common.MathUtils.Cross$2(w3.$clone(), w1.$clone());
                var d123_3 = n123 * FarseerPhysics.Common.MathUtils.Cross$2(w1.$clone(), w2.$clone());

                if (d12_2 <= 0.0 && d13_2 <= 0.0) {
                    var v0_1 = this.V.getItem(0).$clone();
                    v0_1.A = 1.0;
                    this.V.setItem(0, v0_1.$clone());
                    this.Count = 1;
                    return;
                }

                if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
                    var inv_d12 = 1.0 / (d12_1 + d12_2);
                    var v0_2 = this.V.getItem(0).$clone();
                    var v1_2 = this.V.getItem(1).$clone();
                    v0_2.A = d12_1 * inv_d12;
                    v1_2.A = d12_2 * inv_d12;
                    this.V.setItem(0, v0_2.$clone());
                    this.V.setItem(1, v1_2.$clone());
                    this.Count = 2;
                    return;
                }

                if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
                    var inv_d13 = 1.0 / (d13_1 + d13_2);
                    var v0_3 = this.V.getItem(0).$clone();
                    var v2_3 = this.V.getItem(2).$clone();
                    v0_3.A = d13_1 * inv_d13;
                    v2_3.A = d13_2 * inv_d13;
                    this.V.setItem(0, v0_3.$clone());
                    this.V.setItem(2, v2_3.$clone());
                    this.Count = 2;
                    this.V.setItem(1, this.V.getItem(2).$clone());
                    return;
                }

                if (d12_1 <= 0.0 && d23_2 <= 0.0) {
                    var v1_4 = this.V.getItem(1).$clone();
                    v1_4.A = 1.0;
                    this.V.setItem(1, v1_4.$clone());
                    this.Count = 1;
                    this.V.setItem(0, this.V.getItem(1).$clone());
                    return;
                }

                if (d13_1 <= 0.0 && d23_1 <= 0.0) {
                    var v2_5 = this.V.getItem(2).$clone();
                    v2_5.A = 1.0;
                    this.V.setItem(2, v2_5.$clone());
                    this.Count = 1;
                    this.V.setItem(0, this.V.getItem(2).$clone());
                    return;
                }

                if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
                    var inv_d23 = 1.0 / (d23_1 + d23_2);
                    var v1_6 = this.V.getItem(1).$clone();
                    var v2_6 = this.V.getItem(2).$clone();
                    v1_6.A = d23_1 * inv_d23;
                    v2_6.A = d23_2 * inv_d23;
                    this.V.setItem(1, v1_6.$clone());
                    this.V.setItem(2, v2_6.$clone());
                    this.Count = 2;
                    this.V.setItem(0, this.V.getItem(2).$clone());
                    return;
                }

                var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
                var v0_7 = this.V.getItem(0).$clone();
                var v1_7 = this.V.getItem(1).$clone();
                var v2_7 = this.V.getItem(2).$clone();
                v0_7.A = d123_1 * inv_d123;
                v1_7.A = d123_2 * inv_d123;
                v2_7.A = d123_3 * inv_d123;
                this.V.setItem(0, v0_7.$clone());
                this.V.setItem(1, v1_7.$clone());
                this.V.setItem(2, v2_7.$clone());
                this.Count = 3;
            },
            getHashCode: function () {
                var h = Bridge.addHash([1894108863, this.Count, this.V]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.Simplex)) {
                    return false;
                }
                return Bridge.equals(this.Count, o.Count) && Bridge.equals(this.V, o.V);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.Simplex();
                s.Count = this.Count;
                s.V = this.V.$clone();
                return s;
            }
        }
    });

    /**
     * Used to warm start ComputeDistance.
     Set count to zero on first call.
     *
     * @public
     * @class FarseerPhysics.Collision.SimplexCache
     */
    Bridge.define("FarseerPhysics.Collision.SimplexCache", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.SimplexCache(); }
            }
        },
        fields: {
            /**
             * Length or area
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexCache
             * @type number
             */
            Count: 0,
            /**
             * Vertices on shape A
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexCache
             * @type FarseerPhysics.Common.FixedArray3$1
             */
            IndexA: null,
            /**
             * Vertices on shape B
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexCache
             * @type FarseerPhysics.Common.FixedArray3$1
             */
            IndexB: null,
            Metric: 0
        },
        ctors: {
            init: function () {
                this.IndexA = new (FarseerPhysics.Common.FixedArray3$1(System.Byte))();
                this.IndexB = new (FarseerPhysics.Common.FixedArray3$1(System.Byte))();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([4719522336, this.Count, this.IndexA, this.IndexB, this.Metric]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.SimplexCache)) {
                    return false;
                }
                return Bridge.equals(this.Count, o.Count) && Bridge.equals(this.IndexA, o.IndexA) && Bridge.equals(this.IndexB, o.IndexB) && Bridge.equals(this.Metric, o.Metric);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.SimplexCache();
                s.Count = this.Count;
                s.IndexA = this.IndexA.$clone();
                s.IndexB = this.IndexB.$clone();
                s.Metric = this.Metric;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.SimplexVertex", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.SimplexVertex(); }
            }
        },
        fields: {
            /**
             * Barycentric coordinate for closest point
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type number
             */
            A: 0,
            /**
             * wA index
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type number
             */
            IndexA: 0,
            /**
             * wB index
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type number
             */
            IndexB: 0,
            /**
             * wB - wA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type Microsoft.Xna.Framework.Vector2
             */
            W: null,
            /**
             * Support point in proxyA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type Microsoft.Xna.Framework.Vector2
             */
            WA: null,
            /**
             * Support point in proxyB
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type Microsoft.Xna.Framework.Vector2
             */
            WB: null
        },
        ctors: {
            init: function () {
                this.W = new Microsoft.Xna.Framework.Vector2();
                this.WA = new Microsoft.Xna.Framework.Vector2();
                this.WB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5039079836, this.A, this.IndexA, this.IndexB, this.W, this.WA, this.WB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.SimplexVertex)) {
                    return false;
                }
                return Bridge.equals(this.A, o.A) && Bridge.equals(this.IndexA, o.IndexA) && Bridge.equals(this.IndexB, o.IndexB) && Bridge.equals(this.W, o.W) && Bridge.equals(this.WA, o.WA) && Bridge.equals(this.WB, o.WB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.SimplexVertex();
                s.A = this.A;
                s.IndexA = this.IndexA;
                s.IndexB = this.IndexB;
                s.W = this.W.$clone();
                s.WA = this.WA.$clone();
                s.WB = this.WB.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.TimeOfImpact", {
        statics: {
            fields: {
                TOICalls: 0,
                TOIIters: 0,
                TOIMaxIters: 0,
                TOIRootIters: 0,
                TOIMaxRootIters: 0,
                _distanceInput: null
            },
            ctors: {
                init: function () {
                    this._distanceInput = new FarseerPhysics.Collision.DistanceInput();
                }
            },
            methods: {
                /**
                 * Compute the upper bound on time before two shapes penetrate. Time is represented as
                 a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
                 non-tunneling collision. If you change the time interval, you should call this function
                 again.
                 Note: use Distance() to compute the contact point and normal at the time of impact.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.TimeOfImpact
                 * @memberof FarseerPhysics.Collision.TimeOfImpact
                 * @param   {FarseerPhysics.Collision.TOIOutput}    output    The output.
                 * @param   {FarseerPhysics.Collision.TOIInput}     input     The input.
                 * @return  {void}
                 */
                CalculateTimeOfImpact: function (output, input) {
                    FarseerPhysics.Collision.TimeOfImpact.TOICalls = (FarseerPhysics.Collision.TimeOfImpact.TOICalls + 1) | 0;

                    output.v = new FarseerPhysics.Collision.TOIOutput();
                    output.v.State = FarseerPhysics.Collision.TOIOutputState.Unknown;
                    output.v.T = input.TMax;

                    var sweepA = { v : input.SweepA.$clone() };
                    var sweepB = { v : input.SweepB.$clone() };

                    sweepA.v.Normalize();
                    sweepB.v.Normalize();

                    var tMax = input.TMax;

                    var totalRadius = input.ProxyA.Radius + input.ProxyB.Radius;
                    var target = Math.max(FarseerPhysics.Settings.LinearSlop, totalRadius - 0.015);
                    var tolerance = 0.00125;
                    System.Diagnostics.Debug.Assert(target > tolerance);

                    var t1 = 0.0;
                    var k_maxIterations = 20;
                    var iter = 0;

                    var cache = { v : new FarseerPhysics.Collision.SimplexCache() };
                    FarseerPhysics.Collision.TimeOfImpact._distanceInput.ProxyA = input.ProxyA;
                    FarseerPhysics.Collision.TimeOfImpact._distanceInput.ProxyB = input.ProxyB;
                    FarseerPhysics.Collision.TimeOfImpact._distanceInput.UseRadii = false;

                    for (; ; ) {
                        var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                        sweepA.v.GetTransform(xfA, t1);
                        sweepB.v.GetTransform(xfB, t1);

                        FarseerPhysics.Collision.TimeOfImpact._distanceInput.TransformA = xfA.v.$clone();
                        FarseerPhysics.Collision.TimeOfImpact._distanceInput.TransformB = xfB.v.$clone();
                        var distanceOutput = { v : new FarseerPhysics.Collision.DistanceOutput() };
                        FarseerPhysics.Collision.Distance.ComputeDistance(distanceOutput, cache, FarseerPhysics.Collision.TimeOfImpact._distanceInput);

                        if (distanceOutput.v.Distance <= 0.0) {
                            output.v.State = FarseerPhysics.Collision.TOIOutputState.Overlapped;
                            output.v.T = 0.0;
                            break;
                        }

                        if (distanceOutput.v.Distance < target + tolerance) {
                            output.v.State = FarseerPhysics.Collision.TOIOutputState.Touching;
                            output.v.T = t1;
                            break;
                        }

                        FarseerPhysics.Collision.SeparationFunction.Set(cache, input.ProxyA, sweepA, input.ProxyB, sweepB, t1);

                        var done = false;
                        var t2 = tMax;
                        var pushBackIter = 0;
                        for (; ; ) {
                            var indexA = { }, indexB = { };
                            var s2 = FarseerPhysics.Collision.SeparationFunction.FindMinSeparation(indexA, indexB, t2);

                            if (s2 > target + tolerance) {
                                output.v.State = FarseerPhysics.Collision.TOIOutputState.Seperated;
                                output.v.T = tMax;
                                done = true;
                                break;
                            }

                            if (s2 > target - tolerance) {
                                t1 = t2;
                                break;
                            }

                            var s1 = FarseerPhysics.Collision.SeparationFunction.Evaluate(indexA.v, indexB.v, t1);

                            if (s1 < target - tolerance) {
                                output.v.State = FarseerPhysics.Collision.TOIOutputState.Failed;
                                output.v.T = t1;
                                done = true;
                                break;
                            }

                            if (s1 <= target + tolerance) {
                                output.v.State = FarseerPhysics.Collision.TOIOutputState.Touching;
                                output.v.T = t1;
                                done = true;
                                break;
                            }

                            var rootIterCount = 0;
                            var a1 = t1, a2 = t2;
                            for (; ; ) {
                                var t;
                                if ((rootIterCount & 1) !== 0) {
                                    t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
                                } else {
                                    t = 0.5 * (a1 + a2);
                                }

                                var s = FarseerPhysics.Collision.SeparationFunction.Evaluate(indexA.v, indexB.v, t);

                                if (Math.abs(s - target) < tolerance) {
                                    t2 = t;
                                    break;
                                }

                                if (s > target) {
                                    a1 = t;
                                    s1 = s;
                                } else {
                                    a2 = t;
                                    s2 = s;
                                }

                                rootIterCount = (rootIterCount + 1) | 0;
                                FarseerPhysics.Collision.TimeOfImpact.TOIRootIters = (FarseerPhysics.Collision.TimeOfImpact.TOIRootIters + 1) | 0;

                                if (rootIterCount === 50) {
                                    break;
                                }
                            }

                            FarseerPhysics.Collision.TimeOfImpact.TOIMaxRootIters = Math.max(FarseerPhysics.Collision.TimeOfImpact.TOIMaxRootIters, rootIterCount);

                            pushBackIter = (pushBackIter + 1) | 0;

                            if (pushBackIter === FarseerPhysics.Settings.MaxPolygonVertices) {
                                break;
                            }
                        }

                        iter = (iter + 1) | 0;
                        FarseerPhysics.Collision.TimeOfImpact.TOIIters = (FarseerPhysics.Collision.TimeOfImpact.TOIIters + 1) | 0;

                        if (done) {
                            break;
                        }

                        if (iter === k_maxIterations) {
                            output.v.State = FarseerPhysics.Collision.TOIOutputState.Failed;
                            output.v.T = t1;
                            break;
                        }
                    }

                    FarseerPhysics.Collision.TimeOfImpact.TOIMaxIters = Math.max(FarseerPhysics.Collision.TimeOfImpact.TOIMaxIters, iter);
                }
            }
        }
    });

    /**
     * Input parameters for CalculateTimeOfImpact
     *
     * @public
     * @class FarseerPhysics.Collision.TOIInput
     */
    Bridge.define("FarseerPhysics.Collision.TOIInput", {
        fields: {
            ProxyA: null,
            ProxyB: null,
            SweepA: null,
            SweepB: null,
            TMax: 0
        },
        ctors: {
            init: function () {
                this.SweepA = new FarseerPhysics.Common.Sweep();
                this.SweepB = new FarseerPhysics.Common.Sweep();
                this.ProxyA = new FarseerPhysics.Collision.DistanceProxy();
                this.ProxyB = new FarseerPhysics.Collision.DistanceProxy();
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.TOIOutput", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.TOIOutput(); }
            }
        },
        fields: {
            State: 0,
            T: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3300508733, this.State, this.T]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.TOIOutput)) {
                    return false;
                }
                return Bridge.equals(this.State, o.State) && Bridge.equals(this.T, o.T);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.TOIOutput();
                s.State = this.State;
                s.T = this.T;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.TOIOutputState", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: 0,
                Failed: 1,
                Overlapped: 2,
                Touching: 3,
                Seperated: 4
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.ConvexHull.ChainHull", {
        statics: {
            methods: {
                /**
                 * Gets the convex hull.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.ConvexHull.ChainHull
                 * @memberof FarseerPhysics.Common.ConvexHull.ChainHull
                 * @param   {FarseerPhysics.Common.Vertices}    P
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                GetConvexHull: function (P) {
                    P.Sort$1(new FarseerPhysics.Common.ConvexHull.ChainHull.PointComparer());

                    var H = System.Array.init(P.Count, function (){
                        return new Microsoft.Xna.Framework.Vector2();
                    }, Microsoft.Xna.Framework.Vector2);
                    var res = new FarseerPhysics.Common.Vertices.ctor();

                    var n = P.Count;

                    var bot, top = -1;
                    var i;

                    var minmin = 0, minmax;
                    var xmin = P.getItem(0).$clone().X;
                    for (i = 1; i < n; i = (i + 1) | 0) {
                        if (P.getItem(i).$clone().X !== xmin) {
                            break;
                        }
                    }
                    minmax = (i - 1) | 0;
                    if (minmax === ((n - 1) | 0)) {
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmin).$clone();
                        if (P.getItem(minmax).$clone().Y !== P.getItem(minmin).$clone().Y) {
                            H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmax).$clone();
                        }
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmin).$clone();

                        for (var j = 0; j < ((top + 1) | 0); j = (j + 1) | 0) {
                            res.add(H[System.Array.index(j, H)].$clone());
                        }

                        return res;
                    }

                    top = (res.Count - 1) | 0;

                    var maxmin, maxmax = (n - 1) | 0;
                    var xmax = P.getItem(((n - 1) | 0)).$clone().X;
                    for (i = (n - 2) | 0; i >= 0; i = (i - 1) | 0) {
                        if (P.getItem(i).$clone().X !== xmax) {
                            break;
                        }
                    }
                    maxmin = (i + 1) | 0;

                    H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmin).$clone();
                    i = minmax;
                    while (((i = (i + 1) | 0)) <= maxmin) {
                        if (FarseerPhysics.Common.MathUtils.Area(P.getItem(minmin).$clone(), P.getItem(maxmin).$clone(), P.getItem(i).$clone()) >= 0 && i < maxmin) {
                            continue;
                        }

                        while (top > 0) {
                            if (FarseerPhysics.Common.MathUtils.Area(H[System.Array.index(((top - 1) | 0), H)].$clone(), H[System.Array.index(top, H)].$clone(), P.getItem(i).$clone()) > 0) {
                                break;
                            } else {
                                top = (top - 1) | 0;
                            }
                        }
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(i).$clone();
                    }

                    if (maxmax !== maxmin) {
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(maxmax).$clone();
                    }
                    bot = top;
                    i = maxmin;
                    while (((i = (i - 1) | 0)) >= minmax) {
                        if (FarseerPhysics.Common.MathUtils.Area(P.getItem(maxmax).$clone(), P.getItem(minmax).$clone(), P.getItem(i).$clone()) >= 0 && i > minmax) {
                            continue;
                        }

                        while (top > bot) {
                            if (FarseerPhysics.Common.MathUtils.Area(H[System.Array.index(((top - 1) | 0), H)].$clone(), H[System.Array.index(top, H)].$clone(), P.getItem(i).$clone()) > 0) {
                                break;
                            } else {
                                top = (top - 1) | 0;
                            }
                        }
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(i).$clone();
                    }
                    if (minmax !== minmin) {
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmin).$clone();
                    }

                    for (var j1 = 0; j1 < ((top + 1) | 0); j1 = (j1 + 1) | 0) {
                        res.add(H[System.Array.index(j1, H)].$clone());
                    }

                    return res;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.ConvexHull.ChainHull.PointComparer", {
        inherits: [System.Collections.Generic.Comparer$1(Microsoft.Xna.Framework.Vector2)],
        $kind: "nested class",
        alias: ["compare", ["System$Collections$Generic$IComparer$1$Microsoft$Xna$Framework$Vector2$compare", "System$Collections$Generic$IComparer$1$compare"]],
        methods: {
            compare: function (a, b) {
                var f = Bridge.compare(a.X, b.X);
                return f !== 0 ? f : Bridge.compare(a.Y, b.Y);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.ConvexHull.GiftWrap", {
        statics: {
            methods: {
                /**
                 * Find the convex hull of a point cloud using "Gift-wrap" algorithm - start
                 with an extremal point, and walk around the outside edge by testing
                 angles.
                 Runs in O(N*S) time where S is number of sides of resulting polygon.
                 Worst case: point cloud is all vertices of convex polygon: O(N^2).
                 There may be faster algorithms to do this, should you need one -
                 this is just the simplest. You can get O(N log N) expected time if you
                 try, I think, and O(N) if you restrict inputs to simple polygons.
                 Returns null if number of vertices passed is less than 3.
                 Results should be passed through convex decomposition afterwards
                 to ensure that each shape has few enough points to be used in Box2d.
                 Warning: May be buggy with colinear points on hull.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.ConvexHull.GiftWrap
                 * @memberof FarseerPhysics.Common.ConvexHull.GiftWrap
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                GetConvexHull: function (vertices) {
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    var edgeList = System.Array.init(vertices.Count, 0, System.Int32);
                    var numEdges = 0;

                    var minY = 3.40282347E+38;
                    var minYIndex = vertices.Count;
                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        if (vertices.getItem(i).$clone().Y < minY) {
                            minY = vertices.getItem(i).$clone().Y;
                            minYIndex = i;
                        }
                    }

                    var startIndex = minYIndex;
                    var winIndex = -1;
                    var dx = -1.0;
                    var dy = 0.0;
                    while (winIndex !== minYIndex) {
                        var maxDot = -2.0;
                        var nrm;

                        for (var i1 = 0; i1 < vertices.Count; i1 = (i1 + 1) | 0) {
                            if (i1 === startIndex) {
                                continue;
                            }
                            var newdx = vertices.getItem(i1).$clone().X - vertices.getItem(startIndex).$clone().X;
                            var newdy = vertices.getItem(i1).$clone().Y - vertices.getItem(startIndex).$clone().Y;
                            nrm = Math.sqrt(newdx * newdx + newdy * newdy);
                            nrm = (nrm === 0.0) ? 1.0 : nrm;
                            newdx /= nrm;
                            newdy /= nrm;

                            var newDot = newdx * dx + newdy * dy;
                            if (newDot > maxDot) {
                                maxDot = newDot;
                                winIndex = i1;
                            }
                        }
                        edgeList[System.Array.index(Bridge.identity(numEdges, (numEdges = (numEdges + 1) | 0)), edgeList)] = winIndex;
                        dx = vertices.getItem(winIndex).$clone().X - vertices.getItem(startIndex).$clone().X;
                        dy = vertices.getItem(winIndex).$clone().Y - vertices.getItem(startIndex).$clone().Y;
                        nrm = Math.sqrt(dx * dx + dy * dy);
                        nrm = (nrm === 0.0) ? 1.0 : nrm;
                        dx /= nrm;
                        dy /= nrm;
                        startIndex = winIndex;
                    }

                    var returnVal = new FarseerPhysics.Common.Vertices.$ctor3(numEdges);

                    for (var i2 = 0; i2 < numEdges; i2 = (i2 + 1) | 0) {
                        returnVal.add(vertices.getItem(edgeList[System.Array.index(i2, edgeList)]).$clone());
                    }


                    return returnVal;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.ConvexHull.Melkman", {
        statics: {
            methods: {
                /**
                 * Creates a convex hull.
                 Note:
                 1. Vertices must be of a simple polygon, i.e. edges do not overlap.
                 2. Melkman does not work on point clouds
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.ConvexHull.Melkman
                 * @memberof FarseerPhysics.Common.ConvexHull.Melkman
                 * @param   {FarseerPhysics.Common.Vertices}    vertices
                 * @return  {FarseerPhysics.Common.Vertices}                A convex hull in counterclockwise winding order.
                 */
                GetConvexHull: function (vertices) {
                    var $t;
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    var deque = System.Array.init(((vertices.Count + 1) | 0), function (){
                        return new Microsoft.Xna.Framework.Vector2();
                    }, Microsoft.Xna.Framework.Vector2);
                    var qf = 3, qb = 0;
                    var qfm1, qbm1;

                    var startIndex = 3;
                    var k = FarseerPhysics.Common.MathUtils.Area(vertices.getItem(0).$clone(), vertices.getItem(1).$clone(), vertices.getItem(2).$clone());
                    if (k === 0) {
                        deque[System.Array.index(0, deque)] = vertices.getItem(0).$clone();
                        deque[System.Array.index(1, deque)] = vertices.getItem(2).$clone();
                        deque[System.Array.index(2, deque)] = vertices.getItem(0).$clone();
                        qf = 2;

                        for (startIndex = 3; startIndex < vertices.Count; startIndex = (startIndex + 1) | 0) {
                            var tmp = { v : vertices.getItem(startIndex).$clone() };
                            if (FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, 0), Bridge.ref(deque, 1), tmp) === 0) {
                                deque[System.Array.index(1, deque)] = vertices.getItem(startIndex).$clone();
                            } else {
                                break;
                            }
                        }
                    } else {
                        deque[System.Array.index(0, deque)] = ($t = vertices.getItem(2).$clone(), deque[System.Array.index(3, deque)] = $t.$clone(), $t);
                        if (k > 0) {
                            deque[System.Array.index(1, deque)] = vertices.getItem(0).$clone();
                            deque[System.Array.index(2, deque)] = vertices.getItem(1).$clone();
                        } else {
                            deque[System.Array.index(1, deque)] = vertices.getItem(1).$clone();
                            deque[System.Array.index(2, deque)] = vertices.getItem(0).$clone();
                        }
                    }

                    qfm1 = qf === 0 ? ((deque.length - 1) | 0) : ((qf - 1) | 0);
                    qbm1 = qb === ((deque.length - 1) | 0) ? 0 : ((qb + 1) | 0);

                    for (var i = startIndex; i < vertices.Count; i = (i + 1) | 0) {
                        var nextPt = { v : vertices.getItem(i).$clone() };

                        if (FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, qfm1), Bridge.ref(deque, qf), nextPt) > 0 && FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, qb), Bridge.ref(deque, qbm1), nextPt) > 0) {
                            continue;
                        }

                        while (!(FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, qfm1), Bridge.ref(deque, qf), nextPt) > 0)) {
                            qf = qfm1;
                            qfm1 = qf === 0 ? ((deque.length - 1) | 0) : ((qf - 1) | 0);
                        }
                        qf = qf === ((deque.length - 1) | 0) ? 0 : ((qf + 1) | 0);
                        qfm1 = qf === 0 ? ((deque.length - 1) | 0) : ((qf - 1) | 0);
                        deque[System.Array.index(qf, deque)] = nextPt.v.$clone();

                        while (!(FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, qb), Bridge.ref(deque, qbm1), nextPt) > 0)) {
                            qb = qbm1;
                            qbm1 = qb === ((deque.length - 1) | 0) ? 0 : ((qb + 1) | 0);
                        }
                        qb = qb === 0 ? ((deque.length - 1) | 0) : ((qb - 1) | 0);
                        qbm1 = qb === ((deque.length - 1) | 0) ? 0 : ((qb + 1) | 0);
                        deque[System.Array.index(qb, deque)] = nextPt.v.$clone();
                    }

                    var convexHull = new FarseerPhysics.Common.Vertices.$ctor3(((vertices.Count + 1) | 0));
                    if (qb < qf) {
                        for (var i1 = qb; i1 < qf; i1 = (i1 + 1) | 0) {
                            convexHull.add(deque[System.Array.index(i1, deque)].$clone());
                        }
                    } else {
                        for (var i2 = 0; i2 < qf; i2 = (i2 + 1) | 0) {
                            convexHull.add(deque[System.Array.index(i2, deque)].$clone());
                        }
                        for (var i3 = qb; i3 < deque.length; i3 = (i3 + 1) | 0) {
                            convexHull.add(deque[System.Array.index(i3, deque)].$clone());
                        }
                    }
                    return convexHull;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposer", {
        $kind: "enum",
        statics: {
            fields: {
                Bayazit: 0,
                CDT: 1,
                Earclip: 2,
                Flipcode: 3,
                Seidel: 4
            }
        }
    });

    /** @namespace FarseerPhysics.Common.Decomposition */

    /**
     * Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
     For more information about this algorithm, see http://mnbayazit.com/406/bayazit
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.Decomposition.BayazitDecomposer
     */
    Bridge.define("FarseerPhysics.Common.Decomposition.BayazitDecomposer", {
        statics: {
            methods: {
                At: function (i, vertices) {
                    var s = vertices.Count;
                    return vertices.getItem(i < 0 ? ((s - (((-i) | 0) % s)) | 0) : i % s).$clone();
                },
                Copy: function (i, j, vertices) {
                    var p = new FarseerPhysics.Common.Vertices.ctor();
                    while (j < i) {
                        j = (j + vertices.Count) | 0;
                    }
                    for (; i <= j; i = (i + 1) | 0) {
                        p.add(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices));
                    }
                    return p;
                },
                /**
                 * Decompose the polygon into several smaller non-concave polygon.
                 If the polygon is already convex, it will return the original polygon, unless it is over Settings.MaxPolygonVertices.
                 Precondition: Counter Clockwise polygon
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.BayazitDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.BayazitDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices
                 * @return  {System.Collections.Generic.List$1}
                 */
                ConvexPartition: function (vertices) {
                    vertices.ForceCounterClockWise();

                    var list = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                    var d, lowerDist, upperDist;
                    var p = new Microsoft.Xna.Framework.Vector2();
                    var lowerInt = new Microsoft.Xna.Framework.Vector2.ctor();
                    var upperInt = new Microsoft.Xna.Framework.Vector2.ctor();
                    var lowerIndex = 0, upperIndex = 0;
                    var lowerPoly, upperPoly;

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Reflex(i, vertices)) {
                            lowerDist = (upperDist = 3.40282347E+38);
                            for (var j = 0; j < vertices.Count; j = (j + 1) | 0) {
                                if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Left(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j - 1) | 0), vertices))) {
                                    p = FarseerPhysics.Common.LineTools.LineIntersect(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j - 1) | 0), vertices));
                                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Right(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), p.$clone())) {
                                        d = FarseerPhysics.Common.Decomposition.BayazitDecomposer.SquareDist(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), p.$clone());
                                        if (d < lowerDist) {
                                            lowerDist = d;
                                            lowerInt = p.$clone();
                                            lowerIndex = j;
                                        }
                                    }
                                }

                                if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Left(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j + 1) | 0), vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices))) {
                                    p = FarseerPhysics.Common.LineTools.LineIntersect(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j + 1) | 0), vertices));
                                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Left(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), p.$clone())) {
                                        d = FarseerPhysics.Common.Decomposition.BayazitDecomposer.SquareDist(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), p.$clone());
                                        if (d < upperDist) {
                                            upperDist = d;
                                            upperIndex = j;
                                            upperInt = p.$clone();
                                        }
                                    }
                                }
                            }

                            if (lowerIndex === (((upperIndex + 1) | 0)) % vertices.Count) {
                                var sp = (Microsoft.Xna.Framework.Vector2.op_Division$1((Microsoft.Xna.Framework.Vector2.op_Addition(lowerInt.$clone(), upperInt.$clone())), 2));

                                lowerPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(i, upperIndex, vertices);
                                lowerPoly.add(sp.$clone());
                                upperPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(lowerIndex, i, vertices);
                                upperPoly.add(sp.$clone());
                            } else {
                                var highestScore = 0, bestIndex = lowerIndex;
                                while (upperIndex < lowerIndex) {
                                    upperIndex = (upperIndex + vertices.Count) | 0;
                                }
                                for (var j1 = lowerIndex; j1 <= upperIndex; j1 = (j1 + 1) | 0) {
                                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.CanSee(i, j1, vertices)) {
                                        var score = 1 / (FarseerPhysics.Common.Decomposition.BayazitDecomposer.SquareDist(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j1, vertices)) + 1);
                                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Reflex(j1, vertices)) {
                                            if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j1 - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j1, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j1 + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j1, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices))) {
                                                score += 3;
                                            } else {
                                                score += 2;
                                            }
                                        } else {
                                            score += 1;
                                        }
                                        if (score > highestScore) {
                                            bestIndex = j1;
                                            highestScore = score;
                                        }
                                    }
                                }
                                lowerPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(i, Bridge.Int.clip32(bestIndex), vertices);
                                upperPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(Bridge.Int.clip32(bestIndex), i, vertices);
                            }
                            list.AddRange(FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(lowerPoly));
                            list.AddRange(FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(upperPoly));
                            return list;
                        }
                    }

                    if (vertices.Count > FarseerPhysics.Settings.MaxPolygonVertices) {
                        lowerPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(0, ((Bridge.Int.div(vertices.Count, 2)) | 0), vertices);
                        upperPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(((Bridge.Int.div(vertices.Count, 2)) | 0), 0, vertices);
                        list.AddRange(FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(lowerPoly));
                        list.AddRange(FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(upperPoly));
                    } else {
                        list.add(vertices);
                    }

                    for (var i1 = 0; i1 < list.Count; i1 = (i1 + 1) | 0) {
                        list.setItem(i1, FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify$1(list.getItem(i1), 0));
                    }

                    for (var i2 = (list.Count - 1) | 0; i2 >= 0; i2 = (i2 - 1) | 0) {
                        if (list.getItem(i2).Count === 0) {
                            list.removeAt(i2);
                        }
                    }

                    return list;
                },
                CanSee: function (i, j, vertices) {
                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Reflex(i, vertices)) {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices))) {
                            return false;
                        }
                    } else {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices)) || FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices))) {
                            return false;
                        }
                    }
                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Reflex(j, vertices)) {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices))) {
                            return false;
                        }
                    } else {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices)) || FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices))) {
                            return false;
                        }
                    }
                    for (var k = 0; k < vertices.Count; k = (k + 1) | 0) {
                        if ((((k + 1) | 0)) % vertices.Count === i || k === i || (((k + 1) | 0)) % vertices.Count === j || k === j) {
                            continue;
                        }
                        var intersectionPoint = { v : new Microsoft.Xna.Framework.Vector2() };
                        if (FarseerPhysics.Common.LineTools.LineIntersect$1(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(k, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((k + 1) | 0), vertices), intersectionPoint)) {
                            return false;
                        }
                    }
                    return true;
                },
                Reflex: function (i, vertices) {
                    return FarseerPhysics.Common.Decomposition.BayazitDecomposer.Right$1(i, vertices);
                },
                Right$1: function (i, vertices) {
                    return FarseerPhysics.Common.Decomposition.BayazitDecomposer.Right(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices));
                },
                Right: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c) < 0;
                },
                Left: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c) > 0;
                },
                LeftOn: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c) >= 0;
                },
                RightOn: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c) <= 0;
                },
                SquareDist: function (a, b) {
                    var dx = b.X - a.X;
                    var dy = b.Y - a.Y;
                    return dx * dx + dy * dy;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.CDT.Orientation", {
        $kind: "enum",
        statics: {
            fields: {
                CW: 0,
                CCW: 1,
                Collinear: 2
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.CDTDecomposer", {
        statics: {
            methods: {
                ConvexPartition$1: function (vertices) {
                    var $t, $t1, $t2;
                    var poly = new Poly2Tri.Triangulation.Polygon.Polygon.ctor();

                    $t = Bridge.getEnumerator(vertices);
                    try {
                        while ($t.moveNext()) {
                            var vertex = $t.Current.$clone();
                            System.Array.add(poly.Points, new Poly2Tri.Triangulation.TriangulationPoint(vertex.X, vertex.Y), Poly2Tri.Triangulation.TriangulationPoint);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    var tcx = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext();
                    tcx.PrepareTriangulation(poly);
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Triangulate(tcx);

                    var results = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    $t1 = Bridge.getEnumerator(poly.Triangles, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                    try {
                        while ($t1.moveNext()) {
                            var triangle = $t1.Current;
                            var v = new FarseerPhysics.Common.Vertices.ctor();
                            $t2 = Bridge.getEnumerator(triangle.Points);
                            try {
                                while ($t2.moveNext()) {
                                    var p = $t2.Current;
                                    v.add(new Microsoft.Xna.Framework.Vector2.$ctor2(p.X, p.Y));
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }results.add(v);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return results;
                },
                ConvexPartition: function (vertices) {
                    var $t, $t1, $t2, $t3, $t4;
                    var poly = new Poly2Tri.Triangulation.Polygon.Polygon.ctor();
                    $t = Bridge.getEnumerator(vertices);
                    try {
                        while ($t.moveNext()) {
                            var vertex = $t.Current.$clone();
                            System.Array.add(poly.Points, new Poly2Tri.Triangulation.TriangulationPoint(vertex.X, vertex.Y), Poly2Tri.Triangulation.TriangulationPoint);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    if (vertices.Holes != null) {
                        $t1 = Bridge.getEnumerator(vertices.Holes);
                        try {
                            while ($t1.moveNext()) {
                                var holeVertices = $t1.Current;
                                var hole = new Poly2Tri.Triangulation.Polygon.Polygon.ctor();
                                $t2 = Bridge.getEnumerator(holeVertices);
                                try {
                                    while ($t2.moveNext()) {
                                        var vertex1 = $t2.Current.$clone();
                                        System.Array.add(hole.Points, new Poly2Tri.Triangulation.TriangulationPoint(vertex1.X, vertex1.Y), Poly2Tri.Triangulation.TriangulationPoint);
                                    }
                                } finally {
                                    if (Bridge.is($t2, System.IDisposable)) {
                                        $t2.System$IDisposable$Dispose();
                                    }
                                }
                                poly.AddHole(hole);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }}

                    var tcx = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext();
                    tcx.PrepareTriangulation(poly);
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Triangulate(tcx);

                    var results = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    $t3 = Bridge.getEnumerator(poly.Triangles, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                    try {
                        while ($t3.moveNext()) {
                            var triangle = $t3.Current;
                            var v = new FarseerPhysics.Common.Vertices.ctor();
                            $t4 = Bridge.getEnumerator(triangle.Points);
                            try {
                                while ($t4.moveNext()) {
                                    var p = $t4.Current;
                                    v.add(new Microsoft.Xna.Framework.Vector2.$ctor2(p.X, p.Y));
                                }
                            } finally {
                                if (Bridge.is($t4, System.IDisposable)) {
                                    $t4.System$IDisposable$Dispose();
                                }
                            }results.add(v);
                        }
                    } finally {
                        if (Bridge.is($t3, System.IDisposable)) {
                            $t3.System$IDisposable$Dispose();
                        }
                    }
                    return results;
                }
            }
        }
    });

    /**
     * Ported from jBox2D. Original author: ewjordan 
     Triangulates a polygon using simple ear-clipping algorithm.
     Only works on simple polygons.
     Triangles may be degenerate, especially if you have identical points
     in the input to the algorithm.  Check this before you use them.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.Decomposition.EarclipDecomposer
     */
    Bridge.define("FarseerPhysics.Common.Decomposition.EarclipDecomposer", {
        statics: {
            fields: {
                Tol: 0
            },
            ctors: {
                init: function () {
                    this.Tol = 0.001;
                }
            },
            methods: {
                /**
                 * Decomposes a non-convex polygon into a number of convex polygons, up
                 to maxPolys (remaining pieces are thrown out).
                 Each resulting polygon will have no more than Settings.MaxPolygonVertices
                 vertices.
                 Warning: Only works on simple polygons
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices    The vertices.
                 * @return  {System.Collections.Generic.List$1}
                 */
                ConvexPartition: function (vertices) {
                    return FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition$1(vertices, 2147483647, 0);
                },
                /**
                 * Decomposes a non-convex polygon into a number of convex polygons, up
                 to maxPolys (remaining pieces are thrown out).
                 Each resulting polygon will have no more than Settings.MaxPolygonVertices
                 vertices.
                 Warning: Only works on simple polygons
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices     The vertices.
                 * @param   {number}                               maxPolys     The maximum number of polygons.
                 * @param   {number}                               tolerance    The tolerance.
                 * @return  {System.Collections.Generic.List$1}
                 */
                ConvexPartition$1: function (vertices, maxPolys, tolerance) {
                    if (vertices.Count < 3) {
                        return function (_o1) {
                                _o1.add(vertices);
                                return _o1;
                            }(new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor());
                    }
                    /* 
                    if (vertices.IsConvex() && vertices.Count <= Settings.MaxPolygonVertices)
                    {
                       if (vertices.IsCounterClockWise())
                       {
                           Vertices tempP = new Vertices(vertices);
                           tempP.Reverse();
                           tempP = SimplifyTools.CollinearSimplify(tempP);
                           tempP.ForceCounterClockWise();
                           return new List<Vertices> { tempP };
                       }
                       vertices = SimplifyTools.CollinearSimplify(vertices);
                       vertices.ForceCounterClockWise();
                       return new List<Vertices> { vertices };
                    }
                    */
                    var triangulated;

                    if (vertices.IsCounterClockWise()) {
                        var tempP = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                        tempP.Reverse();
                        triangulated = FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(tempP);
                    } else {
                        triangulated = FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(vertices);
                    }
                    if (triangulated.Count < 1) {
                        throw new System.Exception("Can't triangulate your polygon.");
                    }

                    var polygonizedTriangles = FarseerPhysics.Common.Decomposition.EarclipDecomposer.PolygonizeTriangles(triangulated, maxPolys, tolerance);

                    for (var i = 0; i < polygonizedTriangles.Count; i = (i + 1) | 0) {
                        polygonizedTriangles.setItem(i, FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify$1(polygonizedTriangles.getItem(i), 0));
                    }

                    for (var i1 = (polygonizedTriangles.Count - 1) | 0; i1 >= 0; i1 = (i1 - 1) | 0) {
                        if (polygonizedTriangles.getItem(i1).Count === 0) {
                            polygonizedTriangles.removeAt(i1);
                        }
                    }

                    return polygonizedTriangles;
                },
                /**
                 * Turns a list of triangles into a list of convex polygons. Very simple
                 method - start with a seed triangle, keep adding triangles to it until
                 you can't add any more without making the polygon non-convex.
                 Returns an integer telling how many polygons were created.  Will fill
                 polys array up to polysLength entries, which may be smaller or larger
                 than the return value.
                 Takes O(NP) where P is the number of resultant polygons, N is triangle
                 count.
                 The final polygon list will not necessarily be minimal, though in
                 practice it works fairly well.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {System.Collections.Generic.List$1}    triangulated    The triangulated.
                 * @param   {number}                               maxPolys        The maximun number of polygons
                 * @param   {number}                               tolerance       The tolerance
                 * @return  {System.Collections.Generic.List$1}
                 */
                PolygonizeTriangles: function (triangulated, maxPolys, tolerance) {
                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13;
                    var polys = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).$ctor2(50);

                    var polyIndex = 0;

                    if (triangulated.Count <= 0) {
                        return polys;
                    }

                    var covered = System.Array.init(triangulated.Count, false, System.Boolean);
                    for (var i = 0; i < triangulated.Count; i = (i + 1) | 0) {
                        covered[System.Array.index(i, covered)] = false;

                        if (((($t = triangulated.getItem(i).X)[System.Array.index(0, $t)] === ($t1 = triangulated.getItem(i).X)[System.Array.index(1, $t1)]) && (($t2 = triangulated.getItem(i).Y)[System.Array.index(0, $t2)] === ($t3 = triangulated.getItem(i).Y)[System.Array.index(1, $t3)])) || ((($t4 = triangulated.getItem(i).X)[System.Array.index(1, $t4)] === ($t5 = triangulated.getItem(i).X)[System.Array.index(2, $t5)]) && (($t6 = triangulated.getItem(i).Y)[System.Array.index(1, $t6)] === ($t7 = triangulated.getItem(i).Y)[System.Array.index(2, $t7)])) || ((($t8 = triangulated.getItem(i).X)[System.Array.index(0, $t8)] === ($t9 = triangulated.getItem(i).X)[System.Array.index(2, $t9)]) && (($t10 = triangulated.getItem(i).Y)[System.Array.index(0, $t10)] === ($t11 = triangulated.getItem(i).Y)[System.Array.index(2, $t11)]))) {
                            covered[System.Array.index(i, covered)] = true;
                        }
                    }

                    var notDone = true;
                    while (notDone) {
                        var currTri = -1;
                        for (var i1 = 0; i1 < triangulated.Count; i1 = (i1 + 1) | 0) {
                            if (covered[System.Array.index(i1, covered)]) {
                                continue;
                            }
                            currTri = i1;
                            break;
                        }
                        if (currTri === -1) {
                            notDone = false;
                        } else {
                            var poly = new FarseerPhysics.Common.Vertices.$ctor3(3);

                            for (var i2 = 0; i2 < 3; i2 = (i2 + 1) | 0) {
                                poly.add(new Microsoft.Xna.Framework.Vector2.$ctor2(($t12 = triangulated.getItem(currTri).X)[System.Array.index(i2, $t12)], ($t13 = triangulated.getItem(currTri).Y)[System.Array.index(i2, $t13)]));
                            }

                            covered[System.Array.index(currTri, covered)] = true;
                            var index = 0;
                            for (var i3 = 0; i3 < Bridge.Int.mul(2, triangulated.Count); i3 = (i3 + 1) | 0, index = (index + 1) | 0) {
                                while (index >= triangulated.Count) {
                                    index = (index - triangulated.Count) | 0;
                                }
                                if (covered[System.Array.index(index, covered)]) {
                                    continue;
                                }
                                var newP = FarseerPhysics.Common.Decomposition.EarclipDecomposer.AddTriangle(triangulated.getItem(index), poly);
                                if (newP == null) {
                                    continue;
                                }

                                if (newP.Count > FarseerPhysics.Settings.MaxPolygonVertices) {
                                    continue;
                                }

                                if (newP.IsConvex()) {
                                    poly = new FarseerPhysics.Common.Vertices.$ctor2(newP);
                                    covered[System.Array.index(index, covered)] = true;
                                }
                            }

                            if (polyIndex < maxPolys) {

                                if (poly.Count >= 3) {
                                    polys.add(new FarseerPhysics.Common.Vertices.$ctor2(poly));
                                }
                            }
                            if (poly.Count >= 3) {
                                polyIndex = (polyIndex + 1) | 0;
                            }
                        }
                    }

                    return polys;
                },
                /**
                 * Triangulates a polygon using simple ear-clipping algorithm. Returns
                 size of Triangle array unless the polygon can't be triangulated.
                 This should only happen if the polygon self-intersects,
                 though it will not _always_ return null for a bad polygon - it is the
                 caller's responsibility to check for self-intersection, and if it
                 doesn't, it should at least check that the return value is non-null
                 before using. You're warned!
                 Triangles may be degenerate, especially if you have identical points
                 in the input to the algorithm.  Check this before you use them.
                 This is totally unoptimized, so for large polygons it should not be part
                 of the simulation loop.
                 Warning: Only works on simple polygons.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices
                 * @return  {System.Collections.Generic.List$1}
                 */
                TriangulatePolygon: function (vertices) {
                    var results = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Triangle)).ctor();
                    if (vertices.Count < 3) {
                        return new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Triangle)).ctor();
                    }

                    var pA = { }, pB = { };
                    var pin = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                    if (FarseerPhysics.Common.Decomposition.EarclipDecomposer.ResolvePinchPoint(pin, pA, pB)) {
                        var mergeA = FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(pA.v);
                        var mergeB = FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(pB.v);

                        if (mergeA.Count === -1 || mergeB.Count === -1) {
                            throw new System.Exception("Can't triangulate your polygon.");
                        }

                        for (var i = 0; i < mergeA.Count; i = (i + 1) | 0) {
                            results.add(new FarseerPhysics.Common.Decomposition.Triangle.ctor(mergeA.getItem(i)));
                        }
                        for (var i1 = 0; i1 < mergeB.Count; i1 = (i1 + 1) | 0) {
                            results.add(new FarseerPhysics.Common.Decomposition.Triangle.ctor(mergeB.getItem(i1)));
                        }

                        return results;
                    }

                    var buffer = System.Array.init(((vertices.Count - 2) | 0), null, FarseerPhysics.Common.Decomposition.Triangle);
                    var bufferSize = 0;
                    var xrem = System.Array.init(vertices.Count, 0, System.Single);
                    var yrem = System.Array.init(vertices.Count, 0, System.Single);
                    for (var i2 = 0; i2 < vertices.Count; i2 = (i2 + 1) | 0) {
                        xrem[System.Array.index(i2, xrem)] = vertices.getItem(i2).$clone().X;
                        yrem[System.Array.index(i2, yrem)] = vertices.getItem(i2).$clone().Y;
                    }

                    var vNum = vertices.Count;

                    while (vNum > 3) {
                        var earIndex = -1;
                        var earMaxMinCross = -10.0;
                        for (var i3 = 0; i3 < vNum; i3 = (i3 + 1) | 0) {
                            if (FarseerPhysics.Common.Decomposition.EarclipDecomposer.IsEar(i3, xrem, yrem, vNum)) {
                                var lower = FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(((i3 - 1) | 0), vNum);
                                var upper = FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(((i3 + 1) | 0), vNum);
                                var d1 = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[System.Array.index(upper, xrem)] - xrem[System.Array.index(i3, xrem)], yrem[System.Array.index(upper, yrem)] - yrem[System.Array.index(i3, yrem)]) };
                                var d2 = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[System.Array.index(i3, xrem)] - xrem[System.Array.index(lower, xrem)], yrem[System.Array.index(i3, yrem)] - yrem[System.Array.index(lower, yrem)]) };
                                var d3 = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[System.Array.index(lower, xrem)] - xrem[System.Array.index(upper, xrem)], yrem[System.Array.index(lower, yrem)] - yrem[System.Array.index(upper, yrem)]) };

                                d1.v.Normalize();
                                d2.v.Normalize();
                                d3.v.Normalize();
                                var cross12 = { };
                                FarseerPhysics.Common.MathUtils.Cross$3(d1, d2, cross12);
                                cross12.v = Math.abs(cross12.v);

                                var cross23 = { };
                                FarseerPhysics.Common.MathUtils.Cross$3(d2, d3, cross23);
                                cross23.v = Math.abs(cross23.v);

                                var cross31 = { };
                                FarseerPhysics.Common.MathUtils.Cross$3(d3, d1, cross31);
                                cross31.v = Math.abs(cross31.v);

                                var minCross = Math.min(cross12.v, Math.min(cross23.v, cross31.v));
                                if (minCross > earMaxMinCross) {
                                    earIndex = i3;
                                    earMaxMinCross = minCross;
                                }
                            }
                        }

                        if (earIndex === -1) {
                            for (var i4 = 0; i4 < bufferSize; i4 = (i4 + 1) | 0) {
                                results.add(new FarseerPhysics.Common.Decomposition.Triangle.ctor(buffer[System.Array.index(i4, buffer)]));
                            }

                            return results;
                        }


                        vNum = (vNum - 1) | 0;
                        var newx = System.Array.init(vNum, 0, System.Single);
                        var newy = System.Array.init(vNum, 0, System.Single);
                        var currDest = 0;
                        for (var i5 = 0; i5 < vNum; i5 = (i5 + 1) | 0) {
                            if (currDest === earIndex) {
                                currDest = (currDest + 1) | 0;
                            }
                            newx[System.Array.index(i5, newx)] = xrem[System.Array.index(currDest, xrem)];
                            newy[System.Array.index(i5, newy)] = yrem[System.Array.index(currDest, yrem)];
                            currDest = (currDest + 1) | 0;
                        }

                        var under = (earIndex === 0) ? (vNum) : (((earIndex - 1) | 0));
                        var over = (earIndex === vNum) ? 0 : (((earIndex + 1) | 0));
                        var toAdd = new FarseerPhysics.Common.Decomposition.Triangle.$ctor1(xrem[System.Array.index(earIndex, xrem)], yrem[System.Array.index(earIndex, yrem)], xrem[System.Array.index(over, xrem)], yrem[System.Array.index(over, yrem)], xrem[System.Array.index(under, xrem)], yrem[System.Array.index(under, yrem)]);
                        buffer[System.Array.index(bufferSize, buffer)] = toAdd;
                        bufferSize = (bufferSize + 1) | 0;

                        xrem = newx;
                        yrem = newy;
                    }

                    var tooAdd = new FarseerPhysics.Common.Decomposition.Triangle.$ctor1(xrem[System.Array.index(1, xrem)], yrem[System.Array.index(1, yrem)], xrem[System.Array.index(2, xrem)], yrem[System.Array.index(2, yrem)], xrem[System.Array.index(0, xrem)], yrem[System.Array.index(0, yrem)]);
                    buffer[System.Array.index(bufferSize, buffer)] = tooAdd;
                    bufferSize = (bufferSize + 1) | 0;

                    for (var i6 = 0; i6 < bufferSize; i6 = (i6 + 1) | 0) {
                        results.add(new FarseerPhysics.Common.Decomposition.Triangle.ctor(buffer[System.Array.index(i6, buffer)]));
                    }

                    return results;
                },
                /**
                 * Finds and fixes "pinch points," points where two polygon
                 vertices are at the same point.
                 If a pinch point is found, pin is broken up into poutA and poutB
                 and true is returned; otherwise, returns false.
                 Mostly for internal use.
                 O(N^2) time, which sucks...
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}    pin      The pin.
                 * @param   {FarseerPhysics.Common.Vertices}    poutA    The pout A.
                 * @param   {FarseerPhysics.Common.Vertices}    poutB    The pout B.
                 * @return  {boolean}
                 */
                ResolvePinchPoint: function (pin, poutA, poutB) {
                    poutA.v = new FarseerPhysics.Common.Vertices.ctor();
                    poutB.v = new FarseerPhysics.Common.Vertices.ctor();

                    if (pin.Count < 3) {
                        return false;
                    }

                    var hasPinchPoint = false;
                    var pinchIndexA = -1;
                    var pinchIndexB = -1;
                    for (var i = 0; i < pin.Count; i = (i + 1) | 0) {
                        for (var j = (i + 1) | 0; j < pin.Count; j = (j + 1) | 0) {
                            if (Math.abs(pin.getItem(i).$clone().X - pin.getItem(j).$clone().X) < FarseerPhysics.Common.Decomposition.EarclipDecomposer.Tol && Math.abs(pin.getItem(i).$clone().Y - pin.getItem(j).$clone().Y) < FarseerPhysics.Common.Decomposition.EarclipDecomposer.Tol && j !== ((i + 1) | 0)) {
                                pinchIndexA = i;
                                pinchIndexB = j;
                                hasPinchPoint = true;
                                break;
                            }
                        }
                        if (hasPinchPoint) {
                            break;
                        }
                    }
                    if (hasPinchPoint) {
                        var sizeA = (pinchIndexB - pinchIndexA) | 0;
                        if (sizeA === pin.Count) {
                            return false;
                        }
                        for (var i1 = 0; i1 < sizeA; i1 = (i1 + 1) | 0) {
                            var ind = FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(((pinchIndexA + i1) | 0), pin.Count);
                            poutA.v.add(pin.getItem(ind).$clone());
                        }

                        var sizeB = (pin.Count - sizeA) | 0;
                        for (var i2 = 0; i2 < sizeB; i2 = (i2 + 1) | 0) {
                            var ind1 = FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(((pinchIndexB + i2) | 0), pin.Count);
                            poutB.v.add(pin.getItem(ind1).$clone());
                        }
                    }
                    return hasPinchPoint;
                },
                /**
                 * Fix for obnoxious behavior for the % operator for negative numbers...
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {number}    x          The x.
                 * @param   {number}    modulus    The modulus.
                 * @return  {number}
                 */
                Remainder: function (x, modulus) {
                    var rem = x % modulus;
                    while (rem < 0) {
                        rem = (rem + modulus) | 0;
                    }
                    return rem;
                },
                AddTriangle: function (t, vertices) {
                    var firstP = -1;
                    var firstT = -1;
                    var secondP = -1;
                    var secondT = -1;
                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        if (t.X[System.Array.index(0, t.X)] === vertices.getItem(i).$clone().X && t.Y[System.Array.index(0, t.Y)] === vertices.getItem(i).$clone().Y) {
                            if (firstP === -1) {
                                firstP = i;
                                firstT = 0;
                            } else {
                                secondP = i;
                                secondT = 0;
                            }
                        } else if (t.X[System.Array.index(1, t.X)] === vertices.getItem(i).$clone().X && t.Y[System.Array.index(1, t.Y)] === vertices.getItem(i).$clone().Y) {
                            if (firstP === -1) {
                                firstP = i;
                                firstT = 1;
                            } else {
                                secondP = i;
                                secondT = 1;
                            }
                        } else if (t.X[System.Array.index(2, t.X)] === vertices.getItem(i).$clone().X && t.Y[System.Array.index(2, t.Y)] === vertices.getItem(i).$clone().Y) {
                            if (firstP === -1) {
                                firstP = i;
                                firstT = 2;
                            } else {
                                secondP = i;
                                secondT = 2;
                            }
                        }
                    }
                    if (firstP === 0 && secondP === ((vertices.Count - 1) | 0)) {
                        firstP = (vertices.Count - 1) | 0;
                        secondP = 0;
                    }

                    if (secondP === -1) {
                        return null;
                    }

                    var tipT = 0;
                    if (tipT === firstT || tipT === secondT) {
                        tipT = 1;
                    }
                    if (tipT === firstT || tipT === secondT) {
                        tipT = 2;
                    }

                    var result = new FarseerPhysics.Common.Vertices.$ctor3(((vertices.Count + 1) | 0));
                    for (var i1 = 0; i1 < vertices.Count; i1 = (i1 + 1) | 0) {
                        result.add(vertices.getItem(i1).$clone());

                        if (i1 === firstP) {
                            result.add(new Microsoft.Xna.Framework.Vector2.$ctor2(t.X[System.Array.index(tipT, t.X)], t.Y[System.Array.index(tipT, t.Y)]));
                        }
                    }

                    return result;
                },
                /**
                 * Checks if vertex i is the tip of an ear in polygon defined by xv[] and
                 yv[].
                 Assumes clockwise orientation of polygon...ick
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {number}            i           The i.
                 * @param   {Array.<number>}    xv          The xv.
                 * @param   {Array.<number>}    yv          The yv.
                 * @param   {number}            xvLength    Length of the xv.
                 * @return  {boolean}                       <pre><code>true</code></pre> if the specified i is ear; otherwise, <pre><code>false</code></pre>.
                 */
                IsEar: function (i, xv, yv, xvLength) {
                    var dx0, dy0, dx1, dy1;
                    if (i >= xvLength || i < 0 || xvLength < 3) {
                        return false;
                    }
                    var upper = (i + 1) | 0;
                    var lower = (i - 1) | 0;
                    if (i === 0) {
                        dx0 = xv[System.Array.index(0, xv)] - xv[System.Array.index(((xvLength - 1) | 0), xv)];
                        dy0 = yv[System.Array.index(0, yv)] - yv[System.Array.index(((xvLength - 1) | 0), yv)];
                        dx1 = xv[System.Array.index(1, xv)] - xv[System.Array.index(0, xv)];
                        dy1 = yv[System.Array.index(1, yv)] - yv[System.Array.index(0, yv)];
                        lower = (xvLength - 1) | 0;
                    } else if (i === ((xvLength - 1) | 0)) {
                        dx0 = xv[System.Array.index(i, xv)] - xv[System.Array.index(((i - 1) | 0), xv)];
                        dy0 = yv[System.Array.index(i, yv)] - yv[System.Array.index(((i - 1) | 0), yv)];
                        dx1 = xv[System.Array.index(0, xv)] - xv[System.Array.index(i, xv)];
                        dy1 = yv[System.Array.index(0, yv)] - yv[System.Array.index(i, yv)];
                        upper = 0;
                    } else {
                        dx0 = xv[System.Array.index(i, xv)] - xv[System.Array.index(((i - 1) | 0), xv)];
                        dy0 = yv[System.Array.index(i, yv)] - yv[System.Array.index(((i - 1) | 0), yv)];
                        dx1 = xv[System.Array.index(((i + 1) | 0), xv)] - xv[System.Array.index(i, xv)];
                        dy1 = yv[System.Array.index(((i + 1) | 0), yv)] - yv[System.Array.index(i, yv)];
                    }
                    var cross = dx0 * dy1 - dx1 * dy0;
                    if (cross > 0) {
                        return false;
                    }
                    var myTri = new FarseerPhysics.Common.Decomposition.Triangle.$ctor1(xv[System.Array.index(i, xv)], yv[System.Array.index(i, yv)], xv[System.Array.index(upper, xv)], yv[System.Array.index(upper, yv)], xv[System.Array.index(lower, xv)], yv[System.Array.index(lower, yv)]);
                    for (var j = 0; j < xvLength; j = (j + 1) | 0) {
                        if (j === i || j === lower || j === upper) {
                            continue;
                        }
                        if (myTri.IsInside(xv[System.Array.index(j, xv)], yv[System.Array.index(j, yv)])) {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Edge", {
        fields: {
            Above: null,
            B: 0,
            Below: null,
            MPoints: null,
            P: null,
            Q: null,
            Slope: 0
        },
        ctors: {
            ctor: function (p, q) {
                this.$initialize();
                this.P = p;
                this.Q = q;

                if (q.X - p.X !== 0) {
                    this.Slope = (q.Y - p.Y) / (q.X - p.X);
                } else {
                    this.Slope = 0;
                }

                this.B = p.Y - (p.X * this.Slope);
                this.Above = null;
                this.Below = null;
                this.MPoints = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Common.Decomposition.Point)).ctor();
                this.MPoints.add(p);
                this.MPoints.add(q);
            }
        },
        methods: {
            IsAbove: function (point) {
                return this.P.Orient2D(this.Q, point) < 0;
            },
            IsBelow: function (point) {
                return this.P.Orient2D(this.Q, point) > 0;
            },
            AddMpoint: function (point) {
                var $t;
                $t = Bridge.getEnumerator(this.MPoints);
                try {
                    while ($t.moveNext()) {
                        var mp = $t.Current;
                        if (!mp.Neq(point)) {
                            return;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.MPoints.add(point);
            }
        }
    });

    /**
     * Triangulates a polygon into triangles.
     Doesn't handle holes.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
     */
    Bridge.define("FarseerPhysics.Common.Decomposition.FlipcodeDecomposer", {
        statics: {
            fields: {
                _tmpA: null,
                _tmpB: null,
                _tmpC: null
            },
            ctors: {
                init: function () {
                    this._tmpA = new Microsoft.Xna.Framework.Vector2();
                    this._tmpB = new Microsoft.Xna.Framework.Vector2();
                    this._tmpC = new Microsoft.Xna.Framework.Vector2();
                }
            },
            methods: {
                /**
                 * Check if the point P is inside the triangle defined by
                 the points A, B, C
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    The A point.
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    The B point.
                 * @param   {Microsoft.Xna.Framework.Vector2}    c    The C point.
                 * @param   {Microsoft.Xna.Framework.Vector2}    p    The point to be tested.
                 * @return  {boolean}                                 True if the point is inside the triangle
                 */
                InsideTriangle: function (a, b, c, p) {
                    var abp = (c.v.X - b.v.X) * (p.v.Y - b.v.Y) - (c.v.Y - b.v.Y) * (p.v.X - b.v.X);

                    var aap = (b.v.X - a.v.X) * (p.v.Y - a.v.Y) - (b.v.Y - a.v.Y) * (p.v.X - a.v.X);

                    var bcp = (a.v.X - c.v.X) * (p.v.Y - c.v.Y) - (a.v.Y - c.v.Y) * (p.v.X - c.v.X);

                    return ((abp >= 0.0) && (bcp >= 0.0) && (aap >= 0.0));
                },
                /**
                 * Cut a the contour and add a triangle into V to describe the 
                 location of the cut
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}    contour    The list of points defining the polygon
                 * @param   {number}                            u          The index of the first point
                 * @param   {number}                            v          The index of the second point
                 * @param   {number}                            w          The index of the third point
                 * @param   {number}                            n          The number of elements in the array.
                 * @param   {Array.<number>}                    V          The array to populate with indicies of triangles.
                 * @return  {boolean}                                      True if a triangle was found
                 */
                Snip: function (contour, u, v, w, n, V) {
                    if (FarseerPhysics.Settings.Epsilon > FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpA"), Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpB"), Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpC"))) {
                        return false;
                    }

                    for (var p = 0; p < n; p = (p + 1) | 0) {
                        if ((p === u) || (p === v) || (p === w)) {
                            continue;
                        }

                        var point = { v : contour.getItem(V[System.Array.index(p, V)]).$clone() };

                        if (FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.InsideTriangle(Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpA"), Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpB"), Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpC"), point)) {
                            return false;
                        }
                    }

                    return true;
                },
                /**
                 * Decompose the polygon into triangles
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       contour    The list of points describing the polygon
                 * @return  {System.Collections.Generic.List$1}
                 */
                ConvexPartition: function (contour) {
                    var n = contour.Count;
                    if (n < 3) {
                        return new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                    }

                    var V = System.Array.init(n, 0, System.Int32);

                    if (contour.IsCounterClockWise()) {
                        for (var v = 0; v < n; v = (v + 1) | 0) {
                            V[System.Array.index(v, V)] = v;
                        }
                    } else {
                        for (var v1 = 0; v1 < n; v1 = (v1 + 1) | 0) {
                            V[System.Array.index(v1, V)] = ((((n - 1) | 0)) - v1) | 0;
                        }
                    }

                    var nv = n;

                    var count = Bridge.Int.mul(2, nv); /* error detection */

                    var result = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    for (var v2 = (nv - 1) | 0; nv > 2; ) {
                        if (0 >= (Bridge.identity(count, (count = (count - 1) | 0)))) {
                            return new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                        }

                        var u = v2;
                        if (nv <= u) {
                            u = 0;
                        }
                        v2 = (u + 1) | 0;
                        if (nv <= v2) {
                            v2 = 0;
                        }
                        var w = (v2 + 1) | 0;
                        if (nv <= w) {
                            w = 0;
                        }

                        FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpA = contour.getItem(V[System.Array.index(u, V)]).$clone();
                        FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpB = contour.getItem(V[System.Array.index(v2, V)]).$clone();
                        FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpC = contour.getItem(V[System.Array.index(w, V)]).$clone();

                        if (FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.Snip(contour, u, v2, w, nv, V)) {
                            var s, t;

                            var triangle = new FarseerPhysics.Common.Vertices.$ctor3(3);
                            triangle.add(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpA.$clone());
                            triangle.add(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpB.$clone());
                            triangle.add(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpC.$clone());
                            result.add(triangle);

                            for (s = v2, t = (v2 + 1) | 0; t < nv; s = (s + 1) | 0, t = (t + 1) | 0) {
                                V[System.Array.index(s, V)] = V[System.Array.index(t, V)];
                            }
                            nv = (nv - 1) | 0;

                            count = Bridge.Int.mul(2, nv);
                        }
                    }

                    return result;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.MonotoneMountain", {
        statics: {
            fields: {
                PiSlop: 0
            },
            ctors: {
                init: function () {
                    this.PiSlop = 3.1;
                }
            }
        },
        fields: {
            Triangles: null,
            _convexPoints: null,
            _head: null,
            _monoPoly: null,
            _positive: false,
            _size: 0,
            _tail: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this._size = 0;
                this._tail = null;
                this._head = null;
                this._positive = false;
                this._convexPoints = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Common.Decomposition.Point)).ctor();
                this._monoPoly = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).ctor();
                this.Triangles = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point))).ctor();
            }
        },
        methods: {
            Add: function (point) {
                if (this._size === 0) {
                    this._head = point;
                    this._size = 1;
                } else if (this._size === 1) {
                    this._tail = point;
                    this._tail.Prev = this._head;
                    this._head.Next = this._tail;
                    this._size = 2;
                } else {
                    this._tail.Next = point;
                    point.Prev = this._tail;
                    this._tail = point;
                    this._size = (this._size + 1) | 0;
                }
            },
            Remove: function (point) {
                var next = point.Next;
                var prev = point.Prev;
                point.Prev.Next = next;
                point.Next.Prev = prev;
                this._size = (this._size - 1) | 0;
            },
            Process: function () {
                this._positive = this.AngleSign();
                this.GenMonoPoly();

                var p = this._head.Next;
                while (p.Neq(this._tail)) {
                    var a = this.Angle(p);
                    if (a >= FarseerPhysics.Common.Decomposition.MonotoneMountain.PiSlop || a <= -3.1 || a === 0.0) {
                        this.Remove(p);
                    } else {
                        if (this.IsConvex(p)) {
                            this._convexPoints.add(p);
                        }
                    }
                    p = p.Next;
                }

                this.Triangulate();
            },
            Triangulate: function () {
                while (this._convexPoints.Count !== 0) {
                    var e = this._convexPoints.GetEnumerator().$clone();
                    e.System$Collections$IEnumerator$moveNext();
                    var ear = e[Bridge.geti(e, "System$Collections$Generic$IEnumerator$1$FarseerPhysics$Common$Decomposition$Point$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")];

                    this._convexPoints.remove(ear);
                    var a = ear.Prev;
                    var b = ear;
                    var c = ear.Next;
                    var triangle = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor2(3);
                    triangle.add(a);
                    triangle.add(b);
                    triangle.add(c);

                    this.Triangles.add(triangle);

                    this.Remove(ear);
                    if (this.Valid(a)) {
                        this._convexPoints.add(a);
                    }
                    if (this.Valid(c)) {
                        this._convexPoints.add(c);
                    }
                }

                System.Diagnostics.Debug.Assert$1(this._size <= 3, "Triangulation bug, please report");
            },
            Valid: function (p) {
                return p.Neq(this._head) && p.Neq(this._tail) && this.IsConvex(p);
            },
            GenMonoPoly: function () {
                var p = this._head;
                while (p != null) {
                    this._monoPoly.add(p);
                    p = p.Next;
                }
            },
            Angle: function (p) {
                var a = (FarseerPhysics.Common.Decomposition.Point.op_Subtraction(p.Next, p));
                var b = (FarseerPhysics.Common.Decomposition.Point.op_Subtraction(p.Prev, p));
                return Math.atan2(a.Cross(b), a.Dot(b));
            },
            AngleSign: function () {
                var a = (FarseerPhysics.Common.Decomposition.Point.op_Subtraction(this._head.Next, this._head));
                var b = (FarseerPhysics.Common.Decomposition.Point.op_Subtraction(this._tail, this._head));
                return Math.atan2(a.Cross(b), a.Dot(b)) >= 0;
            },
            IsConvex: function (p) {
                if (this._positive !== (this.Angle(p) >= 0)) {
                    return false;
                }
                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Node", {
        fields: {
            LeftChild: null,
            ParentList: null,
            RightChild: null
        },
        ctors: {
            ctor: function (left, right) {
                this.$initialize();
                this.ParentList = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Node)).ctor();
                this.LeftChild = left;
                this.RightChild = right;

                if (left != null) {
                    left.ParentList.add(this);
                }
                if (right != null) {
                    right.ParentList.add(this);
                }
            }
        },
        methods: {
            Replace: function (node) {
                var $t;
                $t = Bridge.getEnumerator(node.ParentList);
                try {
                    while ($t.moveNext()) {
                        var parent = $t.Current;
                        if (Bridge.referenceEquals(parent.LeftChild, node)) {
                            parent.LeftChild = this;
                        } else {
                            parent.RightChild = this;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }this.ParentList.AddRange(node.ParentList);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Point", {
        statics: {
            methods: {
                op_Subtraction: function (p1, p2) {
                    return new FarseerPhysics.Common.Decomposition.Point(p1.X - p2.X, p1.Y - p2.Y);
                },
                op_Subtraction$1: function (p1, f) {
                    return new FarseerPhysics.Common.Decomposition.Point(p1.X - f, p1.Y - f);
                },
                op_Addition: function (p1, p2) {
                    return new FarseerPhysics.Common.Decomposition.Point(p1.X + p2.X, p1.Y + p2.Y);
                },
                op_Addition$1: function (p1, f) {
                    return new FarseerPhysics.Common.Decomposition.Point(p1.X + f, p1.Y + f);
                }
            }
        },
        fields: {
            Next: null,
            Prev: null,
            X: 0,
            Y: 0
        },
        ctors: {
            ctor: function (x, y) {
                this.$initialize();
                this.X = x;
                this.Y = y;
                this.Next = null;
                this.Prev = null;
            }
        },
        methods: {
            Cross: function (p) {
                return this.X * p.Y - this.Y * p.X;
            },
            Dot: function (p) {
                return this.X * p.X + this.Y * p.Y;
            },
            Neq: function (p) {
                return p.X !== this.X || p.Y !== this.Y;
            },
            Orient2D: function (pb, pc) {
                var acx = this.X - pc.X;
                var bcx = pb.X - pc.X;
                var acy = this.Y - pc.Y;
                var bcy = pb.Y - pc.Y;
                return acx * bcy - acy * bcx;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.QueryGraph", {
        fields: {
            _head: null
        },
        ctors: {
            ctor: function (head) {
                this.$initialize();
                this._head = head;
            }
        },
        methods: {
            Locate: function (edge) {
                return this._head.Locate(edge).Trapezoid;
            },
            FollowEdge: function (edge) {
                var trapezoids = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Trapezoid)).ctor();
                trapezoids.add(this.Locate(edge));
                var j = 0;

                while (edge.Q.X > trapezoids.getItem(j).RightPoint.X) {
                    if (edge.IsAbove(trapezoids.getItem(j).RightPoint)) {
                        trapezoids.add(trapezoids.getItem(j).UpperRight);
                    } else {
                        trapezoids.add(trapezoids.getItem(j).LowerRight);
                    }
                    j = (j + 1) | 0;
                }
                return trapezoids;
            },
            Replace: function (sink, node) {
                if (sink.ParentList.Count === 0) {
                    this._head = node;
                } else {
                    node.Replace(sink);
                }
            },
            Case1: function (sink, edge, tList) {
                var yNode = new FarseerPhysics.Common.Decomposition.YNode(edge, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(1, tList)]), FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(2, tList)]));
                var qNode = new FarseerPhysics.Common.Decomposition.XNode(edge.Q, yNode, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(3, tList)]));
                var pNode = new FarseerPhysics.Common.Decomposition.XNode(edge.P, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(0, tList)]), qNode);
                this.Replace(sink, pNode);
            },
            Case2: function (sink, edge, tList) {
                var yNode = new FarseerPhysics.Common.Decomposition.YNode(edge, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(1, tList)]), FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(2, tList)]));
                var pNode = new FarseerPhysics.Common.Decomposition.XNode(edge.P, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(0, tList)]), yNode);
                this.Replace(sink, pNode);
            },
            Case3: function (sink, edge, tList) {
                var yNode = new FarseerPhysics.Common.Decomposition.YNode(edge, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(0, tList)]), FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(1, tList)]));
                this.Replace(sink, yNode);
            },
            Case4: function (sink, edge, tList) {
                var yNode = new FarseerPhysics.Common.Decomposition.YNode(edge, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(0, tList)]), FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(1, tList)]));
                var qNode = new FarseerPhysics.Common.Decomposition.XNode(edge.Q, yNode, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(2, tList)]));
                this.Replace(sink, qNode);
            }
        }
    });

    /**
     * Convex decomposition algorithm based on Raimund Seidel's paper "A simple and fast incremental randomized
     algorithm for computing trapezoidal decompositions and for triangulating polygons"
     See also: "Computational Geometry", 3rd edition, by Mark de Berg et al, Chapter 6.2
               "Computational Geometry in C", 2nd edition, by Joseph O'Rourke
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.Decomposition.SeidelDecomposer
     */
    Bridge.define("FarseerPhysics.Common.Decomposition.SeidelDecomposer", {
        statics: {
            methods: {
                /**
                 * Decompose the polygon into several smaller non-concave polygon.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.SeidelDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.SeidelDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices    The polygon to decompose.
                 * @param   {number}                               sheer       The sheer to use. If you get bad results, try using a higher value. The default value is 0.001
                 * @return  {System.Collections.Generic.List$1}                A list of triangles
                 */
                ConvexPartition: function (vertices, sheer) {
                    var $t, $t1, $t2;
                    var compatList = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor2(vertices.Count);

                    $t = Bridge.getEnumerator(vertices);
                    try {
                        while ($t.moveNext()) {
                            var vertex = $t.Current.$clone();
                            compatList.add(new FarseerPhysics.Common.Decomposition.Point(vertex.X, vertex.Y));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    var t = new FarseerPhysics.Common.Decomposition.Triangulator(compatList, sheer);

                    var list = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    $t1 = Bridge.getEnumerator(t.Triangles);
                    try {
                        while ($t1.moveNext()) {
                            var triangle = $t1.Current;
                            var verts = new FarseerPhysics.Common.Vertices.$ctor3(triangle.Count);

                            $t2 = Bridge.getEnumerator(triangle);
                            try {
                                while ($t2.moveNext()) {
                                    var point = $t2.Current;
                                    verts.add(new Microsoft.Xna.Framework.Vector2.$ctor2(point.X, point.Y));
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                            list.add(verts);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return list;
                },
                /**
                 * Decompose the polygon into several smaller non-concave polygon.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.SeidelDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.SeidelDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices    The polygon to decompose.
                 * @param   {number}                               sheer       The sheer to use. If you get bad results, try using a higher value. The default value is 0.001
                 * @return  {System.Collections.Generic.List$1}                A list of trapezoids
                 */
                ConvexPartitionTrapezoid: function (vertices, sheer) {
                    var $t, $t1, $t2;
                    var compatList = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor2(vertices.Count);

                    $t = Bridge.getEnumerator(vertices);
                    try {
                        while ($t.moveNext()) {
                            var vertex = $t.Current.$clone();
                            compatList.add(new FarseerPhysics.Common.Decomposition.Point(vertex.X, vertex.Y));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    var t = new FarseerPhysics.Common.Decomposition.Triangulator(compatList, sheer);

                    var list = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    $t1 = Bridge.getEnumerator(t.Trapezoids);
                    try {
                        while ($t1.moveNext()) {
                            var trapezoid = $t1.Current;
                            var verts = new FarseerPhysics.Common.Vertices.ctor();

                            var points = trapezoid.Vertices();
                            $t2 = Bridge.getEnumerator(points);
                            try {
                                while ($t2.moveNext()) {
                                    var point = $t2.Current;
                                    verts.add(new Microsoft.Xna.Framework.Vector2.$ctor2(point.X, point.Y));
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                            list.add(verts);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return list;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Trapezoid", {
        fields: {
            Bottom: null,
            Inside: false,
            LeftPoint: null,
            LowerLeft: null,
            LowerRight: null,
            RightPoint: null,
            Sink: null,
            Top: null,
            UpperLeft: null,
            UpperRight: null
        },
        ctors: {
            ctor: function (leftPoint, rightPoint, top, bottom) {
                this.$initialize();
                this.LeftPoint = leftPoint;
                this.RightPoint = rightPoint;
                this.Top = top;
                this.Bottom = bottom;
                this.UpperLeft = null;
                this.UpperRight = null;
                this.LowerLeft = null;
                this.LowerRight = null;
                this.Inside = true;
                this.Sink = null;
            }
        },
        methods: {
            UpdateLeft: function (ul, ll) {
                this.UpperLeft = ul;
                if (ul != null) {
                    ul.UpperRight = this;
                }
                this.LowerLeft = ll;
                if (ll != null) {
                    ll.LowerRight = this;
                }
            },
            UpdateRight: function (ur, lr) {
                this.UpperRight = ur;
                if (ur != null) {
                    ur.UpperLeft = this;
                }
                this.LowerRight = lr;
                if (lr != null) {
                    lr.LowerLeft = this;
                }
            },
            UpdateLeftRight: function (ul, ll, ur, lr) {
                this.UpperLeft = ul;
                if (ul != null) {
                    ul.UpperRight = this;
                }
                this.LowerLeft = ll;
                if (ll != null) {
                    ll.LowerRight = this;
                }
                this.UpperRight = ur;
                if (ur != null) {
                    ur.UpperLeft = this;
                }
                this.LowerRight = lr;
                if (lr != null) {
                    lr.LowerLeft = this;
                }
            },
            TrimNeighbors: function () {
                if (this.Inside) {
                    this.Inside = false;
                    if (this.UpperLeft != null) {
                        this.UpperLeft.TrimNeighbors();
                    }
                    if (this.LowerLeft != null) {
                        this.LowerLeft.TrimNeighbors();
                    }
                    if (this.UpperRight != null) {
                        this.UpperRight.TrimNeighbors();
                    }
                    if (this.LowerRight != null) {
                        this.LowerRight.TrimNeighbors();
                    }
                }
            },
            Contains: function (point) {
                return (point.X > this.LeftPoint.X && point.X < this.RightPoint.X && this.Top.IsAbove(point) && this.Bottom.IsBelow(point));
            },
            Vertices: function () {
                var verts = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor2(4);
                verts.add(this.LineIntersect(this.Top, this.LeftPoint.X));
                verts.add(this.LineIntersect(this.Bottom, this.LeftPoint.X));
                verts.add(this.LineIntersect(this.Bottom, this.RightPoint.X));
                verts.add(this.LineIntersect(this.Top, this.RightPoint.X));
                return verts;
            },
            LineIntersect: function (edge, x) {
                var y = edge.Slope * x + edge.B;
                return new FarseerPhysics.Common.Decomposition.Point(x, y);
            },
            AddPoints: function () {
                if (!Bridge.referenceEquals(this.LeftPoint, this.Bottom.P)) {
                    this.Bottom.AddMpoint(this.LeftPoint);
                }
                if (!Bridge.referenceEquals(this.RightPoint, this.Bottom.Q)) {
                    this.Bottom.AddMpoint(this.RightPoint);
                }
                if (!Bridge.referenceEquals(this.LeftPoint, this.Top.P)) {
                    this.Top.AddMpoint(this.LeftPoint);
                }
                if (!Bridge.referenceEquals(this.RightPoint, this.Top.Q)) {
                    this.Top.AddMpoint(this.RightPoint);
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.TrapezoidalMap", {
        fields: {
            Map: null,
            _bCross: null,
            _cross: null,
            _margin: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Map = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Common.Decomposition.Trapezoid)).ctor();
                this._margin = 50.0;
                this._bCross = null;
                this._cross = null;
            }
        },
        methods: {
            Clear: function () {
                this._bCross = null;
                this._cross = null;
            },
            Case1: function (t, e) {
                var trapezoids = System.Array.init(4, null, FarseerPhysics.Common.Decomposition.Trapezoid);
                trapezoids[System.Array.index(0, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(t.LeftPoint, e.P, t.Top, t.Bottom);
                trapezoids[System.Array.index(1, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.P, e.Q, t.Top, e);
                trapezoids[System.Array.index(2, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.P, e.Q, e, t.Bottom);
                trapezoids[System.Array.index(3, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.Q, t.RightPoint, t.Top, t.Bottom);

                trapezoids[System.Array.index(0, trapezoids)].UpdateLeft(t.UpperLeft, t.LowerLeft);
                trapezoids[System.Array.index(1, trapezoids)].UpdateLeftRight(trapezoids[System.Array.index(0, trapezoids)], null, trapezoids[System.Array.index(3, trapezoids)], null);
                trapezoids[System.Array.index(2, trapezoids)].UpdateLeftRight(null, trapezoids[System.Array.index(0, trapezoids)], null, trapezoids[System.Array.index(3, trapezoids)]);
                trapezoids[System.Array.index(3, trapezoids)].UpdateRight(t.UpperRight, t.LowerRight);

                return trapezoids;
            },
            Case2: function (t, e) {
                var rp;
                if (e.Q.X === t.RightPoint.X) {
                    rp = e.Q;
                } else {
                    rp = t.RightPoint;
                }

                var trapezoids = System.Array.init(3, null, FarseerPhysics.Common.Decomposition.Trapezoid);
                trapezoids[System.Array.index(0, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(t.LeftPoint, e.P, t.Top, t.Bottom);
                trapezoids[System.Array.index(1, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.P, rp, t.Top, e);
                trapezoids[System.Array.index(2, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.P, rp, e, t.Bottom);

                trapezoids[System.Array.index(0, trapezoids)].UpdateLeft(t.UpperLeft, t.LowerLeft);
                trapezoids[System.Array.index(1, trapezoids)].UpdateLeftRight(trapezoids[System.Array.index(0, trapezoids)], null, t.UpperRight, null);
                trapezoids[System.Array.index(2, trapezoids)].UpdateLeftRight(null, trapezoids[System.Array.index(0, trapezoids)], null, t.LowerRight);

                this._bCross = t.Bottom;
                this._cross = t.Top;

                e.Above = trapezoids[System.Array.index(1, trapezoids)];
                e.Below = trapezoids[System.Array.index(2, trapezoids)];

                return trapezoids;
            },
            Case3: function (t, e) {
                var lp;
                if (e.P.X === t.LeftPoint.X) {
                    lp = e.P;
                } else {
                    lp = t.LeftPoint;
                }

                var rp;
                if (e.Q.X === t.RightPoint.X) {
                    rp = e.Q;
                } else {
                    rp = t.RightPoint;
                }

                var trapezoids = System.Array.init(2, null, FarseerPhysics.Common.Decomposition.Trapezoid);

                if (Bridge.referenceEquals(this._cross, t.Top)) {
                    trapezoids[System.Array.index(0, trapezoids)] = t.UpperLeft;
                    trapezoids[System.Array.index(0, trapezoids)].UpdateRight(t.UpperRight, null);
                    trapezoids[System.Array.index(0, trapezoids)].RightPoint = rp;
                } else {
                    trapezoids[System.Array.index(0, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(lp, rp, t.Top, e);
                    trapezoids[System.Array.index(0, trapezoids)].UpdateLeftRight(t.UpperLeft, e.Above, t.UpperRight, null);
                }

                if (Bridge.referenceEquals(this._bCross, t.Bottom)) {
                    trapezoids[System.Array.index(1, trapezoids)] = t.LowerLeft;
                    trapezoids[System.Array.index(1, trapezoids)].UpdateRight(null, t.LowerRight);
                    trapezoids[System.Array.index(1, trapezoids)].RightPoint = rp;
                } else {
                    trapezoids[System.Array.index(1, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(lp, rp, e, t.Bottom);
                    trapezoids[System.Array.index(1, trapezoids)].UpdateLeftRight(e.Below, t.LowerLeft, null, t.LowerRight);
                }

                this._bCross = t.Bottom;
                this._cross = t.Top;

                e.Above = trapezoids[System.Array.index(0, trapezoids)];
                e.Below = trapezoids[System.Array.index(1, trapezoids)];

                return trapezoids;
            },
            Case4: function (t, e) {
                var lp;
                if (e.P.X === t.LeftPoint.X) {
                    lp = e.P;
                } else {
                    lp = t.LeftPoint;
                }

                var trapezoids = System.Array.init(3, null, FarseerPhysics.Common.Decomposition.Trapezoid);

                if (Bridge.referenceEquals(this._cross, t.Top)) {
                    trapezoids[System.Array.index(0, trapezoids)] = t.UpperLeft;
                    trapezoids[System.Array.index(0, trapezoids)].RightPoint = e.Q;
                } else {
                    trapezoids[System.Array.index(0, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(lp, e.Q, t.Top, e);
                    trapezoids[System.Array.index(0, trapezoids)].UpdateLeft(t.UpperLeft, e.Above);
                }

                if (Bridge.referenceEquals(this._bCross, t.Bottom)) {
                    trapezoids[System.Array.index(1, trapezoids)] = t.LowerLeft;
                    trapezoids[System.Array.index(1, trapezoids)].RightPoint = e.Q;
                } else {
                    trapezoids[System.Array.index(1, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(lp, e.Q, e, t.Bottom);
                    trapezoids[System.Array.index(1, trapezoids)].UpdateLeft(e.Below, t.LowerLeft);
                }

                trapezoids[System.Array.index(2, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.Q, t.RightPoint, t.Top, t.Bottom);
                trapezoids[System.Array.index(2, trapezoids)].UpdateLeftRight(trapezoids[System.Array.index(0, trapezoids)], trapezoids[System.Array.index(1, trapezoids)], t.UpperRight, t.LowerRight);

                return trapezoids;
            },
            BoundingBox: function (edges) {
                var $t;
                var max = FarseerPhysics.Common.Decomposition.Point.op_Addition$1(edges.getItem(0).P, this._margin);
                var min = FarseerPhysics.Common.Decomposition.Point.op_Subtraction$1(edges.getItem(0).Q, this._margin);

                $t = Bridge.getEnumerator(edges);
                try {
                    while ($t.moveNext()) {
                        var e = $t.Current;
                        if (e.P.X > max.X) {
                            max = new FarseerPhysics.Common.Decomposition.Point(e.P.X + this._margin, max.Y);
                        }
                        if (e.P.Y > max.Y) {
                            max = new FarseerPhysics.Common.Decomposition.Point(max.X, e.P.Y + this._margin);
                        }
                        if (e.Q.X > max.X) {
                            max = new FarseerPhysics.Common.Decomposition.Point(e.Q.X + this._margin, max.Y);
                        }
                        if (e.Q.Y > max.Y) {
                            max = new FarseerPhysics.Common.Decomposition.Point(max.X, e.Q.Y + this._margin);
                        }
                        if (e.P.X < min.X) {
                            min = new FarseerPhysics.Common.Decomposition.Point(e.P.X - this._margin, min.Y);
                        }
                        if (e.P.Y < min.Y) {
                            min = new FarseerPhysics.Common.Decomposition.Point(min.X, e.P.Y - this._margin);
                        }
                        if (e.Q.X < min.X) {
                            min = new FarseerPhysics.Common.Decomposition.Point(e.Q.X - this._margin, min.Y);
                        }
                        if (e.Q.Y < min.Y) {
                            min = new FarseerPhysics.Common.Decomposition.Point(min.X, e.Q.Y - this._margin);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var top = new FarseerPhysics.Common.Decomposition.Edge(new FarseerPhysics.Common.Decomposition.Point(min.X, max.Y), new FarseerPhysics.Common.Decomposition.Point(max.X, max.Y));
                var bottom = new FarseerPhysics.Common.Decomposition.Edge(new FarseerPhysics.Common.Decomposition.Point(min.X, min.Y), new FarseerPhysics.Common.Decomposition.Point(max.X, min.Y));
                var left = bottom.P;
                var right = top.Q;

                return new FarseerPhysics.Common.Decomposition.Trapezoid(left, right, top, bottom);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Triangle", {
        fields: {
            X: null,
            Y: null
        },
        ctors: {
            $ctor1: function (x1, y1, x2, y2, x3, y3) {
                this.$initialize();
                this.X = System.Array.init(3, 0, System.Single);
                this.Y = System.Array.init(3, 0, System.Single);
                var dx1 = x2 - x1;
                var dx2 = x3 - x1;
                var dy1 = y2 - y1;
                var dy2 = y3 - y1;
                var cross = dx1 * dy2 - dx2 * dy1;
                var ccw = (cross > 0);
                if (ccw) {
                    this.X[System.Array.index(0, this.X)] = x1;
                    this.X[System.Array.index(1, this.X)] = x2;
                    this.X[System.Array.index(2, this.X)] = x3;
                    this.Y[System.Array.index(0, this.Y)] = y1;
                    this.Y[System.Array.index(1, this.Y)] = y2;
                    this.Y[System.Array.index(2, this.Y)] = y3;
                } else {
                    this.X[System.Array.index(0, this.X)] = x1;
                    this.X[System.Array.index(1, this.X)] = x3;
                    this.X[System.Array.index(2, this.X)] = x2;
                    this.Y[System.Array.index(0, this.Y)] = y1;
                    this.Y[System.Array.index(1, this.Y)] = y3;
                    this.Y[System.Array.index(2, this.Y)] = y2;
                }
            },
            ctor: function (t) {
                this.$initialize();
                this.X = System.Array.init(3, 0, System.Single);
                this.Y = System.Array.init(3, 0, System.Single);

                this.X[System.Array.index(0, this.X)] = t.X[System.Array.index(0, t.X)];
                this.X[System.Array.index(1, this.X)] = t.X[System.Array.index(1, t.X)];
                this.X[System.Array.index(2, this.X)] = t.X[System.Array.index(2, t.X)];
                this.Y[System.Array.index(0, this.Y)] = t.Y[System.Array.index(0, t.Y)];
                this.Y[System.Array.index(1, this.Y)] = t.Y[System.Array.index(1, t.Y)];
                this.Y[System.Array.index(2, this.Y)] = t.Y[System.Array.index(2, t.Y)];
            }
        },
        methods: {
            IsInside: function (x, y) {
                if (x < this.X[System.Array.index(0, this.X)] && x < this.X[System.Array.index(1, this.X)] && x < this.X[System.Array.index(2, this.X)]) {
                    return false;
                }
                if (x > this.X[System.Array.index(0, this.X)] && x > this.X[System.Array.index(1, this.X)] && x > this.X[System.Array.index(2, this.X)]) {
                    return false;
                }
                if (y < this.Y[System.Array.index(0, this.Y)] && y < this.Y[System.Array.index(1, this.Y)] && y < this.Y[System.Array.index(2, this.Y)]) {
                    return false;
                }
                if (y > this.Y[System.Array.index(0, this.Y)] && y > this.Y[System.Array.index(1, this.Y)] && y > this.Y[System.Array.index(2, this.Y)]) {
                    return false;
                }

                var vx2 = x - this.X[System.Array.index(0, this.X)];
                var vy2 = y - this.Y[System.Array.index(0, this.Y)];
                var vx1 = this.X[System.Array.index(1, this.X)] - this.X[System.Array.index(0, this.X)];
                var vy1 = this.Y[System.Array.index(1, this.Y)] - this.Y[System.Array.index(0, this.Y)];
                var vx0 = this.X[System.Array.index(2, this.X)] - this.X[System.Array.index(0, this.X)];
                var vy0 = this.Y[System.Array.index(2, this.Y)] - this.Y[System.Array.index(0, this.Y)];

                var dot00 = vx0 * vx0 + vy0 * vy0;
                var dot01 = vx0 * vx1 + vy0 * vy1;
                var dot02 = vx0 * vx2 + vy0 * vy2;
                var dot11 = vx1 * vx1 + vy1 * vy1;
                var dot12 = vx1 * vx2 + vy1 * vy2;
                var invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

                return ((u > 0) && (v > 0) && (u + v < 1));
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Triangulator", {
        statics: {
            methods: {
                Shuffle: function (T, list) {
                    var rng = new System.Random.ctor();
                    var n = System.Array.getCount(list, T);
                    while (n > 1) {
                        n = (n - 1) | 0;
                        var k = rng.Next$1(((n + 1) | 0));
                        var value = System.Array.getItem(list, k, T);
                        System.Array.setItem(list, k, System.Array.getItem(list, n, T), T);
                        System.Array.setItem(list, n, value, T);
                    }
                }
            }
        },
        fields: {
            Trapezoids: null,
            Triangles: null,
            _boundingBox: null,
            _edgeList: null,
            _queryGraph: null,
            _sheer: 0,
            _trapezoidalMap: null,
            _xMonoPoly: null
        },
        ctors: {
            init: function () {
                this._sheer = 0.001;
            },
            ctor: function (polyLine, sheer) {
                this.$initialize();
                this._sheer = sheer;
                this.Triangles = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point))).ctor();
                this.Trapezoids = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Trapezoid)).ctor();
                this._xMonoPoly = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.MonotoneMountain)).ctor();
                this._edgeList = this.InitEdges(polyLine);
                this._trapezoidalMap = new FarseerPhysics.Common.Decomposition.TrapezoidalMap();
                this._boundingBox = this._trapezoidalMap.BoundingBox(this._edgeList);
                this._queryGraph = new FarseerPhysics.Common.Decomposition.QueryGraph(FarseerPhysics.Common.Decomposition.Sink.Isink(this._boundingBox));

                this.Process();
            }
        },
        methods: {
            Process: function () {
                var $t, $t1, $t2, $t3, $t4;
                $t = Bridge.getEnumerator(this._edgeList);
                try {
                    while ($t.moveNext()) {
                        var edge = $t.Current;
                        var traps = this._queryGraph.FollowEdge(edge);

                        $t1 = Bridge.getEnumerator(traps);
                        try {
                            while ($t1.moveNext()) {
                                var t = $t1.Current;
                                this._trapezoidalMap.Map.remove(t);

                                var cp = t.Contains(edge.P);
                                var cq = t.Contains(edge.Q);
                                var tList;

                                if (cp && cq) {
                                    tList = this._trapezoidalMap.Case1(t, edge);
                                    this._queryGraph.Case1(t.Sink, edge, tList);
                                } else if (cp && !cq) {
                                    tList = this._trapezoidalMap.Case2(t, edge);
                                    this._queryGraph.Case2(t.Sink, edge, tList);
                                } else if (!cp && !cq) {
                                    tList = this._trapezoidalMap.Case3(t, edge);
                                    this._queryGraph.Case3(t.Sink, edge, tList);
                                } else {
                                    tList = this._trapezoidalMap.Case4(t, edge);
                                    this._queryGraph.Case4(t.Sink, edge, tList);
                                }
                                $t2 = Bridge.getEnumerator(tList);
                                try {
                                    while ($t2.moveNext()) {
                                        var y = $t2.Current;
                                        this._trapezoidalMap.Map.add(y);
                                    }
                                } finally {
                                    if (Bridge.is($t2, System.IDisposable)) {
                                        $t2.System$IDisposable$Dispose();
                                    }
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }this._trapezoidalMap.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t3 = Bridge.getEnumerator(this._trapezoidalMap.Map);
                try {
                    while ($t3.moveNext()) {
                        var t1 = $t3.Current;
                        this.MarkOutside(t1);
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }
                $t4 = Bridge.getEnumerator(this._trapezoidalMap.Map);
                try {
                    while ($t4.moveNext()) {
                        var t2 = $t4.Current;
                        if (t2.Inside) {
                            this.Trapezoids.add(t2);
                            t2.AddPoints();
                        }
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }
                this.CreateMountains();
            },
            CreateMountains: function () {
                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this._edgeList);
                try {
                    while ($t.moveNext()) {
                        var edge = $t.Current;
                        if (edge.MPoints.Count > 2) {
                            var mountain = new FarseerPhysics.Common.Decomposition.MonotoneMountain();



                            var points = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor1(edge.MPoints);
                            points.Sort$2(function (p1, p2) {
                                return Bridge.compare(p1.X, p2.X);
                            });

                            $t1 = Bridge.getEnumerator(points);
                            try {
                                while ($t1.moveNext()) {
                                    var p = $t1.Current;
                                    mountain.Add(p);
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                            mountain.Process();

                            $t2 = Bridge.getEnumerator(mountain.Triangles);
                            try {
                                while ($t2.moveNext()) {
                                    var t = $t2.Current;
                                    this.Triangles.add(t);
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                            this._xMonoPoly.add(mountain);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            MarkOutside: function (t) {
                if (Bridge.referenceEquals(t.Top, this._boundingBox.Top) || Bridge.referenceEquals(t.Bottom, this._boundingBox.Bottom)) {
                    t.TrimNeighbors();
                }
            },
            InitEdges: function (points) {
                var edges = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Edge)).ctor();

                for (var i = 0; i < ((points.Count - 1) | 0); i = (i + 1) | 0) {
                    edges.add(new FarseerPhysics.Common.Decomposition.Edge(points.getItem(i), points.getItem(((i + 1) | 0))));
                }
                edges.add(new FarseerPhysics.Common.Decomposition.Edge(points.getItem(0), points.getItem(((points.Count - 1) | 0))));
                return this.OrderSegments(edges);
            },
            OrderSegments: function (edgeInput) {
                var $t;
                var edges = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Edge)).ctor();

                $t = Bridge.getEnumerator(edgeInput);
                try {
                    while ($t.moveNext()) {
                        var e = $t.Current;
                        var p = this.ShearTransform(e.P);
                        var q = this.ShearTransform(e.Q);

                        if (p.X > q.X) {
                            edges.add(new FarseerPhysics.Common.Decomposition.Edge(q, p));
                        } else if (p.X < q.X) {
                            edges.add(new FarseerPhysics.Common.Decomposition.Edge(p, q));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                FarseerPhysics.Common.Decomposition.Triangulator.Shuffle(Bridge.global.FarseerPhysics.Common.Decomposition.Edge, edges);
                return edges;
            },
            ShearTransform: function (point) {
                return new FarseerPhysics.Common.Decomposition.Point(point.X + this._sheer * point.Y, point.Y);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Vertices", {
        inherits: [System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);
            },
            $ctor3: function (capacity) {
                this.$initialize();
                System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);
                this.Capacity = capacity;
            },
            $ctor1: function (vector2) {
                this.$initialize();
                System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);
                for (var i = 0; i < vector2.length; i = (i + 1) | 0) {
                    this.add(vector2[System.Array.index(i, vector2)].$clone());
                }
            },
            $ctor2: function (vertices) {
                this.$initialize();
                System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);
                for (var i = 0; i < System.Array.getCount(vertices, Microsoft.Xna.Framework.Vector2); i = (i + 1) | 0) {
                    this.add(System.Array.getItem(vertices, i, Microsoft.Xna.Framework.Vector2).$clone());
                }
            }
        },
        methods: {
            /**
             * Nexts the index.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {number}    index    The index.
             * @return  {number}
             */
            NextIndex: function (index) {
                if (index === ((this.Count - 1) | 0)) {
                    return 0;
                }
                return ((index + 1) | 0);
            },
            NextVertex: function (index) {
                return this.getItem(this.NextIndex(index)).$clone();
            },
            /**
             * Gets the previous index.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {number}    index    The index.
             * @return  {number}
             */
            PreviousIndex: function (index) {
                if (index === 0) {
                    return ((this.Count - 1) | 0);
                }
                return ((index - 1) | 0);
            },
            PreviousVertex: function (index) {
                return this.getItem(this.PreviousIndex(index)).$clone();
            },
            /**
             * Gets the signed area.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {number}
             */
            GetSignedArea: function () {
                var i;
                var area = 0;

                for (i = 0; i < this.Count; i = (i + 1) | 0) {
                    var j = (((i + 1) | 0)) % this.Count;
                    area += this.getItem(i).$clone().X * this.getItem(j).$clone().Y;
                    area -= this.getItem(i).$clone().Y * this.getItem(j).$clone().X;
                }
                area /= 2.0;
                return area;
            },
            /**
             * Gets the area.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {number}
             */
            GetArea: function () {
                var i;
                var area = 0;

                for (i = 0; i < this.Count; i = (i + 1) | 0) {
                    var j = (((i + 1) | 0)) % this.Count;
                    area += this.getItem(i).$clone().X * this.getItem(j).$clone().Y;
                    area -= this.getItem(i).$clone().Y * this.getItem(j).$clone().X;
                }
                area /= 2.0;
                return (area < 0 ? -area : area);
            },
            /**
             * Gets the centroid.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {Microsoft.Xna.Framework.Vector2}
             */
            GetCentroid: function () {

                var c = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var area = 0.0;

                var inv3 = 0.333333343;
                var pRef = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var p1 = pRef.$clone();
                    var p2 = this.getItem(i).$clone();
                    var p3 = ((i + 1) | 0) < this.Count ? this.getItem(((i + 1) | 0)).$clone() : this.getItem(0).$clone();

                    var e1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());
                    var e2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p3.$clone(), p1.$clone());

                    var D = FarseerPhysics.Common.MathUtils.Cross$2(e1.$clone(), e2.$clone());

                    var triangleArea = 0.5 * D;
                    area += triangleArea;

                    c = Microsoft.Xna.Framework.Vector2.op_Addition(c.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea * inv3, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), p2.$clone()), p3.$clone()))));
                }

                c = Microsoft.Xna.Framework.Vector2.op_Multiply$1(c.$clone(), 1.0 / area);
                return c.$clone();
            },
            /**
             * Gets the radius based on area.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {number}
             */
            GetRadius: function () {
                var area = this.GetSignedArea();

                var radiusSqrd = area / Microsoft.Xna.Framework.MathHelper.Pi;
                if (radiusSqrd < 0) {
                    radiusSqrd *= -1;
                }

                return Math.sqrt(radiusSqrd);
            },
            /**
             * Returns an AABB for vertex.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {FarseerPhysics.Collision.AABB}
             */
            GetCollisionBox: function () {
                var aabb = new FarseerPhysics.Collision.AABB();
                var lowerBound = new Microsoft.Xna.Framework.Vector2.$ctor2(3.40282347E+38, 3.40282347E+38);
                var upperBound = new Microsoft.Xna.Framework.Vector2.$ctor2(-3.40282347E+38, -3.40282347E+38);

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (this.getItem(i).$clone().X < lowerBound.X) {
                        lowerBound.X = this.getItem(i).$clone().X;
                    }
                    if (this.getItem(i).$clone().X > upperBound.X) {
                        upperBound.X = this.getItem(i).$clone().X;
                    }

                    if (this.getItem(i).$clone().Y < lowerBound.Y) {
                        lowerBound.Y = this.getItem(i).$clone().Y;
                    }
                    if (this.getItem(i).$clone().Y > upperBound.Y) {
                        upperBound.Y = this.getItem(i).$clone().Y;
                    }
                }

                aabb.LowerBound = lowerBound.$clone();
                aabb.UpperBound = upperBound.$clone();

                return aabb.$clone();
            },
            Translate: function (vector) {
                vector = {v:vector};
                this.Translate$1(vector);
            },
            /**
             * Translates the vertices with the specified vector.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    vector    The vector.
             * @return  {void}
             */
            Translate$1: function (vector) {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    this.setItem(i, Microsoft.Xna.Framework.Vector2.Add(this.getItem(i).$clone(), vector.v.$clone()));
                }
            },
            /**
             * Scales the vertices with the specified vector.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    value    The Value.
             * @return  {void}
             */
            Scale: function (value) {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    this.setItem(i, Microsoft.Xna.Framework.Vector2.Multiply(this.getItem(i).$clone(), value.v.$clone()));
                }
            },
            /**
             * Rotate the vertices with the defined value in radians.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {number}    value    The amount to rotate by in radians.
             * @return  {void}
             */
            Rotate: function (value) {
                var rotationMatrix = { v : new Microsoft.Xna.Framework.Matrix() };
                Microsoft.Xna.Framework.Matrix.CreateRotationZ$1(value, rotationMatrix);

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    this.setItem(i, Microsoft.Xna.Framework.Vector2.Transform(this.getItem(i).$clone(), rotationMatrix.v.$clone()));
                }
            },
            /**
             * Assuming the polygon is simple; determines whether the polygon is convex.
             NOTE: It will also return false if the input contains colinear edges.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {boolean}        <pre><code>true</code></pre> if it is convex; otherwise, <pre><code>false</code></pre>.
             */
            IsConvex: function () {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var i1 = i;
                    var i2 = ((i + 1) | 0) < this.Count ? ((i + 1) | 0) : 0;
                    var edge = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(i2).$clone(), this.getItem(i1).$clone());

                    for (var j = 0; j < this.Count; j = (j + 1) | 0) {
                        if (j === i1 || j === i2) {
                            continue;
                        }

                        var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(j).$clone(), this.getItem(i1).$clone());

                        var s = edge.X * r.Y - edge.Y * r.X;

                        if (s <= 0.0) {
                            return false;
                        }
                    }
                }
                return true;
            },
            IsCounterClockWise: function () {
                if (this.Count < 3) {
                    return true;
                }

                return (this.GetSignedArea() > 0.0);
            },
            /**
             * Forces counter clock wise order.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {void}
             */
            ForceCounterClockWise: function () {
                if (!this.IsCounterClockWise()) {
                    this.Reverse();
                }
            },
            /**
             * Check for edge crossings
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {boolean}
             */
            IsSimple: function () {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var iplus = (((i + 1) | 0) > ((this.Count - 1) | 0)) ? 0 : ((i + 1) | 0);
                    var a1 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(i).$clone().X, this.getItem(i).$clone().Y);
                    var a2 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(iplus).$clone().X, this.getItem(iplus).$clone().Y);
                    for (var j = (i + 1) | 0; j < this.Count; j = (j + 1) | 0) {
                        var jplus = (((j + 1) | 0) > ((this.Count - 1) | 0)) ? 0 : ((j + 1) | 0);
                        var b1 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(j).$clone().X, this.getItem(j).$clone().Y);
                        var b2 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(jplus).$clone().X, this.getItem(jplus).$clone().Y);

                        var temp = { v : new Microsoft.Xna.Framework.Vector2() };

                        if (FarseerPhysics.Common.LineTools.LineIntersect2(a1.$clone(), a2.$clone(), b1.$clone(), b2.$clone(), temp)) {
                            return false;
                        }
                    }
                }
                return true;
            },
            IsSimple2: function () {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (i < ((this.Count - 1) | 0)) {
                        for (var h = (i + 1) | 0; h < this.Count; h = (h + 1) | 0) {
                            if (Microsoft.Xna.Framework.Vector2.op_Equality(this.getItem(i).$clone(), this.getItem(h).$clone())) {
                                return true;
                            }
                        }
                    }

                    var j = (((i + 1) | 0)) % this.Count;
                    var iToj = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(j).$clone(), this.getItem(i).$clone());
                    var iTojNormal = new Microsoft.Xna.Framework.Vector2.$ctor2(iToj.Y, -iToj.X);

                    var startK = (((j + 1) | 0)) % this.Count;
                    var endK = (((((i - 1) | 0) + this.Count) | 0)) % this.Count;
                    endK = (endK + (startK < endK ? 0 : ((startK + 1) | 0))) | 0;
                    var k = startK;
                    var iTok = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(k).$clone(), this.getItem(i).$clone());
                    var onLeftSide = Microsoft.Xna.Framework.Vector2.Dot(iTok.$clone(), iTojNormal.$clone()) >= 0;
                    var prevK = this.getItem(k).$clone();
                    k = (k + 1) | 0;
                    for (; k <= endK; k = (k + 1) | 0) {
                        var modK = k % this.Count;
                        iTok = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(modK).$clone(), this.getItem(i).$clone());
                        if (onLeftSide !== Microsoft.Xna.Framework.Vector2.Dot(iTok.$clone(), iTojNormal.$clone()) >= 0) {
                            var prevKtoK = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(modK).$clone(), prevK.$clone());
                            var prevKtoKNormal = new Microsoft.Xna.Framework.Vector2.$ctor2(prevKtoK.Y, -prevKtoK.X);
                            if ((Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(i).$clone(), prevK.$clone()), prevKtoKNormal.$clone()) >= 0) !== (Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(j).$clone(), prevK.$clone()), prevKtoKNormal.$clone()) >= 0)) {
                                return true;
                            }
                        }
                        onLeftSide = Microsoft.Xna.Framework.Vector2.Dot(iTok.$clone(), iTojNormal.$clone()) > 0;
                        prevK = this.getItem(modK).$clone();
                    }
                }
                return false;
            },
            /**
             * Checks if polygon is valid for use in Box2d engine.
             Last ditch effort to ensure no invalid polygons are
             added to world geometry.
             Performs a full check, for simplicity, convexity,
             orientation, minimum angle, and volume.  This won't
             be very efficient, and a lot of it is redundant when
             other tools in this section are used.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {boolean}
             */
            CheckPolygon: function () {
                var error = -1;
                if (this.Count < 3 || this.Count > FarseerPhysics.Settings.MaxPolygonVertices) {
                    error = 0;
                }
                if (!this.IsConvex()) {
                    error = 1;
                }
                if (!this.IsSimple()) {
                    error = 2;
                }
                if (this.GetArea() < FarseerPhysics.Settings.Epsilon) {
                    error = 3;
                }

                var normals = System.Array.init(this.Count, function (){
                    return new Microsoft.Xna.Framework.Vector2();
                }, Microsoft.Xna.Framework.Vector2);
                var vertices = new FarseerPhysics.Common.Vertices.$ctor3(this.Count);
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(i).$clone().X, this.getItem(i).$clone().Y));
                    var i1 = i;
                    var i2 = ((i + 1) | 0) < this.Count ? ((i + 1) | 0) : 0;
                    var edge = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(i2).$clone().X - this.getItem(i1).$clone().X, this.getItem(i2).$clone().Y - this.getItem(i1).$clone().Y);
                    normals[System.Array.index(i, normals)] = FarseerPhysics.Common.MathUtils.Cross(edge.$clone(), 1.0);
                    normals[System.Array.index(i, normals)].Normalize();
                }

                for (var i3 = 0; i3 < this.Count; i3 = (i3 + 1) | 0) {
                    var iminus = (i3 === 0) ? ((this.Count - 1) | 0) : ((i3 - 1) | 0);

                    var cross = FarseerPhysics.Common.MathUtils.Cross$2(normals[System.Array.index(iminus, normals)].$clone(), normals[System.Array.index(i3, normals)].$clone());
                    cross = FarseerPhysics.Common.MathUtils.Clamp$2(cross, -1.0, 1.0);
                    var angle = Math.asin(cross);
                    if (angle <= FarseerPhysics.Settings.AngularSlop) {
                        error = 4;
                        break;
                    }

                    for (var j = 0; j < this.Count; j = (j + 1) | 0) {
                        if (j === i3 || j === (((i3 + 1) | 0)) % this.Count) {
                            continue;
                        }
                        var s = Microsoft.Xna.Framework.Vector2.Dot(normals[System.Array.index(i3, normals)].$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(j).$clone(), vertices.getItem(i3).$clone()));
                        if (s >= -0.005) {
                            error = 5;
                        }
                    }


                    var centroid = vertices.GetCentroid();
                    var n1 = normals[System.Array.index(iminus, normals)].$clone();
                    var n2 = normals[System.Array.index(i3, normals)].$clone();
                    var v = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i3).$clone(), centroid.$clone());

                    var d = new Microsoft.Xna.Framework.Vector2.ctor();
                    d.X = Microsoft.Xna.Framework.Vector2.Dot(n1.$clone(), v.$clone());
                    d.Y = Microsoft.Xna.Framework.Vector2.Dot(n2.$clone(), v.$clone());

                    if ((d.X < 0.0) || (d.Y < 0.0)) {
                        error = 6;
                    }
                }

                if (error !== -1) {
                    System.Diagnostics.Debug.WriteLine$2("Found invalid polygon, ");
                    switch (error) {
                        case 0: 
                            System.Diagnostics.Debug.WriteLine$2(System.String.format("must have between 3 and {0} vertices.\n", [Bridge.box(FarseerPhysics.Settings.MaxPolygonVertices, System.Int32)]));
                            break;
                        case 1: 
                            System.Diagnostics.Debug.WriteLine$2("must be convex.\n");
                            break;
                        case 2: 
                            System.Diagnostics.Debug.WriteLine$2("must be simple (cannot intersect itself).\n");
                            break;
                        case 3: 
                            System.Diagnostics.Debug.WriteLine$2("area is too small.\n");
                            break;
                        case 4: 
                            System.Diagnostics.Debug.WriteLine$2("sides are too close to parallel.\n");
                            break;
                        case 5: 
                            System.Diagnostics.Debug.WriteLine$2("polygon is too thin.\n");
                            break;
                        case 6: 
                            System.Diagnostics.Debug.WriteLine$2("core shape generation would move edge past centroid (too thin).\n");
                            break;
                        default: 
                            System.Diagnostics.Debug.WriteLine$2("don't know why.\n");
                            break;
                    }
                }
                return error !== -1;
            },
            /**
             * Trace the edge of a non-simple polygon and return a simple polygon.
             Method:
             Start at vertex with minimum y (pick maximum x one if there are two).
             We aim our "lastDir" vector at (1.0, 0)
             We look at the two rays going off from our start vertex, and follow whichever
             has the smallest angle (in -Pi . Pi) wrt lastDir ("rightest" turn)
             Loop until we hit starting vertex:
             We add our current vertex to the list.
             We check the seg from current vertex to next vertex for intersections
             - if no intersections, follow to next vertex and continue
             - if intersections, pick one with minimum distance
             - if more than one, pick one with "rightest" next point (two possibilities for each)
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {FarseerPhysics.Common.Vertices}    verts    The vertices.
             * @return  {FarseerPhysics.Common.Vertices}
             */
            TraceEdge: function (verts) {
                var $step = 0,
                    $jumpFromFinally, 
                    nodes, 
                    nNodes, 
                    i, 
                    pos, 
                    iplus, 
                    iminus, 
                    dirty, 
                    counter, 
                    i1, 
                    j, 
                    k, 
                    $t, 
                    l, 
                    $t1, 
                    $t2, 
                    $t3, 
                    intersectPt, 
                    crosses, 
                    $t4, 
                    $t5, 
                    connj, 
                    $t6, 
                    connl, 
                    $t7, 
                    $t8, 
                    $t9, 
                    foundDupe, 
                    nActive, 
                    i2, 
                    j1, 
                    diff, 
                    inode, 
                    jnode, 
                    njConn, 
                    k1, 
                    knode, 
                    minY, 
                    maxX, 
                    minYIndex, 
                    i3, 
                    origDir, 
                    resultVecs, 
                    nResultVecs, 
                    currentNode, 
                    startNode, 
                    nextNode, 
                    vertices, 
                    i4, 
                    oldNode, 
                    vertices1, 
                    i5, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,13,15,17,19,20,21,22], $step);
                            switch ($step) {
                                case 0: {
                                    nodes = System.Array.init(Bridge.Int.mul(verts.Count, verts.Count), null, FarseerPhysics.Common.Vertices.PolyNode);
                                    nNodes = 0;

                                    for (i = 0; i < verts.Count; i = (i + 1) | 0) {
                                        pos = new Microsoft.Xna.Framework.Vector2.$ctor2(verts.getItem(i).$clone().X, verts.getItem(i).$clone().Y);
                                        nodes[System.Array.index(i, nodes)].Position = pos.$clone();
                                        nNodes = (nNodes + 1) | 0;
                                        iplus = (i === ((verts.Count - 1) | 0)) ? 0 : ((i + 1) | 0);
                                        iminus = (i === 0) ? ((verts.Count - 1) | 0) : ((i - 1) | 0);
                                        nodes[System.Array.index(i, nodes)].AddConnection(nodes[System.Array.index(iplus, nodes)]);
                                        nodes[System.Array.index(i, nodes)].AddConnection(nodes[System.Array.index(iminus, nodes)]);
                                    }

                                    dirty = true;
                                    counter = 0;
                                    
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( dirty ) {
                                        $step = 2;
                                        continue;
                                    } 
                                    $step = 22;
                                    continue;
                                }
                                case 2: {
                                    dirty = false;
                                    i1 = 0;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( i1 < nNodes ) {
                                        $step = 4;
                                        continue;
                                    }
                                    $step = 20;
                                    continue;
                                }
                                case 4: {
                                    j = 0;
                                    $step = 5;
                                    continue;
                                }
                                case 5: {
                                    if ( j < nodes[System.Array.index(i1, nodes)].NConnected ) {
                                        $step = 6;
                                        continue;
                                    }
                                    $step = 18;
                                    continue;
                                }
                                case 6: {
                                    k = 0;
                                    $step = 7;
                                    continue;
                                }
                                case 7: {
                                    if ( k < nNodes ) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 16;
                                    continue;
                                }
                                case 8: {
                                    if (k === i1 || Bridge.referenceEquals(nodes[System.Array.index(k, nodes)], ($t = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t)])) {
                                        $step = 15;
                                        continue;
                                    }
                                    l = 0;
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    if ( l < nodes[System.Array.index(k, nodes)].NConnected ) {
                                        $step = 10;
                                        continue;
                                    }
                                    $step = 14;
                                    continue;
                                }
                                case 10: {
                                    if (Bridge.referenceEquals(($t1 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t1)], ($t2 = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t2)]) || Bridge.referenceEquals(($t3 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t3)], nodes[System.Array.index(i1, nodes)])) {
                                        $step = 13;
                                        continue;
                                    }

                                    intersectPt = { v : new Microsoft.Xna.Framework.Vector2() };

                                    crosses = FarseerPhysics.Common.LineTools.LineIntersect$1(nodes[System.Array.index(i1, nodes)].Position.$clone(), ($t4 = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t4)].Position.$clone(), nodes[System.Array.index(k, nodes)].Position.$clone(), ($t5 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t5)].Position.$clone(), intersectPt);
                                    if (crosses) {
                                        $step = 11;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 11: {
                                    dirty = true;
                                    connj = ($t6 = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t6)];
                                    connl = ($t7 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t7)];
                                    ($t8 = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t8)].RemoveConnection(nodes[System.Array.index(i1, nodes)]);
                                    nodes[System.Array.index(i1, nodes)].RemoveConnection(connj);
                                    ($t9 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t9)].RemoveConnection(nodes[System.Array.index(k, nodes)]);
                                    nodes[System.Array.index(k, nodes)].RemoveConnection(connl);
                                    nodes[System.Array.index(nNodes, nodes)] = new FarseerPhysics.Common.Vertices.PolyNode(intersectPt.v.$clone());
                                    nodes[System.Array.index(nNodes, nodes)].AddConnection(nodes[System.Array.index(i1, nodes)]);
                                    nodes[System.Array.index(i1, nodes)].AddConnection(nodes[System.Array.index(nNodes, nodes)]);
                                    nodes[System.Array.index(nNodes, nodes)].AddConnection(nodes[System.Array.index(k, nodes)]);
                                    nodes[System.Array.index(k, nodes)].AddConnection(nodes[System.Array.index(nNodes, nodes)]);
                                    nodes[System.Array.index(nNodes, nodes)].AddConnection(connj);
                                    connj.AddConnection(nodes[System.Array.index(nNodes, nodes)]);
                                    nodes[System.Array.index(nNodes, nodes)].AddConnection(connl);
                                    connl.AddConnection(nodes[System.Array.index(nNodes, nodes)]);
                                    nNodes = (nNodes + 1) | 0;
                                    $step = 21;
                                    continue;
                                }

                                case 13: {
                                    l = (l + 1) | 0;
                                    $step = 9;
                                    continue;
                                }

                                case 15: {
                                    k = (k + 1) | 0;
                                    $step = 7;
                                    continue;
                                }

                                case 17: {
                                    j = (j + 1) | 0;
                                    $step = 5;
                                    continue;
                                }

                                case 19: {
                                    i1 = (i1 + 1) | 0;
                                    $step = 3;
                                    continue;
                                }
                                case 20: {

                                }
                                case 21: {
                                    counter = (counter + 1) | 0;

                                    $step = 1;
                                    continue;
                                }
                                case 22: {
                                    foundDupe = true;
                                    nActive = nNodes;
                                    while (foundDupe) {
                                        foundDupe = false;
                                        for (i2 = 0; i2 < nNodes; i2 = (i2 + 1) | 0) {
                                            if (nodes[System.Array.index(i2, nodes)].NConnected === 0) {
                                                continue;
                                            }
                                            for (j1 = (i2 + 1) | 0; j1 < nNodes; j1 = (j1 + 1) | 0) {
                                                if (nodes[System.Array.index(j1, nodes)].NConnected === 0) {
                                                    continue;
                                                }
                                                diff = Microsoft.Xna.Framework.Vector2.op_Subtraction(nodes[System.Array.index(i2, nodes)].Position.$clone(), nodes[System.Array.index(j1, nodes)].Position.$clone());
                                                if (diff.LengthSquared() <= 1.42108547E-14) {
                                                    if (nActive <= 3) {
                                                        return new FarseerPhysics.Common.Vertices.ctor();
                                                    }

                                                    nActive = (nActive - 1) | 0;
                                                    foundDupe = true;
                                                    inode = nodes[System.Array.index(i2, nodes)];
                                                    jnode = nodes[System.Array.index(j1, nodes)];
                                                    njConn = jnode.NConnected;
                                                    for (k1 = 0; k1 < njConn; k1 = (k1 + 1) | 0) {
                                                        knode = jnode.Connected[System.Array.index(k1, jnode.Connected)];
                                                        System.Diagnostics.Debug.Assert(!Bridge.referenceEquals(knode, jnode));
                                                        if (!Bridge.referenceEquals(knode, inode)) {
                                                            inode.AddConnection(knode);
                                                            knode.AddConnection(inode);
                                                        }
                                                        knode.RemoveConnection(jnode);
                                                    }
                                                    jnode.NConnected = 0;
                                                }
                                            }
                                        }
                                    }


                                    minY = 3.40282347E+38;
                                    maxX = -3.40282347E+38;
                                    minYIndex = -1;
                                    for (i3 = 0; i3 < nNodes; i3 = (i3 + 1) | 0) {
                                        if (nodes[System.Array.index(i3, nodes)].Position.Y < minY && nodes[System.Array.index(i3, nodes)].NConnected > 1) {
                                            minY = nodes[System.Array.index(i3, nodes)].Position.Y;
                                            minYIndex = i3;
                                            maxX = nodes[System.Array.index(i3, nodes)].Position.X;
                                        } else if (nodes[System.Array.index(i3, nodes)].Position.Y === minY && nodes[System.Array.index(i3, nodes)].Position.X > maxX && nodes[System.Array.index(i3, nodes)].NConnected > 1) {
                                            minYIndex = i3;
                                            maxX = nodes[System.Array.index(i3, nodes)].Position.X;
                                        }
                                    }

                                    origDir = new Microsoft.Xna.Framework.Vector2.$ctor2(1.0, 0.0);
                                    resultVecs = System.Array.init(Bridge.Int.mul(4, nNodes), function (){
                                        return new Microsoft.Xna.Framework.Vector2();
                                    }, Microsoft.Xna.Framework.Vector2);
                                    nResultVecs = 0;
                                    currentNode = nodes[System.Array.index(minYIndex, nodes)];
                                    startNode = currentNode;
                                    System.Diagnostics.Debug.Assert(currentNode.NConnected > 0);
                                    nextNode = currentNode.GetRightestConnection$1(origDir.$clone());
                                    if (nextNode == null) {
                                        vertices = new FarseerPhysics.Common.Vertices.$ctor3(nResultVecs);

                                        for (i4 = 0; i4 < nResultVecs; i4 = (i4 + 1) | 0) {
                                            vertices.add(resultVecs[System.Array.index(i4, resultVecs)].$clone());
                                        }

                                        return vertices;
                                    }

                                    resultVecs[System.Array.index(0, resultVecs)] = startNode.Position.$clone();
                                    nResultVecs = (nResultVecs + 1) | 0;
                                    while (!Bridge.referenceEquals(nextNode, startNode)) {
                                        if (nResultVecs > Bridge.Int.mul(4, nNodes)) {
                                            System.Diagnostics.Debug.Assert(false);
                                        }
                                        resultVecs[System.Array.index(Bridge.identity(nResultVecs, (nResultVecs = (nResultVecs + 1) | 0)), resultVecs)] = nextNode.Position.$clone();
                                        oldNode = currentNode;
                                        currentNode = nextNode;
                                        nextNode = currentNode.GetRightestConnection(oldNode);
                                        if (nextNode == null) {
                                            vertices1 = new FarseerPhysics.Common.Vertices.$ctor3(nResultVecs);
                                            for (i5 = 0; i5 < nResultVecs; i5 = (i5 + 1) | 0) {
                                                vertices1.add(resultVecs[System.Array.index(i5, resultVecs)].$clone());
                                            }
                                            return vertices1;
                                        }
                                    }

                                    return new FarseerPhysics.Common.Vertices.ctor();
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            toString: function () {
                var builder = new System.Text.StringBuilder();
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    builder.append(this.getItem(i).$clone().toString());
                    if (i < ((this.Count - 1) | 0)) {
                        builder.append(" ");
                    }
                }
                return builder.toString();
            },
            /**
             * Projects to axis.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    axis    The axis.
             * @param   {System.Single}                      min     The min.
             * @param   {System.Single}                      max     The max.
             * @return  {void}
             */
            ProjectToAxis: function (axis, min, max) {
                var dotProduct = Microsoft.Xna.Framework.Vector2.Dot(axis.v.$clone(), this.getItem(0).$clone());
                min.v = dotProduct;
                max.v = dotProduct;

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    dotProduct = Microsoft.Xna.Framework.Vector2.Dot(this.getItem(i).$clone(), axis.v.$clone());
                    if (dotProduct < min.v) {
                        min.v = dotProduct;
                    } else {
                        if (dotProduct > max.v) {
                            max.v = dotProduct;
                        }
                    }
                }
            },
            /**
             * Winding number test for a point in a polygon.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    point    The point to be tested.
             * @return  {number}                                      -1 if the winding number is zero and the point is outside
             the polygon, 1 if the point is inside the polygon, and 0 if the point
             is on the polygons edge.
             */
            PointInPolygon: function (point) {
                var wn = 0;

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var p1 = { v : this.getItem(i).$clone() };
                    var p2 = { v : this.getItem(this.NextIndex(i)).$clone() };

                    var edge = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.v.$clone(), p1.v.$clone());
                    var area = FarseerPhysics.Common.MathUtils.Area$1(p1, p2, point);
                    if (area === 0.0 && Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), p1.v.$clone()), edge.$clone()) >= 0.0 && Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), p2.v.$clone()), edge.$clone()) <= 0.0) {
                        return 0;
                    }
                    if (p1.v.Y <= point.v.Y) {
                        if (p2.v.Y > point.v.Y && area > 0.0) {
                            wn = (wn + 1) | 0;
                        }
                    } else {
                        if (p2.v.Y <= point.v.Y && area < 0.0) {
                            wn = (wn - 1) | 0;
                        }
                    }
                }
                return (wn === 0 ? -1 : 1);
            },
            /**
             * Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
             If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
             ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    point
             * @return  {boolean}
             */
            PointInPolygonAngle: function (point) {
                var angle = 0;

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var p1 = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(i).$clone(), point.v.$clone()) };
                    var p2 = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(this.NextIndex(i)).$clone(), point.v.$clone()) };

                    angle += FarseerPhysics.Common.MathUtils.VectorAngle$1(p1, p2);
                }

                if (Math.abs(angle) < Math.PI) {
                    return false;
                }

                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.FixedArray2$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Common.FixedArray2$1(T))(); }
            }
        },
        fields: {
            _value0: Bridge.getDefaultValue(T),
            _value1: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._value0;
                    case 1: 
                        return this._value1;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._value0 = value;
                        break;
                    case 1: 
                        this._value1 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([3625788427, this._value0, this._value1]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.FixedArray2$1(T))) {
                    return false;
                }
                return Bridge.equals(this._value0, o._value0) && Bridge.equals(this._value1, o._value1);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Common.FixedArray2$1(T))();
                s._value0 = this._value0;
                s._value1 = this._value1;
                return s;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.FixedArray3$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Common.FixedArray3$1(T))(); }
            }
        },
        fields: {
            _value0: Bridge.getDefaultValue(T),
            _value1: Bridge.getDefaultValue(T),
            _value2: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._value0;
                    case 1: 
                        return this._value1;
                    case 2: 
                        return this._value2;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._value0 = value;
                        break;
                    case 1: 
                        this._value1 = value;
                        break;
                    case 2: 
                        this._value2 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([3625853963, this._value0, this._value1, this._value2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.FixedArray3$1(T))) {
                    return false;
                }
                return Bridge.equals(this._value0, o._value0) && Bridge.equals(this._value1, o._value1) && Bridge.equals(this._value2, o._value2);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Common.FixedArray3$1(T))();
                s._value0 = this._value0;
                s._value1 = this._value1;
                s._value2 = this._value2;
                return s;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.FixedArray4$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Common.FixedArray4$1(T))(); }
            }
        },
        fields: {
            _value0: Bridge.getDefaultValue(T),
            _value1: Bridge.getDefaultValue(T),
            _value2: Bridge.getDefaultValue(T),
            _value3: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._value0;
                    case 1: 
                        return this._value1;
                    case 2: 
                        return this._value2;
                    case 3: 
                        return this._value3;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._value0 = value;
                        break;
                    case 1: 
                        this._value1 = value;
                        break;
                    case 2: 
                        this._value2 = value;
                        break;
                    case 3: 
                        this._value3 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([3625919499, this._value0, this._value1, this._value2, this._value3]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.FixedArray4$1(T))) {
                    return false;
                }
                return Bridge.equals(this._value0, o._value0) && Bridge.equals(this._value1, o._value1) && Bridge.equals(this._value2, o._value2) && Bridge.equals(this._value3, o._value3);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Common.FixedArray4$1(T))();
                s._value0 = this._value0;
                s._value1 = this._value1;
                s._value2 = this._value2;
                s._value3 = this._value3;
                return s;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.FixedArray8$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Common.FixedArray8$1(T))(); }
            }
        },
        fields: {
            _value0: Bridge.getDefaultValue(T),
            _value1: Bridge.getDefaultValue(T),
            _value2: Bridge.getDefaultValue(T),
            _value3: Bridge.getDefaultValue(T),
            _value4: Bridge.getDefaultValue(T),
            _value5: Bridge.getDefaultValue(T),
            _value6: Bridge.getDefaultValue(T),
            _value7: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._value0;
                    case 1: 
                        return this._value1;
                    case 2: 
                        return this._value2;
                    case 3: 
                        return this._value3;
                    case 4: 
                        return this._value4;
                    case 5: 
                        return this._value5;
                    case 6: 
                        return this._value6;
                    case 7: 
                        return this._value7;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._value0 = value;
                        break;
                    case 1: 
                        this._value1 = value;
                        break;
                    case 2: 
                        this._value2 = value;
                        break;
                    case 3: 
                        this._value3 = value;
                        break;
                    case 4: 
                        this._value4 = value;
                        break;
                    case 5: 
                        this._value5 = value;
                        break;
                    case 6: 
                        this._value6 = value;
                        break;
                    case 7: 
                        this._value7 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([3626181643, this._value0, this._value1, this._value2, this._value3, this._value4, this._value5, this._value6, this._value7]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.FixedArray8$1(T))) {
                    return false;
                }
                return Bridge.equals(this._value0, o._value0) && Bridge.equals(this._value1, o._value1) && Bridge.equals(this._value2, o._value2) && Bridge.equals(this._value3, o._value3) && Bridge.equals(this._value4, o._value4) && Bridge.equals(this._value5, o._value5) && Bridge.equals(this._value6, o._value6) && Bridge.equals(this._value7, o._value7);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Common.FixedArray8$1(T))();
                s._value0 = this._value0;
                s._value1 = this._value1;
                s._value2 = this._value2;
                s._value3 = this._value3;
                s._value4 = this._value4;
                s._value5 = this._value5;
                s._value6 = this._value6;
                s._value7 = this._value7;
                return s;
            }
        }
    }; });

    /** @namespace FarseerPhysics.Common */

    /**
     * Collection of helper methods for misc collisions.
     Does float tolerance and line collisions with lines and AABBs.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.LineTools
     */
    Bridge.define("FarseerPhysics.Common.LineTools", {
        statics: {
            methods: {
                DistanceBetweenPointAndPoint: function (point1, point2) {
                    var v = { v : new Microsoft.Xna.Framework.Vector2() };
                    Microsoft.Xna.Framework.Vector2.Subtract$1(point1, point2, v);
                    return v.v.Length();
                },
                DistanceBetweenPointAndLineSegment: function (point, lineEndPoint1, lineEndPoint2) {
                    var v = Microsoft.Xna.Framework.Vector2.Subtract(lineEndPoint2.v.$clone(), lineEndPoint1.v.$clone());
                    var w = Microsoft.Xna.Framework.Vector2.Subtract(point.v.$clone(), lineEndPoint1.v.$clone());

                    var c1 = Microsoft.Xna.Framework.Vector2.Dot(w.$clone(), v.$clone());
                    if (c1 <= 0) {
                        return FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(point, lineEndPoint1);
                    }

                    var c2 = Microsoft.Xna.Framework.Vector2.Dot(v.$clone(), v.$clone());
                    if (c2 <= c1) {
                        return FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(point, lineEndPoint2);
                    }

                    var b = c1 / c2;
                    var pointOnLine = { v : Microsoft.Xna.Framework.Vector2.Add(lineEndPoint1.v.$clone(), Microsoft.Xna.Framework.Vector2.Multiply$1(v.$clone(), b)) };
                    return FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(point, pointOnLine);
                },
                /**
                 * Check if the lines a0-&gt;a1 and b0-&gt;b1 cross.
                If they do, intersectionPoint will be filled
                with the point of crossing.
                Grazing lines should not return true.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    a0                   
                 * @param   {Microsoft.Xna.Framework.Vector2}    a1                   
                 * @param   {Microsoft.Xna.Framework.Vector2}    b0                   
                 * @param   {Microsoft.Xna.Framework.Vector2}    b1                   
                 * @param   {Microsoft.Xna.Framework.Vector2}    intersectionPoint
                 * @return  {boolean}
                 */
                LineIntersect2: function (a0, a1, b0, b1, intersectionPoint) {
                    intersectionPoint.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                    if (Microsoft.Xna.Framework.Vector2.op_Equality(a0.$clone(), b0.$clone()) || Microsoft.Xna.Framework.Vector2.op_Equality(a0.$clone(), b1.$clone()) || Microsoft.Xna.Framework.Vector2.op_Equality(a1.$clone(), b0.$clone()) || Microsoft.Xna.Framework.Vector2.op_Equality(a1.$clone(), b1.$clone())) {
                        return false;
                    }

                    var x1 = a0.X;
                    var y1 = a0.Y;
                    var x2 = a1.X;
                    var y2 = a1.Y;
                    var x3 = b0.X;
                    var y3 = b0.Y;
                    var x4 = b1.X;
                    var y4 = b1.Y;

                    if (Math.max(x1, x2) < Math.min(x3, x4) || Math.max(x3, x4) < Math.min(x1, x2)) {
                        return false;
                    }

                    if (Math.max(y1, y2) < Math.min(y3, y4) || Math.max(y3, y4) < Math.min(y1, y2)) {
                        return false;
                    }

                    var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3));
                    var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3));
                    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                    if (Math.abs(denom) < FarseerPhysics.Settings.Epsilon) {
                        return false;
                    }
                    ua /= denom;
                    ub /= denom;

                    if ((0 < ua) && (ua < 1) && (0 < ub) && (ub < 1)) {
                        intersectionPoint.v.X = (x1 + ua * (x2 - x1));
                        intersectionPoint.v.Y = (y1 + ua * (y2 - y1));
                        return true;
                    }

                    return false;
                },
                LineIntersect: function (p1, p2, q1, q2) {
                    var i = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    var a1 = p2.Y - p1.Y;
                    var b1 = p1.X - p2.X;
                    var c1 = a1 * p1.X + b1 * p1.Y;
                    var a2 = q2.Y - q1.Y;
                    var b2 = q1.X - q2.X;
                    var c2 = a2 * q1.X + b2 * q1.Y;
                    var det = a1 * b2 - a2 * b1;

                    if (!FarseerPhysics.Common.MathUtils.FloatEquals(det, 0)) {
                        i.X = (b2 * c1 - b1 * c2) / det;
                        i.Y = (a1 * c2 - a2 * c1) / det;
                    }
                    return i.$clone();
                },
                /**
                 * This method detects if two line segments (or lines) intersect,
                 and, if so, the point of intersection. Use the <b /> and
                 <b /> parameters to set whether the intersection point
                 must be on the first and second line segments. Setting these
                 both to true means you are doing a line-segment to line-segment
                 intersection. Setting one of them to true means you are doing a
                 line to line-segment intersection test, and so on.
                 Note: If two line segments are coincident, then 
                 no intersection is detected (there are actually
                 infinite intersection points).
                 Author: Jeremy Bell
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    point1             The first point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point2             The second point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point3             The first point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point4             The second point of the second line segment.
                 * @param   {boolean}                            firstIsSegment     Set this to true to require that the 
                 intersection point be on the first line segment.
                 * @param   {boolean}                            secondIsSegment    Set this to true to require that the
                 intersection point be on the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point              This is set to the intersection
                 point if an intersection is detected.
                 * @return  {boolean}                                               True if an intersection is detected, false otherwise.
                 */
                LineIntersect$4: function (point1, point2, point3, point4, firstIsSegment, secondIsSegment, point) {
                    point.v = new Microsoft.Xna.Framework.Vector2.ctor();

                    var a = point4.v.Y - point3.v.Y;
                    var b = point2.v.X - point1.v.X;
                    var c = point4.v.X - point3.v.X;
                    var d = point2.v.Y - point1.v.Y;

                    var denom = (a * b) - (c * d);

                    if (!(denom >= -1.1920929E-07 && denom <= FarseerPhysics.Settings.Epsilon)) {
                        var e = point1.v.Y - point3.v.Y;
                        var f = point1.v.X - point3.v.X;
                        var oneOverDenom = 1.0 / denom;

                        var ua = (c * e) - (a * f);
                        ua *= oneOverDenom;

                        if (!firstIsSegment || ua >= 0.0 && ua <= 1.0) {
                            var ub = (b * e) - (d * f);
                            ub *= oneOverDenom;

                            if (!secondIsSegment || ub >= 0.0 && ub <= 1.0) {
                                if (ua !== 0.0 || ub !== 0.0) {
                                    point.v.X = point1.v.X + ua * b;
                                    point.v.Y = point1.v.Y + ua * d;
                                    return true;
                                }
                            }
                        }
                    }

                    return false;
                },
                /**
                 * This method detects if two line segments (or lines) intersect,
                 and, if so, the point of intersection. Use the <b /> and
                 <b /> parameters to set whether the intersection point
                 must be on the first and second line segments. Setting these
                 both to true means you are doing a line-segment to line-segment
                 intersection. Setting one of them to true means you are doing a
                 line to line-segment intersection test, and so on.
                 Note: If two line segments are coincident, then 
                 no intersection is detected (there are actually
                 infinite intersection points).
                 Author: Jeremy Bell
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    point1               The first point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point2               The second point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point3               The first point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point4               The second point of the second line segment.
                 * @param   {boolean}                            firstIsSegment       Set this to true to require that the 
                 intersection point be on the first line segment.
                 * @param   {boolean}                            secondIsSegment      Set this to true to require that the
                 intersection point be on the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    intersectionPoint    This is set to the intersection
                 point if an intersection is detected.
                 * @return  {boolean}                                                 True if an intersection is detected, false otherwise.
                 */
                LineIntersect$2: function (point1, point2, point3, point4, firstIsSegment, secondIsSegment, intersectionPoint) {
                    point1 = {v:point1};
                    point2 = {v:point2};
                    point3 = {v:point3};
                    point4 = {v:point4};
                    return FarseerPhysics.Common.LineTools.LineIntersect$4(point1, point2, point3, point4, firstIsSegment, secondIsSegment, intersectionPoint);
                },
                /**
                 * This method detects if two line segments intersect,
                 and, if so, the point of intersection. 
                 Note: If two line segments are coincident, then 
                 no intersection is detected (there are actually
                 infinite intersection points).
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    point1               The first point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point2               The second point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point3               The first point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point4               The second point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    intersectionPoint    This is set to the intersection
                 point if an intersection is detected.
                 * @return  {boolean}                                                 True if an intersection is detected, false otherwise.
                 */
                LineIntersect$3: function (point1, point2, point3, point4, intersectionPoint) {
                    return FarseerPhysics.Common.LineTools.LineIntersect$4(point1, point2, point3, point4, true, true, intersectionPoint);
                },
                /**
                 * This method detects if two line segments intersect,
                 and, if so, the point of intersection. 
                 Note: If two line segments are coincident, then 
                 no intersection is detected (there are actually
                 infinite intersection points).
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    point1               The first point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point2               The second point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point3               The first point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point4               The second point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    intersectionPoint    This is set to the intersection
                 point if an intersection is detected.
                 * @return  {boolean}                                                 True if an intersection is detected, false otherwise.
                 */
                LineIntersect$1: function (point1, point2, point3, point4, intersectionPoint) {
                    point1 = {v:point1};
                    point2 = {v:point2};
                    point3 = {v:point3};
                    point4 = {v:point4};
                    return FarseerPhysics.Common.LineTools.LineIntersect$4(point1, point2, point3, point4, true, true, intersectionPoint);
                },
                /**
                 * Get all intersections between a line segment and a list of vertices
                 representing a polygon. The vertices reuse adjacent points, so for example
                 edges one and two are between the first and second vertices and between the
                 second and third vertices. The last edge is between vertex vertices.Count - 1
                 and verts0. (ie, vertices from a Geometry or AABB)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}      point1                The first point of the line segment to test
                 * @param   {Microsoft.Xna.Framework.Vector2}      point2                The second point of the line segment to test.
                 * @param   {FarseerPhysics.Common.Vertices}       vertices              The vertices, as described above
                 * @param   {System.Collections.Generic.List$1}    intersectionPoints    An list of intersection points. Any intersection points
                 found will be added to this list.
                 * @return  {void}
                 */
                LineSegmentVerticesIntersect: function (point1, point2, vertices, intersectionPoints) {
                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var point = { v : new Microsoft.Xna.Framework.Vector2() };
                        if (FarseerPhysics.Common.LineTools.LineIntersect$2(vertices.getItem(i).$clone(), vertices.getItem(vertices.NextIndex(i)).$clone(), point1.v.$clone(), point2.v.$clone(), true, true, point)) {
                            intersectionPoints.v.add(point.v.$clone());
                        }
                    }
                },
                /**
                 * Get all intersections between a line segment and an AABB.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}      point1                The first point of the line segment to test
                 * @param   {Microsoft.Xna.Framework.Vector2}      point2                The second point of the line segment to test.
                 * @param   {FarseerPhysics.Collision.AABB}        aabb                  The AABB that is used for testing intersection.
                 * @param   {System.Collections.Generic.List$1}    intersectionPoints    An list of intersection points. Any intersection points found will be added to this list.
                 * @return  {void}
                 */
                LineSegmentAABBIntersect: function (point1, point2, aabb, intersectionPoints) {
                    FarseerPhysics.Common.LineTools.LineSegmentVerticesIntersect(point1, point2, aabb.Vertices, intersectionPoints);
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.MarchingSquares", {
        statics: {
            fields: {
                _lookMarch: null
            },
            ctors: {
                init: function () {
                    this._lookMarch = System.Array.init([
                        0, 
                        224, 
                        56, 
                        216, 
                        14, 
                        238, 
                        54, 
                        214, 
                        131, 
                        99, 
                        187, 
                        91, 
                        141, 
                        109, 
                        181, 
                        85
                    ], System.Int32);
                }
            },
            methods: {
                /**
                 * Marching squares over the given domain using the mesh defined via the dimensions
                    (wid,hei) to build a set of polygons such that f(x,y) less than 0, using the given number
                    'bin' for recursive linear inteprolation along cell boundaries.
                    if 'comb' is true, then the polygons will also be composited into larger possible concave
                    polygons.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MarchingSquares
                 * @memberof FarseerPhysics.Common.MarchingSquares
                 * @param   {FarseerPhysics.Collision.AABB}        domain        
                 * @param   {number}                               cellWidth     
                 * @param   {number}                               cellHeight    
                 * @param   {Array.<number>}                       f             
                 * @param   {number}                               lerpCount     
                 * @param   {boolean}                              combine
                 * @return  {System.Collections.Generic.List$1}
                 */
                DetectSquares: function (domain, cellWidth, cellHeight, f, lerpCount, combine) {
                    var $t, $t1;
                    var ret = new (FarseerPhysics.Common.MarchingSquares.CxFastList$1(FarseerPhysics.Common.MarchingSquares.GeomPoly))();

                    var verticesList = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    var polyList;
                    var gp = { };

                    var xn = Bridge.Int.clip32(domain.Extents.X * 2 / cellWidth);
                    var xp = xn === (domain.Extents.X * 2 / cellWidth);
                    var yn = Bridge.Int.clip32(domain.Extents.Y * 2 / cellHeight);
                    var yp = yn === (domain.Extents.Y * 2 / cellHeight);
                    if (!xp) {
                        xn = (xn + 1) | 0;
                    }
                    if (!yp) {
                        yn = (yn + 1) | 0;
                    }

                    var fs = System.Array.create(0, null, System.SByte, ((xn + 1) | 0), ((yn + 1) | 0));
                    var ps = System.Array.create(null, null, FarseerPhysics.Common.MarchingSquares.GeomPolyVal, ((xn + 1) | 0), ((yn + 1) | 0));

                    for (var x = 0; x < ((xn + 1) | 0); x = (x + 1) | 0) {
                        var x0;
                        if (x === xn) {
                            x0 = Bridge.Int.clip32(domain.UpperBound.X);
                        } else {
                            x0 = Bridge.Int.clip32(x * cellWidth + domain.LowerBound.X);
                        }
                        for (var y = 0; y < ((yn + 1) | 0); y = (y + 1) | 0) {
                            var y0;
                            if (y === yn) {
                                y0 = Bridge.Int.clip32(domain.UpperBound.Y);
                            } else {
                                y0 = Bridge.Int.clip32(y * cellHeight + domain.LowerBound.Y);
                            }
                            fs.set([x, y], f.get([x0, y0]));
                        }
                    }

                    for (var y1 = 0; y1 < yn; y1 = (y1 + 1) | 0) {
                        var y01 = y1 * cellHeight + domain.LowerBound.Y;
                        var y11;
                        if (y1 === ((yn - 1) | 0)) {
                            y11 = domain.UpperBound.Y;
                        } else {
                            y11 = y01 + cellHeight;
                        }
                        var pre = { v : null };
                        for (var x1 = 0; x1 < xn; x1 = (x1 + 1) | 0) {
                            var x01 = x1 * cellWidth + domain.LowerBound.X;
                            var x11;
                            if (x1 === ((xn - 1) | 0)) {
                                x11 = domain.UpperBound.X;
                            } else {
                                x11 = x01 + cellWidth;
                            }

                            gp.v = new FarseerPhysics.Common.MarchingSquares.GeomPoly();

                            var key = FarseerPhysics.Common.MarchingSquares.MarchSquare(f, fs, gp, x1, y1, x01, y01, x11, y11, lerpCount);
                            if (gp.v.Length !== 0) {
                                if (combine && pre.v != null && (key & 9) !== 0) {
                                    FarseerPhysics.Common.MarchingSquares.combLeft(pre, gp);
                                    gp.v = pre.v;
                                } else {
                                    ret.Add(gp.v);
                                }
                                ps.set([x1, y1], new FarseerPhysics.Common.MarchingSquares.GeomPolyVal(gp.v, key));
                            } else {
                                gp.v = null;
                            }
                            pre.v = gp.v;
                        }
                    }
                    if (!combine) {
                        polyList = ret.GetListOfElements();

                        $t = Bridge.getEnumerator(polyList);
                        try {
                            while ($t.moveNext()) {
                                var poly = $t.Current;
                                verticesList.add(new FarseerPhysics.Common.Vertices.$ctor2(poly.Points.GetListOfElements()));
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        return verticesList;
                    }

                    for (var y2 = 1; y2 < yn; y2 = (y2 + 1) | 0) {
                        var x2 = 0;
                        while (x2 < xn) {
                            var p = ps.get([x2, y2]);

                            if (p == null) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            if ((p.Key & 12) === 0) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var u = ps.get([x2, ((y2 - 1) | 0)]);
                            if (u == null) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            if ((u.Key & 3) === 0) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var ax = x2 * cellWidth + domain.LowerBound.X;
                            var ay = y2 * cellHeight + domain.LowerBound.Y;

                            var bp = p.GeomP.Points;
                            var ap = u.GeomP.Points;

                            if (Bridge.referenceEquals(u.GeomP, p.GeomP)) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var bi = bp.Begin();
                            while (FarseerPhysics.Common.MarchingSquares.Square(bi.Elem().Y - ay) > FarseerPhysics.Settings.Epsilon || bi.Elem().X < ax) {
                                bi = bi.Next();
                            }

                            var b1 = bi.Next().Elem().$clone();
                            if (FarseerPhysics.Common.MarchingSquares.Square(b1.Y - ay) > FarseerPhysics.Settings.Epsilon) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var brk = true;
                            var ai = ap.Begin();
                            while (!Bridge.referenceEquals(ai, ap.End())) {
                                if (FarseerPhysics.Common.MarchingSquares.VecDsq(ai.Elem().$clone(), b1.$clone()) < FarseerPhysics.Settings.Epsilon) {
                                    brk = false;
                                    break;
                                }
                                ai = ai.Next();
                            }
                            if (brk) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var bj = bi.Next().Next();
                            if (Bridge.referenceEquals(bj, bp.End())) {
                                bj = bp.Begin();
                            }
                            while (!Bridge.referenceEquals(bj, bi)) {
                                ai = ap.Insert(ai, bj.Elem().$clone());
                                bj = bj.Next();
                                if (Bridge.referenceEquals(bj, bp.End())) {
                                    bj = bp.Begin();
                                }
                                u.GeomP.Length = (u.GeomP.Length + 1) | 0;
                            }
                            ax = (x2 + 1) | 0;
                            while (ax < xn) {
                                var p2 = ps.get([Bridge.Int.clip32(ax), y2]);
                                if (p2 == null || !Bridge.referenceEquals(p2.GeomP, p.GeomP)) {
                                    ax++;
                                    continue;
                                }
                                p2.GeomP = u.GeomP;
                                ax++;
                            }
                            ax = (x2 - 1) | 0;
                            while (ax >= 0) {
                                var p21 = ps.get([Bridge.Int.clip32(ax), y2]);
                                if (p21 == null || !Bridge.referenceEquals(p21.GeomP, p.GeomP)) {
                                    ax--;
                                    continue;
                                }
                                p21.GeomP = u.GeomP;
                                ax--;
                            }
                            ret.Remove(p.GeomP);
                            p.GeomP = u.GeomP;

                            x2 = (Bridge.Int.clip32(((bi.Next().Elem().X - domain.LowerBound.X) / cellWidth)) + 1) | 0;
                        }
                    }

                    polyList = ret.GetListOfElements();

                    $t1 = Bridge.getEnumerator(polyList);
                    try {
                        while ($t1.moveNext()) {
                            var poly1 = $t1.Current;
                            verticesList.add(new FarseerPhysics.Common.Vertices.$ctor2(poly1.Points.GetListOfElements()));
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return verticesList;
                },
                Lerp: function (x0, x1, v0, v1) {
                    var dv = v0 - v1;
                    var t;
                    if (dv * dv < FarseerPhysics.Settings.Epsilon) {
                        t = 0.5;
                    } else {
                        t = v0 / dv;
                    }
                    return x0 + t * (x1 - x0);
                },
                Xlerp: function (x0, x1, y, v0, v1, f, c) {
                    var xm = FarseerPhysics.Common.MarchingSquares.Lerp(x0, x1, v0, v1);
                    if (c === 0) {
                        return xm;
                    }

                    var vm = f.get([Bridge.Int.clip32(xm), Bridge.Int.clip32(y)]);

                    if (v0 * vm < 0) {
                        return FarseerPhysics.Common.MarchingSquares.Xlerp(x0, xm, y, v0, vm, f, ((c - 1) | 0));
                    }

                    return FarseerPhysics.Common.MarchingSquares.Xlerp(xm, x1, y, vm, v1, f, ((c - 1) | 0));
                },
                Ylerp: function (y0, y1, x, v0, v1, f, c) {
                    var ym = FarseerPhysics.Common.MarchingSquares.Lerp(y0, y1, v0, v1);
                    if (c === 0) {
                        return ym;
                    }

                    var vm = f.get([Bridge.Int.clip32(x), Bridge.Int.clip32(ym)]);

                    if (v0 * vm < 0) {
                        return FarseerPhysics.Common.MarchingSquares.Ylerp(y0, ym, x, v0, vm, f, ((c - 1) | 0));
                    }

                    return FarseerPhysics.Common.MarchingSquares.Ylerp(ym, y1, x, vm, v1, f, ((c - 1) | 0));
                },
                Square: function (x) {
                    return x * x;
                },
                VecDsq: function (a, b) {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(a.$clone(), b.$clone());
                    return d.X * d.X + d.Y * d.Y;
                },
                VecCross: function (a, b) {
                    return a.X * b.Y - a.Y * b.X;
                },
                MarchSquare: function (f, fs, poly, ax, ay, x0, y0, x1, y1, bin) {
                    var key = 0;
                    var v0 = fs.get([ax, ay]);
                    if (v0 < 0) {
                        key = key | 8;
                    }
                    var v1 = fs.get([((ax + 1) | 0), ay]);
                    if (v1 < 0) {
                        key = key | 4;
                    }
                    var v2 = fs.get([((ax + 1) | 0), ((ay + 1) | 0)]);
                    if (v2 < 0) {
                        key = key | 2;
                    }
                    var v3 = fs.get([ax, ((ay + 1) | 0)]);
                    if (v3 < 0) {
                        key = key | 1;
                    }

                    var val = FarseerPhysics.Common.MarchingSquares._lookMarch[System.Array.index(key, FarseerPhysics.Common.MarchingSquares._lookMarch)];
                    if (val !== 0) {
                        var pi = null;
                        for (var i = 0; i < 8; i = (i + 1) | 0) {
                            var p = new Microsoft.Xna.Framework.Vector2();
                            if ((val & (1 << i)) !== 0) {
                                if (i === 7 && (val & 1) === 0) {
                                    poly.v.Points.Add((p = new Microsoft.Xna.Framework.Vector2.$ctor2(x0, FarseerPhysics.Common.MarchingSquares.Ylerp(y0, y1, x0, v0, v3, f, bin))).$clone());
                                } else {
                                    if (i === 0) {
                                        p = new Microsoft.Xna.Framework.Vector2.$ctor2(x0, y0);
                                    } else {
                                        if (i === 2) {
                                            p = new Microsoft.Xna.Framework.Vector2.$ctor2(x1, y0);
                                        } else {
                                            if (i === 4) {
                                                p = new Microsoft.Xna.Framework.Vector2.$ctor2(x1, y1);
                                            } else {
                                                if (i === 6) {
                                                    p = new Microsoft.Xna.Framework.Vector2.$ctor2(x0, y1);
                                                } else {
                                                    if (i === 1) {
                                                        p = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Common.MarchingSquares.Xlerp(x0, x1, y0, v0, v1, f, bin), y0);
                                                    } else {
                                                        if (i === 5) {
                                                            p = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Common.MarchingSquares.Xlerp(x0, x1, y1, v3, v2, f, bin), y1);
                                                        } else {
                                                            if (i === 3) {
                                                                p = new Microsoft.Xna.Framework.Vector2.$ctor2(x1, FarseerPhysics.Common.MarchingSquares.Ylerp(y0, y1, x1, v1, v2, f, bin));
                                                            } else {
                                                                p = new Microsoft.Xna.Framework.Vector2.$ctor2(x0, FarseerPhysics.Common.MarchingSquares.Ylerp(y0, y1, x0, v0, v3, f, bin));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    pi = poly.v.Points.Insert(pi, p.$clone());
                                }
                                poly.v.Length = (poly.v.Length + 1) | 0;
                            }
                        }
                    }
                    return key;
                },
                combLeft: function (polya, polyb) {
                    var ap = polya.v.Points;
                    var bp = polyb.v.Points;
                    var ai = ap.Begin();
                    var bi = bp.Begin();

                    var b = bi.Elem().$clone();
                    var prea = null;
                    while (!Bridge.referenceEquals(ai, ap.End())) {
                        var a = ai.Elem().$clone();
                        if (FarseerPhysics.Common.MarchingSquares.VecDsq(a.$clone(), b.$clone()) < FarseerPhysics.Settings.Epsilon) {
                            if (prea != null) {
                                var a0 = prea.Elem().$clone();
                                b = bi.Next().Elem().$clone();

                                var u = Microsoft.Xna.Framework.Vector2.op_Subtraction(a.$clone(), a0.$clone());
                                var v = Microsoft.Xna.Framework.Vector2.op_Subtraction(b.$clone(), a.$clone());
                                var dot = FarseerPhysics.Common.MarchingSquares.VecCross(u.$clone(), v.$clone());
                                if (dot * dot < FarseerPhysics.Settings.Epsilon) {
                                    ap.Erase(prea, ai);
                                    polya.v.Length = (polya.v.Length - 1) | 0;
                                    ai = prea;
                                }
                            }

                            var fst = true;
                            var preb = null;
                            while (!bp.Empty()) {
                                var bb = bp.Front().$clone();
                                bp.Pop();
                                if (!fst && !bp.Empty()) {
                                    ai = ap.Insert(ai, bb.$clone());
                                    polya.v.Length = (polya.v.Length + 1) | 0;
                                    preb = ai;
                                }
                                fst = false;
                            }

                            ai = ai.Next();
                            var a1 = ai.Elem().$clone();
                            ai = ai.Next();
                            if (Bridge.referenceEquals(ai, ap.End())) {
                                ai = ap.Begin();
                            }
                            var a2 = ai.Elem().$clone();
                            var a00 = preb.Elem().$clone();
                            var uu = Microsoft.Xna.Framework.Vector2.op_Subtraction(a1.$clone(), a00.$clone());
                            var vv = Microsoft.Xna.Framework.Vector2.op_Subtraction(a2.$clone(), a1.$clone());
                            var dot1 = FarseerPhysics.Common.MarchingSquares.VecCross(uu.$clone(), vv.$clone());
                            if (dot1 * dot1 < FarseerPhysics.Settings.Epsilon) {
                                ap.Erase(preb, preb.Next());
                                polya.v.Length = (polya.v.Length - 1) | 0;
                            }

                            return;
                        }
                        prea = ai;
                        ai = ai.Next();
                    }
                }
            }
        }
    });

    /**
     * Designed as a complete port of CxFastList from CxStd.
     *
     * @class FarseerPhysics.Common.MarchingSquares.CxFastList$1
     */
    Bridge.define("FarseerPhysics.Common.MarchingSquares.CxFastList$1", function (T) { return {
        $kind: "nested class",
        fields: {
            _head: null,
            _count: 0
        },
        methods: {
            /**
             * Iterator to start of list (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Begin: function () {
                return this._head;
            },
            /**
             * Iterator to end of list (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            End: function () {
                return null;
            },
            /**
             * Returns first element of list (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {T}
             */
            Front: function () {
                return this._head.Elem();
            },
            /**
             * add object to list (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {T}                                                         value
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Add: function (value) {
                var newNode = new (FarseerPhysics.Common.MarchingSquares.CxFastListNode$1(T))(value);
                if (this._head == null) {
                    newNode._next = null;
                    this._head = newNode;
                    this._count = (this._count + 1) | 0;
                    return newNode;
                }
                newNode._next = this._head;
                this._head = newNode;

                this._count = (this._count + 1) | 0;

                return newNode;
            },
            /**
             * remove object from list, returns true if an element was removed (O(n))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {T}          value
             * @return  {boolean}
             */
            Remove: function (value) {
                var head = this._head;
                var prev = this._head;

                var comparer = System.Collections.Generic.EqualityComparer$1(T).def;

                if (head != null) {
                    if (value != null) {
                        do {
                            if (comparer.equals2(head._elt, value)) {
                                if (Bridge.referenceEquals(head, this._head)) {
                                    this._head = head._next;
                                    this._count = (this._count - 1) | 0;
                                    return true;
                                } else {
                                    prev._next = head._next;
                                    this._count = (this._count - 1) | 0;
                                    return true;
                                }
                            }
                            prev = head;
                            head = head._next;
                        } while (head != null);
                    }
                }
                return false;
            },
            /**
             * pop element from head of list (O(1)) Note: this does not return the object popped! 
             There is good reason to this, and it regards the Alloc list variants which guarantee 
             objects are released to the object pool. You do not want to retrieve an element 
             through pop or else that object may suddenly be used by another piece of code which 
             retrieves it from the object pool.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Pop: function () {
                return this.Erase(null, this._head);
            },
            /**
             * insert object after 'node' returning an iterator to the inserted object.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}    node     
             * @param   {T}                                                         value
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Insert: function (node, value) {
                if (node == null) {
                    return this.Add(value);
                }
                var newNode = new (FarseerPhysics.Common.MarchingSquares.CxFastListNode$1(T))(value);
                var nextNode = node._next;
                newNode._next = nextNode;
                node._next = newNode;

                this._count = (this._count + 1) | 0;

                return newNode;
            },
            /**
             * removes the element pointed to by 'node' with 'prev' being the previous iterator, 
             returning an iterator to the element following that of 'node' (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}    prev    
             * @param   {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}    node
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Erase: function (prev, node) {
                var nextNode = node._next;
                if (prev != null) {
                    prev._next = nextNode;
                } else {
                    if (this._head != null) {
                        this._head = this._head._next;
                    } else {
                        return null;
                    }
                }

                this._count = (this._count - 1) | 0;
                return nextNode;
            },
            /**
             * whether the list is empty (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {boolean}
             */
            Empty: function () {
                if (this._head == null) {
                    return true;
                }
                return false;
            },
            /**
             * computes size of list (O(n))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {number}
             */
            Size: function () {
                var i = this.Begin();
                var count = 0;

                do {
                    count = (count + 1) | 0;
                } while (i.Next() != null);

                return count;
            },
            /**
             * empty the list (O(1) if CxMixList, O(n) otherwise)
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {void}
             */
            Clear: function () {
                var head = this._head;
                while (head != null) {
                    var node2 = head;
                    head = head._next;
                    node2._next = null;
                }
                this._head = null;
                this._count = 0;
            },
            /**
             * returns true if 'value' is an element of the list (O(n))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {T}          value
             * @return  {boolean}
             */
            Has: function (value) {
                return (this.Find(value) != null);
            },
            Find: function (value) {
                var head = this._head;
                var comparer = System.Collections.Generic.EqualityComparer$1(T).def;
                if (head != null) {
                    if (value != null) {
                        do {
                            if (comparer.equals2(head._elt, value)) {
                                return head;
                            }
                            head = head._next;
                        } while (!Bridge.referenceEquals(head, this._head));
                    } else {
                        do {
                            if (head._elt == null) {
                                return head;
                            }
                            head = head._next;
                        } while (!Bridge.referenceEquals(head, this._head));
                    }
                }
                return null;
            },
            GetListOfElements: function () {
                var list = new (System.Collections.Generic.List$1(T)).ctor();

                var iter = this.Begin();

                if (iter != null) {
                    do {
                        list.add(iter._elt);
                        iter = iter._next;
                    } while (iter != null);
                }
                return list;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.MarchingSquares.CxFastListNode$1", function (T) { return {
        $kind: "nested class",
        fields: {
            _elt: Bridge.getDefaultValue(T),
            _next: null
        },
        ctors: {
            ctor: function (obj) {
                this.$initialize();
                this._elt = obj;
            }
        },
        methods: {
            Elem: function () {
                return this._elt;
            },
            Next: function () {
                return this._next;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.MarchingSquares.GeomPoly", {
        $kind: "nested class",
        fields: {
            Length: 0,
            Points: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Points = new (FarseerPhysics.Common.MarchingSquares.CxFastList$1(Microsoft.Xna.Framework.Vector2))();
                this.Length = 0;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.MarchingSquares.GeomPolyVal", {
        $kind: "nested class",
        fields: {
            Key: 0,
            GeomP: null
        },
        ctors: {
            ctor: function (geomP, K) {
                this.$initialize();
                this.GeomP = geomP;
                this.Key = K;
            }
        }
    });

    /**
     * A 2-by-2 matrix. Stored in column-major order.
     *
     * @public
     * @class FarseerPhysics.Common.Mat22
     */
    Bridge.define("FarseerPhysics.Common.Mat22", {
        $kind: "struct",
        statics: {
            methods: {
                Add: function (A, B, R) {
                    R.v.Col1 = Microsoft.Xna.Framework.Vector2.op_Addition(A.v.Col1.$clone(), B.v.Col1.$clone());
                    R.v.Col2 = Microsoft.Xna.Framework.Vector2.op_Addition(A.v.Col2.$clone(), B.v.Col2.$clone());
                },
                getDefaultValue: function () { return new FarseerPhysics.Common.Mat22(); }
            }
        },
        fields: {
            Col1: null,
            Col2: null
        },
        props: {
            /**
             * Extract the angle from this matrix (assumed to be
             a rotation matrix).
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Common.Mat22
             * @function Angle
             * @type number
             */
            Angle: {
                get: function () {
                    return Math.atan2(this.Col1.Y, this.Col1.X);
                }
            },
            Inverse: {
                get: function () {
                    var a = this.Col1.X, b = this.Col2.X, c = this.Col1.Y, d = this.Col2.Y;
                    var det = a * d - b * c;
                    if (det !== 0.0) {
                        det = 1.0 / det;
                    }

                    var result = new FarseerPhysics.Common.Mat22.ctor();
                    result.Col1.X = det * d;
                    result.Col1.Y = -det * c;

                    result.Col2.X = -det * b;
                    result.Col2.Y = det * a;

                    return result.$clone();
                }
            }
        },
        ctors: {
            init: function () {
                this.Col1 = new Microsoft.Xna.Framework.Vector2();
                this.Col2 = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * Construct this matrix using columns.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {Microsoft.Xna.Framework.Vector2}    c1    The c1.
             * @param   {Microsoft.Xna.Framework.Vector2}    c2    The c2.
             * @return  {void}
             */
            $ctor1: function (c1, c2) {
                this.$initialize();
                this.Col1 = c1.$clone();
                this.Col2 = c2.$clone();
            },
            /**
             * Construct this matrix using scalars.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {number}    a11    The a11.
             * @param   {number}    a12    The a12.
             * @param   {number}    a21    The a21.
             * @param   {number}    a22    The a22.
             * @return  {void}
             */
            $ctor3: function (a11, a12, a21, a22) {
                this.$initialize();
                this.Col1 = new Microsoft.Xna.Framework.Vector2.$ctor2(a11, a21);
                this.Col2 = new Microsoft.Xna.Framework.Vector2.$ctor2(a12, a22);
            },
            /**
             * Construct this matrix using an angle. This matrix becomes
             an orthonormal rotation matrix.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {number}    angle    The angle.
             * @return  {void}
             */
            $ctor2: function (angle) {
                this.$initialize();
                var c = Math.cos(angle), s = Math.sin(angle);
                this.Col1 = new Microsoft.Xna.Framework.Vector2.$ctor2(c, s);
                this.Col2 = new Microsoft.Xna.Framework.Vector2.$ctor2(-s, c);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Initialize this matrix using columns.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {Microsoft.Xna.Framework.Vector2}    c1    The c1.
             * @param   {Microsoft.Xna.Framework.Vector2}    c2    The c2.
             * @return  {void}
             */
            Set: function (c1, c2) {
                this.Col1 = c1.$clone();
                this.Col2 = c2.$clone();
            },
            /**
             * Initialize this matrix using an angle. This matrix becomes
             an orthonormal rotation matrix.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {number}    angle    The angle.
             * @return  {void}
             */
            Set$1: function (angle) {
                var c = Math.cos(angle), s = Math.sin(angle);
                this.Col1.X = c;
                this.Col2.X = -s;
                this.Col1.Y = s;
                this.Col2.Y = c;
            },
            /**
             * Set this to the identity matrix.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @return  {void}
             */
            SetIdentity: function () {
                this.Col1.X = 1.0;
                this.Col2.X = 0.0;
                this.Col1.Y = 0.0;
                this.Col2.Y = 1.0;
            },
            /**
             * Set this matrix to all zeros.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @return  {void}
             */
            SetZero: function () {
                this.Col1.X = 0.0;
                this.Col2.X = 0.0;
                this.Col1.Y = 0.0;
                this.Col2.Y = 0.0;
            },
            /**
             * Solve A * x = b, where b is a column vector. This is more efficient
             than computing the inverse in one-shot cases.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {Microsoft.Xna.Framework.Vector2}    b    The b.
             * @return  {Microsoft.Xna.Framework.Vector2}
             */
            Solve: function (b) {
                var a11 = this.Col1.X, a12 = this.Col2.X, a21 = this.Col1.Y, a22 = this.Col2.Y;
                var det = a11 * a22 - a12 * a21;
                if (det !== 0.0) {
                    det = 1.0 / det;
                }

                return new Microsoft.Xna.Framework.Vector2.$ctor2(det * (a22 * b.X - a12 * b.Y), det * (a11 * b.Y - a21 * b.X));
            },
            getHashCode: function () {
                var h = Bridge.addHash([846487935, this.Col1, this.Col2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.Mat22)) {
                    return false;
                }
                return Bridge.equals(this.Col1, o.Col1) && Bridge.equals(this.Col2, o.Col2);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.Mat22();
                s.Col1 = this.Col1.$clone();
                s.Col2 = this.Col2.$clone();
                return s;
            }
        }
    });

    /**
     * A 3-by-3 matrix. Stored in column-major order.
     *
     * @public
     * @class FarseerPhysics.Common.Mat33
     */
    Bridge.define("FarseerPhysics.Common.Mat33", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.Mat33(); }
            }
        },
        fields: {
            Col1: null,
            Col2: null,
            Col3: null
        },
        ctors: {
            init: function () {
                this.Col1 = new Microsoft.Xna.Framework.Vector3();
                this.Col2 = new Microsoft.Xna.Framework.Vector3();
                this.Col3 = new Microsoft.Xna.Framework.Vector3();
            },
            /**
             * Construct this matrix using columns.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat33
             * @memberof FarseerPhysics.Common.Mat33
             * @param   {Microsoft.Xna.Framework.Vector3}    c1    The c1.
             * @param   {Microsoft.Xna.Framework.Vector3}    c2    The c2.
             * @param   {Microsoft.Xna.Framework.Vector3}    c3    The c3.
             * @return  {void}
             */
            $ctor1: function (c1, c2, c3) {
                this.$initialize();
                this.Col1 = c1.$clone();
                this.Col2 = c2.$clone();
                this.Col3 = c3.$clone();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Set this matrix to all zeros.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat33
             * @memberof FarseerPhysics.Common.Mat33
             * @return  {void}
             */
            SetZero: function () {
                this.Col1 = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                this.Col2 = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                this.Col3 = Microsoft.Xna.Framework.Vector3.Zero.$clone();
            },
            /**
             * Solve A * x = b, where b is a column vector. This is more efficient
             than computing the inverse in one-shot cases.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat33
             * @memberof FarseerPhysics.Common.Mat33
             * @param   {Microsoft.Xna.Framework.Vector3}    b    The b.
             * @return  {Microsoft.Xna.Framework.Vector3}
             */
            Solve33: function (b) {
                var det = Microsoft.Xna.Framework.Vector3.Dot(this.Col1.$clone(), Microsoft.Xna.Framework.Vector3.Cross(this.Col2.$clone(), this.Col3.$clone()));
                if (det !== 0.0) {
                    det = 1.0 / det;
                }

                return new Microsoft.Xna.Framework.Vector3.$ctor3(det * Microsoft.Xna.Framework.Vector3.Dot(b.$clone(), Microsoft.Xna.Framework.Vector3.Cross(this.Col2.$clone(), this.Col3.$clone())), det * Microsoft.Xna.Framework.Vector3.Dot(this.Col1.$clone(), Microsoft.Xna.Framework.Vector3.Cross(b.$clone(), this.Col3.$clone())), det * Microsoft.Xna.Framework.Vector3.Dot(this.Col1.$clone(), Microsoft.Xna.Framework.Vector3.Cross(this.Col2.$clone(), b.$clone())));
            },
            /**
             * Solve A * x = b, where b is a column vector. This is more efficient
             than computing the inverse in one-shot cases. Solve only the upper
             2-by-2 matrix equation.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat33
             * @memberof FarseerPhysics.Common.Mat33
             * @param   {Microsoft.Xna.Framework.Vector2}    b    The b.
             * @return  {Microsoft.Xna.Framework.Vector2}
             */
            Solve22: function (b) {
                var a11 = this.Col1.X, a12 = this.Col2.X, a21 = this.Col1.Y, a22 = this.Col2.Y;
                var det = a11 * a22 - a12 * a21;

                if (det !== 0.0) {
                    det = 1.0 / det;
                }

                return new Microsoft.Xna.Framework.Vector2.$ctor2(det * (a22 * b.X - a12 * b.Y), det * (a11 * b.Y - a21 * b.X));
            },
            getHashCode: function () {
                var h = Bridge.addHash([863265152, this.Col1, this.Col2, this.Col3]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.Mat33)) {
                    return false;
                }
                return Bridge.equals(this.Col1, o.Col1) && Bridge.equals(this.Col2, o.Col2) && Bridge.equals(this.Col3, o.Col3);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.Mat33();
                s.Col1 = this.Col1.$clone();
                s.Col2 = this.Col2.$clone();
                s.Col3 = this.Col3.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.MathUtils", {
        statics: {
            methods: {
                IsClose: function (v1, v2, tolerence) {
                    return (Microsoft.Xna.Framework.Vector2.Distance(v1.$clone(), v2.$clone()) < tolerence);
                },
                IsEqual: function (v1, v2) {
                    return (v1.X === v2.X && v1.Y === v2.Y);
                },
                CloneVector: function (vector) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(vector.X, vector.Y);
                },
                VectorAngle$2: function (vector) {
                    return Math.atan2(vector.Y, vector.X);
                },
                /**
                 * Return the angle between two vectors on a plane
                 The angle is from vector 1 to vector 2, positive anticlockwise
                 The result is between -pi -&gt; pi
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {Microsoft.Xna.Framework.Vector2}    p1    
                 * @param   {Microsoft.Xna.Framework.Vector2}    p2
                 * @return  {number}
                 */
                VectorAngle$1: function (p1, p2) {
                    var theta1 = Math.atan2(p1.v.Y, p1.v.X);
                    var theta2 = Math.atan2(p2.v.Y, p2.v.X);
                    var dtheta = theta2 - theta1;
                    while (dtheta > Math.PI) {
                        dtheta -= (6.2831853071795862);
                    }
                    while (dtheta < -3.1415926535897931) {
                        dtheta += (6.2831853071795862);
                    }

                    return (dtheta);
                },
                VectorAngle: function (p1, p2) {
                    p1 = {v:p1};
                    p2 = {v:p2};
                    return FarseerPhysics.Common.MathUtils.VectorAngle$1(p1, p2);
                },
                /**
                 * Initialize a Vector using polar coordinate
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}                             radius    
                 * @param   {number}                             angle
                 * @return  {Microsoft.Xna.Framework.Vector2}
                 */
                VectorPolar: function (radius, angle) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(radius * Math.cos(angle), radius * Math.sin(angle));
                },
                Cross$2: function (a, b) {
                    return a.X * b.Y - a.Y * b.X;
                },
                Cross: function (a, s) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(s * a.Y, -s * a.X);
                },
                Cross$1: function (s, a) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(-s * a.Y, s * a.X);
                },
                Cross$3: function (a, b, c) {
                    c.v = a.v.X * b.v.Y - a.v.Y * b.v.X;
                },
                Cross$4: function (s, a, b) {
                    b.v = new Microsoft.Xna.Framework.Vector2.$ctor2(-s * a.v.Y, s * a.v.X);
                },
                Abs: function (v) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(Math.abs(v.X), Math.abs(v.Y));
                },
                Multiply: function (A, v) {
                    v = {v:v};
                    return FarseerPhysics.Common.MathUtils.Multiply$1(A, v);
                },
                Multiply$1: function (A, v) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(A.v.Col1.X * v.v.X + A.v.Col2.X * v.v.Y, A.v.Col1.Y * v.v.X + A.v.Col2.Y * v.v.Y);
                },
                Multiply$2: function (T, v) {
                    v = {v:v};
                    return FarseerPhysics.Common.MathUtils.Multiply$3(T, v);
                },
                Multiply$3: function (T, v) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(T.v.Position.X + T.v.R.Col1.X * v.v.X + T.v.R.Col2.X * v.v.Y, T.v.Position.Y + T.v.R.Col1.Y * v.v.X + T.v.R.Col2.Y * v.v.Y);
                },
                MultiplyT: function (A, v) {
                    v = {v:v};
                    return FarseerPhysics.Common.MathUtils.MultiplyT$1(A, v);
                },
                MultiplyT$1: function (A, v) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(v.v.X * A.v.Col1.X + v.v.Y * A.v.Col1.Y, v.v.X * A.v.Col2.X + v.v.Y * A.v.Col2.Y);
                },
                MultiplyT$2: function (T, v) {
                    v = {v:v};
                    return FarseerPhysics.Common.MathUtils.MultiplyT$3(T, v);
                },
                MultiplyT$3: function (T, v) {
                    var tmp = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };
                    tmp.v.X = v.v.X - T.v.Position.X;
                    tmp.v.Y = v.v.Y - T.v.Position.Y;
                    return FarseerPhysics.Common.MathUtils.MultiplyT$1(Bridge.ref(T.v, "R"), tmp);
                },
                MultiplyT$4: function (A, B, C) {
                    C.v = new FarseerPhysics.Common.Mat22.ctor();
                    C.v.Col1.X = A.v.Col1.X * B.v.Col1.X + A.v.Col1.Y * B.v.Col1.Y;
                    C.v.Col1.Y = A.v.Col2.X * B.v.Col1.X + A.v.Col2.Y * B.v.Col1.Y;
                    C.v.Col2.X = A.v.Col1.X * B.v.Col2.X + A.v.Col1.Y * B.v.Col2.Y;
                    C.v.Col2.Y = A.v.Col2.X * B.v.Col2.X + A.v.Col2.Y * B.v.Col2.Y;
                },
                MultiplyT$5: function (A, B, C) {
                    C.v = new FarseerPhysics.Common.Transform.ctor();
                    FarseerPhysics.Common.MathUtils.MultiplyT$4(Bridge.ref(A.v, "R"), Bridge.ref(B.v, "R"), Bridge.ref(C.v, "R"));
                    C.v.Position.X = B.v.Position.X - A.v.Position.X;
                    C.v.Position.Y = B.v.Position.Y - A.v.Position.Y;
                },
                Swap: function (T, a, b) {
                    var tmp = a.v;
                    a.v = b.v;
                    b.v = tmp;
                },
                /**
                 * This function is used to ensure that a floating point number is
                 not a NaN or infinity.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}     x    The x.
                 * @return  {boolean}         <pre><code>true</code></pre> if the specified x is valid; otherwise, <pre><code>false</code></pre>.
                 */
                IsValid$1: function (x) {
                    if (isNaN(x)) {
                        return false;
                    }

                    return !(Math.abs(x) === Number.POSITIVE_INFINITY);
                },
                IsValid: function (x) {
                    return FarseerPhysics.Common.MathUtils.IsValid$1(x.X) && FarseerPhysics.Common.MathUtils.IsValid$1(x.Y);
                },
                /**
                 * This is a approximate yet fast inverse square-root.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}    x    The x.
                 * @return  {number}
                 */
                InvSqrt: function (x) {
                    var convert = new FarseerPhysics.Common.MathUtils.FloatConverter();
                    convert.x = x;
                    var xhalf = 0.5 * x;
                    convert.i = (1597463007 - (convert.i >> 1)) | 0;
                    x = convert.x;
                    x = x * (1.5 - xhalf * x * x);
                    return x;
                },
                Clamp$1: function (a, low, high) {
                    return Math.max(low, Math.min(a, high));
                },
                Clamp$2: function (a, low, high) {
                    return Math.max(low, Math.min(a, high));
                },
                Clamp: function (a, low, high) {
                    return Microsoft.Xna.Framework.Vector2.Max(low.$clone(), Microsoft.Xna.Framework.Vector2.Min(a.$clone(), high.$clone()));
                },
                /**
                 * Returns a positive number if c is to the left of the line going from a to b.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    
                 * @param   {Microsoft.Xna.Framework.Vector2}    c
                 * @return  {number}                                  Positive number if point is left, negative if point is right, 
                 and 0 if points are collinear.
                 */
                Area: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c);
                },
                /**
                 * Returns a positive number if c is to the left of the line going from a to b.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    
                 * @param   {Microsoft.Xna.Framework.Vector2}    c
                 * @return  {number}                                  Positive number if point is left, negative if point is right, 
                 and 0 if points are collinear.
                 */
                Area$1: function (a, b, c) {
                    return a.v.X * (b.v.Y - c.v.Y) + b.v.X * (c.v.Y - a.v.Y) + c.v.X * (a.v.Y - b.v.Y);
                },
                /**
                 * Determines if three vertices are collinear (ie. on a straight line)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    First vertex
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    Second vertex
                 * @param   {Microsoft.Xna.Framework.Vector2}    c    Third vertex
                 * @return  {boolean}
                 */
                Collinear: function (a, b, c) {
                    return FarseerPhysics.Common.MathUtils.Collinear$1(a, b, c, 0);
                },
                Collinear$1: function (a, b, c, tolerance) {
                    return FarseerPhysics.Common.MathUtils.FloatInRange(FarseerPhysics.Common.MathUtils.Area$1(a, b, c), -tolerance, tolerance);
                },
                FloatEquals: function (value1, value2) {
                    return Math.abs(value1 - value2) <= FarseerPhysics.Settings.Epsilon;
                },
                /**
                 * Checks if a floating point Value is equal to another,
                 within a certain tolerance.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}     value1    The first floating point Value.
                 * @param   {number}     value2    The second floating point Value.
                 * @param   {number}     delta     The floating point tolerance.
                 * @return  {boolean}              True if the values are "equal", false otherwise.
                 */
                FloatEquals$1: function (value1, value2, delta) {
                    return FarseerPhysics.Common.MathUtils.FloatInRange(value1, value2 - delta, value2 + delta);
                },
                /**
                 * Checks if a floating point Value is within a specified
                 range of values (inclusive).
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}     value    The Value to check.
                 * @param   {number}     min      The minimum Value.
                 * @param   {number}     max      The maximum Value.
                 * @return  {boolean}             True if the Value is within the range specified,
                 false otherwise.
                 */
                FloatInRange: function (value, min, max) {
                    return (value >= min && value <= max);
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.MathUtils.FloatConverter", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.MathUtils.FloatConverter(); }
            }
        },
        fields: {
            x: 0,
            i: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5441161109, this.x, this.i]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.MathUtils.FloatConverter)) {
                    return false;
                }
                return Bridge.equals(this.x, o.x) && Bridge.equals(this.i, o.i);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.MathUtils.FloatConverter();
                s.x = this.x;
                s.i = this.i;
                return s;
            }
        }
    });

    /**
     * @memberof FarseerPhysics.Common
     * @callback FarseerPhysics.Common.TerrainTester
     * @param   {Microsoft.Xna.Framework.Color}    Color
     * @return  {boolean}
     */

    /**
     * Simple class to maintain a terrain.
     *
     * @public
     * @class FarseerPhysics.Common.MSTerrain
     */
    Bridge.define("FarseerPhysics.Common.MSTerrain", {
        statics: {
            methods: {
                /**
                 * Convert a texture to an sbtye array compatible with ApplyData().
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MSTerrain
                 * @memberof FarseerPhysics.Common.MSTerrain
                 * @param   {Microsoft.Xna.Framework.Graphics.Texture2D}    texture    Texture to convert.
                 * @param   {FarseerPhysics.Common.TerrainTester}           tester
                 * @return  {Array.<number>}
                 */
                ConvertTextureToData: function (texture, tester) {
                    var data = System.Array.create(0, null, System.SByte, texture.Width, texture.Height);
                    var colorData = System.Array.init(Bridge.Int.mul(texture.Width, texture.Height), function (){
                        return new Microsoft.Xna.Framework.Color();
                    }, Microsoft.Xna.Framework.Color);

                    texture.GetData(Bridge.global.Microsoft.Xna.Framework.Color, colorData);

                    for (var y = 0; y < texture.Height; y = (y + 1) | 0) {
                        for (var x = 0; x < texture.Width; x = (x + 1) | 0) {
                            var inside = tester(colorData[System.Array.index((((Bridge.Int.mul(y, texture.Width)) + x) | 0), colorData)].$clone());

                            if (!inside) {
                                data.set([x, y], 1);
                            } else {
                                data.set([x, y], -1);
                            }
                        }
                    }

                    return data;
                }
            }
        },
        fields: {
            /**
             * World to manage terrain in.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type FarseerPhysics.Dynamics.World
             */
            World: null,
            /**
             * Center of terrain in world units.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type Microsoft.Xna.Framework.Vector2
             */
            Center: null,
            /**
             * Width of terrain in world units.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            Width: 0,
            /**
             * Height of terrain in world units.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            Height: 0,
            /**
             * Points per each world unit used to define the terrain in the point cloud.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            PointsPerUnit: 0,
            /**
             * Points per cell.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            CellSize: 0,
            /**
             * Points per sub cell.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            SubCellSize: 0,
            /**
             * Number of iterations to perform in the Marching Squares algorithm.
             Note: More then 3 has almost no effect on quality.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @default 2
             * @type number
             */
            Iterations: 0,
            /**
             * Decomposer to use when regenerating terrain. Can be changed on the fly without consequence.
             Note: Some decomposerers are unstable.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type FarseerPhysics.Common.Decomposer
             */
            Decomposer: 0,
            /**
             * Point cloud defining the terrain.
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type Array.<number>
             */
            _terrainMap: null,
            /**
             * Generated bodies.
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type Array.<System.Collections.Generic.List$1>
             */
            _bodyMap: null,
            _localWidth: 0,
            _localHeight: 0,
            _xnum: 0,
            _ynum: 0,
            _dirtyArea: null,
            _topLeft: null
        },
        ctors: {
            init: function () {
                this.Center = new Microsoft.Xna.Framework.Vector2();
                this._dirtyArea = new FarseerPhysics.Collision.AABB();
                this._topLeft = new Microsoft.Xna.Framework.Vector2();
                this.Iterations = 2;
            },
            ctor: function (world, area) {
                this.$initialize();
                this.World = world;
                this.Width = area.Extents.X * 2;
                this.Height = area.Extents.Y * 2;
                this.Center = area.Center.$clone();
            }
        },
        methods: {
            /**
             * Initialize the terrain for use.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @return  {void}
             */
            Initialize: function () {
                this._topLeft = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X - (this.Width * 0.5), this.Center.Y - (-this.Height * 0.5));

                this._localWidth = this.Width * this.PointsPerUnit;
                this._localHeight = this.Height * this.PointsPerUnit;

                this._terrainMap = System.Array.create(0, null, System.SByte, ((Bridge.Int.clip32(this._localWidth) + 1) | 0), ((Bridge.Int.clip32(this._localHeight) + 1) | 0));

                for (var x = 0; x < this._localWidth; x = (x + 1) | 0) {
                    for (var y = 0; y < this._localHeight; y = (y + 1) | 0) {
                        this._terrainMap.set([x, y], 1);
                    }
                }

                this._xnum = Bridge.Int.clip32(this._localWidth / this.CellSize);
                this._ynum = Bridge.Int.clip32(this._localHeight / this.CellSize);
                this._bodyMap = System.Array.create(null, null, System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body), this._xnum, this._ynum);

                this._dirtyArea = new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(3.40282347E+38, 3.40282347E+38), new Microsoft.Xna.Framework.Vector2.$ctor2(-3.40282347E+38, -3.40282347E+38));
            },
            /**
             * Apply a texture to the terrain using the specified TerrainTester.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @param   {Microsoft.Xna.Framework.Graphics.Texture2D}    texture     Texture to apply.
             * @param   {Microsoft.Xna.Framework.Vector2}               position    Top left position of the texture relative to the terrain.
             * @param   {FarseerPhysics.Common.TerrainTester}           tester      Delegate method used to determine what colors should be included in the terrain.
             * @return  {void}
             */
            ApplyTexture: function (texture, position, tester) {
                var colorData = System.Array.init(Bridge.Int.mul(texture.Width, texture.Height), function (){
                    return new Microsoft.Xna.Framework.Color();
                }, Microsoft.Xna.Framework.Color);

                texture.GetData(Bridge.global.Microsoft.Xna.Framework.Color, colorData);

                for (var y = Bridge.Int.clip32(position.Y); y < ((texture.Height + Bridge.Int.clip32(position.Y)) | 0); y = (y + 1) | 0) {
                    for (var x = Bridge.Int.clip32(position.X); x < ((texture.Width + Bridge.Int.clip32(position.X)) | 0); x = (x + 1) | 0) {
                        if (x >= 0 && x < this._localWidth && y >= 0 && y < this._localHeight) {
                            var inside = tester(colorData[System.Array.index((((Bridge.Int.mul((((y - Bridge.Int.clip32(position.Y)) | 0)), texture.Width)) + (((x - Bridge.Int.clip32(position.X)) | 0))) | 0), colorData)].$clone());

                            if (!inside) {
                                this._terrainMap.set([x, y], 1);
                            } else {
                                this._terrainMap.set([x, y], -1);
                            }
                        }
                    }
                }

                for (var gy = 0; gy < this._ynum; gy = (gy + 1) | 0) {
                    for (var gx = 0; gx < this._xnum; gx = (gx + 1) | 0) {
                        if (this._bodyMap.get([gx, gy]) != null) {
                            for (var i = 0; i < this._bodyMap.get([gx, gy]).Count; i = (i + 1) | 0) {
                                this.World.RemoveBody(this._bodyMap.get([gx, gy]).getItem(i));
                            }
                        }

                        this._bodyMap.set([gx, gy], null);

                        this.GenerateTerrain(gx, gy);
                    }
                }
            },
            /**
             * Apply a texture to the terrain using the specified TerrainTester.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @param   {Array.<number>}                     data        
             * @param   {Microsoft.Xna.Framework.Vector2}    position    Top left position of the texture relative to the terrain.
             * @return  {void}
             */
            ApplyData: function (data, position) {
                for (var y = Bridge.Int.clip32(position.Y); y < (((System.Array.getLength(data, 1) - 1) + Bridge.Int.clip32(position.Y)) | 0); y = (y + 1) | 0) {
                    for (var x = Bridge.Int.clip32(position.X); x < (((System.Array.getLength(data, 0) - 1) + Bridge.Int.clip32(position.X)) | 0); x = (x + 1) | 0) {
                        if (x >= 0 && x < this._localWidth && y >= 0 && y < this._localHeight) {
                            this._terrainMap.set([x, y], data.get([x, y]));
                        }
                    }
                }

                for (var gy = 0; gy < this._ynum; gy = (gy + 1) | 0) {
                    for (var gx = 0; gx < this._xnum; gx = (gx + 1) | 0) {
                        if (this._bodyMap.get([gx, gy]) != null) {
                            for (var i = 0; i < this._bodyMap.get([gx, gy]).Count; i = (i + 1) | 0) {
                                this.World.RemoveBody(this._bodyMap.get([gx, gy]).getItem(i));
                            }
                        }

                        this._bodyMap.set([gx, gy], null);

                        this.GenerateTerrain(gx, gy);
                    }
                }
            },
            /**
             * Modify a single point in the terrain.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @param   {Microsoft.Xna.Framework.Vector2}    location    World location to modify. Automatically clipped.
             * @param   {number}                             value       -1 = inside terrain, 1 = outside terrain
             * @return  {void}
             */
            ModifyTerrain: function (location, value) {
                var p = Microsoft.Xna.Framework.Vector2.op_Subtraction(location.$clone(), this._topLeft.$clone());

                p.X = p.X * this._localWidth / this.Width;
                p.Y = p.Y * -this._localHeight / this.Height;

                if (p.X >= 0 && p.X < this._localWidth && p.Y >= 0 && p.Y < this._localHeight) {
                    this._terrainMap.set([Bridge.Int.clip32(p.X), Bridge.Int.clip32(p.Y)], value);

                    if (p.X < this._dirtyArea.LowerBound.X) {
                        this._dirtyArea.LowerBound.X = p.X;
                    }
                    if (p.X > this._dirtyArea.UpperBound.X) {
                        this._dirtyArea.UpperBound.X = p.X;
                    }

                    if (p.Y < this._dirtyArea.LowerBound.Y) {
                        this._dirtyArea.LowerBound.Y = p.Y;
                    }
                    if (p.Y > this._dirtyArea.UpperBound.Y) {
                        this._dirtyArea.UpperBound.Y = p.Y;
                    }
                }
            },
            /**
             * Regenerate the terrain.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @return  {void}
             */
            RegenerateTerrain: function () {
                var gx0 = Bridge.Int.clip32(this._dirtyArea.LowerBound.X / this.CellSize);
                var gx1 = (Bridge.Int.clip32((this._dirtyArea.UpperBound.X / this.CellSize)) + 1) | 0;
                if (gx0 < 0) {
                    gx0 = 0;
                }
                if (gx1 > this._xnum) {
                    gx1 = this._xnum;
                }
                var gy0 = Bridge.Int.clip32(this._dirtyArea.LowerBound.Y / this.CellSize);
                var gy1 = (Bridge.Int.clip32((this._dirtyArea.UpperBound.Y / this.CellSize)) + 1) | 0;
                if (gy0 < 0) {
                    gy0 = 0;
                }
                if (gy1 > this._ynum) {
                    gy1 = this._ynum;
                }

                for (var gx = gx0; gx < gx1; gx = (gx + 1) | 0) {
                    for (var gy = gy0; gy < gy1; gy = (gy + 1) | 0) {
                        if (this._bodyMap.get([gx, gy]) != null) {
                            for (var i = 0; i < this._bodyMap.get([gx, gy]).Count; i = (i + 1) | 0) {
                                this.World.RemoveBody(this._bodyMap.get([gx, gy]).getItem(i));
                            }
                        }

                        this._bodyMap.set([gx, gy], null);

                        this.GenerateTerrain(gx, gy);
                    }
                }

                this._dirtyArea = new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(3.40282347E+38, 3.40282347E+38), new Microsoft.Xna.Framework.Vector2.$ctor2(-3.40282347E+38, -3.40282347E+38));
            },
            GenerateTerrain: function (gx, gy) {
                var $t, $t1;
                var ax = Bridge.Int.mul(gx, this.CellSize);
                var ay = Bridge.Int.mul(gy, this.CellSize);

                var polys = FarseerPhysics.Common.MarchingSquares.DetectSquares(new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(ax, ay), new Microsoft.Xna.Framework.Vector2.$ctor2(ax + this.CellSize, ay + this.CellSize)), this.SubCellSize, this.SubCellSize, this._terrainMap, this.Iterations, true);
                if (polys.Count === 0) {
                    return;
                }

                this._bodyMap.set([gx, gy], new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body)).ctor());

                var scale = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(1.0 / this.PointsPerUnit, 1.0 / ((-this.PointsPerUnit) | 0)) };

                $t = Bridge.getEnumerator(polys);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        item.Scale(scale);
                        item.Translate$1(Bridge.ref(this, "_topLeft"));
                        item.ForceCounterClockWise();
                        var p = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(item);
                        var decompPolys = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                        switch (this.Decomposer) {
                            case FarseerPhysics.Common.Decomposer.Bayazit: 
                                decompPolys = FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(p);
                                break;
                            case FarseerPhysics.Common.Decomposer.CDT: 
                                decompPolys = FarseerPhysics.Common.Decomposition.CDTDecomposer.ConvexPartition$1(p);
                                break;
                            case FarseerPhysics.Common.Decomposer.Earclip: 
                                decompPolys = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(p);
                                break;
                            case FarseerPhysics.Common.Decomposer.Flipcode: 
                                decompPolys = FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.ConvexPartition(p);
                                break;
                            case FarseerPhysics.Common.Decomposer.Seidel: 
                                decompPolys = FarseerPhysics.Common.Decomposition.SeidelDecomposer.ConvexPartition(p, 0.001);
                                break;
                            default: 
                                break;
                        }

                        $t1 = Bridge.getEnumerator(decompPolys);
                        try {
                            while ($t1.moveNext()) {
                                var poly = $t1.Current;
                                if (poly.Count > 2) {
                                    this._bodyMap.get([gx, gy]).add(FarseerPhysics.Factories.BodyFactory.CreatePolygon(this.World, poly, 1));
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        }
    });

    /** @namespace FarseerPhysics.Dynamics */

    /**
     * Contains filter data that can determine whether an object should be processed or not.
     *
     * @abstract
     * @public
     * @class FarseerPhysics.Dynamics.FilterData
     */
    Bridge.define("FarseerPhysics.Dynamics.FilterData", {
        fields: {
            DisabledOnCategories: 0,
            DisabledOnGroup: 0,
            EnabledOnCategories: 0,
            EnabledOnGroup: 0
        },
        ctors: {
            init: function () {
                this.DisabledOnCategories = FarseerPhysics.Dynamics.Category.None;
                this.EnabledOnCategories = FarseerPhysics.Dynamics.Category.All;
            }
        },
        methods: {
            IsActiveOn: function (body) {
                var $t;
                if (body == null || !body.Enabled || body.IsStatic) {
                    return false;
                }

                if (body.FixtureList == null) {
                    return false;
                }

                $t = Bridge.getEnumerator(body.FixtureList);
                try {
                    while ($t.moveNext()) {
                        var fixture = $t.Current;
                        if ((fixture.CollisionGroup === this.DisabledOnGroup) && fixture.CollisionGroup !== 0 && this.DisabledOnGroup !== 0) {
                            return false;
                        }

                        if ((fixture.CollisionCategories & this.DisabledOnCategories) !== FarseerPhysics.Dynamics.Category.None) {
                            return false;
                        }

                        if (this.EnabledOnGroup !== 0 || this.EnabledOnCategories !== FarseerPhysics.Dynamics.Category.All) {
                            if ((fixture.CollisionGroup === this.EnabledOnGroup) && fixture.CollisionGroup !== 0 && this.EnabledOnGroup !== 0) {
                                return true;
                            }

                            if ((fixture.CollisionCategories & this.EnabledOnCategories) !== FarseerPhysics.Dynamics.Category.None && this.EnabledOnCategories !== FarseerPhysics.Dynamics.Category.All) {
                                return true;
                            }
                        } else {
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return false;
            },
            /**
             * Adds the category.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {void}
             */
            AddDisabledCategory: function (category) {
                this.DisabledOnCategories |= category;
            },
            /**
             * Removes the category.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {void}
             */
            RemoveDisabledCategory: function (category) {
                this.DisabledOnCategories &= ~category;
            },
            /**
             * Determines whether this body ignores the the specified controller.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {boolean}                                         <pre><code>true</code></pre> if the object has the specified category; otherwise, <pre><code>false</code></pre>.
             */
            IsInDisabledCategory: function (category) {
                return (this.DisabledOnCategories & category) === category;
            },
            /**
             * Adds the category.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {void}
             */
            AddEnabledCategory: function (category) {
                this.EnabledOnCategories |= category;
            },
            /**
             * Removes the category.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {void}
             */
            RemoveEnabledCategory: function (category) {
                this.EnabledOnCategories &= ~category;
            },
            /**
             * Determines whether this body ignores the the specified controller.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {boolean}                                         <pre><code>true</code></pre> if the object has the specified category; otherwise, <pre><code>false</code></pre>.
             */
            IsInEnabledCategory: function (category) {
                return (this.EnabledOnCategories & category) === category;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter(); }
            }
        },
        fields: {
            ControllerIgnores: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Ignores the controller. The controller has no effect on this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @memberof FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @param   {FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType}    type    The logic type.
             * @return  {void}
             */
            IgnorePhysicsLogic: function (type) {
                this.ControllerIgnores |= type;
            },
            /**
             * Restore the controller. The controller affects this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @memberof FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @param   {FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType}    type    The logic type.
             * @return  {void}
             */
            RestorePhysicsLogic: function (type) {
                this.ControllerIgnores &= ~type;
            },
            /**
             * Determines whether this body ignores the the specified controller.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @memberof FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @param   {FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType}    type    The logic type.
             * @return  {boolean}                                                        <pre><code>true</code></pre> if the body has the specified flag; otherwise, <pre><code>false</code></pre>.
             */
            IsPhysicsLogicIgnored: function (type) {
                return (this.ControllerIgnores & type) === type;
            },
            getHashCode: function () {
                var h = Bridge.addHash([6841110227, this.ControllerIgnores]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter)) {
                    return false;
                }
                return Bridge.equals(this.ControllerIgnores, o.ControllerIgnores);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter();
                s.ControllerIgnores = this.ControllerIgnores;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType", {
        $kind: "enum",
        statics: {
            fields: {
                Explosion: 1
            }
        },
        $flags: true
    });

    /** @namespace FarseerPhysics.Common.PhysicsLogic */

    /**
     * This is a comprarer used for 
     detecting angle difference between rays
     *
     * @class FarseerPhysics.Common.PhysicsLogic.RayDataComparer
     * @implements  System.Collections.Generic.IComparer$1
     */
    Bridge.define("FarseerPhysics.Common.PhysicsLogic.RayDataComparer", {
        inherits: [System.Collections.Generic.IComparer$1(System.Single)],
        alias: ["System$Collections$Generic$IComparer$1$System$Single$compare", "System$Collections$Generic$IComparer$1$compare"],
        methods: {
            System$Collections$Generic$IComparer$1$System$Single$compare: function (a, b) {
                var diff = (a - b);
                if (diff > 0) {
                    return 1;
                }
                if (diff < 0) {
                    return -1;
                }
                return 0;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PhysicsLogic.ShapeData", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.PhysicsLogic.ShapeData(); }
            }
        },
        fields: {
            Body: null,
            Max: 0,
            Min: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3837963545, this.Body, this.Max, this.Min]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.PhysicsLogic.ShapeData)) {
                    return false;
                }
                return Bridge.equals(this.Body, o.Body) && Bridge.equals(this.Max, o.Max) && Bridge.equals(this.Min, o.Min);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.PhysicsLogic.ShapeData();
                s.Body = this.Body;
                s.Max = this.Max;
                s.Min = this.Min;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.CuttingTools", {
        statics: {
            methods: {
                /**
                 * Split a fixture into 2 vertice collections using the given entry and exit-point.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.CuttingTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.CuttingTools
                 * @param   {FarseerPhysics.Dynamics.Fixture}    fixture       The Fixture to split
                 * @param   {Microsoft.Xna.Framework.Vector2}    entryPoint    The entry point - The start point
                 * @param   {Microsoft.Xna.Framework.Vector2}    exitPoint     The exit point - The end point
                 * @param   {number}                             splitSize     The size of the split. Think of this as the laser-width
                 * @param   {FarseerPhysics.Common.Vertices}     first         The first collection of vertexes
                 * @param   {FarseerPhysics.Common.Vertices}     second        The second collection of vertexes
                 * @return  {void}
                 */
                SplitShape: function (fixture, entryPoint, exitPoint, splitSize, first, second) {
                    entryPoint = {v:entryPoint};
                    exitPoint = {v:exitPoint};
                    var localEntryPoint = fixture.Body.GetLocalPoint$1(entryPoint);
                    var localExitPoint = fixture.Body.GetLocalPoint$1(exitPoint);

                    var shape = Bridge.as(fixture.Shape, FarseerPhysics.Collision.Shapes.PolygonShape);

                    if (shape == null) {
                        first.v = new FarseerPhysics.Common.Vertices.ctor();
                        second.v = new FarseerPhysics.Common.Vertices.ctor();
                        return;
                    }

                    var vertices = new FarseerPhysics.Common.Vertices.$ctor2(shape.Vertices);
                    var newPolygon = System.Array.init(2, null, FarseerPhysics.Common.Vertices);

                    for (var i = 0; i < newPolygon.length; i = (i + 1) | 0) {
                        newPolygon[System.Array.index(i, newPolygon)] = new FarseerPhysics.Common.Vertices.$ctor3(vertices.Count);
                    }

                    var cutAdded = System.Array.init([-1, -1], System.Int32);
                    var last = -1;
                    for (var i1 = 0; i1 < vertices.Count; i1 = (i1 + 1) | 0) {
                        var n;
                        if (Microsoft.Xna.Framework.Vector2.Dot(FarseerPhysics.Common.MathUtils.Cross(Microsoft.Xna.Framework.Vector2.op_Subtraction(localExitPoint.$clone(), localEntryPoint.$clone()), 1), Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i1).$clone(), localEntryPoint.$clone())) > FarseerPhysics.Settings.Epsilon) {
                            n = 0;
                        } else {
                            n = 1;
                        }

                        if (last !== n) {
                            if (last === 0) {
                                System.Diagnostics.Debug.Assert(cutAdded[System.Array.index(0, cutAdded)] === -1);
                                cutAdded[System.Array.index(0, cutAdded)] = newPolygon[System.Array.index(last, newPolygon)].Count;
                                newPolygon[System.Array.index(last, newPolygon)].add(localExitPoint.$clone());
                                newPolygon[System.Array.index(last, newPolygon)].add(localEntryPoint.$clone());
                            }
                            if (last === 1) {
                                System.Diagnostics.Debug.Assert(cutAdded[System.Array.index(last, cutAdded)] === -1);
                                cutAdded[System.Array.index(last, cutAdded)] = newPolygon[System.Array.index(last, newPolygon)].Count;
                                newPolygon[System.Array.index(last, newPolygon)].add(localEntryPoint.$clone());
                                newPolygon[System.Array.index(last, newPolygon)].add(localExitPoint.$clone());
                            }
                        }

                        newPolygon[System.Array.index(n, newPolygon)].add(vertices.getItem(i1).$clone());
                        last = n;
                    }

                    if (cutAdded[System.Array.index(0, cutAdded)] === -1) {
                        cutAdded[System.Array.index(0, cutAdded)] = newPolygon[System.Array.index(0, newPolygon)].Count;
                        newPolygon[System.Array.index(0, newPolygon)].add(localExitPoint.$clone());
                        newPolygon[System.Array.index(0, newPolygon)].add(localEntryPoint.$clone());
                    }
                    if (cutAdded[System.Array.index(1, cutAdded)] === -1) {
                        cutAdded[System.Array.index(1, cutAdded)] = newPolygon[System.Array.index(1, newPolygon)].Count;
                        newPolygon[System.Array.index(1, newPolygon)].add(localEntryPoint.$clone());
                        newPolygon[System.Array.index(1, newPolygon)].add(localExitPoint.$clone());
                    }

                    for (var n1 = 0; n1 < 2; n1 = (n1 + 1) | 0) {
                        var offset = new Microsoft.Xna.Framework.Vector2();
                        if (cutAdded[System.Array.index(n1, cutAdded)] > 0) {
                            offset = (Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[System.Array.index(n1, newPolygon)].getItem(((cutAdded[System.Array.index(n1, cutAdded)] - 1) | 0)).$clone(), newPolygon[System.Array.index(n1, newPolygon)].getItem(cutAdded[System.Array.index(n1, cutAdded)]).$clone()));
                        } else {
                            offset = (Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[System.Array.index(n1, newPolygon)].getItem(((newPolygon[System.Array.index(n1, newPolygon)].Count - 1) | 0)).$clone(), newPolygon[System.Array.index(n1, newPolygon)].getItem(0).$clone()));
                        }
                        offset.Normalize();

                        newPolygon[System.Array.index(n1, newPolygon)].setItem(cutAdded[System.Array.index(n1, cutAdded)], Microsoft.Xna.Framework.Vector2.op_Addition(newPolygon[System.Array.index(n1, newPolygon)].getItem(cutAdded[System.Array.index(n1, cutAdded)]).$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(splitSize, offset.$clone())));

                        if (cutAdded[System.Array.index(n1, cutAdded)] < ((newPolygon[System.Array.index(n1, newPolygon)].Count - 2) | 0)) {
                            offset = (Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[System.Array.index(n1, newPolygon)].getItem(((cutAdded[System.Array.index(n1, cutAdded)] + 2) | 0)).$clone(), newPolygon[System.Array.index(n1, newPolygon)].getItem(((cutAdded[System.Array.index(n1, cutAdded)] + 1) | 0)).$clone()));
                        } else {
                            offset = (Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[System.Array.index(n1, newPolygon)].getItem(0).$clone(), newPolygon[System.Array.index(n1, newPolygon)].getItem(((newPolygon[System.Array.index(n1, newPolygon)].Count - 1) | 0)).$clone()));
                        }
                        offset.Normalize();

                        newPolygon[System.Array.index(n1, newPolygon)].setItem(((cutAdded[System.Array.index(n1, cutAdded)] + 1) | 0), Microsoft.Xna.Framework.Vector2.op_Addition(newPolygon[System.Array.index(n1, newPolygon)].getItem(((cutAdded[System.Array.index(n1, cutAdded)] + 1) | 0)).$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(splitSize, offset.$clone())));
                    }

                    first.v = newPolygon[System.Array.index(0, newPolygon)];
                    second.v = newPolygon[System.Array.index(1, newPolygon)];
                },
                /**
                 * This is a high-level function to cuts fixtures inside the given world, using the start and end points.
                 Note: We don't support cutting when the start or end is inside a shape.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.CuttingTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.CuttingTools
                 * @param   {FarseerPhysics.Dynamics.World}      world        The world.
                 * @param   {Microsoft.Xna.Framework.Vector2}    start        The startpoint.
                 * @param   {Microsoft.Xna.Framework.Vector2}    end          The endpoint.
                 * @param   {number}                             thickness    The thickness of the cut
                 * @return  {void}
                 */
                Cut: function (world, start, end, thickness) {
                    var fixtures = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).ctor();
                    var entryPoints = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();
                    var exitPoints = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();

                    if (world.TestPoint(start.$clone()) != null || world.TestPoint(end.$clone()) != null) {
                        return;
                    }

                    world.RayCast(function (f, p, n, fr) {
                        fixtures.add(f);
                        entryPoints.add(p.$clone());
                        return 1;
                    }, start.$clone(), end.$clone());

                    world.RayCast(function (f, p, n, fr) {
                        exitPoints.add(p.$clone());
                        return 1;
                    }, end.$clone(), start.$clone());

                    if (((entryPoints.Count + exitPoints.Count) | 0) < 2) {
                        return;
                    }

                    for (var i = 0; i < fixtures.Count; i = (i + 1) | 0) {
                        if (fixtures.getItem(i).Shape.ShapeType !== FarseerPhysics.Collision.Shapes.ShapeType.Polygon) {
                            continue;
                        }

                        if (fixtures.getItem(i).Body.BodyType !== FarseerPhysics.Dynamics.BodyType.Static) {
                            var first = { };
                            var second = { };
                            FarseerPhysics.Common.PolygonManipulation.CuttingTools.SplitShape(fixtures.getItem(i), entryPoints.getItem(i).$clone(), exitPoints.getItem(i).$clone(), thickness, first, second);

                            if (FarseerPhysics.Common.PolygonManipulation.CuttingTools.SanityCheck(first.v)) {
                                var firstFixture = FarseerPhysics.Factories.BodyFactory.CreatePolygon$1(world, first.v, fixtures.getItem(i).Shape.Density, fixtures.getItem(i).Body.Position.$clone());
                                firstFixture.Rotation = fixtures.getItem(i).Body.Rotation;
                                firstFixture.LinearVelocity = fixtures.getItem(i).Body.LinearVelocity.$clone();
                                firstFixture.AngularVelocity = fixtures.getItem(i).Body.AngularVelocity;
                                firstFixture.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;
                            }

                            if (FarseerPhysics.Common.PolygonManipulation.CuttingTools.SanityCheck(second.v)) {
                                var secondFixture = FarseerPhysics.Factories.BodyFactory.CreatePolygon$1(world, second.v, fixtures.getItem(i).Shape.Density, fixtures.getItem(i).Body.Position.$clone());
                                secondFixture.Rotation = fixtures.getItem(i).Body.Rotation;
                                secondFixture.LinearVelocity = fixtures.getItem(i).Body.LinearVelocity.$clone();
                                secondFixture.AngularVelocity = fixtures.getItem(i).Body.AngularVelocity;
                                secondFixture.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;
                            }
                            world.RemoveBody(fixtures.getItem(i).Body);
                        }
                    }
                },
                SanityCheck: function (vertices) {
                    if (vertices.Count < 3) {
                        return false;
                    }

                    if (vertices.GetArea() < 1E-05) {
                        return false;
                    }

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var i1 = i;
                        var i2 = ((i + 1) | 0) < vertices.Count ? ((i + 1) | 0) : 0;
                        var edge = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i2).$clone(), vertices.getItem(i1).$clone());
                        if (edge.LengthSquared() < 1.42108547E-14) {
                            return false;
                        }
                    }

                    for (var i3 = 0; i3 < vertices.Count; i3 = (i3 + 1) | 0) {
                        var i11 = i3;
                        var i21 = ((i3 + 1) | 0) < vertices.Count ? ((i3 + 1) | 0) : 0;
                        var edge1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i21).$clone(), vertices.getItem(i11).$clone());

                        for (var j = 0; j < vertices.Count; j = (j + 1) | 0) {
                            if (j === i11 || j === i21) {
                                continue;
                            }

                            var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(j).$clone(), vertices.getItem(i11).$clone());

                            var s = edge1.X * r.Y - edge1.Y * r.X;

                            if (s < 0.0) {
                                return false;
                            }
                        }
                    }

                    return true;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.PolyClipError", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                DegeneratedOutput: 1,
                NonSimpleInput: 2,
                BrokenResult: 3
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.PolyClipType", {
        $kind: "enum",
        statics: {
            fields: {
                Intersect: 0,
                Union: 1,
                Difference: 2
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.SimplifyTools", {
        statics: {
            fields: {
                _usePt: null,
                _distanceTolerance: 0
            },
            methods: {
                /**
                 * Removes all collinear points on the polygon.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices                 The polygon that needs simplification.
                 * @param   {number}                            collinearityTolerance    The collinearity tolerance.
                 * @return  {FarseerPhysics.Common.Vertices}                             A simplified polygon.
                 */
                CollinearSimplify$1: function (vertices, collinearityTolerance) {
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    var simplified = new FarseerPhysics.Common.Vertices.ctor();

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var prevId = vertices.PreviousIndex(i);
                        var nextId = vertices.NextIndex(i);

                        var prev = { v : vertices.getItem(prevId).$clone() };
                        var current = { v : vertices.getItem(i).$clone() };
                        var next = { v : vertices.getItem(nextId).$clone() };

                        if (FarseerPhysics.Common.MathUtils.Collinear$1(prev, current, next, collinearityTolerance)) {
                            continue;
                        }

                        simplified.add(current.v.$clone());
                    }

                    return simplified;
                },
                /**
                 * Removes all collinear points on the polygon.
                 Has a default bias of 0
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The polygon that needs simplification.
                 * @return  {FarseerPhysics.Common.Vertices}                A simplified polygon.
                 */
                CollinearSimplify: function (vertices) {
                    return FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify$1(vertices, 0);
                },
                /**
                 * Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not use the
                 speed-up technique by using the Melkman convex hull.
                 If you pass in 0, it will remove all collinear points
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices             
                 * @param   {number}                            distanceTolerance
                 * @return  {FarseerPhysics.Common.Vertices}                         The simplified polygon
                 */
                DouglasPeuckerSimplify: function (vertices, distanceTolerance) {
                    FarseerPhysics.Common.PolygonManipulation.SimplifyTools._distanceTolerance = distanceTolerance;

                    FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt = System.Array.init(vertices.Count, false, System.Boolean);
                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt[System.Array.index(i, FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt)] = true;
                    }

                    FarseerPhysics.Common.PolygonManipulation.SimplifyTools.SimplifySection(vertices, 0, ((vertices.Count - 1) | 0));
                    var result = new FarseerPhysics.Common.Vertices.ctor();

                    for (var i1 = 0; i1 < vertices.Count; i1 = (i1 + 1) | 0) {
                        if (FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt[System.Array.index(i1, FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt)]) {
                            result.add(vertices.getItem(i1).$clone());
                        }
                    }

                    return result;
                },
                SimplifySection: function (vertices, i, j) {
                    if ((((i + 1) | 0)) === j) {
                        return;
                    }

                    var A = vertices.getItem(i).$clone();
                    var B = vertices.getItem(j).$clone();
                    var maxDistance = -1.0;
                    var maxIndex = i;
                    for (var k = (i + 1) | 0; k < j; k = (k + 1) | 0) {
                        var distance = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DistancePointLine(vertices.getItem(k).$clone(), A.$clone(), B.$clone());

                        if (distance > maxDistance) {
                            maxDistance = distance;
                            maxIndex = k;
                        }
                    }
                    if (maxDistance <= FarseerPhysics.Common.PolygonManipulation.SimplifyTools._distanceTolerance) {
                        for (var k1 = (i + 1) | 0; k1 < j; k1 = (k1 + 1) | 0) {
                            FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt[System.Array.index(k1, FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt)] = false;
                        }
                    } else {
                        FarseerPhysics.Common.PolygonManipulation.SimplifyTools.SimplifySection(vertices, i, maxIndex);
                        FarseerPhysics.Common.PolygonManipulation.SimplifyTools.SimplifySection(vertices, maxIndex, j);
                    }
                },
                DistancePointPoint: function (p, p2) {
                    var dx = p.X - p2.X;
                    var dy = p.Y - p2.X;
                    return Math.sqrt(dx * dx + dy * dy);
                },
                DistancePointLine: function (p, A, B) {
                    if (A.X === B.X && A.Y === B.Y) {
                        return FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DistancePointPoint(p.$clone(), A.$clone());
                    }

                    /* (1)     	      AC dot AB
                               r =   ---------
                                     ||AB||^2

                    		                r has the following meaning:
                    		                r=0 Point = A
                    		                r=1 Point = B
                    		                r<0 Point is on the backward extension of AB
                    		                r>1 Point is on the forward extension of AB
                    		                0<r<1 Point is interior to AB
                    	        */

                    var r = ((p.X - A.X) * (B.X - A.X) + (p.Y - A.Y) * (B.Y - A.Y)) / ((B.X - A.X) * (B.X - A.X) + (B.Y - A.Y) * (B.Y - A.Y));

                    if (r <= 0.0) {
                        return FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DistancePointPoint(p.$clone(), A.$clone());
                    }
                    if (r >= 1.0) {
                        return FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DistancePointPoint(p.$clone(), B.$clone());
                    }


                    /* (2)
                    		                    (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
                    		                s = -----------------------------
                    		             	                Curve^2

                    		                Then the distance from C to Point = |s|*Curve.
                    	        */

                    var s = ((A.Y - p.Y) * (B.X - A.X) - (A.X - p.X) * (B.Y - A.Y)) / ((B.X - A.X) * (B.X - A.X) + (B.Y - A.Y) * (B.Y - A.Y));

                    return Math.abs(s) * Math.sqrt(((B.X - A.X) * (B.X - A.X) + (B.Y - A.Y) * (B.Y - A.Y)));
                },
                ReduceByArea: function (vertices, areaTolerance) {
                    if (vertices.Count <= 3) {
                        return vertices;
                    }

                    if (areaTolerance < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("areaTolerance", "must be equal to or greater then zero.");
                    }

                    var result = new FarseerPhysics.Common.Vertices.ctor();
                    var v1 = { v : new Microsoft.Xna.Framework.Vector2() }, v2 = { v : new Microsoft.Xna.Framework.Vector2() }, v3 = { v : new Microsoft.Xna.Framework.Vector2() };
                    var old1 = { }, old2 = { }, new1 = { };
                    v1.v = vertices.getItem(((vertices.Count - 2) | 0)).$clone();
                    v2.v = vertices.getItem(((vertices.Count - 1) | 0)).$clone();
                    areaTolerance *= 2;
                    for (var index = 0; index < vertices.Count; index = (index + 1) | 0, v2.v = v3.v.$clone()) {
                        if (index === ((vertices.Count - 1) | 0)) {
                            if (result.Count === 0) {
                                throw new System.ArgumentOutOfRangeException.$ctor4("areaTolerance", "The tolerance is too high!");
                            }
                            v3.v = result.getItem(0).$clone();
                        } else {
                            v3.v = vertices.getItem(index).$clone();
                        }
                        FarseerPhysics.Common.MathUtils.Cross$3(v1, v2, old1);
                        FarseerPhysics.Common.MathUtils.Cross$3(v2, v3, old2);
                        FarseerPhysics.Common.MathUtils.Cross$3(v1, v3, new1);
                        if (Math.abs(new1.v - (old1.v + old2.v)) > areaTolerance) {
                            result.add(v2.v.$clone());
                            v1.v = v2.v.$clone();
                        }
                    }
                    return result;
                },
                /**
                 * Merges all parallel edges in the list of vertices
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices     The vertices.
                 * @param   {number}                            tolerance    The tolerance.
                 * @return  {void}
                 */
                MergeParallelEdges: function (vertices, tolerance) {
                    if (vertices.Count <= 3) {
                        return;
                    }

                    var mergeMe = System.Array.init(vertices.Count, false, System.Boolean);
                    var newNVertices = vertices.Count;

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var lower = (i === 0) ? (((vertices.Count - 1) | 0)) : (((i - 1) | 0));
                        var middle = i;
                        var upper = (i === ((vertices.Count - 1) | 0)) ? (0) : (((i + 1) | 0));

                        var dx0 = vertices.getItem(middle).$clone().X - vertices.getItem(lower).$clone().X;
                        var dy0 = vertices.getItem(middle).$clone().Y - vertices.getItem(lower).$clone().Y;
                        var dx1 = vertices.getItem(upper).$clone().Y - vertices.getItem(middle).$clone().X;
                        var dy1 = vertices.getItem(upper).$clone().Y - vertices.getItem(middle).$clone().Y;
                        var norm0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);
                        var norm1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

                        if (!(norm0 > 0.0 && norm1 > 0.0) && newNVertices > 3) {
                            mergeMe[System.Array.index(i, mergeMe)] = true;
                            newNVertices = (newNVertices - 1) | 0;
                        }

                        dx0 /= norm0;
                        dy0 /= norm0;
                        dx1 /= norm1;
                        dy1 /= norm1;
                        var cross = dx0 * dy1 - dx1 * dy0;
                        var dot = dx0 * dx1 + dy0 * dy1;

                        if (Math.abs(cross) < tolerance && dot > 0 && newNVertices > 3) {
                            mergeMe[System.Array.index(i, mergeMe)] = true;
                            newNVertices = (newNVertices - 1) | 0;
                        } else {
                            mergeMe[System.Array.index(i, mergeMe)] = false;
                        }
                    }

                    if (newNVertices === vertices.Count || newNVertices === 0) {
                        return;
                    }

                    var currIndex = 0;

                    var oldVertices = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                    vertices.clear();

                    for (var i1 = 0; i1 < oldVertices.Count; i1 = (i1 + 1) | 0) {
                        if (mergeMe[System.Array.index(i1, mergeMe)] || newNVertices === 0 || currIndex === newNVertices) {
                            continue;
                        }

                        System.Diagnostics.Debug.Assert(currIndex < newNVertices);

                        vertices.add(oldVertices.getItem(i1).$clone());
                        currIndex = (currIndex + 1) | 0;
                    }
                },
                /**
                 * Merges the identical points in the polygon.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                MergeIdenticalPoints: function (vertices) {
                    var $t;
                    var results = new (System.Collections.Generic.HashSet$1(Microsoft.Xna.Framework.Vector2)).ctor();

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        results.add(vertices.getItem(i).$clone());
                    }

                    var returnResults = new FarseerPhysics.Common.Vertices.ctor();
                    $t = Bridge.getEnumerator(results);
                    try {
                        while ($t.moveNext()) {
                            var v = $t.Current.$clone();
                            returnResults.add(v.$clone());
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return returnResults;
                },
                /**
                 * Reduces the polygon by distance.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
                 * @param   {number}                            distance    The distance between points. Points closer than this will be 'joined'.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                ReduceByDistance: function (vertices, distance) {
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    var simplified = new FarseerPhysics.Common.Vertices.ctor();

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var current = vertices.getItem(i).$clone();
                        var next = vertices.NextVertex(i);

                        if ((Microsoft.Xna.Framework.Vector2.op_Subtraction(next.$clone(), current.$clone())).LengthSquared() <= distance) {
                            continue;
                        }

                        simplified.add(current.$clone());
                    }

                    return simplified;
                },
                /**
                 * Reduces the polygon by removing the Nth vertex in the vertices list.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
                 * @param   {number}                            nth         The Nth point to remove. Example: 5.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                ReduceByNth: function (vertices, nth) {
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    if (nth === 0) {
                        return vertices;
                    }

                    var result = new FarseerPhysics.Common.Vertices.$ctor3(vertices.Count);

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        if (i % nth === 0) {
                            continue;
                        }

                        result.add(vertices.getItem(i).$clone());
                    }

                    return result;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.YuPengClipper", {
        statics: {
            fields: {
                ClipperEpsilonSquared: 0
            },
            ctors: {
                init: function () {
                    this.ClipperEpsilonSquared = 1.1920929E-07;
                }
            },
            methods: {
                Union: function (polygon1, polygon2, error) {
                    return FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(polygon1, polygon2, FarseerPhysics.Common.PolygonManipulation.PolyClipType.Union, error);
                },
                Difference: function (polygon1, polygon2, error) {
                    return FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(polygon1, polygon2, FarseerPhysics.Common.PolygonManipulation.PolyClipType.Difference, error);
                },
                Intersect: function (polygon1, polygon2, error) {
                    return FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(polygon1, polygon2, FarseerPhysics.Common.PolygonManipulation.PolyClipType.Intersect, error);
                },
                /**
                 * Implements "A new algorithm for Boolean operations on general polygons" 
                 available here: http://liama.ia.ac.cn/wiki/_media/user:dong:dong_cg_05.pdf
                 Merges two polygons, a subject and a clip with the specified operation. Polygons may not be 
                 self-intersecting.
                 Warning: May yield incorrect results or even crash if polygons contain collinear points.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {FarseerPhysics.Common.Vertices}                             subject     The subject polygon.
                 * @param   {FarseerPhysics.Common.Vertices}                             clip        The clip polygon, which is added, 
                 substracted or intersected with the subject
                 * @param   {FarseerPhysics.Common.PolygonManipulation.PolyClipType}     clipType    The operation to be performed. Either
                 Union, Difference or Intersection.
                 * @param   {FarseerPhysics.Common.PolygonManipulation.PolyClipError}    error       The error generated (if any)
                 * @return  {System.Collections.Generic.List$1}                                      A list of closed polygons, which make up the result of the clipping operation.
                 Outer contours are ordered counter clockwise, holes are ordered clockwise.
                 */
                Execute: function (subject, clip, clipType, error) {
                    System.Diagnostics.Debug.Assert$2(subject.IsSimple() && clip.IsSimple(), "Non simple input!", "Input polygons must be simple (cannot intersect themselves).");

                    var slicedSubject = { };
                    var slicedClip = { };
                    FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateIntersections(subject, clip, slicedSubject, slicedClip);

                    var lbSubject = { v : subject.GetCollisionBox().LowerBound.$clone() };
                    var lbClip = { v : clip.GetCollisionBox().LowerBound.$clone() };
                    var translate = { v : new Microsoft.Xna.Framework.Vector2() };
                    Microsoft.Xna.Framework.Vector2.Min$1(lbSubject, lbClip, translate);
                    translate.v = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.One.$clone(), translate.v.$clone());
                    if (Microsoft.Xna.Framework.Vector2.op_Inequality(translate.v.$clone(), Microsoft.Xna.Framework.Vector2.Zero.$clone())) {
                        slicedSubject.v.Translate$1(translate);
                        slicedClip.v.Translate$1(translate);
                    }

                    slicedSubject.v.ForceCounterClockWise();
                    slicedClip.v.ForceCounterClockWise();

                    var subjectSimplices = { };
                    var subjectCoeff = { };
                    var clipSimplices = { };
                    var clipCoeff = { };
                    FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(slicedSubject.v, subjectCoeff, subjectSimplices);
                    FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(slicedClip.v, clipCoeff, clipSimplices);

                    var resultSimplices = { };

                    FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateResultChain(subjectCoeff.v, subjectSimplices.v, clipCoeff.v, clipSimplices.v, clipType, resultSimplices);

                    var result = { };
                    error.v = FarseerPhysics.Common.PolygonManipulation.YuPengClipper.BuildPolygonsFromChain(resultSimplices.v, result);

                    translate.v = Microsoft.Xna.Framework.Vector2.op_Multiply$1(translate.v.$clone(), -1.0);
                    for (var i = 0; i < result.v.Count; i = (i + 1) | 0) {
                        result.v.getItem(i).Translate$1(translate);
                        FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(result.v.getItem(i));
                    }
                    return result.v;
                },
                /**
                 * Calculates all intersections between two polygons.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {FarseerPhysics.Common.Vertices}    polygon1       The first polygon.
                 * @param   {FarseerPhysics.Common.Vertices}    polygon2       The second polygon.
                 * @param   {FarseerPhysics.Common.Vertices}    slicedPoly1    Returns the first polygon with added intersection points.
                 * @param   {FarseerPhysics.Common.Vertices}    slicedPoly2    Returns the second polygon with added intersection points.
                 * @return  {void}
                 */
                CalculateIntersections: function (polygon1, polygon2, slicedPoly1, slicedPoly2) {
                    slicedPoly1.v = new FarseerPhysics.Common.Vertices.$ctor2(polygon1);
                    slicedPoly2.v = new FarseerPhysics.Common.Vertices.$ctor2(polygon2);

                    for (var i = 0; i < polygon1.Count; i = (i + 1) | 0) {
                        var a = polygon1.getItem(i).$clone();
                        var b = polygon1.getItem(polygon1.NextIndex(i)).$clone();

                        for (var j = 0; j < polygon2.Count; j = (j + 1) | 0) {
                            var c = polygon2.getItem(j).$clone();
                            var d = polygon2.getItem(polygon2.NextIndex(j)).$clone();

                            var intersectionPoint = { v : new Microsoft.Xna.Framework.Vector2() };
                            if (FarseerPhysics.Common.LineTools.LineIntersect$1(a.$clone(), b.$clone(), c.$clone(), d.$clone(), intersectionPoint)) {
                                var alpha;
                                alpha = FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(a.$clone(), b.$clone(), intersectionPoint.v.$clone());
                                if (alpha > 0.0 && alpha < 1.0) {
                                    var index = (slicedPoly1.v.indexOf(a.$clone()) + 1) | 0;
                                    while (index < slicedPoly1.v.Count && FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(a.$clone(), b.$clone(), slicedPoly1.v.getItem(index).$clone()) <= alpha) {
                                        index = (index + 1) | 0;
                                    }
                                    slicedPoly1.v.insert(index, intersectionPoint.v.$clone());
                                }
                                alpha = FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(c.$clone(), d.$clone(), intersectionPoint.v.$clone());
                                if (alpha > 0.0 && alpha < 1.0) {
                                    var index1 = (slicedPoly2.v.indexOf(c.$clone()) + 1) | 0;
                                    while (index1 < slicedPoly2.v.Count && FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(c.$clone(), d.$clone(), slicedPoly2.v.getItem(index1).$clone()) <= alpha) {
                                        index1 = (index1 + 1) | 0;
                                    }
                                    slicedPoly2.v.insert(index1, intersectionPoint.v.$clone());
                                }
                            }
                        }
                    }
                    for (var i1 = 0; i1 < slicedPoly1.v.Count; i1 = (i1 + 1) | 0) {
                        var iNext = slicedPoly1.v.NextIndex(i1);
                        if ((Microsoft.Xna.Framework.Vector2.op_Subtraction(slicedPoly1.v.getItem(iNext).$clone(), slicedPoly1.v.getItem(i1).$clone())).LengthSquared() <= FarseerPhysics.Common.PolygonManipulation.YuPengClipper.ClipperEpsilonSquared) {
                            slicedPoly1.v.removeAt(i1);
                            i1 = (i1 - 1) | 0;
                        }
                    }
                    for (var i2 = 0; i2 < slicedPoly2.v.Count; i2 = (i2 + 1) | 0) {
                        var iNext1 = slicedPoly2.v.NextIndex(i2);
                        if ((Microsoft.Xna.Framework.Vector2.op_Subtraction(slicedPoly2.v.getItem(iNext1).$clone(), slicedPoly2.v.getItem(i2).$clone())).LengthSquared() <= FarseerPhysics.Common.PolygonManipulation.YuPengClipper.ClipperEpsilonSquared) {
                            slicedPoly2.v.removeAt(i2);
                            i2 = (i2 - 1) | 0;
                        }
                    }
                },
                /**
                 * Calculates the simplical chain corresponding to the input polygon.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {FarseerPhysics.Common.Vertices}     poly          
                 * @param   {System.Collections.Generic.List}    coeff         
                 * @param   {System.Collections.Generic.List}    simplicies
                 * @return  {void}
                 */
                CalculateSimplicalChain: function (poly, coeff, simplicies) {
                    simplicies.v = new (System.Collections.Generic.List$1(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge)).ctor();
                    coeff.v = new (System.Collections.Generic.List$1(System.Single)).ctor();
                    for (var i = 0; i < poly.Count; i = (i + 1) | 0) {
                        simplicies.v.add(new FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge(poly.getItem(i).$clone(), poly.getItem(poly.NextIndex(i)).$clone()));
                        coeff.v.add(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplexCoefficient(Microsoft.Xna.Framework.Vector2.Zero.$clone(), poly.getItem(i).$clone(), poly.getItem(poly.NextIndex(i)).$clone()));
                    }
                },
                /**
                 * Calculates the characteristics function for all edges of
                 the given simplical chains and builds the result chain.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {System.Collections.Generic.List$1}                         poly1Coeff         
                 * @param   {System.Collections.Generic.List$1}                         poly1Simplicies    
                 * @param   {System.Collections.Generic.List$1}                         poly2Coeff         
                 * @param   {System.Collections.Generic.List$1}                         poly2Simplicies    
                 * @param   {FarseerPhysics.Common.PolygonManipulation.PolyClipType}    clipType           
                 * @param   {System.Collections.Generic.List}                           resultSimplices
                 * @return  {void}
                 */
                CalculateResultChain: function (poly1Coeff, poly1Simplicies, poly2Coeff, poly2Simplicies, clipType, resultSimplices) {
                    resultSimplices.v = new (System.Collections.Generic.List$1(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge)).ctor();

                    for (var i = 0; i < poly1Simplicies.Count; i = (i + 1) | 0) {
                        var edgeCharacter = 0.0;
                        if (poly2Simplicies.contains(poly1Simplicies.getItem(i)) || (poly2Simplicies.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly1Simplicies.getItem(i))) && clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Union)) {
                            edgeCharacter = 1.0;
                        } else {
                            for (var j = 0; j < poly2Simplicies.Count; j = (j + 1) | 0) {
                                if (!poly2Simplicies.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly1Simplicies.getItem(i)))) {
                                    edgeCharacter += FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateBeta(poly1Simplicies.getItem(i).GetCenter(), poly2Simplicies.getItem(j), poly2Coeff.getItem(j));
                                }
                            }
                        }
                        if (clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Intersect) {
                            if (edgeCharacter === 1.0) {
                                resultSimplices.v.add(poly1Simplicies.getItem(i));
                            }
                        } else {
                            if (edgeCharacter === 0.0) {
                                resultSimplices.v.add(poly1Simplicies.getItem(i));
                            }
                        }
                    }
                    for (var i1 = 0; i1 < poly2Simplicies.Count; i1 = (i1 + 1) | 0) {
                        if (!resultSimplices.v.contains(poly2Simplicies.getItem(i1)) && !resultSimplices.v.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1)))) {
                            var edgeCharacter1 = 0.0;
                            if (poly1Simplicies.contains(poly2Simplicies.getItem(i1)) || (poly1Simplicies.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1))) && clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Union)) {
                                edgeCharacter1 = 1.0;
                            } else {
                                for (var j1 = 0; j1 < poly1Simplicies.Count; j1 = (j1 + 1) | 0) {
                                    if (!poly1Simplicies.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1)))) {
                                        edgeCharacter1 += FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateBeta(poly2Simplicies.getItem(i1).GetCenter(), poly1Simplicies.getItem(j1), poly1Coeff.getItem(j1));
                                    }
                                }
                            }
                            if (clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Intersect || clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Difference) {
                                if (edgeCharacter1 === 1.0) {
                                    resultSimplices.v.add(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1)));
                                }
                            } else {
                                if (edgeCharacter1 === 0.0) {
                                    resultSimplices.v.add(poly2Simplicies.getItem(i1));
                                }
                            }
                        }
                    }
                },
                /**
                 * Calculates the polygon(s) from the result simplical chain.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {System.Collections.Generic.List$1}                          simplicies    
                 * @param   {System.Collections.Generic.List}                            result
                 * @return  {FarseerPhysics.Common.PolygonManipulation.PolyClipError}
                 */
                BuildPolygonsFromChain: function (simplicies, result) {
                    result.v = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                    var errVal = FarseerPhysics.Common.PolygonManipulation.PolyClipError.None;

                    while (simplicies.Count > 0) {
                        var output = new FarseerPhysics.Common.Vertices.ctor();
                        output.add(simplicies.getItem(0).EdgeStart.$clone());
                        output.add(simplicies.getItem(0).EdgeEnd.$clone());
                        simplicies.removeAt(0);
                        var closed = false;
                        var index = 0;
                        var count = simplicies.Count;
                        while (!closed && simplicies.Count > 0) {
                            if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(output.getItem(((output.Count - 1) | 0)).$clone(), simplicies.getItem(index).EdgeStart.$clone())) {
                                if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(simplicies.getItem(index).EdgeEnd.$clone(), output.getItem(0).$clone())) {
                                    closed = true;
                                } else {
                                    output.add(simplicies.getItem(index).EdgeEnd.$clone());
                                }
                                simplicies.removeAt(index);
                                index = (index - 1) | 0;
                            } else if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(output.getItem(((output.Count - 1) | 0)).$clone(), simplicies.getItem(index).EdgeEnd.$clone())) {
                                if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(simplicies.getItem(index).EdgeStart.$clone(), output.getItem(0).$clone())) {
                                    closed = true;
                                } else {
                                    output.add(simplicies.getItem(index).EdgeStart.$clone());
                                }
                                simplicies.removeAt(index);
                                index = (index - 1) | 0;
                            }
                            if (!closed) {
                                if (((index = (index + 1) | 0)) === simplicies.Count) {
                                    if (count === simplicies.Count) {
                                        result.v = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                                        System.Diagnostics.Debug.WriteLine$2("Undefined error while building result polygon(s).");
                                        return FarseerPhysics.Common.PolygonManipulation.PolyClipError.BrokenResult;
                                    }
                                    index = 0;
                                    count = simplicies.Count;
                                }
                            }
                        }
                        if (output.Count < 3) {
                            errVal = FarseerPhysics.Common.PolygonManipulation.PolyClipError.DegeneratedOutput;
                            System.Diagnostics.Debug.WriteLine$2("Degenerated output polygon produced (vertices < 3).");
                        }
                        result.v.add(output);
                    }
                    return errVal;
                },
                /**
                 * Needed to calculate the characteristics function of a simplex.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}                                 point          
                 * @param   {FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}    e              
                 * @param   {number}                                                          coefficient
                 * @return  {number}
                 */
                CalculateBeta: function (point, e, coefficient) {
                    var result = 0.0;
                    if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointInSimplex(point.$clone(), e)) {
                        result = coefficient;
                    }
                    if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2.Zero.$clone(), e.EdgeStart.$clone(), point.$clone()) || FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2.Zero.$clone(), e.EdgeEnd.$clone(), point.$clone())) {
                        result = 0.5 * coefficient;
                    }
                    return result;
                },
                /**
                 * Needed for sorting multiple intersections points on the same edge.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}    start    
                 * @param   {Microsoft.Xna.Framework.Vector2}    end      
                 * @param   {Microsoft.Xna.Framework.Vector2}    point
                 * @return  {number}
                 */
                GetAlpha: function (start, end, point) {
                    return (Microsoft.Xna.Framework.Vector2.op_Subtraction(point.$clone(), start.$clone())).LengthSquared() / (Microsoft.Xna.Framework.Vector2.op_Subtraction(end.$clone(), start.$clone())).LengthSquared();
                },
                /**
                 * Returns the coefficient of a simplex.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    
                 * @param   {Microsoft.Xna.Framework.Vector2}    c
                 * @return  {number}
                 */
                CalculateSimplexCoefficient: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    var isLeft = FarseerPhysics.Common.MathUtils.Area$1(a, b, c);
                    if (isLeft < 0.0) {
                        return -1.0;
                    }

                    if (isLeft > 0.0) {
                        return 1.0;
                    }

                    return 0.0;
                },
                /**
                 * Winding number test for a point in a simplex.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}                                 point    The point to be tested.
                 * @param   {FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}    edge     The edge that the point is tested against.
                 * @return  {boolean}                                                                  False if the winding number is even and the point is outside
                 the simplex and True otherwise.
                 */
                PointInSimplex: function (point, edge) {
                    point = {v:point};
                    var polygon = new FarseerPhysics.Common.Vertices.ctor();
                    polygon.add(Microsoft.Xna.Framework.Vector2.Zero.$clone());
                    polygon.add(edge.EdgeStart.$clone());
                    polygon.add(edge.EdgeEnd.$clone());
                    return (polygon.PointInPolygon(point) === 1);
                },
                /**
                 * Tests if a point lies on a line segment.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}    start    
                 * @param   {Microsoft.Xna.Framework.Vector2}    end      
                 * @param   {Microsoft.Xna.Framework.Vector2}    point
                 * @return  {boolean}
                 */
                PointOnLineSegment: function (start, end, point) {
                    start = {v:start};
                    end = {v:end};
                    point = {v:point};
                    var segment = Microsoft.Xna.Framework.Vector2.op_Subtraction(end.v.$clone(), start.v.$clone());
                    return FarseerPhysics.Common.MathUtils.Area$1(start, end, point) === 0.0 && Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), start.v.$clone()), segment.$clone()) >= 0.0 && Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), end.v.$clone()), segment.$clone()) <= 0.0;
                },
                VectorEqual: function (vec1, vec2) {
                    return (Microsoft.Xna.Framework.Vector2.op_Subtraction(vec2.$clone(), vec1.$clone())).LengthSquared() <= FarseerPhysics.Common.PolygonManipulation.YuPengClipper.ClipperEpsilonSquared;
                }
            }
        }
    });

    /** @namespace FarseerPhysics.Common.PolygonManipulation */

    /**
     * Specifies an Edge. Edges are used to represent simplicies in simplical chains
     *
     * @private
     * @class FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge
     */
    Bridge.define("FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge", {
        $kind: "nested class",
        statics: {
            methods: {
                op_UnaryNegation: function (e) {
                    return new FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge(e.EdgeEnd.$clone(), e.EdgeStart.$clone());
                }
            }
        },
        fields: {
            EdgeStart: null,
            EdgeEnd: null
        },
        ctors: {
            init: function () {
                this.EdgeStart = new Microsoft.Xna.Framework.Vector2();
                this.EdgeEnd = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function (edgeStart, edgeEnd) {
                this.$initialize();
                this.EdgeStart = edgeStart.$clone();
                this.EdgeEnd = edgeEnd.$clone();
            }
        },
        methods: {
            GetCenter: function () {
                return Microsoft.Xna.Framework.Vector2.op_Division$1((Microsoft.Xna.Framework.Vector2.op_Addition(this.EdgeStart.$clone(), this.EdgeEnd.$clone())), 2.0);
            },
            equals: function (obj) {
                if (obj == null) {
                    return false;
                }

                return this.Equals(Bridge.as(obj, FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge));
            },
            Equals: function (e) {
                if (e == null) {
                    return false;
                }

                return FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(this.EdgeStart.$clone(), e.EdgeStart.$clone()) && FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(this.EdgeEnd.$clone(), e.EdgeEnd.$clone());
            },
            getHashCode: function () {
                return this.EdgeStart.getHashCode() ^ this.EdgeEnd.getHashCode();
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonTools", {
        statics: {
            methods: {
                /**
                 * Build vertices to represent an axis-aligned box.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            hx    the half-width.
                 * @param   {number}                            hy    the half-height.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateRectangle: function (hx, hy) {
                    var vertices = new FarseerPhysics.Common.Vertices.$ctor3(4);
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-hx, -hy));
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(hx, -hy));
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(hx, hy));
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-hx, hy));

                    return vertices;
                },
                /**
                 * Build vertices to represent an oriented box.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                             hx        the half-width.
                 * @param   {number}                             hy        the half-height.
                 * @param   {Microsoft.Xna.Framework.Vector2}    center    the center of the box in local coordinates.
                 * @param   {number}                             angle     the rotation of the box in local coordinates.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateRectangle$1: function (hx, hy, center, angle) {
                    var vertices = FarseerPhysics.Common.PolygonTools.CreateRectangle(hx, hy);

                    var xf = { v : new FarseerPhysics.Common.Transform.ctor() };
                    xf.v.Position = center.$clone();
                    xf.v.R.Set$1(angle);

                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        vertices.setItem(i, FarseerPhysics.Common.MathUtils.Multiply$2(xf, vertices.getItem(i).$clone()));
                    }

                    return vertices;
                },
                /**
                 * Creates a rounded rectangle with the specified width and height.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            width       The width.
                 * @param   {number}                            height      The height.
                 * @param   {number}                            xRadius     The rounding X radius.
                 * @param   {number}                            yRadius     The rounding Y radius.
                 * @param   {number}                            segments    The number of segments to subdivide the edges.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateRoundedRectangle: function (width, height, xRadius, yRadius, segments) {
                    if (yRadius > height / 2 || xRadius > width / 2) {
                        throw new System.Exception("Rounding amount can't be more than half the height and width respectively.");
                    }
                    if (segments < 0) {
                        throw new System.Exception("Segments must be zero or more.");
                    }

                    System.Diagnostics.Debug.Assert(FarseerPhysics.Settings.MaxPolygonVertices >= 8);

                    var vertices = new FarseerPhysics.Common.Vertices.ctor();
                    if (segments === 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width * 0.5 - xRadius, -height * 0.5));
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width * 0.5, -height * 0.5 + yRadius));

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width * 0.5, height * 0.5 - yRadius));
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width * 0.5 - xRadius, height * 0.5));

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width * 0.5 + xRadius, height * 0.5));
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width * 0.5, height * 0.5 - yRadius));

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width * 0.5, -height * 0.5 + yRadius));
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width * 0.5 + xRadius, -height * 0.5));
                    } else {
                        var numberOfEdges = (((Bridge.Int.mul(segments, 4) + 8) | 0));

                        var stepSize = Microsoft.Xna.Framework.MathHelper.TwoPi / (((numberOfEdges - 4) | 0));
                        var perPhase = (Bridge.Int.div(numberOfEdges, 4)) | 0;

                        var posOffset = new Microsoft.Xna.Framework.Vector2.$ctor2(width / 2 - xRadius, height / 2 - yRadius);
                        vertices.add(Microsoft.Xna.Framework.Vector2.op_Addition(posOffset.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius, -yRadius + yRadius)));
                        var phase = 0;
                        for (var i = 1; i < numberOfEdges; i = (i + 1) | 0) {
                            if (((i - perPhase) | 0) === 0 || ((i - Bridge.Int.mul(perPhase, 3)) | 0) === 0) {
                                posOffset.X *= -1;
                                phase = Bridge.Int.sxs((phase - 1) & 65535);
                            } else if (((i - Bridge.Int.mul(perPhase, 2)) | 0) === 0) {
                                posOffset.Y *= -1;
                                phase = Bridge.Int.sxs((phase - 1) & 65535);
                            }

                            vertices.add(Microsoft.Xna.Framework.Vector2.op_Addition(posOffset.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius * Math.cos(stepSize * ((-(((i + phase) | 0))) | 0)), -yRadius * Math.sin(stepSize * ((-(((i + phase) | 0))) | 0)))));
                        }
                    }

                    return vertices;
                },
                /**
                 * Set this as a single edge.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    start    The first point.
                 * @param   {Microsoft.Xna.Framework.Vector2}    end      The second point.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateLine: function (start, end) {
                    var vertices = new FarseerPhysics.Common.Vertices.$ctor3(2);
                    vertices.add(start.$clone());
                    vertices.add(end.$clone());

                    return vertices;
                },
                /**
                 * Creates a circle with the specified radius and number of edges.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            radius           The radius.
                 * @param   {number}                            numberOfEdges    The number of edges. The more edges, the more it resembles a circle
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateCircle: function (radius, numberOfEdges) {
                    return FarseerPhysics.Common.PolygonTools.CreateEllipse(radius, radius, numberOfEdges);
                },
                /**
                 * Creates a ellipse with the specified width, height and number of edges.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            xRadius          Width of the ellipse.
                 * @param   {number}                            yRadius          Height of the ellipse.
                 * @param   {number}                            numberOfEdges    The number of edges. The more edges, the more it resembles an ellipse
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateEllipse: function (xRadius, yRadius, numberOfEdges) {
                    var vertices = new FarseerPhysics.Common.Vertices.ctor();

                    var stepSize = Microsoft.Xna.Framework.MathHelper.TwoPi / numberOfEdges;

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius, 0));
                    for (var i = (numberOfEdges - 1) | 0; i > 0; i = (i - 1) | 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius * Math.cos(stepSize * i), -yRadius * Math.sin(stepSize * i)));
                    }

                    return vertices;
                },
                CreateArc: function (radians, sides, radius) {
                    System.Diagnostics.Debug.Assert$1(radians > 0, "The arc needs to be larger than 0");
                    System.Diagnostics.Debug.Assert$1(sides > 1, "The arc needs to have more than 1 sides");
                    System.Diagnostics.Debug.Assert$1(radius > 0, "The arc needs to have a radius larger than 0");

                    var vertices = new FarseerPhysics.Common.Vertices.ctor();

                    var stepSize = radians / sides;
                    for (var i = (sides - 1) | 0; i > 0; i = (i - 1) | 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius * Math.cos(stepSize * i), radius * Math.sin(stepSize * i)));
                    }

                    return vertices;
                },
                /**
                 * Creates an capsule with the specified height, radius and number of edges.
                 A capsule has the same form as a pill capsule.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            height       Height (inner height + 2 * radius) of the capsule.
                 * @param   {number}                            endRadius    Radius of the capsule ends.
                 * @param   {number}                            edges        The number of edges of the capsule ends. The more edges, the more it resembles an capsule
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateCapsule: function (height, endRadius, edges) {
                    if (endRadius >= height / 2) {
                        throw new System.ArgumentException.$ctor3("The radius must be lower than height / 2. Higher values of radius would create a circle, and not a half circle.", "endRadius");
                    }

                    return FarseerPhysics.Common.PolygonTools.CreateCapsule$1(height, endRadius, edges, endRadius, edges);
                },
                /**
                 * Creates an capsule with the specified  height, radius and number of edges.
                 A capsule has the same form as a pill capsule.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            height          Height (inner height + radii) of the capsule.
                 * @param   {number}                            topRadius       Radius of the top.
                 * @param   {number}                            topEdges        The number of edges of the top. The more edges, the more it resembles an capsule
                 * @param   {number}                            bottomRadius    Radius of bottom.
                 * @param   {number}                            bottomEdges     The number of edges of the bottom. The more edges, the more it resembles an capsule
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateCapsule$1: function (height, topRadius, topEdges, bottomRadius, bottomEdges) {
                    if (height <= 0) {
                        throw new System.ArgumentException.$ctor3("Height must be longer than 0", "height");
                    }

                    if (topRadius <= 0) {
                        throw new System.ArgumentException.$ctor3("The top radius must be more than 0", "topRadius");
                    }

                    if (topEdges <= 0) {
                        throw new System.ArgumentException.$ctor3("Top edges must be more than 0", "topEdges");
                    }

                    if (bottomRadius <= 0) {
                        throw new System.ArgumentException.$ctor3("The bottom radius must be more than 0", "bottomRadius");
                    }

                    if (bottomEdges <= 0) {
                        throw new System.ArgumentException.$ctor3("Bottom edges must be more than 0", "bottomEdges");
                    }

                    if (topRadius >= height / 2) {
                        throw new System.ArgumentException.$ctor3("The top radius must be lower than height / 2. Higher values of top radius would create a circle, and not a half circle.", "topRadius");
                    }

                    if (bottomRadius >= height / 2) {
                        throw new System.ArgumentException.$ctor3("The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle, and not a half circle.", "bottomRadius");
                    }

                    var vertices = new FarseerPhysics.Common.Vertices.ctor();

                    var newHeight = (height - topRadius - bottomRadius) * 0.5;

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(topRadius, newHeight));

                    var stepSize = Microsoft.Xna.Framework.MathHelper.Pi / topEdges;
                    for (var i = 1; i < topEdges; i = (i + 1) | 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(topRadius * Math.cos(stepSize * i), topRadius * Math.sin(stepSize * i) + newHeight));
                    }

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-topRadius, newHeight));

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-bottomRadius, -newHeight));

                    stepSize = Microsoft.Xna.Framework.MathHelper.Pi / bottomEdges;
                    for (var i1 = 1; i1 < bottomEdges; i1 = (i1 + 1) | 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-bottomRadius * Math.cos(stepSize * i1), -bottomRadius * Math.sin(stepSize * i1) - newHeight));
                    }

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(bottomRadius, -newHeight));

                    return vertices;
                },
                /**
                 * Creates a gear shape with the specified radius and number of teeth.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            radius           The radius.
                 * @param   {number}                            numberOfTeeth    The number of teeth.
                 * @param   {number}                            tipPercentage    The tip percentage.
                 * @param   {number}                            toothHeight      Height of the tooth.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateGear: function (radius, numberOfTeeth, tipPercentage, toothHeight) {
                    var vertices = new FarseerPhysics.Common.Vertices.ctor();

                    var stepSize = Microsoft.Xna.Framework.MathHelper.TwoPi / numberOfTeeth;
                    tipPercentage /= 100.0;
                    Microsoft.Xna.Framework.MathHelper.Clamp$1(tipPercentage, 0.0, 1.0);
                    var toothTipStepSize = (stepSize / 2.0) * tipPercentage;

                    var toothAngleStepSize = (stepSize - (toothTipStepSize * 2.0)) / 2.0;

                    for (var i = (numberOfTeeth - 1) | 0; i >= 0; i = (i - 1) | 0) {
                        if (toothTipStepSize > 0.0) {
                            vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius * Math.cos(stepSize * i + toothAngleStepSize * 2.0 + toothTipStepSize), -radius * Math.sin(stepSize * i + toothAngleStepSize * 2.0 + toothTipStepSize)));

                            vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2((radius + toothHeight) * Math.cos(stepSize * i + toothAngleStepSize + toothTipStepSize), -(radius + toothHeight) * Math.sin(stepSize * i + toothAngleStepSize + toothTipStepSize)));
                        }

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2((radius + toothHeight) * Math.cos(stepSize * i + toothAngleStepSize), -(radius + toothHeight) * Math.sin(stepSize * i + toothAngleStepSize)));

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius * Math.cos(stepSize * i), -radius * Math.sin(stepSize * i)));
                    }

                    return vertices;
                },
                /**
                 * Detects the vertices by analyzing the texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {Array.<number>}                    data     The texture data.
                 * @param   {number}                            width    The texture width.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreatePolygon: function (data, width) {
                    return FarseerPhysics.Common.TextureConverter.DetectVertices(data, width);
                },
                /**
                 * Detects the vertices by analyzing the texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {Array.<number>}                    data             The texture data.
                 * @param   {number}                            width            The texture width.
                 * @param   {boolean}                           holeDetection    if set to <pre><code>true</code></pre> it will perform hole detection.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreatePolygon$1: function (data, width, holeDetection) {
                    return FarseerPhysics.Common.TextureConverter.DetectVertices$1(data, width, holeDetection);
                },
                /**
                 * Detects the vertices by analyzing the texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {Array.<number>}                       data                  The texture data.
                 * @param   {number}                               width                 The texture width.
                 * @param   {number}                               hullTolerance         The hull tolerance.
                 * @param   {number}                               alphaTolerance        The alpha tolerance.
                 * @param   {boolean}                              multiPartDetection    if set to <pre><code>true</code></pre> it will perform multi part detection.
                 * @param   {boolean}                              holeDetection         if set to <pre><code>true</code></pre> it will perform hole detection.
                 * @return  {System.Collections.Generic.List$1}
                 */
                CreatePolygon$2: function (data, width, hullTolerance, alphaTolerance, multiPartDetection, holeDetection) {
                    return FarseerPhysics.Common.TextureConverter.DetectVertices$2(data, width, hullTolerance, alphaTolerance, multiPartDetection, holeDetection);
                }
            }
        }
    });

    /**
     * This describes the motion of a body/shape for TOI computation.
     Shapes are defined with respect to the body origin, which may
     no coincide with the center of mass. However, to support dynamics
     we must interpolate the center of mass position.
     *
     * @public
     * @class FarseerPhysics.Common.Sweep
     */
    Bridge.define("FarseerPhysics.Common.Sweep", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.Sweep(); }
            }
        },
        fields: {
            /**
             * World angles
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.Sweep
             * @type number
             */
            A: 0,
            A0: 0,
            /**
             * Fraction of the current time step in the range [0,1]
             c0 and a0 are the positions at alpha0.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.Sweep
             * @type number
             */
            Alpha0: 0,
            /**
             * Center world positions
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.Sweep
             * @type Microsoft.Xna.Framework.Vector2
             */
            C: null,
            C0: null,
            /**
             * Local center of mass position
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.Sweep
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalCenter: null
        },
        ctors: {
            init: function () {
                this.C = new Microsoft.Xna.Framework.Vector2();
                this.C0 = new Microsoft.Xna.Framework.Vector2();
                this.LocalCenter = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Get the interpolated transform at a specific time.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Sweep
             * @memberof FarseerPhysics.Common.Sweep
             * @param   {FarseerPhysics.Common.Transform}    xf      The transform.
             * @param   {number}                             beta    beta is a factor in [0,1], where 0 indicates alpha0.
             * @return  {void}
             */
            GetTransform: function (xf, beta) {
                xf.v = new FarseerPhysics.Common.Transform.ctor();
                xf.v.Position.X = (1.0 - beta) * this.C0.X + beta * this.C.X;
                xf.v.Position.Y = (1.0 - beta) * this.C0.Y + beta * this.C.Y;
                var angle = (1.0 - beta) * this.A0 + beta * this.A;
                xf.v.R.Set$1(angle);

                xf.v.Position = Microsoft.Xna.Framework.Vector2.op_Subtraction(xf.v.Position.$clone(), FarseerPhysics.Common.MathUtils.Multiply$1(Bridge.ref(xf.v, "R"), Bridge.ref(this, "LocalCenter")));
            },
            /**
             * Advance the sweep forward, yielding a new initial state.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Sweep
             * @memberof FarseerPhysics.Common.Sweep
             * @param   {number}    alpha    new initial time..
             * @return  {void}
             */
            Advance: function (alpha) {
                System.Diagnostics.Debug.Assert(this.Alpha0 < 1.0);
                var beta = (alpha - this.Alpha0) / (1.0 - this.Alpha0);
                this.C0.X = (1.0 - beta) * this.C0.X + beta * this.C.X;
                this.C0.Y = (1.0 - beta) * this.C0.Y + beta * this.C.Y;
                this.A0 = (1.0 - beta) * this.A0 + beta * this.A;
                this.Alpha0 = alpha;
            },
            /**
             * Normalize the angles.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Sweep
             * @memberof FarseerPhysics.Common.Sweep
             * @return  {void}
             */
            Normalize: function () {
                var d = Microsoft.Xna.Framework.MathHelper.TwoPi * Math.floor(this.A0 / Microsoft.Xna.Framework.MathHelper.TwoPi);
                this.A0 -= d;
                this.A -= d;
            },
            getHashCode: function () {
                var h = Bridge.addHash([1701148611, this.A, this.A0, this.Alpha0, this.C, this.C0, this.LocalCenter]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.Sweep)) {
                    return false;
                }
                return Bridge.equals(this.A, o.A) && Bridge.equals(this.A0, o.A0) && Bridge.equals(this.Alpha0, o.Alpha0) && Bridge.equals(this.C, o.C) && Bridge.equals(this.C0, o.C0) && Bridge.equals(this.LocalCenter, o.LocalCenter);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.Sweep();
                s.A = this.A;
                s.A0 = this.A0;
                s.Alpha0 = this.Alpha0;
                s.C = this.C.$clone();
                s.C0 = this.C0.$clone();
                s.LocalCenter = this.LocalCenter.$clone();
                return s;
            }
        }
    });

    /**
     * @public
     * @class FarseerPhysics.Common.TextureConverter
     */
    Bridge.define("FarseerPhysics.Common.TextureConverter", {
        statics: {
            fields: {
                _CLOSEPIXELS_LENGTH: 0,
                /**
                 * This array is ment to be readonly.
                 It's not because it is accessed very frequently.
                 *
                 * @static
                 * @private
                 * @memberof FarseerPhysics.Common.TextureConverter
                 * @type Array.<number>
                 */
                ClosePixels: null
            },
            ctors: {
                init: function () {
                    this._CLOSEPIXELS_LENGTH = 8;
                    this.ClosePixels = System.Array.create(0, [[-1, -1], [0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0]], System.Int32, 8, 2);
                }
            },
            methods: {
                /**
                 * Detects the vertices of the supplied texture data. (PolygonDetectionType.Integrated)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.TextureConverter
                 * @memberof FarseerPhysics.Common.TextureConverter
                 * @param   {Array.<number>}                    data     The texture data.
                 * @param   {number}                            width    The texture width.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                DetectVertices: function (data, width) {
                    var tc = new FarseerPhysics.Common.TextureConverter.$ctor2(data, width);

                    var detectedVerticesList = tc.DetectVertices();

                    return detectedVerticesList.getItem(0);
                },
                /**
                 * Detects the vertices of the supplied texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.TextureConverter
                 * @memberof FarseerPhysics.Common.TextureConverter
                 * @param   {Array.<number>}                    data             The texture data.
                 * @param   {number}                            width            The texture width.
                 * @param   {boolean}                           holeDetection    if set to <pre><code>true</code></pre> it will perform hole detection.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                DetectVertices$1: function (data, width, holeDetection) {
                    var $t;
                    var tc = ($t = new FarseerPhysics.Common.TextureConverter.$ctor2(data, width), $t.HoleDetection = holeDetection, $t);

                    var detectedVerticesList = tc.DetectVertices();

                    return detectedVerticesList.getItem(0);
                },
                /**
                 * Detects the vertices of the supplied texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.TextureConverter
                 * @memberof FarseerPhysics.Common.TextureConverter
                 * @param   {Array.<number>}                       data                  The texture data.
                 * @param   {number}                               width                 The texture width.
                 * @param   {number}                               hullTolerance         The hull tolerance.
                 * @param   {number}                               alphaTolerance        The alpha tolerance.
                 * @param   {boolean}                              multiPartDetection    if set to <pre><code>true</code></pre> it will perform multi part detection.
                 * @param   {boolean}                              holeDetection         if set to <pre><code>true</code></pre> it will perform hole detection.
                 * @return  {System.Collections.Generic.List$1}
                 */
                DetectVertices$2: function (data, width, hullTolerance, alphaTolerance, multiPartDetection, holeDetection) {
                    var $t;
                    var tc = ($t = new FarseerPhysics.Common.TextureConverter.$ctor2(data, width), $t.HullTolerance = hullTolerance, $t.AlphaTolerance = alphaTolerance, $t.MultipartDetection = multiPartDetection, $t.HoleDetection = holeDetection, $t);

                    var detectedVerticesList = tc.DetectVertices();
                    var result = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    for (var i = 0; i < detectedVerticesList.Count; i = (i + 1) | 0) {
                        result.add(detectedVerticesList.getItem(i));
                    }

                    return result;
                }
            }
        },
        fields: {
            _data: null,
            _dataLength: 0,
            _width: 0,
            _height: 0,
            _polygonDetectionType: 0,
            _alphaTolerance: 0,
            _hullTolerance: 0,
            _holeDetection: false,
            _multipartDetection: false,
            _pixelOffsetOptimization: false,
            _transform: null,
            _tempIsSolidX: 0,
            _tempIsSolidY: 0
        },
        props: {
            /**
             * Get or set the polygon detection type.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function PolygonDetectionType
             * @type FarseerPhysics.Common.VerticesDetectionType
             */
            PolygonDetectionType: {
                get: function () {
                    return this._polygonDetectionType;
                },
                set: function (value) {
                    this._polygonDetectionType = value;
                }
            },
            /**
             * Will detect texture 'holes' if set to true. Slows down the detection. Default is false.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function HoleDetection
             * @type boolean
             */
            HoleDetection: {
                get: function () {
                    return this._holeDetection;
                },
                set: function (value) {
                    this._holeDetection = value;
                }
            },
            /**
             * Will detect texture multiple 'solid' isles if set to true. Slows down the detection. Default is false.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function MultipartDetection
             * @type boolean
             */
            MultipartDetection: {
                get: function () {
                    return this._multipartDetection;
                },
                set: function (value) {
                    this._multipartDetection = value;
                }
            },
            /**
             * Will optimize the vertex positions along the interpolated normal between two edges about a half pixel (post processing). Default is false.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function PixelOffsetOptimization
             * @type boolean
             */
            PixelOffsetOptimization: {
                get: function () {
                    return this._pixelOffsetOptimization;
                },
                set: function (value) {
                    this._pixelOffsetOptimization = value;
                }
            },
            /**
             * Can be used for scaling.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function Transform
             * @type Microsoft.Xna.Framework.Matrix
             */
            Transform: {
                get: function () {
                    return this._transform.$clone();
                },
                set: function (value) {
                    this._transform = value.$clone();
                }
            },
            /**
             * Alpha (coverage) tolerance. Default is 20: Every pixel with a coverage value equal or greater to 20 will be counts as solid.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function AlphaTolerance
             * @type number
             */
            AlphaTolerance: {
                get: function () {
                    return ((this._alphaTolerance >>> 24) & 255);
                },
                set: function (value) {
                    this._alphaTolerance = (value << 24) >>> 0;
                }
            },
            /**
             * Default is 1.5f.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function HullTolerance
             * @type number
             */
            HullTolerance: {
                get: function () {
                    return this._hullTolerance;
                },
                set: function (value) {
                    if (value > 4.0) {
                        this._hullTolerance = 4.0;
                    } else if (value < 0.9) {
                        this._hullTolerance = 0.9;
                    } else {
                        this._hullTolerance = value;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this._transform = new Microsoft.Xna.Framework.Matrix();
                this._transform = Microsoft.Xna.Framework.Matrix.Identity.$clone();
            },
            ctor: function () {
                this.$initialize();
                this.Initialize(null, null, null, null, null, null, null, null);
            },
            $ctor1: function (alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, transform) {
                this.$initialize();
                this.Initialize(null, null, alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, System.Nullable.lift1("$clone", transform));
            },
            $ctor2: function (data, width) {
                this.$initialize();
                this.Initialize(data, width, null, null, null, null, null, null);
            },
            $ctor3: function (data, width, alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, transform) {
                this.$initialize();
                this.Initialize(data, width, alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, System.Nullable.lift1("$clone", transform));
            }
        },
        methods: {
            Initialize: function (data, width, alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, transform) {
                if (data != null && !System.Nullable.hasValue(width)) {
                    throw new System.ArgumentNullException.$ctor3("width", "'width' can't be null if 'data' is set.");
                }

                if (data == null && System.Nullable.hasValue(width)) {
                    throw new System.ArgumentNullException.$ctor3("data", "'data' can't be null if 'width' is set.");
                }

                if (data != null && System.Nullable.hasValue(width)) {
                    this.SetTextureData(data, System.Nullable.getValue(width));
                }

                if (System.Nullable.hasValue(alphaTolerance)) {
                    this.AlphaTolerance = System.Nullable.getValue(alphaTolerance);
                } else {
                    this.AlphaTolerance = 20;
                }

                if (System.Nullable.hasValue(hullTolerance)) {
                    this.HullTolerance = System.Nullable.getValue(hullTolerance);
                } else {
                    this.HullTolerance = 1.5;
                }

                if (System.Nullable.hasValue(holeDetection)) {
                    this.HoleDetection = System.Nullable.getValue(holeDetection);
                } else {
                    this.HoleDetection = false;
                }

                if (System.Nullable.hasValue(multipartDetection)) {
                    this.MultipartDetection = System.Nullable.getValue(multipartDetection);
                } else {
                    this.MultipartDetection = false;
                }

                if (System.Nullable.hasValue(pixelOffsetOptimization)) {
                    this.PixelOffsetOptimization = System.Nullable.getValue(pixelOffsetOptimization);
                } else {
                    this.PixelOffsetOptimization = false;
                }

                if (System.Nullable.hasValue(transform)) {
                    this.Transform = System.Nullable.getValue(transform).$clone();
                } else {
                    this.Transform = Microsoft.Xna.Framework.Matrix.Identity.$clone();
                }
            },
            /**
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {Array.<number>}    data     
             * @param   {number}            width
             * @return  {void}
             */
            SetTextureData: function (data, width) {
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "'data' can't be null.");
                }

                if (data.length < 4) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("data", "'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size.");
                }

                if (width < 2) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("width", "'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size.");
                }

                if (data.length % width !== 0) {
                    throw new System.ArgumentException.$ctor1("'width' has an invalid value.");
                }

                this._data = data;
                this._dataLength = this._data.length;
                this._width = width;
                this._height = (Bridge.Int.div(this._dataLength, width)) | 0;
            },
            DetectVertices: function () {

                if (this._data == null) {
                    throw new System.Exception("'_data' can't be null. You have to use SetTextureData(uint[] data, int width) before calling this method.");
                }

                if (this._data.length < 4) {
                    throw new System.Exception("'_data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size. You have to use SetTextureData(uint[] data, int width) before calling this method.");
                }

                if (this._width < 2) {
                    throw new System.Exception("'_width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size. You have to use SetTextureData(uint[] data, int width) before calling this method.");
                }

                if (this._data.length % this._width !== 0) {
                    throw new System.Exception("'_width' has an invalid value. You have to use SetTextureData(uint[] data, int width) before calling this method.");
                }



                var detectedPolygons = { v : new (System.Collections.Generic.List$1(FarseerPhysics.Common.DetectedVertices)).ctor() };

                var polygon;
                var holePolygon;

                var holeEntrance = null;
                var polygonEntrance = { v : null };

                var blackList = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();

                var searchOn;
                do {
                    if (detectedPolygons.v.Count === 0) {
                        polygon = new FarseerPhysics.Common.DetectedVertices.$ctor1(this.CreateSimplePolygon(Microsoft.Xna.Framework.Vector2.Zero.$clone(), Microsoft.Xna.Framework.Vector2.Zero.$clone()));

                        if (polygon.Count > 2) {
                            polygonEntrance.v = this.GetTopMostVertex(polygon);
                        }
                    } else if (System.Nullable.hasValue(polygonEntrance.v)) {
                        polygon = new FarseerPhysics.Common.DetectedVertices.$ctor1(this.CreateSimplePolygon(System.Nullable.getValue(polygonEntrance.v).$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(System.Nullable.getValue(polygonEntrance.v).X - 1.0, System.Nullable.getValue(polygonEntrance.v).Y)));
                    } else {
                        break;
                    }

                    searchOn = false;


                    if (polygon.Count > 2) {
                        if (this._holeDetection) {
                            do {
                                holeEntrance = this.SearchHoleEntrance(polygon, System.Nullable.lift1("$clone", holeEntrance));

                                if (System.Nullable.hasValue(holeEntrance)) {
                                    if (!blackList.contains(System.Nullable.getValue(holeEntrance).$clone())) {
                                        blackList.add(System.Nullable.getValue(holeEntrance).$clone());
                                        holePolygon = this.CreateSimplePolygon(System.Nullable.getValue(holeEntrance).$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(System.Nullable.getValue(holeEntrance).X + 1, System.Nullable.getValue(holeEntrance).Y));

                                        if (holePolygon != null && holePolygon.Count > 2) {
                                            switch (this._polygonDetectionType) {
                                                case FarseerPhysics.Common.VerticesDetectionType.Integrated: 
                                                    holePolygon.add(holePolygon.getItem(0).$clone());
                                                    var vertex1Index = { }, vertex2Index = { };
                                                    if (this.SplitPolygonEdge(polygon, System.Nullable.getValue(holeEntrance).$clone(), vertex1Index, vertex2Index)) {
                                                        polygon.InsertRange(vertex2Index.v, holePolygon);
                                                    }
                                                    break;
                                                case FarseerPhysics.Common.VerticesDetectionType.Separated: 
                                                    if (polygon.Holes == null) {
                                                        polygon.Holes = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                                                    }
                                                    polygon.Holes.add(holePolygon);
                                                    break;
                                            }
                                        }
                                    } else {
                                        break;
                                    }
                                } else {
                                    break;
                                }
                            } while (true);
                        }

                        detectedPolygons.v.add(polygon);
                    }

                    if (this._multipartDetection || polygon.Count <= 2) {
                        if (this.SearchNextHullEntrance(detectedPolygons.v, System.Nullable.getValue(polygonEntrance.v).$clone(), polygonEntrance)) {
                            searchOn = true;
                        }
                    }
                } while (searchOn);

                if (detectedPolygons.v == null || (detectedPolygons.v != null && detectedPolygons.v.Count === 0)) {
                    throw new System.Exception("Couldn't detect any vertices.");
                }


                if (this.PolygonDetectionType === FarseerPhysics.Common.VerticesDetectionType.Separated) {
                    this.ApplyTriangulationCompatibleWinding(detectedPolygons);
                }

                if (this._pixelOffsetOptimization) {
                    this.ApplyPixelOffsetOptimization(detectedPolygons);
                }

                if (Microsoft.Xna.Framework.Matrix.op_Inequality(this._transform.$clone(), Microsoft.Xna.Framework.Matrix.Identity.$clone())) {
                    this.ApplyTransform(detectedPolygons);
                }


                return detectedPolygons.v;
            },
            ApplyTriangulationCompatibleWinding: function (detectedPolygons) {
                for (var i = 0; i < detectedPolygons.v.Count; i = (i + 1) | 0) {
                    detectedPolygons.v.getItem(i).Reverse();

                    if (detectedPolygons.v.getItem(i).Holes != null && detectedPolygons.v.getItem(i).Holes.Count > 0) {
                        for (var j = 0; j < detectedPolygons.v.getItem(i).Holes.Count; j = (j + 1) | 0) {
                            detectedPolygons.v.getItem(i).Holes.getItem(j).Reverse();
                        }
                    }
                }
            },
            ApplyPixelOffsetOptimization: function (detectedPolygons) {

            },
            ApplyTransform: function (detectedPolygons) {
                for (var i = 0; i < detectedPolygons.v.Count; i = (i + 1) | 0) {
                    detectedPolygons.v.getItem(i).Transform(this._transform.$clone());
                }
            },
            IsSolid: function (v) {
                this._tempIsSolidX = Bridge.Int.clip32(v.v.X);
                this._tempIsSolidY = Bridge.Int.clip32(v.v.Y);

                if (this._tempIsSolidX >= 0 && this._tempIsSolidX < this._width && this._tempIsSolidY >= 0 && this._tempIsSolidY < this._height) {
                    return (this._data[System.Array.index(((this._tempIsSolidX + Bridge.Int.mul(this._tempIsSolidY, this._width)) | 0), this._data)] >= this._alphaTolerance);
                }

                return false;
            },
            IsSolid$2: function (x, y) {
                if (x.v >= 0 && x.v < this._width && y.v >= 0 && y.v < this._height) {
                    return (this._data[System.Array.index(((x.v + Bridge.Int.mul(y.v, this._width)) | 0), this._data)] >= this._alphaTolerance);
                }

                return false;
            },
            IsSolid$1: function (index) {
                if (index.v >= 0 && index.v < this._dataLength) {
                    return (this._data[System.Array.index(index.v, this._data)] >= this._alphaTolerance);
                }

                return false;
            },
            InBounds: function (coord) {
                return (coord.v.X >= 0.0 && coord.v.X < this._width && coord.v.Y >= 0.0 && coord.v.Y < this._height);
            },
            /**
             * Function to search for an entrance point of a hole in a polygon. It searches the polygon from top to bottom between the polygon edges.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {FarseerPhysics.Common.Vertices}      polygon             The polygon to search in.
             * @param   {?Microsoft.Xna.Framework.Vector2}    lastHoleEntrance    The last entrance point.
             * @return  {?Microsoft.Xna.Framework.Vector2}                        The next holes entrance point. Null if ther are no holes.
             */
            SearchHoleEntrance: function (polygon, lastHoleEntrance) {
                if (polygon == null) {
                    throw new System.ArgumentNullException.$ctor1("'polygon' can't be null.");
                }

                if (polygon.Count < 3) {
                    throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");
                }


                var xCoords;
                var entrance;

                var startY;
                var endY;

                var lastSolid = 0;
                var foundSolid;
                var foundTransparent;

                if (System.Nullable.hasValue(lastHoleEntrance)) {
                    startY = Bridge.Int.clip32(System.Nullable.getValue(lastHoleEntrance).Y);
                } else {
                    startY = Bridge.Int.clip32(this.GetTopMostCoord(polygon));
                }

                endY = Bridge.Int.clip32(this.GetBottomMostCoord(polygon));

                if (startY > 0 && startY < this._height && endY > 0 && endY < this._height) {
                    for (var y = { v : startY }; y.v <= endY; y.v = (y.v + 1) | 0) {
                        xCoords = this.SearchCrossingEdges$1(polygon, y.v);

                        if (xCoords.Count > 1 && xCoords.Count % 2 === 0) {
                            for (var i = 0; i < xCoords.Count; i = (i + 2) | 0) {
                                foundSolid = false;
                                foundTransparent = false;

                                for (var x = { v : Bridge.Int.clip32(xCoords.getItem(i)) }; x.v <= Bridge.Int.clip32(xCoords.getItem(((i + 1) | 0))); x.v = (x.v + 1) | 0) {



                                    if (this.IsSolid$2(x, y)) {
                                        if (!foundTransparent) {
                                            foundSolid = true;
                                            lastSolid = x.v;
                                        }

                                        if (foundSolid && foundTransparent) {
                                            entrance = new Microsoft.Xna.Framework.Vector2.$ctor2(lastSolid, y.v);

                                            if (this.DistanceToHullAcceptable$1(polygon, System.Nullable.getValue(entrance).$clone(), true)) {
                                                return System.Nullable.lift1("$clone", entrance);
                                            }

                                            entrance = null;
                                            break;
                                        }
                                    } else {
                                        if (foundSolid) {
                                            foundTransparent = true;
                                        }
                                    }
                                }
                            }
                        } else {
                            if (xCoords.Count % 2 === 0) {
                                System.Diagnostics.Debug.WriteLine$2("SearchCrossingEdges() % 2 != 0");
                            }
                        }
                    }
                }

                return null;
            },
            DistanceToHullAcceptable: function (polygon, point, higherDetail) {
                if (polygon == null) {
                    throw new System.ArgumentNullException.$ctor3("polygon", "'polygon' can't be null.");
                }

                if (polygon.Count < 3) {
                    throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");
                }

                if (this.DistanceToHullAcceptable$1(Bridge.cast(polygon, FarseerPhysics.Common.Vertices), point.$clone(), higherDetail)) {
                    if (polygon.Holes != null) {
                        for (var i = 0; i < polygon.Holes.Count; i = (i + 1) | 0) {
                            if (!this.DistanceToHullAcceptable$1(polygon.Holes.getItem(i), point.$clone(), higherDetail)) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                return false;
            },
            DistanceToHullAcceptable$1: function (polygon, point, higherDetail) {
                point = {v:point};
                if (polygon == null) {
                    throw new System.ArgumentNullException.$ctor3("polygon", "'polygon' can't be null.");
                }

                if (polygon.Count < 3) {
                    throw new System.ArgumentException.$ctor1("'polygon.Count' can't be less then 3.");
                }


                var edgeVertex2 = { v : polygon.getItem(((polygon.Count - 1) | 0)).$clone() };
                var edgeVertex1 = { v : new Microsoft.Xna.Framework.Vector2() };

                if (higherDetail) {
                    for (var i = 0; i < polygon.Count; i = (i + 1) | 0) {
                        edgeVertex1.v = polygon.getItem(i).$clone();

                        if (FarseerPhysics.Common.LineTools.DistanceBetweenPointAndLineSegment(point, edgeVertex1, edgeVertex2) <= this._hullTolerance || FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(point, edgeVertex1) <= this._hullTolerance) {
                            return false;
                        }

                        edgeVertex2.v = polygon.getItem(i).$clone();
                    }

                    return true;
                } else {
                    for (var i1 = 0; i1 < polygon.Count; i1 = (i1 + 1) | 0) {
                        edgeVertex1.v = polygon.getItem(i1).$clone();

                        if (FarseerPhysics.Common.LineTools.DistanceBetweenPointAndLineSegment(point, edgeVertex1, edgeVertex2) <= this._hullTolerance) {
                            return false;
                        }

                        edgeVertex2.v = polygon.getItem(i1).$clone();
                    }

                    return true;
                }
            },
            InPolygon: function (polygon, point) {
                var inPolygon = !this.DistanceToHullAcceptable(polygon, point.$clone(), true);

                if (!inPolygon) {
                    var xCoords = this.SearchCrossingEdges(polygon, Bridge.Int.clip32(point.Y));

                    if (xCoords.Count > 0 && xCoords.Count % 2 === 0) {
                        for (var i = 0; i < xCoords.Count; i = (i + 2) | 0) {
                            if (xCoords.getItem(i) <= point.X && xCoords.getItem(((i + 1) | 0)) >= point.X) {
                                return true;
                            }
                        }
                    }

                    return false;
                }

                return true;
            },
            GetTopMostVertex: function (vertices) {
                var topMostValue = 3.40282347E+38;
                var topMost = null;

                for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                    if (topMostValue > vertices.getItem(i).$clone().Y) {
                        topMostValue = vertices.getItem(i).$clone().Y;
                        topMost = vertices.getItem(i).$clone();
                    }
                }

                return System.Nullable.lift1("$clone", topMost);
            },
            GetTopMostCoord: function (vertices) {
                var returnValue = 3.40282347E+38;

                for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                    if (returnValue > vertices.getItem(i).$clone().Y) {
                        returnValue = vertices.getItem(i).$clone().Y;
                    }
                }

                return returnValue;
            },
            GetBottomMostCoord: function (vertices) {
                var returnValue = -3.40282347E+38;

                for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                    if (returnValue < vertices.getItem(i).$clone().Y) {
                        returnValue = vertices.getItem(i).$clone().Y;
                    }
                }

                return returnValue;
            },
            SearchCrossingEdges: function (polygon, y) {
                if (polygon == null) {
                    throw new System.ArgumentNullException.$ctor3("polygon", "'polygon' can't be null.");
                }

                if (polygon.Count < 3) {
                    throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");
                }

                var result = this.SearchCrossingEdges$1(Bridge.cast(polygon, FarseerPhysics.Common.Vertices), y);

                if (polygon.Holes != null) {
                    for (var i = 0; i < polygon.Holes.Count; i = (i + 1) | 0) {
                        result.AddRange(this.SearchCrossingEdges$1(polygon.Holes.getItem(i), y));
                    }
                }

                result.Sort();
                return result;
            },
            /**
             * Searches the polygon for the x coordinates of the edges that cross the specified y coordinate.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {FarseerPhysics.Common.Vertices}       polygon    Polygon to search in.
             * @param   {number}                               y          Y coordinate to check for edges.
             * @return  {System.Collections.Generic.List$1}               Descending sorted list of x coordinates of edges that cross the specified y coordinate.
             */
            SearchCrossingEdges$1: function (polygon, y) {

                var edges = new (System.Collections.Generic.List$1(System.Single)).ctor();

                var slope = new Microsoft.Xna.Framework.Vector2();
                var vertex1 = new Microsoft.Xna.Framework.Vector2();
                var vertex2 = new Microsoft.Xna.Framework.Vector2();

                var nextSlope = new Microsoft.Xna.Framework.Vector2();
                var nextVertex = new Microsoft.Xna.Framework.Vector2();

                var addFind;

                if (polygon.Count > 2) {
                    vertex2 = polygon.getItem(((polygon.Count - 1) | 0)).$clone();

                    for (var i = 0; i < polygon.Count; i = (i + 1) | 0) {
                        vertex1 = polygon.getItem(i).$clone();

                        if ((vertex1.Y >= y && vertex2.Y <= y) || (vertex1.Y <= y && vertex2.Y >= y)) {
                            if (vertex1.Y !== vertex2.Y) {
                                addFind = true;
                                slope = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex2.$clone(), vertex1.$clone());

                                if (vertex1.Y === y) {
                                    nextVertex = polygon.getItem((((i + 1) | 0)) % polygon.Count).$clone();
                                    nextSlope = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex1.$clone(), nextVertex.$clone());

                                    if (slope.Y > 0) {
                                        addFind = (nextSlope.Y <= 0);
                                    } else {
                                        addFind = (nextSlope.Y >= 0);
                                    }
                                }

                                if (addFind) {
                                    edges.add((y - vertex1.Y) / slope.Y * slope.X + vertex1.X);
                                }
                            }
                        }

                        vertex2 = vertex1.$clone();
                    }
                }

                edges.Sort();
                return edges;
            },
            SplitPolygonEdge: function (polygon, coordInsideThePolygon, vertex1Index, vertex2Index) {
                var slope = new Microsoft.Xna.Framework.Vector2();
                var nearestEdgeVertex1Index = 0;
                var nearestEdgeVertex2Index = 0;
                var edgeFound = false;

                var shortestDistance = 3.40282347E+38;

                var edgeCoordFound = false;
                var foundEdgeCoord = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };

                var xCoords = this.SearchCrossingEdges$1(polygon, Bridge.Int.clip32(coordInsideThePolygon.Y));

                vertex1Index.v = 0;
                vertex2Index.v = 0;

                foundEdgeCoord.v.Y = coordInsideThePolygon.Y;

                if (xCoords != null && xCoords.Count > 1 && xCoords.Count % 2 === 0) {
                    var distance;
                    for (var i = 0; i < xCoords.Count; i = (i + 1) | 0) {
                        if (xCoords.getItem(i) < coordInsideThePolygon.X) {
                            distance = coordInsideThePolygon.X - xCoords.getItem(i);

                            if (distance < shortestDistance) {
                                shortestDistance = distance;
                                foundEdgeCoord.v.X = xCoords.getItem(i);

                                edgeCoordFound = true;
                            }
                        }
                    }

                    if (edgeCoordFound) {
                        shortestDistance = 3.40282347E+38;

                        var edgeVertex2Index = (polygon.Count - 1) | 0;

                        var edgeVertex1Index;
                        for (edgeVertex1Index = 0; edgeVertex1Index < polygon.Count; edgeVertex1Index = (edgeVertex1Index + 1) | 0) {
                            var tempVector1 = { v : polygon.getItem(edgeVertex1Index).$clone() };
                            var tempVector2 = { v : polygon.getItem(edgeVertex2Index).$clone() };
                            distance = FarseerPhysics.Common.LineTools.DistanceBetweenPointAndLineSegment(foundEdgeCoord, tempVector1, tempVector2);
                            if (distance < shortestDistance) {
                                shortestDistance = distance;

                                nearestEdgeVertex1Index = edgeVertex1Index;
                                nearestEdgeVertex2Index = edgeVertex2Index;

                                edgeFound = true;
                            }

                            edgeVertex2Index = edgeVertex1Index;
                        }

                        if (edgeFound) {
                            slope = Microsoft.Xna.Framework.Vector2.op_Subtraction(polygon.getItem(nearestEdgeVertex2Index).$clone(), polygon.getItem(nearestEdgeVertex1Index).$clone());
                            slope.Normalize();

                            var tempVector = { v : polygon.getItem(nearestEdgeVertex1Index).$clone() };
                            distance = FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(tempVector, foundEdgeCoord);

                            vertex1Index.v = nearestEdgeVertex1Index;
                            vertex2Index.v = (nearestEdgeVertex1Index + 1) | 0;

                            polygon.insert(nearestEdgeVertex1Index, Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(distance, slope.$clone()), polygon.getItem(vertex1Index.v).$clone()));
                            polygon.insert(nearestEdgeVertex1Index, Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(distance, slope.$clone()), polygon.getItem(vertex2Index.v).$clone()));

                            return true;
                        }
                    }
                }

                return false;
            },
            /**
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {Microsoft.Xna.Framework.Vector2}    entrance    
             * @param   {Microsoft.Xna.Framework.Vector2}    last
             * @return  {FarseerPhysics.Common.Vertices}
             */
            CreateSimplePolygon: function (entrance, last) {
                entrance = {v:entrance};
                last = {v:last};
                var entranceFound = false;
                var endOfHull = false;

                var polygon = new FarseerPhysics.Common.Vertices.$ctor3(32);
                var hullArea = new FarseerPhysics.Common.Vertices.$ctor3(32);
                var endOfHullArea = new FarseerPhysics.Common.Vertices.$ctor3(32);

                var current = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };


                if (Microsoft.Xna.Framework.Vector2.op_Equality(entrance.v.$clone(), Microsoft.Xna.Framework.Vector2.Zero.$clone()) || !this.InBounds(entrance)) {
                    entranceFound = this.SearchHullEntrance(entrance);

                    if (entranceFound) {
                        current.v = new Microsoft.Xna.Framework.Vector2.$ctor2(entrance.v.X - 1.0, entrance.v.Y);
                    }
                } else {
                    if (this.IsSolid(entrance)) {
                        if (this.IsNearPixel(entrance, last)) {
                            current.v = last.v.$clone();
                            entranceFound = true;
                        } else {
                            var temp = { v : new Microsoft.Xna.Framework.Vector2() };
                            if (this.SearchNearPixels(false, entrance, temp)) {
                                current.v = temp.v.$clone();
                                entranceFound = true;
                            } else {
                                entranceFound = false;
                            }
                        }
                    }
                }


                if (entranceFound) {
                    polygon.add(entrance.v.$clone());
                    hullArea.add(entrance.v.$clone());

                    var next = { v : entrance.v.$clone() };

                    do {
                        var outstanding = { v : new Microsoft.Xna.Framework.Vector2() };
                        if (this.SearchForOutstandingVertex(hullArea, outstanding)) {
                            if (endOfHull) {
                                if (endOfHullArea.contains(outstanding.v.$clone())) {
                                    polygon.add(outstanding.v.$clone());
                                }

                                break;
                            }

                            polygon.add(outstanding.v.$clone());
                            hullArea.RemoveRange(0, hullArea.indexOf(outstanding.v.$clone()));
                        }

                        last.v = current.v.$clone();
                        current.v = next.v.$clone();

                        if (this.GetNextHullPoint(last, current, next)) {
                            hullArea.add(next.v.$clone());
                        } else {
                            break;
                        }

                        if (Microsoft.Xna.Framework.Vector2.op_Equality(next.v.$clone(), entrance.v.$clone()) && !endOfHull) {
                            endOfHull = true;
                            endOfHullArea.AddRange(hullArea);

                            if (endOfHullArea.contains(entrance.v.$clone())) {
                                endOfHullArea.remove(entrance.v.$clone());
                            }
                        }

                    } while (true);
                }

                return polygon;
            },
            SearchNearPixels: function (searchingForSolidPixel, current, foundPixel) {
                for (var i = 0; i < FarseerPhysics.Common.TextureConverter._CLOSEPIXELS_LENGTH; i = (i + 1) | 0) {
                    var x = { v : (Bridge.Int.clip32(current.v.X) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([i, 0])) | 0 };
                    var y = { v : (Bridge.Int.clip32(current.v.Y) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([i, 1])) | 0 };

                    if (!searchingForSolidPixel ^ this.IsSolid$2(x, y)) {
                        foundPixel.v = new Microsoft.Xna.Framework.Vector2.$ctor2(x.v, y.v);
                        return true;
                    }
                }

                foundPixel.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return false;
            },
            IsNearPixel: function (current, near) {
                for (var i = 0; i < FarseerPhysics.Common.TextureConverter._CLOSEPIXELS_LENGTH; i = (i + 1) | 0) {
                    var x = (Bridge.Int.clip32(current.v.X) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([i, 0])) | 0;
                    var y = (Bridge.Int.clip32(current.v.Y) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([i, 1])) | 0;

                    if (x >= 0 && x <= this._width && y >= 0 && y <= this._height) {
                        if (x === Bridge.Int.clip32(near.v.X) && y === Bridge.Int.clip32(near.v.Y)) {
                            return true;
                        }
                    }
                }

                return false;
            },
            SearchHullEntrance: function (entrance) {
                for (var y = { v : 0 }; y.v <= this._height; y.v = (y.v + 1) | 0) {
                    for (var x = { v : 0 }; x.v <= this._width; x.v = (x.v + 1) | 0) {
                        if (this.IsSolid$2(x, y)) {
                            entrance.v = new Microsoft.Xna.Framework.Vector2.$ctor2(x.v, y.v);
                            return true;
                        }
                    }
                }

                entrance.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return false;
            },
            /**
             * Searches for the next shape.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {System.Collections.Generic.List$1}    detectedPolygons    Already detected polygons.
             * @param   {Microsoft.Xna.Framework.Vector2}      start               Search start coordinate.
             * @param   {System.Nullable}                      entrance            Returns the found entrance coordinate. Null if no other shapes found.
             * @return  {boolean}                                                  True if a new shape was found.
             */
            SearchNextHullEntrance: function (detectedPolygons, start, entrance) {
                var x;

                var foundTransparent = false;
                var inPolygon = false;

                for (var i = { v : (Bridge.Int.clip32(start.X) + Bridge.Int.mul(Bridge.Int.clip32(start.Y), this._width)) | 0 }; i.v <= this._dataLength; i.v = (i.v + 1) | 0) {
                    if (this.IsSolid$1(i)) {
                        if (foundTransparent) {
                            x = i.v % this._width;
                            entrance.v = new Microsoft.Xna.Framework.Vector2.$ctor2(x, (((i.v - x) | 0)) / this._width);

                            inPolygon = false;
                            for (var polygonIdx = 0; polygonIdx < detectedPolygons.Count; polygonIdx = (polygonIdx + 1) | 0) {
                                if (this.InPolygon(detectedPolygons.getItem(polygonIdx), System.Nullable.getValue(entrance.v).$clone())) {
                                    inPolygon = true;
                                    break;
                                }
                            }

                            if (inPolygon) {
                                foundTransparent = false;
                            } else {
                                return true;
                            }
                        }
                    } else {
                        foundTransparent = true;
                    }
                }

                entrance.v = null;
                return false;
            },
            GetNextHullPoint: function (last, current, next) {
                var x = { };
                var y = { };

                var indexOfFirstPixelToCheck = this.GetIndexOfFirstPixelToCheck(last, current);
                var indexOfPixelToCheck;

                for (var i = 0; i < FarseerPhysics.Common.TextureConverter._CLOSEPIXELS_LENGTH; i = (i + 1) | 0) {
                    indexOfPixelToCheck = (((indexOfFirstPixelToCheck + i) | 0)) % FarseerPhysics.Common.TextureConverter._CLOSEPIXELS_LENGTH;

                    x.v = (Bridge.Int.clip32(current.v.X) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([indexOfPixelToCheck, 0])) | 0;
                    y.v = (Bridge.Int.clip32(current.v.Y) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([indexOfPixelToCheck, 1])) | 0;

                    if (x.v >= 0 && x.v < this._width && y.v >= 0 && y.v <= this._height) {
                        if (this.IsSolid$2(x, y)) {
                            next.v = new Microsoft.Xna.Framework.Vector2.$ctor2(x.v, y.v);
                            return true;
                        }
                    }
                }

                next.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return false;
            },
            SearchForOutstandingVertex: function (hullArea, outstanding) {
                var outstandingResult = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var found = false;

                if (hullArea.Count > 2) {
                    var hullAreaLastPoint = (hullArea.Count - 1) | 0;

                    var tempVector1 = { v : new Microsoft.Xna.Framework.Vector2() };
                    var tempVector2 = { v : hullArea.getItem(0).$clone() };
                    var tempVector3 = { v : hullArea.getItem(hullAreaLastPoint).$clone() };

                    for (var i = 1; i < hullAreaLastPoint; i = (i + 1) | 0) {
                        tempVector1.v = hullArea.getItem(i).$clone();

                        if (FarseerPhysics.Common.LineTools.DistanceBetweenPointAndLineSegment(tempVector1, tempVector2, tempVector3) >= this._hullTolerance) {
                            outstandingResult = hullArea.getItem(i).$clone();
                            found = true;
                            break;
                        }
                    }
                }

                outstanding.v = outstandingResult.$clone();
                return found;
            },
            GetIndexOfFirstPixelToCheck: function (last, current) {


                switch (Bridge.Int.clip32(current.v.X - last.v.X)) {
                    case 1: 
                        switch (Bridge.Int.clip32(current.v.Y - last.v.Y)) {
                            case 1: 
                                return 1;
                            case 0: 
                                return 0;
                            case -1: 
                                return 7;
                        }
                        break;
                    case 0: 
                        switch (Bridge.Int.clip32(current.v.Y - last.v.Y)) {
                            case 1: 
                                return 2;
                            case -1: 
                                return 6;
                        }
                        break;
                    case -1: 
                        switch (Bridge.Int.clip32(current.v.Y - last.v.Y)) {
                            case 1: 
                                return 3;
                            case 0: 
                                return 4;
                            case -1: 
                                return 5;
                        }
                        break;
                }

                return 0;
            }
        }
    });

    /**
     * A transform contains translation and rotation. It is used to represent
     the position and orientation of rigid frames.
     *
     * @public
     * @class FarseerPhysics.Common.Transform
     */
    Bridge.define("FarseerPhysics.Common.Transform", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.Transform(); }
            }
        },
        fields: {
            Position: null,
            R: null
        },
        props: {
            /**
             * Calculate the angle that the rotation matrix represents.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Common.Transform
             * @function Angle
             * @type number
             */
            Angle: {
                get: function () {
                    return Math.atan2(this.R.Col1.Y, this.R.Col1.X);
                }
            }
        },
        ctors: {
            init: function () {
                this.Position = new Microsoft.Xna.Framework.Vector2();
                this.R = new FarseerPhysics.Common.Mat22();
            },
            /**
             * Initialize using a position vector and a rotation matrix.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Transform
             * @memberof FarseerPhysics.Common.Transform
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The position.
             * @param   {FarseerPhysics.Common.Mat22}        r           The r.
             * @return  {void}
             */
            $ctor1: function (position, r) {
                this.$initialize();
                this.Position = position.v.$clone();
                this.R = r.v.$clone();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Set this to the identity transform.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Transform
             * @memberof FarseerPhysics.Common.Transform
             * @return  {void}
             */
            SetIdentity: function () {
                this.Position = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.R.SetIdentity();
            },
            /**
             * Set this based on the position and angle.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Transform
             * @memberof FarseerPhysics.Common.Transform
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The position.
             * @param   {number}                             angle       The angle.
             * @return  {void}
             */
            Set: function (position, angle) {
                this.Position = position.$clone();
                this.R.Set$1(angle);
            },
            getHashCode: function () {
                var h = Bridge.addHash([3771783476, this.Position, this.R]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.Transform)) {
                    return false;
                }
                return Bridge.equals(this.Position, o.Position) && Bridge.equals(this.R, o.R);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.Transform();
                s.Position = this.Position.$clone();
                s.R = this.R.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Vertices.PolyNode", {
        $kind: "nested class",
        statics: {
            fields: {
                MaxConnected: 0
            },
            ctors: {
                init: function () {
                    this.MaxConnected = 32;
                }
            }
        },
        fields: {
            Connected: null,
            NConnected: 0,
            Position: null
        },
        ctors: {
            init: function () {
                this.Position = new Microsoft.Xna.Framework.Vector2();
                this.Connected = System.Array.init(FarseerPhysics.Common.Vertices.PolyNode.MaxConnected, null, FarseerPhysics.Common.Vertices.PolyNode);
            },
            ctor: function (pos) {
                this.$initialize();
                this.Position = pos.$clone();
                this.NConnected = 0;
            }
        },
        methods: {
            IsRighter: function (sinA, cosA, sinB, cosB) {
                if (sinA < 0) {
                    if (sinB > 0 || cosA <= cosB) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    if (sinB < 0 || cosA <= cosB) {
                        return false;
                    } else {
                        return true;
                    }
                }
            },
            AddConnection: function (toMe) {
                System.Diagnostics.Debug.Assert(this.NConnected < FarseerPhysics.Common.Vertices.PolyNode.MaxConnected);

                for (var i = 0; i < this.NConnected; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.Connected[System.Array.index(i, this.Connected)], toMe)) {
                        return;
                    }
                }
                this.Connected[System.Array.index(this.NConnected, this.Connected)] = toMe;
                this.NConnected = (this.NConnected + 1) | 0;
            },
            RemoveConnection: function (fromMe) {
                var isFound = false;
                var foundIndex = -1;
                for (var i = 0; i < this.NConnected; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(fromMe, this.Connected[System.Array.index(i, this.Connected)])) {
                        isFound = true;
                        foundIndex = i;
                        break;
                    }
                }
                System.Diagnostics.Debug.Assert(isFound);
                this.NConnected = (this.NConnected - 1) | 0;
                for (var i1 = foundIndex; i1 < this.NConnected; i1 = (i1 + 1) | 0) {
                    this.Connected[System.Array.index(i1, this.Connected)] = this.Connected[System.Array.index(((i1 + 1) | 0), this.Connected)];
                }
            },
            GetRightestConnection: function (incoming) {
                if (this.NConnected === 0) {
                    System.Diagnostics.Debug.Assert(false);
                }
                if (this.NConnected === 1) {
                    return incoming;
                }
                var inDir = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Position.$clone(), incoming.Position.$clone());

                var inLength = inDir.Length();
                inDir.Normalize();

                System.Diagnostics.Debug.Assert(inLength > FarseerPhysics.Settings.Epsilon);

                var result = null;
                for (var i = 0; i < this.NConnected; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.Connected[System.Array.index(i, this.Connected)], incoming)) {
                        continue;
                    }
                    var testDir = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Connected[System.Array.index(i, this.Connected)].Position.$clone(), this.Position.$clone());
                    var testLengthSqr = testDir.LengthSquared();
                    testDir.Normalize();
                    System.Diagnostics.Debug.Assert(testLengthSqr >= 1.42108547E-14);
                    var myCos = Microsoft.Xna.Framework.Vector2.Dot(inDir.$clone(), testDir.$clone());
                    var mySin = FarseerPhysics.Common.MathUtils.Cross$2(inDir.$clone(), testDir.$clone());
                    if (result != null) {
                        var resultDir = Microsoft.Xna.Framework.Vector2.op_Subtraction(result.Position.$clone(), this.Position.$clone());
                        resultDir.Normalize();
                        var resCos = Microsoft.Xna.Framework.Vector2.Dot(inDir.$clone(), resultDir.$clone());
                        var resSin = FarseerPhysics.Common.MathUtils.Cross$2(inDir.$clone(), resultDir.$clone());
                        if (this.IsRighter(mySin, myCos, resSin, resCos)) {
                            result = this.Connected[System.Array.index(i, this.Connected)];
                        }
                    } else {
                        result = this.Connected[System.Array.index(i, this.Connected)];
                    }
                }

                System.Diagnostics.Debug.Assert(result != null);

                return result;
            },
            GetRightestConnection$1: function (incomingDir) {
                var diff = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Position.$clone(), incomingDir.$clone());
                var temp = new FarseerPhysics.Common.Vertices.PolyNode(diff.$clone());
                var res = this.GetRightestConnection(temp);
                System.Diagnostics.Debug.Assert(res != null);
                return res;
            }
        }
    });

    /**
     * The detection type affects the resulting polygon data.
     *
     * @public
     * @class FarseerPhysics.Common.VerticesDetectionType
     */
    Bridge.define("FarseerPhysics.Common.VerticesDetectionType", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Holes are integrated into the main polygon.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Common.VerticesDetectionType
                 * @constant
                 * @default 0
                 * @type FarseerPhysics.Common.VerticesDetectionType
                 */
                Integrated: 0,
                /**
                 * The data of the main polygon and hole polygons is returned separately.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Common.VerticesDetectionType
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Common.VerticesDetectionType
                 */
                Separated: 1
            }
        }
    });

    /** @namespace FarseerPhysics.Controllers */

    /**
     * Modes for Decay. Actual Decay must be implemented in inheriting 
     classes
     *
     * @public
     * @class number
     */
    Bridge.define("FarseerPhysics.Controllers.AbstractForceController.DecayModes", {
        $kind: "nested enum",
        statics: {
            fields: {
                None: 0,
                Step: 1,
                Linear: 2,
                InverseSquare: 3,
                Curve: 4
            }
        }
    });

    /**
     * Forcetypes are used in the decay math to properly get the distance.
     They are also used to draw a representation in DebugView
     *
     * @public
     * @class number
     */
    Bridge.define("FarseerPhysics.Controllers.AbstractForceController.ForceTypes", {
        $kind: "nested enum",
        statics: {
            fields: {
                Point: 0,
                Line: 1,
                Area: 2
            }
        }
    });

    /**
     * Timing Modes
     Switched: Standard on/off mode using the baseclass enabled property
     Triggered: When the Trigger() method is called the force is active 
     for a specified Impulse Length
     Curve: Still to be defined. The basic idea is having a Trigger 
     combined with a curve for the strength
     *
     * @public
     * @class number
     */
    Bridge.define("FarseerPhysics.Controllers.AbstractForceController.TimingModes", {
        $kind: "nested enum",
        statics: {
            fields: {
                Switched: 0,
                Triggered: 1,
                Curve: 2
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.ControllerFilter", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Controllers.ControllerFilter(); }
            }
        },
        fields: {
            ControllerFlags: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Ignores the controller. The controller has no effect on this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.ControllerFilter
             * @memberof FarseerPhysics.Controllers.ControllerFilter
             * @param   {FarseerPhysics.Controllers.ControllerType}    controller    The controller type.
             * @return  {void}
             */
            IgnoreController: function (controller) {
                this.ControllerFlags |= controller;
            },
            /**
             * Restore the controller. The controller affects this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.ControllerFilter
             * @memberof FarseerPhysics.Controllers.ControllerFilter
             * @param   {FarseerPhysics.Controllers.ControllerType}    controller    The controller type.
             * @return  {void}
             */
            RestoreController: function (controller) {
                this.ControllerFlags &= ~controller;
            },
            /**
             * Determines whether this body ignores the the specified controller.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.ControllerFilter
             * @memberof FarseerPhysics.Controllers.ControllerFilter
             * @param   {FarseerPhysics.Controllers.ControllerType}    controller    The controller type.
             * @return  {boolean}                                                    <pre><code>true</code></pre> if the body has the specified flag; otherwise, <pre><code>false</code></pre>.
             */
            IsControllerIgnored: function (controller) {
                return (this.ControllerFlags & controller) === controller;
            },
            getHashCode: function () {
                var h = Bridge.addHash([7457916294, this.ControllerFlags]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Controllers.ControllerFilter)) {
                    return false;
                }
                return Bridge.equals(this.ControllerFlags, o.ControllerFlags);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Controllers.ControllerFilter();
                s.ControllerFlags = this.ControllerFlags;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.ControllerType", {
        $kind: "enum",
        statics: {
            fields: {
                GravityController: 1,
                VelocityLimitController: 2,
                AbstractForceController: 4,
                BuoyancyController: 8
            }
        },
        $flags: true
    });

    Bridge.define("FarseerPhysics.Controllers.GravityType", {
        $kind: "enum",
        statics: {
            fields: {
                Linear: 0,
                DistanceSquared: 1
            }
        }
    });

    /** @namespace FarseerPhysics */

    /**
     * @abstract
     * @public
     * @class FarseerPhysics.DebugView
     */
    Bridge.define("FarseerPhysics.DebugView", {
        fields: {
            World: null,
            /**
             * Gets or sets the debug view flags.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.DebugView
             * @function Flags
             * @type FarseerPhysics.DebugViewFlags
             */
            Flags: 0
        },
        ctors: {
            ctor: function (world) {
                this.$initialize();
                this.World = world;
            }
        },
        methods: {
            /**
             * Append flags to the current flags.
             *
             * @instance
             * @public
             * @this FarseerPhysics.DebugView
             * @memberof FarseerPhysics.DebugView
             * @param   {FarseerPhysics.DebugViewFlags}    flags    The flags.
             * @return  {void}
             */
            AppendFlags: function (flags) {
                this.Flags |= flags;
            },
            /**
             * Remove flags from the current flags.
             *
             * @instance
             * @public
             * @this FarseerPhysics.DebugView
             * @memberof FarseerPhysics.DebugView
             * @param   {FarseerPhysics.DebugViewFlags}    flags    The flags.
             * @return  {void}
             */
            RemoveFlags: function (flags) {
                this.Flags &= ~flags;
            }
        }
    });

    Bridge.define("FarseerPhysics.DebugViewFlags", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Draw shapes.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.DebugViewFlags
                 */
                Shape: 1,
                /**
                 * Draw joint connections.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 2
                 * @type FarseerPhysics.DebugViewFlags
                 */
                Joint: 2,
                /**
                 * Draw axis aligned bounding boxes.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 4
                 * @type FarseerPhysics.DebugViewFlags
                 */
                AABB: 4,
                /**
                 * Draw broad-phase pairs.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 8
                 * @type FarseerPhysics.DebugViewFlags
                 */
                Pair: 8,
                /**
                 * Draw center of mass frame.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 16
                 * @type FarseerPhysics.DebugViewFlags
                 */
                CenterOfMass: 16,
                /**
                 * Draw useful debug data such as timings and number of bodies, joints, contacts and more.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 32
                 * @type FarseerPhysics.DebugViewFlags
                 */
                DebugPanel: 32,
                /**
                 * Draw contact points between colliding bodies.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 64
                 * @type FarseerPhysics.DebugViewFlags
                 */
                ContactPoints: 64,
                /**
                 * Draw contact normals. Need ContactPoints to be enabled first.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 128
                 * @type FarseerPhysics.DebugViewFlags
                 */
                ContactNormals: 128,
                /**
                 * Draws the vertices of polygons.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 256
                 * @type FarseerPhysics.DebugViewFlags
                 */
                PolygonPoints: 256,
                /**
                 * Draws the performance graph.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 512
                 * @type FarseerPhysics.DebugViewFlags
                 */
                PerformanceGraph: 512,
                /**
                 * Draws controllers.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 1024
                 * @type FarseerPhysics.DebugViewFlags
                 */
                Controllers: 1024
            }
        },
        $flags: true
    });

    Bridge.define("FarseerPhysics.Dynamics.Body", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                _bodyIdCounter: 0
            }
        },
        fields: {
            AngularVelocityInternal: 0,
            BodyId: 0,
            ControllerFilter: null,
            Flags: 0,
            Force: null,
            InvI: 0,
            InvMass: 0,
            LinearVelocityInternal: null,
            PhysicsLogicFilter: null,
            SleepTime: 0,
            Sweep: null,
            Torque: 0,
            World: null,
            Xf: null,
            _angularDamping: 0,
            _bodyType: 0,
            _inertia: 0,
            _linearDamping: 0,
            _mass: 0,
            /**
             * Get or set this body is penetrable
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Penetrable
             * @type boolean
             */
            Penetrable: false,
            /**
             * Gets all the fixtures attached to this body.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function FixtureList
             * @type System.Collections.Generic.List$1
             */
            FixtureList: null,
            /**
             * Get the list of all joints attached to this body.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function JointList
             * @type FarseerPhysics.Dynamics.Joints.JointEdge
             */
            JointList: null,
            /**
             * Get the list of all contacts attached to this body.
             Warning: this list changes during the time step and you may
             miss some collisions if you don't use ContactListener.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function ContactList
             * @type FarseerPhysics.Dynamics.Contacts.ContactEdge
             */
            ContactList: null,
            /**
             * Set the user data. Use this to store your application specific data.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function UserData
             * @type System.Object
             */
            UserData: null,
            IsDisposed: false
        },
        props: {
            /**
             * Gets the total number revolutions the body has made.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Revolutions
             * @type number
             */
            Revolutions: {
                get: function () {
                    return this.Rotation / 3.14159274;
                }
            },
            /**
             * Gets or sets the body type.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function BodyType
             * @type FarseerPhysics.Dynamics.BodyType
             */
            BodyType: {
                get: function () {
                    return this._bodyType;
                },
                set: function (value) {
                    if (this._bodyType === value) {
                        return;
                    }

                    this._bodyType = value;

                    this.ResetMassData();

                    if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        this.AngularVelocityInternal = 0.0;
                    }

                    this.Awake = true;

                    this.Force = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    this.Torque = 0.0;

                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.Refilter();
                    }
                }
            },
            /**
             * Get or sets the linear velocity of the center of mass.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function LinearVelocity
             * @type Microsoft.Xna.Framework.Vector2
             */
            LinearVelocity: {
                get: function () {
                    return this.LinearVelocityInternal.$clone();
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value.X) && !isNaN(value.Y));

                    if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        return;
                    }

                    if (Microsoft.Xna.Framework.Vector2.Dot(value.$clone(), value.$clone()) > 0.0) {
                        this.Awake = true;
                    }

                    this.LinearVelocityInternal = value.$clone();
                }
            },
            /**
             * Gets or sets the angular velocity. Radians/second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function AngularVelocity
             * @type number
             */
            AngularVelocity: {
                get: function () {
                    return this.AngularVelocityInternal;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        return;
                    }

                    if (value * value > 0.0) {
                        this.Awake = true;
                    }

                    this.AngularVelocityInternal = value;
                }
            },
            /**
             * Gets or sets the linear damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function LinearDamping
             * @type number
             */
            LinearDamping: {
                get: function () {
                    return this._linearDamping;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this._linearDamping = value;
                }
            },
            /**
             * Gets or sets the angular damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function AngularDamping
             * @type number
             */
            AngularDamping: {
                get: function () {
                    return this._angularDamping;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this._angularDamping = value;
                }
            },
            /**
             * Gets or sets a value indicating whether this body should be included in the CCD solver.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function IsBullet
             * @type boolean
             */
            IsBullet: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.Bullet) === FarseerPhysics.Dynamics.BodyFlags.Bullet;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.Bullet;
                    } else {
                        this.Flags &= -9;
                    }
                }
            },
            /**
             * You can disable sleeping on this body. If you disable sleeping, the
             body will be woken.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function SleepingAllowed
             * @type boolean
             */
            SleepingAllowed: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.AutoSleep) === FarseerPhysics.Dynamics.BodyFlags.AutoSleep;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.AutoSleep;
                    } else {
                        this.Flags &= -5;
                        this.Awake = true;
                    }
                }
            },
            /**
             * Set the sleep state of the body. A sleeping body has very
             low CPU cost.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Awake
             * @type boolean
             */
            Awake: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.Awake) === FarseerPhysics.Dynamics.BodyFlags.Awake;
                },
                set: function (value) {
                    if (value) {
                        if ((this.Flags & FarseerPhysics.Dynamics.BodyFlags.Awake) === 0) {
                            this.Flags |= FarseerPhysics.Dynamics.BodyFlags.Awake;
                            this.SleepTime = 0.0;
                        }
                    } else {
                        this.Flags &= -3;
                        this.SleepTime = 0.0;
                        this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        this.AngularVelocityInternal = 0.0;
                        this.Force = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        this.Torque = 0.0;
                    }
                }
            },
            /**
             * Set the active state of the body. An inactive body is not
             simulated and cannot be collided with or woken up.
             If you pass a flag of true, all fixtures will be added to the
             broad-phase.
             If you pass a flag of false, all fixtures will be removed from
             the broad-phase and all contacts will be destroyed.
             Fixtures and joints are otherwise unaffected. You may continue
             to create/destroy fixtures and joints on inactive bodies.
             Fixtures on an inactive body are implicitly inactive and will
             not participate in collisions, ray-casts, or queries.
             Joints connected to an inactive body are implicitly inactive.
             An inactive body is still owned by a b2World object and remains
             in the body list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Enabled
             * @type boolean
             */
            Enabled: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.Enabled) === FarseerPhysics.Dynamics.BodyFlags.Enabled;
                },
                set: function (value) {
                    if (value === this.Enabled) {
                        return;
                    }

                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.Enabled;

                        var broadPhase = this.World.ContactManager.BroadPhase;
                        for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                            this.FixtureList.getItem(i).CreateProxies(broadPhase, Bridge.ref(this, "Xf"));
                        }

                    } else {
                        this.Flags &= -33;

                        var broadPhase1 = this.World.ContactManager.BroadPhase;

                        for (var i1 = 0; i1 < this.FixtureList.Count; i1 = (i1 + 1) | 0) {
                            this.FixtureList.getItem(i1).DestroyProxies(broadPhase1);
                        }

                        var ce = this.ContactList;
                        while (ce != null) {
                            var ce0 = ce;
                            ce = ce.Next;
                            this.World.ContactManager.Destroy(ce0.Contact);
                        }
                        this.ContactList = null;
                    }
                }
            },
            /**
             * Set this body to have fixed rotation. This causes the mass
             to be reset.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function FixedRotation
             * @type boolean
             */
            FixedRotation: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.FixedRotation) === FarseerPhysics.Dynamics.BodyFlags.FixedRotation;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.FixedRotation;
                    } else {
                        this.Flags &= -17;
                    }

                    this.ResetMassData();
                }
            },
            /**
             * Get the world body origin position.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Position
             * @type Microsoft.Xna.Framework.Vector2
             * @return  {[type]}        Return the world position of the body's origin.
             */
            Position: {
                get: function () {
                    return this.Xf.Position.$clone();
                },
                set: function (value) {
                    value = {v:value};
                    System.Diagnostics.Debug.Assert(!isNaN(value.v.X) && !isNaN(value.v.Y));

                    this.SetTransform$1(value, this.Rotation);
                }
            },
            /**
             * Get the angle in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Rotation
             * @type number
             * @return  {[type]}        Return the current world rotation angle in radians.
             */
            Rotation: {
                get: function () {
                    return this.Sweep.A;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this.SetTransform$1(Bridge.ref(this.Xf, "Position"), value);
                }
            },
            /**
             * Gets or sets a value indicating whether this body is static.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function IsStatic
             * @type boolean
             */
            IsStatic: {
                get: function () {
                    return this._bodyType === FarseerPhysics.Dynamics.BodyType.Static;
                },
                set: function (value) {
                    if (value) {
                        this.BodyType = FarseerPhysics.Dynamics.BodyType.Static;
                    } else {
                        this.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;
                    }
                }
            },
            /**
             * Gets or sets a value indicating whether this body ignores gravity.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function IgnoreGravity
             * @type boolean
             */
            IgnoreGravity: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.IgnoreGravity) === FarseerPhysics.Dynamics.BodyFlags.IgnoreGravity;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.IgnoreGravity;
                    } else {
                        this.Flags &= -65;
                    }
                }
            },
            /**
             * Get the world position of the center of mass.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Body
             * @function WorldCenter
             * @type Microsoft.Xna.Framework.Vector2
             */
            WorldCenter: {
                get: function () {
                    return this.Sweep.C.$clone();
                }
            },
            /**
             * Get the local position of the center of mass.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function LocalCenter
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalCenter: {
                get: function () {
                    return this.Sweep.LocalCenter.$clone();
                },
                set: function (value) {
                    var $t;
                    if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                        return;
                    }

                    var oldCenter = this.Sweep.C.$clone();
                    this.Sweep.LocalCenter = value.$clone();
                    this.Sweep.C0 = ($t = FarseerPhysics.Common.MathUtils.Multiply$3(Bridge.ref(this, "Xf"), Bridge.ref(this.Sweep, "LocalCenter")), this.Sweep.C = $t.$clone(), $t);

                    var a = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Sweep.C.$clone(), oldCenter.$clone());
                    this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-this.AngularVelocityInternal * a.Y, this.AngularVelocityInternal * a.X));
                }
            },
            /**
             * Gets or sets the mass. Usually in kilograms (kg).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Mass
             * @type number
             */
            Mass: {
                get: function () {
                    return this._mass;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                        return;
                    }

                    this._mass = value;

                    if (this._mass <= 0.0) {
                        this._mass = 1.0;
                    }

                    this.InvMass = 1.0 / this._mass;
                }
            },
            /**
             * Get or set the rotational inertia of the body about the local origin. usually in kg-m^2.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Inertia
             * @type number
             */
            Inertia: {
                get: function () {
                    return this._inertia + this.Mass * Microsoft.Xna.Framework.Vector2.Dot(this.Sweep.LocalCenter.$clone(), this.Sweep.LocalCenter.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                        return;
                    }

                    if (value > 0.0 && (this.Flags & FarseerPhysics.Dynamics.BodyFlags.FixedRotation) === 0) {
                        this._inertia = value - this.Mass * Microsoft.Xna.Framework.Vector2.Dot(this.LocalCenter.$clone(), this.LocalCenter.$clone());
                        System.Diagnostics.Debug.Assert(this._inertia > 0.0);
                        this.InvI = 1.0 / this._inertia;
                    }
                }
            },
            Restitution: {
                get: function () {
                    var res = 0;

                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        res += f.Restitution;
                    }

                    return res / this.FixtureList.Count;
                },
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.Restitution = value;
                    }
                }
            },
            Friction: {
                get: function () {
                    var res = 0;

                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        res += f.Friction;
                    }

                    return res / this.FixtureList.Count;
                },
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.Friction = value;
                    }
                }
            },
            CollisionCategories: {
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.CollisionCategories = value;
                    }
                }
            },
            CollidesWith: {
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.CollidesWith = value;
                    }
                }
            },
            CollisionGroup: {
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.CollisionGroup = value;
                    }
                }
            },
            IsSensor: {
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.IsSensor = value;
                    }
                }
            },
            IgnoreCCD: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.IgnoreCCD) === FarseerPhysics.Dynamics.BodyFlags.IgnoreCCD;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.IgnoreCCD;
                    } else {
                        this.Flags &= -129;
                    }
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
                this.ControllerFilter = new FarseerPhysics.Controllers.ControllerFilter();
                this.Force = new Microsoft.Xna.Framework.Vector2();
                this.LinearVelocityInternal = new Microsoft.Xna.Framework.Vector2();
                this.PhysicsLogicFilter = new FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter();
                this.Sweep = new FarseerPhysics.Common.Sweep();
                this.Xf = new FarseerPhysics.Common.Transform();
            },
            ctor: function () {
                this.$initialize();
                this.FixtureList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(32);
            },
            $ctor1: function (world) {
                FarseerPhysics.Dynamics.Body.$ctor2.call(this, world, null);
            },
            $ctor2: function (world, userData) {
                var $t;
                this.$initialize();
                this.FixtureList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(32);
                this.BodyId = Bridge.identity(FarseerPhysics.Dynamics.Body._bodyIdCounter, ($t = (FarseerPhysics.Dynamics.Body._bodyIdCounter + 1) | 0, FarseerPhysics.Dynamics.Body._bodyIdCounter = $t, $t));

                this.World = world;
                this.UserData = userData;

                this.FixedRotation = false;
                this.IsBullet = false;
                this.SleepingAllowed = true;
                this.Awake = true;
                this.BodyType = FarseerPhysics.Dynamics.BodyType.Static;
                this.Enabled = true;

                this.Xf.R.Set$1(0);

                world.AddBody(this);
            }
        },
        methods: {
            addOnCollision: function (value) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).OnCollision = Bridge.fn.combine(this.FixtureList.getItem(i).OnCollision, value);
                }
            },
            removeOnCollision: function (value) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).OnCollision = Bridge.fn.remove(this.FixtureList.getItem(i).OnCollision, value);
                }
            },
            addOnSeparation: function (value) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).OnSeparation = Bridge.fn.combine(this.FixtureList.getItem(i).OnSeparation, value);
                }
            },
            removeOnSeparation: function (value) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).OnSeparation = Bridge.fn.remove(this.FixtureList.getItem(i).OnSeparation, value);
                }
            },
            Dispose: function () {
                if (!this.IsDisposed) {

                    this.World.RemoveBody(this);
                    this.IsDisposed = true;
                }
            },
            /**
             * Resets the dynamics of this body.
             Sets torque, force and linear/angular velocity to 0
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @return  {void}
             */
            ResetDynamics: function () {
                this.Torque = 0;
                this.AngularVelocityInternal = 0;
                this.Force = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
            },
            /**
             * Creates a fixture and attach it to this body.
             If the density is non-zero, this function automatically updates the mass of the body.
             Contacts are not created until the next time step.
             Warning: This function is locked during callbacks.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Collision.Shapes.Shape}    shape    The shape.
             * @return  {FarseerPhysics.Dynamics.Fixture}
             */
            CreateFixture: function (shape) {
                return new FarseerPhysics.Dynamics.Fixture.$ctor1(this, shape);
            },
            /**
             * Creates a fixture and attach it to this body.
             If the density is non-zero, this function automatically updates the mass of the body.
             Contacts are not created until the next time step.
             Warning: This function is locked during callbacks.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Collision.Shapes.Shape}    shape       The shape.
             * @param   {System.Object}                            userData    Application specific data
             * @return  {FarseerPhysics.Dynamics.Fixture}
             */
            CreateFixture$1: function (shape, userData) {
                return new FarseerPhysics.Dynamics.Fixture.$ctor2(this, shape, userData);
            },
            /**
             * Destroy a fixture. This removes the fixture from the broad-phase and
             destroys all contacts associated with this fixture. This will
             automatically adjust the mass of the body if the body is dynamic and the
             fixture has positive density.
             All fixtures attached to a body are implicitly destroyed when the body is destroyed.
             Warning: This function is locked during callbacks.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Dynamics.Fixture}    fixture    The fixture to be removed.
             * @return  {void}
             */
            DestroyFixture: function (fixture) {
                System.Diagnostics.Debug.Assert(Bridge.referenceEquals(fixture.Body, this));

                System.Diagnostics.Debug.Assert(this.FixtureList.Count > 0);

                System.Diagnostics.Debug.Assert(this.FixtureList.contains(fixture));

                var edge = this.ContactList;
                while (edge != null) {
                    var c = edge.Contact;
                    edge = edge.Next;

                    var fixtureA = c.FixtureA;
                    var fixtureB = c.FixtureB;

                    if (Bridge.referenceEquals(fixture, fixtureA) || Bridge.referenceEquals(fixture, fixtureB)) {
                        this.World.ContactManager.Destroy(c);
                    }
                }

                if ((this.Flags & FarseerPhysics.Dynamics.BodyFlags.Enabled) === FarseerPhysics.Dynamics.BodyFlags.Enabled) {
                    var broadPhase = this.World.ContactManager.BroadPhase;
                    fixture.DestroyProxies(broadPhase);
                }

                this.FixtureList.remove(fixture);
                fixture.Destroy();
                fixture.Body = null;

                this.ResetMassData();
            },
            /**
             * Set the position of the body's origin and rotation.
             This breaks any contacts and wakes the other bodies.
             Manipulating a body's transform may cause non-physical behavior.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The world position of the body's local origin.
             * @param   {number}                             rotation    The world rotation in radians.
             * @return  {void}
             */
            SetTransform$1: function (position, rotation) {
                this.SetTransformIgnoreContacts(position, rotation);

                this.World.ContactManager.FindNewContacts();
            },
            /**
             * Set the position of the body's origin and rotation.
             This breaks any contacts and wakes the other bodies.
             Manipulating a body's transform may cause non-physical behavior.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The world position of the body's local origin.
             * @param   {number}                             rotation    The world rotation in radians.
             * @return  {void}
             */
            SetTransform: function (position, rotation) {
                position = {v:position};
                this.SetTransform$1(position, rotation);
            },
            /**
             * For teleporting a body without considering new contacts immediately.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The position.
             * @param   {number}                             angle       The angle.
             * @return  {void}
             */
            SetTransformIgnoreContacts: function (position, angle) {
                var $t;
                this.Xf.R.Set$1(angle);
                this.Xf.Position = position.v.$clone();

                this.Sweep.C0 = ($t = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Xf.Position.X + this.Xf.R.Col1.X * this.Sweep.LocalCenter.X + this.Xf.R.Col2.X * this.Sweep.LocalCenter.Y, this.Xf.Position.Y + this.Xf.R.Col1.Y * this.Sweep.LocalCenter.X + this.Xf.R.Col2.Y * this.Sweep.LocalCenter.Y), this.Sweep.C = $t.$clone(), $t);
                this.Sweep.A0 = (this.Sweep.A = angle, angle);

                var broadPhase = this.World.ContactManager.BroadPhase;
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).Synchronize(broadPhase, Bridge.ref(this, "Xf"), Bridge.ref(this, "Xf"));
                }
            },
            /**
             * Get the body transform for the body's origin.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Common.Transform}    transform    The transform of the body's origin.
             * @return  {void}
             */
            GetTransform: function (transform) {
                transform.v = this.Xf.$clone();
            },
            /**
             * Apply a force at a world point. If the force is not
             applied at the center of mass, it will generate a torque and
             affect the angular velocity. This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    force    The world force vector, usually in Newtons (N).
             * @param   {Microsoft.Xna.Framework.Vector2}    point    The world position of the point of application.
             * @return  {void}
             */
            ApplyForce$1: function (force, point) {
                force = {v:force};
                point = {v:point};
                this.ApplyForce$3(force, point);
            },
            /**
             * Applies a force at the center of mass.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    force    The force.
             * @return  {void}
             */
            ApplyForce$2: function (force) {
                this.ApplyForce$3(force, Bridge.ref(this.Xf, "Position"));
            },
            /**
             * Applies a force at the center of mass.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    force    The force.
             * @return  {void}
             */
            ApplyForce: function (force) {
                force = {v:force};
                this.ApplyForce$3(force, Bridge.ref(this.Xf, "Position"));
            },
            /**
             * Apply a force at a world point. If the force is not
             applied at the center of mass, it will generate a torque and
             affect the angular velocity. This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    force    The world force vector, usually in Newtons (N).
             * @param   {Microsoft.Xna.Framework.Vector2}    point    The world position of the point of application.
             * @return  {void}
             */
            ApplyForce$3: function (force, point) {
                System.Diagnostics.Debug.Assert(!isNaN(force.v.X));
                System.Diagnostics.Debug.Assert(!isNaN(force.v.Y));
                System.Diagnostics.Debug.Assert(!isNaN(point.v.X));
                System.Diagnostics.Debug.Assert(!isNaN(point.v.Y));

                if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    if (this.Awake === false) {
                        this.Awake = true;
                    }

                    this.Force = Microsoft.Xna.Framework.Vector2.op_Addition(this.Force.$clone(), force.v.$clone());
                    this.Torque += (point.v.X - this.Sweep.C.X) * force.v.Y - (point.v.Y - this.Sweep.C.Y) * force.v.X;
                }
            },
            /**
             * Apply a torque. This affects the angular velocity
             without affecting the linear velocity of the center of mass.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {number}    torque    The torque about the z-axis (out of the screen), usually in N-m.
             * @return  {void}
             */
            ApplyTorque: function (torque) {
                System.Diagnostics.Debug.Assert(!isNaN(torque));

                if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    if (this.Awake === false) {
                        this.Awake = true;
                    }

                    this.Torque += torque;
                }
            },
            /**
             * Apply an impulse at a point. This immediately modifies the velocity.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    impulse    The world impulse vector, usually in N-seconds or kg-m/s.
             * @return  {void}
             */
            ApplyLinearImpulse: function (impulse) {
                impulse = {v:impulse};
                this.ApplyLinearImpulse$2(impulse);
            },
            /**
             * Apply an impulse at a point. This immediately modifies the velocity.
             It also modifies the angular velocity if the point of application
             is not at the center of mass.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    impulse    The world impulse vector, usually in N-seconds or kg-m/s.
             * @param   {Microsoft.Xna.Framework.Vector2}    point      The world position of the point of application.
             * @return  {void}
             */
            ApplyLinearImpulse$1: function (impulse, point) {
                impulse = {v:impulse};
                point = {v:point};
                this.ApplyLinearImpulse$3(impulse, point);
            },
            /**
             * Apply an impulse at a point. This immediately modifies the velocity.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    impulse    The world impulse vector, usually in N-seconds or kg-m/s.
             * @return  {void}
             */
            ApplyLinearImpulse$2: function (impulse) {
                if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    return;
                }
                if (this.Awake === false) {
                    this.Awake = true;
                }
                this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMass, impulse.v.$clone()));
            },
            /**
             * Apply an impulse at a point. This immediately modifies the velocity.
             It also modifies the angular velocity if the point of application
             is not at the center of mass.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    impulse    The world impulse vector, usually in N-seconds or kg-m/s.
             * @param   {Microsoft.Xna.Framework.Vector2}    point      The world position of the point of application.
             * @return  {void}
             */
            ApplyLinearImpulse$3: function (impulse, point) {
                if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    return;
                }

                if (this.Awake === false) {
                    this.Awake = true;
                }

                this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMass, impulse.v.$clone()));
                this.AngularVelocityInternal += this.InvI * ((point.v.X - this.Sweep.C.X) * impulse.v.Y - (point.v.Y - this.Sweep.C.Y) * impulse.v.X);
            },
            /**
             * Apply an angular impulse.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {number}    impulse    The angular impulse in units of kg*m*m/s.
             * @return  {void}
             */
            ApplyAngularImpulse: function (impulse) {
                if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    return;
                }

                if (this.Awake === false) {
                    this.Awake = true;
                }

                this.AngularVelocityInternal += this.InvI * impulse;
            },
            /**
             * This resets the mass properties to the sum of the mass properties of the fixtures.
             This normally does not need to be called unless you called SetMassData to override
             the mass and you later want to reset the mass.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @return  {void}
             */
            ResetMassData: function () {
                var $t, $t1, $t2, $t3;
                this._mass = 0.0;
                this.InvMass = 0.0;
                this._inertia = 0.0;
                this.InvI = 0.0;
                this.Sweep.LocalCenter = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                if (this.BodyType === FarseerPhysics.Dynamics.BodyType.Kinematic) {
                    this.Sweep.C0 = ($t = this.Xf.Position.$clone(), this.Sweep.C = $t.$clone(), $t);
                    return;
                }

                System.Diagnostics.Debug.Assert(this.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic || this.BodyType === FarseerPhysics.Dynamics.BodyType.Static);

                var center = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                $t1 = Bridge.getEnumerator(this.FixtureList);
                try {
                    while ($t1.moveNext()) {
                        var f = $t1.Current;
                        if (f.Shape._density === 0) {
                            continue;
                        }

                        var massData = f.Shape.MassData.$clone();
                        this._mass += massData.Mass;
                        center = Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(massData.Mass, massData.Centroid.$clone()));
                        this._inertia += massData.Inertia;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                if (this.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                    this.Sweep.C0 = ($t2 = this.Xf.Position.$clone(), this.Sweep.C = $t2.$clone(), $t2);
                    return;
                }

                if (this._mass > 0.0) {
                    this.InvMass = 1.0 / this._mass;
                    center = Microsoft.Xna.Framework.Vector2.op_Multiply$1(center.$clone(), this.InvMass);
                } else {
                    this._mass = 1.0;
                    this.InvMass = 1.0;
                }

                if (this._inertia > 0.0 && (this.Flags & FarseerPhysics.Dynamics.BodyFlags.FixedRotation) === 0) {
                    this._inertia -= this._mass * Microsoft.Xna.Framework.Vector2.Dot(center.$clone(), center.$clone());

                    System.Diagnostics.Debug.Assert(this._inertia > 0.0);
                    this.InvI = 1.0 / this._inertia;
                } else {
                    this._inertia = 0.0;
                    this.InvI = 0.0;
                }

                var oldCenter = this.Sweep.C.$clone();
                this.Sweep.LocalCenter = center.$clone();
                this.Sweep.C0 = ($t3 = FarseerPhysics.Common.MathUtils.Multiply$3(Bridge.ref(this, "Xf"), Bridge.ref(this.Sweep, "LocalCenter")), this.Sweep.C = $t3.$clone(), $t3);

                var a = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Sweep.C.$clone(), oldCenter.$clone());
                this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-this.AngularVelocityInternal * a.Y, this.AngularVelocityInternal * a.X));
            },
            /**
             * Get the world coordinates of a point given the local coordinates.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localPoint    A point on the body measured relative the the body's origin.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The same point expressed in world coordinates.
             */
            GetWorldPoint$1: function (localPoint) {
                return new Microsoft.Xna.Framework.Vector2.$ctor2(this.Xf.Position.X + this.Xf.R.Col1.X * localPoint.v.X + this.Xf.R.Col2.X * localPoint.v.Y, this.Xf.Position.Y + this.Xf.R.Col1.Y * localPoint.v.X + this.Xf.R.Col2.Y * localPoint.v.Y);
            },
            /**
             * Get the world coordinates of a point given the local coordinates.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localPoint    A point on the body measured relative the the body's origin.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The same point expressed in world coordinates.
             */
            GetWorldPoint: function (localPoint) {
                localPoint = {v:localPoint};
                return this.GetWorldPoint$1(localPoint);
            },
            /**
             * Get the world coordinates of a vector given the local coordinates.
             Note that the vector only takes the rotation into account, not the position.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localVector    A vector fixed in the body.
             * @return  {Microsoft.Xna.Framework.Vector2}                   The same vector expressed in world coordinates.
             */
            GetWorldVector$1: function (localVector) {
                return new Microsoft.Xna.Framework.Vector2.$ctor2(this.Xf.R.Col1.X * localVector.v.X + this.Xf.R.Col2.X * localVector.v.Y, this.Xf.R.Col1.Y * localVector.v.X + this.Xf.R.Col2.Y * localVector.v.Y);
            },
            /**
             * Get the world coordinates of a vector given the local coordinates.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localVector    A vector fixed in the body.
             * @return  {Microsoft.Xna.Framework.Vector2}                   The same vector expressed in world coordinates.
             */
            GetWorldVector: function (localVector) {
                localVector = {v:localVector};
                return this.GetWorldVector$1(localVector);
            },
            /**
             * Gets a local point relative to the body's origin given a world point.
             Note that the vector only takes the rotation into account, not the position.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldPoint    A point in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The corresponding local point relative to the body's origin.
             */
            GetLocalPoint$1: function (worldPoint) {
                return new Microsoft.Xna.Framework.Vector2.$ctor2((worldPoint.v.X - this.Xf.Position.X) * this.Xf.R.Col1.X + (worldPoint.v.Y - this.Xf.Position.Y) * this.Xf.R.Col1.Y, (worldPoint.v.X - this.Xf.Position.X) * this.Xf.R.Col2.X + (worldPoint.v.Y - this.Xf.Position.Y) * this.Xf.R.Col2.Y);
            },
            /**
             * Gets a local point relative to the body's origin given a world point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldPoint    A point in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The corresponding local point relative to the body's origin.
             */
            GetLocalPoint: function (worldPoint) {
                worldPoint = {v:worldPoint};
                return this.GetLocalPoint$1(worldPoint);
            },
            /**
             * Gets a local vector given a world vector.
             Note that the vector only takes the rotation into account, not the position.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldVector    A vector in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                   The corresponding local vector.
             */
            GetLocalVector$1: function (worldVector) {
                return new Microsoft.Xna.Framework.Vector2.$ctor2(worldVector.v.X * this.Xf.R.Col1.X + worldVector.v.Y * this.Xf.R.Col1.Y, worldVector.v.X * this.Xf.R.Col2.X + worldVector.v.Y * this.Xf.R.Col2.Y);
            },
            /**
             * Gets a local vector given a world vector.
             Note that the vector only takes the rotation into account, not the position.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldVector    A vector in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                   The corresponding local vector.
             */
            GetLocalVector: function (worldVector) {
                worldVector = {v:worldVector};
                return this.GetLocalVector$1(worldVector);
            },
            /**
             * Get the world linear velocity of a world point attached to this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldPoint    A point in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The world velocity of a point.
             */
            GetLinearVelocityFromWorldPoint: function (worldPoint) {
                worldPoint = {v:worldPoint};
                return this.GetLinearVelocityFromWorldPoint$1(worldPoint);
            },
            /**
             * Get the world linear velocity of a world point attached to this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldPoint    A point in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The world velocity of a point.
             */
            GetLinearVelocityFromWorldPoint$1: function (worldPoint) {
                return Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-this.AngularVelocityInternal * (worldPoint.v.Y - this.Sweep.C.Y), this.AngularVelocityInternal * (worldPoint.v.X - this.Sweep.C.X)));
            },
            /**
             * Get the world velocity of a local point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localPoint    A point in local coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The world velocity of a point.
             */
            GetLinearVelocityFromLocalPoint: function (localPoint) {
                localPoint = {v:localPoint};
                return this.GetLinearVelocityFromLocalPoint$1(localPoint);
            },
            /**
             * Get the world velocity of a local point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localPoint    A point in local coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The world velocity of a point.
             */
            GetLinearVelocityFromLocalPoint$1: function (localPoint) {
                return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint$1(localPoint));
            },
            DeepClone: function () {
                var body = this.Clone();

                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).Clone(body);
                }

                return body;
            },
            Clone: function () {
                var body = new FarseerPhysics.Dynamics.Body.ctor();
                body.World = this.World;
                body.UserData = this.UserData;
                body.LinearDamping = this.LinearDamping;
                body.LinearVelocityInternal = this.LinearVelocityInternal.$clone();
                body.AngularDamping = this.AngularDamping;
                body.AngularVelocityInternal = this.AngularVelocityInternal;
                body.Position = this.Position.$clone();
                body.Rotation = this.Rotation;
                body._bodyType = this._bodyType;
                body.Flags = this.Flags;

                this.World.AddBody(body);

                return body;
            },
            SynchronizeFixtures: function () {
                var xf1 = { v : new FarseerPhysics.Common.Transform.ctor() };
                var c = Math.cos(this.Sweep.A0), s = Math.sin(this.Sweep.A0);
                xf1.v.R.Col1.X = c;
                xf1.v.R.Col2.X = -s;
                xf1.v.R.Col1.Y = s;
                xf1.v.R.Col2.Y = c;

                xf1.v.Position.X = this.Sweep.C0.X - (xf1.v.R.Col1.X * this.Sweep.LocalCenter.X + xf1.v.R.Col2.X * this.Sweep.LocalCenter.Y);
                xf1.v.Position.Y = this.Sweep.C0.Y - (xf1.v.R.Col1.Y * this.Sweep.LocalCenter.X + xf1.v.R.Col2.Y * this.Sweep.LocalCenter.Y);

                var broadPhase = this.World.ContactManager.BroadPhase;
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).Synchronize(broadPhase, xf1, Bridge.ref(this, "Xf"));
                }
            },
            SynchronizeTransform: function () {
                this.Xf.R.Set$1(this.Sweep.A);

                var vx = this.Xf.R.Col1.X * this.Sweep.LocalCenter.X + this.Xf.R.Col2.X * this.Sweep.LocalCenter.Y;
                var vy = this.Xf.R.Col1.Y * this.Sweep.LocalCenter.X + this.Xf.R.Col2.Y * this.Sweep.LocalCenter.Y;

                this.Xf.Position.X = this.Sweep.C.X - vx;
                this.Xf.Position.Y = this.Sweep.C.Y - vy;
            },
            /**
             * This is used to prevent connected bodies from colliding.
             It may lie, depending on the collideConnected flag.
             *
             * @instance
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Dynamics.Body}    other    The other body.
             * @return  {boolean}
             */
            ShouldCollide: function (other) {
                if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic && other._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    return false;
                }

                for (var jn = this.JointList; jn != null; jn = jn.Next) {
                    if (Bridge.referenceEquals(jn.Other, other)) {
                        if (jn.Joint.CollideConnected === false) {
                            return false;
                        }
                    }
                }

                return true;
            },
            Advance: function (alpha) {
                this.Sweep.Advance(alpha);
                this.Sweep.C = this.Sweep.C0.$clone();
                this.Sweep.A = this.Sweep.A0;
                this.SynchronizeTransform();
            },
            IgnoreCollisionWith: function (other) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    var f = this.FixtureList.getItem(i);
                    for (var j = 0; j < other.FixtureList.Count; j = (j + 1) | 0) {
                        var f2 = other.FixtureList.getItem(j);

                        f.IgnoreCollisionWith(f2);
                    }
                }
            },
            RestoreCollisionWith: function (other) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    var f = this.FixtureList.getItem(i);
                    for (var j = 0; j < other.FixtureList.Count; j = (j + 1) | 0) {
                        var f2 = other.FixtureList.getItem(j);

                        f.RestoreCollisionWith(f2);
                    }
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.BodyFlags", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Island: 1,
                Awake: 2,
                AutoSleep: 4,
                Bullet: 8,
                FixedRotation: 16,
                Enabled: 32,
                IgnoreGravity: 64,
                IgnoreCCD: 128
            }
        },
        $flags: true
    });

    /**
     * The body type.
     *
     * @public
     * @class FarseerPhysics.Dynamics.BodyType
     */
    Bridge.define("FarseerPhysics.Dynamics.BodyType", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Zero velocity, may be manually moved. Note: even static bodies have mass.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.BodyType
                 * @constant
                 * @default 0
                 * @type FarseerPhysics.Dynamics.BodyType
                 */
                Static: 0,
                /**
                 * Zero mass, non-zero velocity set by user, moved by solver
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.BodyType
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Dynamics.BodyType
                 */
                Kinematic: 1,
                /**
                 * Positive mass, non-zero velocity determined by forces, moved by solver
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.BodyType
                 * @constant
                 * @default 2
                 * @type FarseerPhysics.Dynamics.BodyType
                 */
                Dynamic: 2
            }
        }
    });

    /**
     * A type of body that supports multiple fixtures that can break apart.
     *
     * @public
     * @class FarseerPhysics.Dynamics.BreakableBody
     */
    Bridge.define("FarseerPhysics.Dynamics.BreakableBody", {
        fields: {
            Broken: false,
            MainBody: null,
            Parts: null,
            /**
             * The force needed to break the body apart.
             Default: 500
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.BreakableBody
             * @default 500.0
             * @type number
             */
            Strength: 0,
            _angularVelocitiesCache: null,
            _break: false,
            _velocitiesCache: null,
            _world: null
        },
        ctors: {
            init: function () {
                this.Parts = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(8);
                this.Strength = 500.0;
                this._angularVelocitiesCache = System.Array.init(8, 0, System.Single);
                this._velocitiesCache = System.Array.init(8, function (){
                    return new Microsoft.Xna.Framework.Vector2();
                }, Microsoft.Xna.Framework.Vector2);
            },
            ctor: function (vertices, world, density) {
                FarseerPhysics.Dynamics.BreakableBody.$ctor1.call(this, vertices, world, density, null);
            },
            $ctor1: function (vertices, world, density, userData) {
                var $t;
                this.$initialize();
                this._world = world;
                this._world.ContactManager.PostSolve = Bridge.fn.combine(this._world.ContactManager.PostSolve, Bridge.fn.cacheBind(this, this.PostSolve));
                this.MainBody = new FarseerPhysics.Dynamics.Body.$ctor1(this._world);
                this.MainBody.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;

                $t = Bridge.getEnumerator(vertices, FarseerPhysics.Common.Vertices);
                try {
                    while ($t.moveNext()) {
                        var part = $t.Current;
                        var polygonShape = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(part, density);
                        var fixture = this.MainBody.CreateFixture$1(polygonShape, userData);
                        this.Parts.add(fixture);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        },
        methods: {
            PostSolve: function (contact, impulse) {
                if (!this.Broken) {
                    if (this.Parts.contains(contact.FixtureA) || this.Parts.contains(contact.FixtureB)) {
                        var maxImpulse = 0.0;
                        var count = contact.Manifold.PointCount;

                        for (var i = 0; i < count; i = (i + 1) | 0) {
                            maxImpulse = Math.max(maxImpulse, impulse.Points[System.Array.index(i, impulse.Points)].NormalImpulse);
                        }

                        if (maxImpulse > this.Strength) {
                            this._break = true;
                        }
                    }
                }
            },
            Update: function () {
                if (this._break) {
                    this.Decompose();
                    this.Broken = true;
                    this._break = false;
                }

                if (this.Broken === false) {
                    if (this.Parts.Count > this._angularVelocitiesCache.length) {
                        this._velocitiesCache = System.Array.init(this.Parts.Count, function (){
                            return new Microsoft.Xna.Framework.Vector2();
                        }, Microsoft.Xna.Framework.Vector2);
                        this._angularVelocitiesCache = System.Array.init(this.Parts.Count, 0, System.Single);
                    }

                    for (var i = 0; i < this.Parts.Count; i = (i + 1) | 0) {
                        this._velocitiesCache[System.Array.index(i, this._velocitiesCache)] = this.Parts.getItem(i).Body.LinearVelocity.$clone();
                        this._angularVelocitiesCache[System.Array.index(i, this._angularVelocitiesCache)] = this.Parts.getItem(i).Body.AngularVelocity;
                    }
                }
            },
            Decompose: function () {
                this._world.ContactManager.PostSolve = Bridge.fn.remove(this._world.ContactManager.PostSolve, Bridge.fn.cacheBind(this, this.PostSolve));

                for (var i = 0; i < this.Parts.Count; i = (i + 1) | 0) {
                    var fixture = this.Parts.getItem(i);

                    var shape = fixture.Shape.Clone();

                    var userdata = fixture.UserData;
                    this.MainBody.DestroyFixture(fixture);

                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody(this._world);
                    body.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;
                    body.Position = this.MainBody.Position.$clone();
                    body.Rotation = this.MainBody.Rotation;
                    body.UserData = this.MainBody.UserData;

                    body.CreateFixture$1(shape, userdata);

                    body.AngularVelocity = this._angularVelocitiesCache[System.Array.index(i, this._angularVelocitiesCache)];
                    body.LinearVelocity = this._velocitiesCache[System.Array.index(i, this._velocitiesCache)].$clone();
                }

                this._world.RemoveBody(this.MainBody);
                this._world.RemoveBreakableBody(this);
            },
            Break: function () {
                this._break = true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Category", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                All: 0,
                Cat1: 1,
                Cat2: 2,
                Cat3: 4,
                Cat4: 8,
                Cat5: 16,
                Cat6: 32,
                Cat7: 64,
                Cat8: 128,
                Cat9: 256,
                Cat10: 512,
                Cat11: 1024,
                Cat12: 2048,
                Cat13: 4096,
                Cat14: 8192,
                Cat15: 16384,
                Cat16: 32768,
                Cat17: 65536,
                Cat18: 131072,
                Cat19: 262144,
                Cat20: 524288,
                Cat21: 1048576,
                Cat22: 2097152,
                Cat23: 4194304,
                Cat24: 8388608,
                Cat25: 16777216,
                Cat26: 33554432,
                Cat27: 67108864,
                Cat28: 134217728,
                Cat29: 268435456,
                Cat30: 536870912,
                Cat31: 1073741824
            },
            ctors: {
                init: function () {
                    this.All = 2147483647;
                }
            }
        },
        $flags: true
    });

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.PreSolveDelegate
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact        
     * @param   {FarseerPhysics.Collision.Manifold}           oldManifold
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.PostSolveDelegate
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}              contact    
     * @param   {FarseerPhysics.Dynamics.Contacts.ContactConstraint}    impulse
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.BroadphaseDelegate
     * @param   {FarseerPhysics.Dynamics.FixtureProxy}    proxyA    
     * @param   {FarseerPhysics.Dynamics.FixtureProxy}    proxyB
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.EndContactDelegate
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.CollisionFilterDelegate
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureB
     * @return  {boolean}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.BeginContactDelegate
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact
     * @return  {boolean}
     */

    Bridge.define("FarseerPhysics.Dynamics.ContactManager", {
        statics: {
            methods: {
                ShouldCollide: function (fixtureA, fixtureB) {
                    if (FarseerPhysics.Settings.UseFPECollisionCategories) {
                        if ((fixtureA.CollisionGroup === fixtureB.CollisionGroup) && fixtureA.CollisionGroup !== 0 && fixtureB.CollisionGroup !== 0) {
                            return false;
                        }

                        if (!!(((fixtureA.CollisionCategories & fixtureB.CollidesWith) === FarseerPhysics.Dynamics.Category.None) & ((fixtureB.CollisionCategories & fixtureA.CollidesWith) === FarseerPhysics.Dynamics.Category.None))) {
                            return false;
                        }

                        if (fixtureA.IsFixtureIgnored(fixtureB) || fixtureB.IsFixtureIgnored(fixtureA)) {
                            return false;
                        }

                        return true;
                    }

                    if (fixtureA.CollisionGroup === fixtureB.CollisionGroup && fixtureA.CollisionGroup !== 0) {
                        return fixtureA.CollisionGroup > 0;
                    }

                    var collide = (fixtureA.CollidesWith & fixtureB.CollisionCategories) !== 0 && (fixtureA.CollisionCategories & fixtureB.CollidesWith) !== 0;

                    if (collide) {
                        if (fixtureA.IsFixtureIgnored(fixtureB) || fixtureB.IsFixtureIgnored(fixtureA)) {
                            return false;
                        }
                    }

                    return collide;
                }
            }
        },
        fields: {
            /**
             * Fires when a contact is created
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.BeginContactDelegate
             */
            BeginContact: null,
            BroadPhase: null,
            /**
             * The filter used by the contact manager.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.CollisionFilterDelegate
             */
            ContactFilter: null,
            ContactList: null,
            /**
             * Fires when a contact is deleted
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.EndContactDelegate
             */
            EndContact: null,
            /**
             * Fires when the broadphase detects that two Fixtures are close to each other.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.BroadphaseDelegate
             */
            OnBroadphaseCollision: null,
            /**
             * Fires after the solver has run
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.PostSolveDelegate
             */
            PostSolve: null,
            /**
             * Fires before the solver runs
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.PreSolveDelegate
             */
            PreSolve: null
        },
        ctors: {
            init: function () {
                this.ContactList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Contacts.Contact)).$ctor2(128);
            },
            ctor: function (broadPhase) {
                this.$initialize();
                this.BroadPhase = broadPhase;
                this.OnBroadphaseCollision = Bridge.fn.cacheBind(this, this.AddPair);
            }
        },
        methods: {
            AddPair: function (proxyA, proxyB) {
                var fixtureA = proxyA.v.Fixture;
                var fixtureB = proxyB.v.Fixture;

                var indexA = proxyA.v.ChildIndex;
                var indexB = proxyB.v.ChildIndex;

                var bodyA = fixtureA.Body;
                var bodyB = fixtureB.Body;

                if (Bridge.referenceEquals(bodyA, bodyB)) {
                    return;
                }

                var edge = bodyB.ContactList;
                while (edge != null) {
                    if (Bridge.referenceEquals(edge.Other, bodyA)) {
                        var fA = edge.Contact.FixtureA;
                        var fB = edge.Contact.FixtureB;
                        var iA = edge.Contact.ChildIndexA;
                        var iB = edge.Contact.ChildIndexB;

                        if (Bridge.referenceEquals(fA, fixtureA) && Bridge.referenceEquals(fB, fixtureB) && iA === indexA && iB === indexB) {
                            return;
                        }

                        if (Bridge.referenceEquals(fA, fixtureB) && Bridge.referenceEquals(fB, fixtureA) && iA === indexB && iB === indexA) {
                            return;
                        }
                    }

                    edge = edge.Next;
                }

                if (bodyB.ShouldCollide(bodyA) === false) {
                    return;
                }

                if (FarseerPhysics.Dynamics.ContactManager.ShouldCollide(fixtureA, fixtureB) === false) {
                    return;
                }

                if (!Bridge.staticEquals(this.ContactFilter, null) && this.ContactFilter(fixtureA, fixtureB) === false) {
                    return;
                }

                if (!Bridge.staticEquals(fixtureA.BeforeCollision, null) && fixtureA.BeforeCollision(fixtureA, fixtureB) === false) {
                    return;
                }

                if (!Bridge.staticEquals(fixtureB.BeforeCollision, null) && fixtureB.BeforeCollision(fixtureB, fixtureA) === false) {
                    return;
                }

                var c = FarseerPhysics.Dynamics.Contacts.Contact.Create(fixtureA, indexA, fixtureB, indexB);

                fixtureA = c.FixtureA;
                fixtureB = c.FixtureB;
                bodyA = fixtureA.Body;
                bodyB = fixtureB.Body;

                this.ContactList.add(c);


                c.NodeA.Contact = c;
                c.NodeA.Other = bodyB;

                c.NodeA.Prev = null;
                c.NodeA.Next = bodyA.ContactList;
                if (bodyA.ContactList != null) {
                    bodyA.ContactList.Prev = c.NodeA;
                }
                bodyA.ContactList = c.NodeA;

                c.NodeB.Contact = c;
                c.NodeB.Other = bodyA;

                c.NodeB.Prev = null;
                c.NodeB.Next = bodyB.ContactList;
                if (bodyB.ContactList != null) {
                    bodyB.ContactList.Prev = c.NodeB;
                }
                bodyB.ContactList = c.NodeB;
            },
            FindNewContacts: function () {
                this.BroadPhase.FarseerPhysics$Collision$IBroadPhase$UpdatePairs(this.OnBroadphaseCollision);
            },
            Destroy: function (contact) {
                var fixtureA = contact.FixtureA;
                var fixtureB = contact.FixtureB;
                var bodyA = fixtureA.Body;
                var bodyB = fixtureB.Body;

                if (!Bridge.staticEquals(this.EndContact, null) && contact.IsTouching()) {
                    this.EndContact(contact);
                }

                this.ContactList.remove(contact);

                if (contact.NodeA.Prev != null) {
                    contact.NodeA.Prev.Next = contact.NodeA.Next;
                }

                if (contact.NodeA.Next != null) {
                    contact.NodeA.Next.Prev = contact.NodeA.Prev;
                }

                if (Bridge.referenceEquals(contact.NodeA, bodyA.ContactList)) {
                    bodyA.ContactList = contact.NodeA.Next;
                }

                if (contact.NodeB.Prev != null) {
                    contact.NodeB.Prev.Next = contact.NodeB.Next;
                }

                if (contact.NodeB.Next != null) {
                    contact.NodeB.Next.Prev = contact.NodeB.Prev;
                }

                if (Bridge.referenceEquals(contact.NodeB, bodyB.ContactList)) {
                    bodyB.ContactList = contact.NodeB.Next;
                }

                contact.Destroy();
            },
            Collide: function () {
                for (var i = 0; i < this.ContactList.Count; i = (i + 1) | 0) {
                    var c = this.ContactList.getItem(i);
                    var fixtureA = c.FixtureA;
                    var fixtureB = c.FixtureB;
                    var indexA = c.ChildIndexA;
                    var indexB = c.ChildIndexB;
                    var bodyA = fixtureA.Body;
                    var bodyB = fixtureB.Body;

                    if (bodyA.Awake === false && bodyB.Awake === false) {
                        continue;
                    }

                    if ((c.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter) {
                        if (bodyB.ShouldCollide(bodyA) === false) {
                            var cNuke = c;
                            this.Destroy(cNuke);
                            continue;
                        }

                        if (FarseerPhysics.Dynamics.ContactManager.ShouldCollide(fixtureA, fixtureB) === false) {
                            var cNuke1 = c;
                            this.Destroy(cNuke1);
                            continue;
                        }

                        if (!Bridge.staticEquals(this.ContactFilter, null) && this.ContactFilter(fixtureA, fixtureB) === false) {
                            var cNuke2 = c;
                            this.Destroy(cNuke2);
                            continue;
                        }

                        c.Flags &= -9;
                    }

                    var proxyIdA = fixtureA.Proxies[System.Array.index(indexA, fixtureA.Proxies)].ProxyId;
                    var proxyIdB = fixtureB.Proxies[System.Array.index(indexB, fixtureB.Proxies)].ProxyId;

                    var overlap = this.BroadPhase.FarseerPhysics$Collision$IBroadPhase$TestOverlap(proxyIdA, proxyIdB);

                    if (overlap === false) {
                        var cNuke3 = c;
                        this.Destroy(cNuke3);
                        continue;
                    }

                    c.Update(this);
                }
            }
        }
    });

    /** @namespace FarseerPhysics.Dynamics.Contacts */

    /**
     * The class manages contact between two shapes. A contact exists for each overlapping
     AABB in the broad-phase (except if filtered). Therefore a contact object may exist
     that has no contact points.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Contacts.Contact
     */
    Bridge.define("FarseerPhysics.Dynamics.Contacts.Contact", {
        statics: {
            fields: {
                _edge: null,
                _registers: null
            },
            ctors: {
                init: function () {
                    this._edge = new FarseerPhysics.Collision.Shapes.EdgeShape.ctor();
                    this._registers = System.Array.create(0, [[
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.Circle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.PolygonAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndCircle
                    ], [
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.NotSupported, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndPolygon, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.NotSupported
                    ], [
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.PolygonAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndPolygon, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.Polygon, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndPolygon
                    ], [
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.NotSupported, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndPolygon, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.NotSupported
                    ]], FarseerPhysics.Dynamics.Contacts.Contact.ContactType, 4, 4);
                }
            },
            methods: {
                Create: function (fixtureA, indexA, fixtureB, indexB) {
                    var type1 = fixtureA.ShapeType;
                    var type2 = fixtureB.ShapeType;

                    System.Diagnostics.Debug.Assert(FarseerPhysics.Collision.Shapes.ShapeType.Unknown < type1 && type1 < FarseerPhysics.Collision.Shapes.ShapeType.TypeCount);
                    System.Diagnostics.Debug.Assert(FarseerPhysics.Collision.Shapes.ShapeType.Unknown < type2 && type2 < FarseerPhysics.Collision.Shapes.ShapeType.TypeCount);

                    var c;
                    var pool = fixtureA.Body.World.ContactPool;
                    if (pool.Count > 0) {
                        c = pool.Dequeue();
                        if ((type1 >= type2 || (type1 === FarseerPhysics.Collision.Shapes.ShapeType.Edge && type2 === FarseerPhysics.Collision.Shapes.ShapeType.Polygon)) && !(type2 === FarseerPhysics.Collision.Shapes.ShapeType.Edge && type1 === FarseerPhysics.Collision.Shapes.ShapeType.Polygon)) {
                            c.Reset(fixtureA, indexA, fixtureB, indexB);
                        } else {
                            c.Reset(fixtureB, indexB, fixtureA, indexA);
                        }
                    } else {
                        if ((type1 >= type2 || (type1 === FarseerPhysics.Collision.Shapes.ShapeType.Edge && type2 === FarseerPhysics.Collision.Shapes.ShapeType.Polygon)) && !(type2 === FarseerPhysics.Collision.Shapes.ShapeType.Edge && type1 === FarseerPhysics.Collision.Shapes.ShapeType.Polygon)) {
                            c = new FarseerPhysics.Dynamics.Contacts.Contact(fixtureA, indexA, fixtureB, indexB);
                        } else {
                            c = new FarseerPhysics.Dynamics.Contacts.Contact(fixtureB, indexB, fixtureA, indexA);
                        }
                    }

                    c._type = FarseerPhysics.Dynamics.Contacts.Contact._registers.get([type1, type2]);

                    return c;
                }
            }
        },
        fields: {
            FixtureA: null,
            FixtureB: null,
            Flags: 0,
            Manifold: null,
            NodeA: null,
            NodeB: null,
            TOI: 0,
            TOICount: 0,
            _type: 0,
            /**
             * Get the child primitive index for fixture A.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @function ChildIndexA
             * @type number
             */
            ChildIndexA: 0,
            /**
             * Get the child primitive index for fixture B.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @function ChildIndexB
             * @type number
             */
            ChildIndexB: 0
        },
        props: {
            /**
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @function Enabled
             * @type boolean
             */
            Enabled: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled;
                    } else {
                        this.Flags &= -5;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.Manifold = new FarseerPhysics.Collision.Manifold();
                this.NodeA = new FarseerPhysics.Dynamics.Contacts.ContactEdge();
                this.NodeB = new FarseerPhysics.Dynamics.Contacts.ContactEdge();
            },
            ctor: function (fA, indexA, fB, indexB) {
                this.$initialize();
                this.Reset(fA, indexA, fB, indexB);
            }
        },
        methods: {
            /**
             * Get the contact manifold. Do not modify the manifold unless you understand the
             internals of Box2D.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @param   {FarseerPhysics.Collision.Manifold}    manifold    The manifold.
             * @return  {void}
             */
            GetManifold: function (manifold) {
                manifold.v = this.Manifold.$clone();
            },
            /**
             * Gets the world manifold.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @param   {Microsoft.Xna.Framework.Vector2}      normal    
             * @param   {FarseerPhysics.Common.FixedArray2}    points
             * @return  {void}
             */
            GetWorldManifold: function (normal, points) {
                var bodyA = this.FixtureA.Body;
                var bodyB = this.FixtureB.Body;
                var shapeA = this.FixtureA.Shape;
                var shapeB = this.FixtureB.Shape;

                FarseerPhysics.Collision.Collision.GetWorldManifold(Bridge.ref(this, "Manifold"), Bridge.ref(bodyA, "Xf"), shapeA.Radius, Bridge.ref(bodyB, "Xf"), shapeB.Radius, normal, points);
            },
            /**
             * Determines whether this contact is touching.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @return  {boolean}        <pre><code>true</code></pre> if this instance is touching; otherwise, <pre><code>false</code></pre>.
             */
            IsTouching: function () {
                return (this.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching;
            },
            /**
             * Flag this contact for filtering. Filtering will occur the next time step.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @return  {void}
             */
            FlagForFiltering: function () {
                this.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter;
            },
            Reset: function (fA, indexA, fB, indexB) {
                this.Flags = FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled;

                this.FixtureA = fA;
                this.FixtureB = fB;

                this.ChildIndexA = indexA;
                this.ChildIndexB = indexB;

                this.Manifold.PointCount = 0;

                this.NodeA.Contact = null;
                this.NodeA.Prev = null;
                this.NodeA.Next = null;
                this.NodeA.Other = null;

                this.NodeB.Contact = null;
                this.NodeB.Prev = null;
                this.NodeB.Next = null;
                this.NodeB.Other = null;

                this.TOICount = 0;
            },
            /**
             * Update the contact manifold and touching status.
             Note: do not assume the fixture AABBs are overlapping or are valid.
             *
             * @instance
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @param   {FarseerPhysics.Dynamics.ContactManager}    contactManager    The contact manager.
             * @return  {void}
             */
            Update: function (contactManager) {
                var oldManifold = { v : this.Manifold.$clone() };

                this.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled;

                var touching;
                var wasTouching = (this.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching;

                var sensor = this.FixtureA.IsSensor || this.FixtureB.IsSensor;

                var bodyA = this.FixtureA.Body;
                var bodyB = this.FixtureB.Body;

                if (sensor) {
                    var shapeA = this.FixtureA.Shape;
                    var shapeB = this.FixtureB.Shape;
                    touching = FarseerPhysics.Collision.AABB.TestOverlap$2(shapeA, this.ChildIndexA, shapeB, this.ChildIndexB, Bridge.ref(bodyA, "Xf"), Bridge.ref(bodyB, "Xf"));

                    this.Manifold.PointCount = 0;
                } else {
                    this.Evaluate(Bridge.ref(this, "Manifold"), Bridge.ref(bodyA, "Xf"), Bridge.ref(bodyB, "Xf"));
                    touching = this.Manifold.PointCount > 0;

                    for (var i = 0; i < this.Manifold.PointCount; i = (i + 1) | 0) {
                        var mp2 = this.Manifold.Points.getItem(i).$clone();
                        mp2.NormalImpulse = 0.0;
                        mp2.TangentImpulse = 0.0;
                        var id2 = mp2.Id.$clone();
                        var found = false;

                        for (var j = 0; j < oldManifold.v.PointCount; j = (j + 1) | 0) {
                            var mp1 = oldManifold.v.Points.getItem(j).$clone();

                            if (mp1.Id.Key === id2.Key) {
                                mp2.NormalImpulse = mp1.NormalImpulse;
                                mp2.TangentImpulse = mp1.TangentImpulse;
                                found = true;
                                break;
                            }
                        }
                        if (found === false) {
                            mp2.NormalImpulse = 0.0;
                            mp2.TangentImpulse = 0.0;
                        }

                        this.Manifold.Points.setItem(i, mp2.$clone());
                    }

                    if (touching !== wasTouching) {
                        bodyA.Awake = true;
                        bodyB.Awake = true;
                    }
                }

                if (touching) {
                    this.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching;
                } else {
                    this.Flags &= -3;
                }

                if (wasTouching === false && touching) {
                    if (!Bridge.staticEquals(this.FixtureA.OnCollision, null)) {
                        this.Enabled = this.FixtureA.OnCollision(this.FixtureA, this.FixtureB, this);
                    }

                    if (!Bridge.staticEquals(this.FixtureB.OnCollision, null)) {
                        this.Enabled = this.FixtureB.OnCollision(this.FixtureB, this.FixtureA, this);
                    }

                    if (!Bridge.staticEquals(contactManager.BeginContact, null)) {
                        this.Enabled = contactManager.BeginContact(this);
                    }

                    if (this.Enabled === false) {
                        this.Flags &= -3;
                    }
                }

                if (wasTouching && touching === false) {
                    if (this.FixtureA != null && !Bridge.staticEquals(this.FixtureA.OnSeparation, null)) {
                        this.FixtureA.OnSeparation(this.FixtureA, this.FixtureB);
                    }

                    if (this.FixtureB != null && !Bridge.staticEquals(this.FixtureB.OnSeparation, null)) {
                        this.FixtureB.OnSeparation(this.FixtureB, this.FixtureA);
                    }

                    if (!Bridge.staticEquals(contactManager.EndContact, null)) {
                        contactManager.EndContact(this);
                    }
                }

                if (sensor) {
                    return;
                }

                if (!Bridge.staticEquals(contactManager.PreSolve, null)) {
                    contactManager.PreSolve(this, oldManifold);
                }
            },
            /**
             * Evaluate this contact with your own manifold and transforms.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @param   {FarseerPhysics.Collision.Manifold}    manifold      The manifold.
             * @param   {FarseerPhysics.Common.Transform}      transformA    The first transform.
             * @param   {FarseerPhysics.Common.Transform}      transformB    The second transform.
             * @return  {void}
             */
            Evaluate: function (manifold, transformA, transformB) {
                switch (this._type) {
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.Polygon: 
                        FarseerPhysics.Collision.Collision.CollidePolygons(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.PolygonAndCircle: 
                        FarseerPhysics.Collision.Collision.CollidePolygonAndCircle(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndCircle: 
                        FarseerPhysics.Collision.Collision.CollideEdgeAndCircle(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.EdgeShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndPolygon: 
                        FarseerPhysics.Collision.Collision.CollideEdgeAndPolygon(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.EdgeShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndCircle: 
                        var loop = Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.LoopShape);
                        loop.GetChildEdge(Bridge.ref(FarseerPhysics.Dynamics.Contacts.Contact, "_edge"), this.ChildIndexA);
                        FarseerPhysics.Collision.Collision.CollideEdgeAndCircle(manifold, FarseerPhysics.Dynamics.Contacts.Contact._edge, transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndPolygon: 
                        var loop2 = Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.LoopShape);
                        loop2.GetChildEdge(Bridge.ref(FarseerPhysics.Dynamics.Contacts.Contact, "_edge"), this.ChildIndexA);
                        FarseerPhysics.Collision.Collision.CollideEdgeAndPolygon(manifold, FarseerPhysics.Dynamics.Contacts.Contact._edge, transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.Circle: 
                        FarseerPhysics.Collision.Collision.CollideCircles(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformB);
                        break;
                }
            },
            Destroy: function () {
                this.FixtureA.Body.World.ContactPool.Enqueue(this);
                this.Reset(null, 0, null, 0);
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.Contact.ContactType", {
        $kind: "nested enum",
        statics: {
            fields: {
                NotSupported: 0,
                Polygon: 1,
                PolygonAndCircle: 2,
                Circle: 3,
                EdgeAndPolygon: 4,
                EdgeAndCircle: 5,
                LoopAndPolygon: 6,
                LoopAndCircle: 7
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactConstraint", {
        fields: {
            BodyA: null,
            BodyB: null,
            Friction: 0,
            K: null,
            LocalNormal: null,
            LocalPoint: null,
            Manifold: null,
            Normal: null,
            NormalMass: null,
            PointCount: 0,
            Points: null,
            RadiusA: 0,
            RadiusB: 0,
            Restitution: 0,
            Type: 0
        },
        ctors: {
            init: function () {
                this.K = new FarseerPhysics.Common.Mat22();
                this.LocalNormal = new Microsoft.Xna.Framework.Vector2();
                this.LocalPoint = new Microsoft.Xna.Framework.Vector2();
                this.Manifold = new FarseerPhysics.Collision.Manifold();
                this.Normal = new Microsoft.Xna.Framework.Vector2();
                this.NormalMass = new FarseerPhysics.Common.Mat22();
                this.Points = System.Array.init(FarseerPhysics.Settings.MaxPolygonVertices, null, FarseerPhysics.Dynamics.Contacts.ContactConstraintPoint);
            },
            ctor: function () {
                this.$initialize();
                for (var i = 0; i < FarseerPhysics.Settings.MaxManifoldPoints; i = (i + 1) | 0) {
                    this.Points[System.Array.index(i, this.Points)] = new FarseerPhysics.Dynamics.Contacts.ContactConstraintPoint();
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactConstraintPoint", {
        fields: {
            LocalPoint: null,
            NormalImpulse: 0,
            NormalMass: 0,
            TangentImpulse: 0,
            TangentMass: 0,
            VelocityBias: 0,
            rA: null,
            rB: null
        },
        ctors: {
            init: function () {
                this.LocalPoint = new Microsoft.Xna.Framework.Vector2();
                this.rA = new Microsoft.Xna.Framework.Vector2();
                this.rB = new Microsoft.Xna.Framework.Vector2();
            }
        }
    });

    /**
     * A contact edge is used to connect bodies and contacts together
     in a contact graph where each body is a node and each contact
     is an edge. A contact edge belongs to a doubly linked list
     maintained in each attached body. Each contact has two contact
     nodes, one for each attached body.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Contacts.ContactEdge
     */
    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactEdge", {
        fields: {
            /**
             * The contact
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.ContactEdge
             * @type FarseerPhysics.Dynamics.Contacts.Contact
             */
            Contact: null,
            /**
             * The next contact edge in the body's contact list
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.ContactEdge
             * @type FarseerPhysics.Dynamics.Contacts.ContactEdge
             */
            Next: null,
            /**
             * Provides quick access to the other body attached.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.ContactEdge
             * @type FarseerPhysics.Dynamics.Body
             */
            Other: null,
            /**
             * The previous contact edge in the body's contact list
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.ContactEdge
             * @type FarseerPhysics.Dynamics.Contacts.ContactEdge
             */
            Prev: null
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactFlags", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                /**
                 * Used when crawling contact graph when forming islands.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                Island: 1,
                /**
                 * Set when the shapes are touching.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 2
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                Touching: 2,
                /**
                 * This contact can be disabled (by user)
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 4
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                Enabled: 4,
                /**
                 * This contact needs filtering because a fixture filter was changed.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 8
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                Filter: 8,
                /**
                 * This bullet contact had a TOI event
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 16
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                BulletHit: 16,
                /**
                 * This contact has a valid TOI i the field TOI
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 32
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                TOI: 32
            }
        },
        $flags: true
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactSolver", {
        statics: {
            methods: {
                Solve: function (cc, index, normal, point, separation) {
                    System.Diagnostics.Debug.Assert(cc.PointCount > 0);

                    normal.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                    switch (cc.Type) {
                        case FarseerPhysics.Collision.ManifoldType.Circles: 
                            {
                                var pointA = cc.BodyA.GetWorldPoint$1(Bridge.ref(cc, "LocalPoint"));
                                var pointB = cc.BodyB.GetWorldPoint$1(Bridge.ref(cc.Points[System.Array.index(0, cc.Points)], "LocalPoint"));
                                var a = (pointA.X - pointB.X) * (pointA.X - pointB.X) + (pointA.Y - pointB.Y) * (pointA.Y - pointB.Y);
                                if (a > 1.42108547E-14) {
                                    var normalTmp = Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(), pointA.$clone());
                                    var factor = 1.0 / Math.sqrt(normalTmp.X * normalTmp.X + normalTmp.Y * normalTmp.Y);
                                    normal.v.X = normalTmp.X * factor;
                                    normal.v.Y = normalTmp.Y * factor;
                                } else {
                                    normal.v.X = 1;
                                    normal.v.Y = 0;
                                }

                                point.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(pointA.$clone(), pointB.$clone())));
                                separation.v = (pointB.X - pointA.X) * normal.v.X + (pointB.Y - pointA.Y) * normal.v.Y - cc.RadiusA - cc.RadiusB;
                            }
                            break;
                        case FarseerPhysics.Collision.ManifoldType.FaceA: 
                            {
                                normal.v = cc.BodyA.GetWorldVector$1(Bridge.ref(cc, "LocalNormal"));
                                var planePoint = cc.BodyA.GetWorldPoint$1(Bridge.ref(cc, "LocalPoint"));
                                var clipPoint = cc.BodyB.GetWorldPoint$1(Bridge.ref(cc.Points[System.Array.index(index, cc.Points)], "LocalPoint"));
                                separation.v = (clipPoint.X - planePoint.X) * normal.v.X + (clipPoint.Y - planePoint.Y) * normal.v.Y - cc.RadiusA - cc.RadiusB;
                                point.v = clipPoint.$clone();
                            }
                            break;
                        case FarseerPhysics.Collision.ManifoldType.FaceB: 
                            {
                                normal.v = cc.BodyB.GetWorldVector$1(Bridge.ref(cc, "LocalNormal"));
                                var planePoint1 = cc.BodyB.GetWorldPoint$1(Bridge.ref(cc, "LocalPoint"));

                                var clipPoint1 = cc.BodyA.GetWorldPoint$1(Bridge.ref(cc.Points[System.Array.index(index, cc.Points)], "LocalPoint"));
                                separation.v = (clipPoint1.X - planePoint1.X) * normal.v.X + (clipPoint1.Y - planePoint1.Y) * normal.v.Y - cc.RadiusA - cc.RadiusB;
                                point.v = clipPoint1.$clone();

                                normal.v = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.v.$clone());
                            }
                            break;
                        default: 
                            point.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                            separation.v = 0.0;
                            break;
                    }
                }
            }
        },
        fields: {
            Constraints: null,
            _constraintCount: 0,
            _contacts: null
        },
        methods: {
            Reset: function (contacts, contactCount, impulseRatio, warmstarting) {
                this._contacts = contacts;
                this._constraintCount = contactCount;

                if (this.Constraints == null || this.Constraints.length < this._constraintCount) {
                    this.Constraints = System.Array.init(Bridge.Int.mul(contactCount, 2), null, FarseerPhysics.Dynamics.Contacts.ContactConstraint);
                    for (var i = 0; i < this.Constraints.length; i = (i + 1) | 0) {
                        this.Constraints[System.Array.index(i, this.Constraints)] = new FarseerPhysics.Dynamics.Contacts.ContactConstraint();
                    }
                }

                for (var i1 = 0; i1 < this._constraintCount; i1 = (i1 + 1) | 0) {
                    var contact = this._contacts[System.Array.index(i1, this._contacts)];

                    var fixtureA = contact.FixtureA;
                    var fixtureB = contact.FixtureB;
                    var shapeA = fixtureA.Shape;
                    var shapeB = fixtureB.Shape;
                    var radiusA = shapeA.Radius;
                    var radiusB = shapeB.Radius;
                    var bodyA = fixtureA.Body;
                    var bodyB = fixtureB.Body;
                    var manifold = contact.Manifold.$clone();

                    System.Diagnostics.Debug.Assert(manifold.PointCount > 0);

                    var cc = this.Constraints[System.Array.index(i1, this.Constraints)];
                    cc.Friction = FarseerPhysics.Settings.MixFriction(fixtureA.Friction, fixtureB.Friction);
                    cc.Restitution = FarseerPhysics.Settings.MixRestitution(fixtureA.Restitution, fixtureB.Restitution);
                    cc.BodyA = bodyA;
                    cc.BodyB = bodyB;
                    cc.Manifold = manifold.$clone();
                    cc.Normal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    cc.PointCount = manifold.PointCount;

                    cc.LocalNormal = manifold.LocalNormal.$clone();
                    cc.LocalPoint = manifold.LocalPoint.$clone();
                    cc.RadiusA = radiusA;
                    cc.RadiusB = radiusB;
                    cc.Type = manifold.Type;

                    for (var j = 0; j < cc.PointCount; j = (j + 1) | 0) {
                        var cp = manifold.Points.getItem(j).$clone();
                        var ccp = cc.Points[System.Array.index(j, cc.Points)];

                        if (warmstarting) {
                            ccp.NormalImpulse = impulseRatio * cp.NormalImpulse;
                            ccp.TangentImpulse = impulseRatio * cp.TangentImpulse;
                        } else {
                            ccp.NormalImpulse = 0.0;
                            ccp.TangentImpulse = 0.0;
                        }

                        ccp.LocalPoint = cp.LocalPoint.$clone();
                        ccp.rA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        ccp.rB = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        ccp.NormalMass = 0.0;
                        ccp.TangentMass = 0.0;
                        ccp.VelocityBias = 0.0;
                    }

                    cc.K.SetZero();
                    cc.NormalMass.SetZero();
                }
            },
            InitializeVelocityConstraints: function () {
                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var cc = this.Constraints[System.Array.index(i, this.Constraints)];

                    var radiusA = cc.RadiusA;
                    var radiusB = cc.RadiusB;
                    var bodyA = cc.BodyA;
                    var bodyB = cc.BodyB;
                    var manifold = { v : cc.Manifold.$clone() };

                    var vA = bodyA.LinearVelocity.$clone();
                    var vB = bodyB.LinearVelocity.$clone();
                    var wA = bodyA.AngularVelocity;
                    var wB = bodyB.AngularVelocity;

                    System.Diagnostics.Debug.Assert(manifold.v.PointCount > 0);
                    var points = { v : new (FarseerPhysics.Common.FixedArray2$1(Microsoft.Xna.Framework.Vector2))() };

                    FarseerPhysics.Collision.Collision.GetWorldManifold(manifold, Bridge.ref(bodyA, "Xf"), radiusA, Bridge.ref(bodyB, "Xf"), radiusB, Bridge.ref(cc, "Normal"), points);
                    var tangent = new Microsoft.Xna.Framework.Vector2.$ctor2(cc.Normal.Y, -cc.Normal.X);

                    for (var j = 0; j < cc.PointCount; j = (j + 1) | 0) {
                        var ccp = cc.Points[System.Array.index(j, cc.Points)];

                        ccp.rA = Microsoft.Xna.Framework.Vector2.op_Subtraction(points.v.getItem(j).$clone(), bodyA.Sweep.C.$clone());
                        ccp.rB = Microsoft.Xna.Framework.Vector2.op_Subtraction(points.v.getItem(j).$clone(), bodyB.Sweep.C.$clone());

                        var rnA = ccp.rA.X * cc.Normal.Y - ccp.rA.Y * cc.Normal.X;
                        var rnB = ccp.rB.X * cc.Normal.Y - ccp.rB.Y * cc.Normal.X;
                        rnA *= rnA;
                        rnB *= rnB;

                        var kNormal = bodyA.InvMass + bodyB.InvMass + bodyA.InvI * rnA + bodyB.InvI * rnB;

                        System.Diagnostics.Debug.Assert(kNormal > FarseerPhysics.Settings.Epsilon);
                        ccp.NormalMass = 1.0 / kNormal;

                        var rtA = ccp.rA.X * tangent.Y - ccp.rA.Y * tangent.X;
                        var rtB = ccp.rB.X * tangent.Y - ccp.rB.Y * tangent.X;

                        rtA *= rtA;
                        rtB *= rtB;
                        var kTangent = bodyA.InvMass + bodyB.InvMass + bodyA.InvI * rtA + bodyB.InvI * rtB;

                        System.Diagnostics.Debug.Assert(kTangent > FarseerPhysics.Settings.Epsilon);
                        ccp.TangentMass = 1.0 / kTangent;

                        ccp.VelocityBias = 0.0;
                        var vRel = cc.Normal.X * (vB.X + -wB * ccp.rB.Y - vA.X - -wA * ccp.rA.Y) + cc.Normal.Y * (vB.Y + wB * ccp.rB.X - vA.Y - wA * ccp.rA.X);
                        if (vRel < -1.0) {
                            ccp.VelocityBias = -cc.Restitution * vRel;
                        }
                    }

                    if (cc.PointCount === 2) {
                        var ccp1 = cc.Points[System.Array.index(0, cc.Points)];
                        var ccp2 = cc.Points[System.Array.index(1, cc.Points)];

                        var invMassA = bodyA.InvMass;
                        var invIA = bodyA.InvI;
                        var invMassB = bodyB.InvMass;
                        var invIB = bodyB.InvI;

                        var rn1A = ccp1.rA.X * cc.Normal.Y - ccp1.rA.Y * cc.Normal.X;
                        var rn1B = ccp1.rB.X * cc.Normal.Y - ccp1.rB.Y * cc.Normal.X;
                        var rn2A = ccp2.rA.X * cc.Normal.Y - ccp2.rA.Y * cc.Normal.X;
                        var rn2B = ccp2.rB.X * cc.Normal.Y - ccp2.rB.Y * cc.Normal.X;

                        var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
                        var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
                        var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;

                        var k_maxConditionNumber = 100.0;
                        if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                            cc.K.Col1.X = k11;
                            cc.K.Col1.Y = k12;
                            cc.K.Col2.X = k12;
                            cc.K.Col2.Y = k22;

                            var a = cc.K.Col1.X, b = cc.K.Col2.X, c = cc.K.Col1.Y, d = cc.K.Col2.Y;
                            var det = a * d - b * c;
                            if (det !== 0.0) {
                                det = 1.0 / det;
                            }

                            cc.NormalMass.Col1.X = det * d;
                            cc.NormalMass.Col1.Y = -det * c;
                            cc.NormalMass.Col2.X = -det * b;
                            cc.NormalMass.Col2.Y = det * a;
                        } else {
                            cc.PointCount = 1;
                        }
                    }
                }
            },
            WarmStart: function () {
                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var c = this.Constraints[System.Array.index(i, this.Constraints)];

                    var tangentx = c.Normal.Y;
                    var tangenty = -c.Normal.X;

                    for (var j = 0; j < c.PointCount; j = (j + 1) | 0) {
                        var ccp = c.Points[System.Array.index(j, c.Points)];
                        var px = ccp.NormalImpulse * c.Normal.X + ccp.TangentImpulse * tangentx;
                        var py = ccp.NormalImpulse * c.Normal.Y + ccp.TangentImpulse * tangenty;
                        c.BodyA.AngularVelocityInternal -= c.BodyA.InvI * (ccp.rA.X * py - ccp.rA.Y * px);
                        c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px;
                        c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py;
                        c.BodyB.AngularVelocityInternal += c.BodyB.InvI * (ccp.rB.X * py - ccp.rB.Y * px);
                        c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px;
                        c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py;
                    }
                }
            },
            SolveVelocityConstraints: function () {
                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var c = this.Constraints[System.Array.index(i, this.Constraints)];
                    if (c.BodyA.Penetrable || c.BodyB.Penetrable) {
                        continue;
                    }
                    var wA = c.BodyA.AngularVelocityInternal;
                    var wB = c.BodyB.AngularVelocityInternal;

                    var tangentx = c.Normal.Y;
                    var tangenty = -c.Normal.X;

                    var friction = c.Friction;

                    System.Diagnostics.Debug.Assert(c.PointCount === 1 || c.PointCount === 2);

                    for (var j = 0; j < c.PointCount; j = (j + 1) | 0) {
                        var ccp = c.Points[System.Array.index(j, c.Points)];
                        var lambda = ccp.TangentMass * -((c.BodyB.LinearVelocityInternal.X + (-wB * ccp.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * ccp.rA.Y)) * tangentx + (c.BodyB.LinearVelocityInternal.Y + (wB * ccp.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * ccp.rA.X)) * tangenty);

                        var maxFriction = friction * ccp.NormalImpulse;
                        var newImpulse = Math.max(-maxFriction, Math.min(ccp.TangentImpulse + lambda, maxFriction));
                        lambda = newImpulse - ccp.TangentImpulse;

                        var px = lambda * tangentx;
                        var py = lambda * tangenty;

                        c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px;
                        c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py;
                        wA -= c.BodyA.InvI * (ccp.rA.X * py - ccp.rA.Y * px);

                        c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px;
                        c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py;
                        wB += c.BodyB.InvI * (ccp.rB.X * py - ccp.rB.Y * px);

                        ccp.TangentImpulse = newImpulse;
                    }

                    if (c.PointCount === 1) {
                        var ccp1 = c.Points[System.Array.index(0, c.Points)];

                        var lambda1 = -ccp1.NormalMass * ((c.BodyB.LinearVelocityInternal.X + (-wB * ccp1.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * ccp1.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * ccp1.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * ccp1.rA.X)) * c.Normal.Y - ccp1.VelocityBias);

                        var newImpulse1 = Math.max(ccp1.NormalImpulse + lambda1, 0.0);
                        lambda1 = newImpulse1 - ccp1.NormalImpulse;

                        var px1 = lambda1 * c.Normal.X;
                        var py1 = lambda1 * c.Normal.Y;

                        c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px1;
                        c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py1;
                        wA -= c.BodyA.InvI * (ccp1.rA.X * py1 - ccp1.rA.Y * px1);

                        c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px1;
                        c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py1;
                        wB += c.BodyB.InvI * (ccp1.rB.X * py1 - ccp1.rB.Y * px1);

                        ccp1.NormalImpulse = newImpulse1;
                    } else {

                        var cp1 = c.Points[System.Array.index(0, c.Points)];
                        var cp2 = c.Points[System.Array.index(1, c.Points)];

                        var ax = cp1.NormalImpulse;
                        var ay = cp2.NormalImpulse;
                        System.Diagnostics.Debug.Assert(ax >= 0.0 && ay >= 0.0);

                        var vn1 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp1.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * cp1.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * cp1.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * cp1.rA.X)) * c.Normal.Y;
                        var vn2 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp2.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * cp2.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * cp2.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * cp2.rA.X)) * c.Normal.Y;

                        var bx = vn1 - cp1.VelocityBias - (c.K.Col1.X * ax + c.K.Col2.X * ay);
                        var by = vn2 - cp2.VelocityBias - (c.K.Col1.Y * ax + c.K.Col2.Y * ay);

                        var xx = -(c.NormalMass.Col1.X * bx + c.NormalMass.Col2.X * by);
                        var xy = -(c.NormalMass.Col1.Y * bx + c.NormalMass.Col2.Y * by);

                        while (true) {
                            if (xx >= 0.0 && xy >= 0.0) {
                                var dx = xx - ax;
                                var dy = xy - ay;

                                var p1x = dx * c.Normal.X;
                                var p1y = dx * c.Normal.Y;

                                var p2x = dy * c.Normal.X;
                                var p2y = dy * c.Normal.Y;

                                var p12x = p1x + p2x;
                                var p12y = p1y + p2y;

                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;
                                c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;
                                wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));

                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;
                                c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;
                                wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));

                                cp1.NormalImpulse = xx;
                                cp2.NormalImpulse = xy;

                                break;
                            }

                            xx = -cp1.NormalMass * bx;
                            xy = 0.0;
                            vn1 = 0.0;
                            vn2 = c.K.Col1.Y * xx + by;

                            if (xx >= 0.0 && vn2 >= 0.0) {
                                var dx1 = xx - ax;
                                var dy1 = xy - ay;

                                var p1x1 = dx1 * c.Normal.X;
                                var p1y1 = dx1 * c.Normal.Y;

                                var p2x1 = dy1 * c.Normal.X;
                                var p2y1 = dy1 * c.Normal.Y;

                                var p12x1 = p1x1 + p2x1;
                                var p12y1 = p1y1 + p2y1;

                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x1;
                                c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y1;
                                wA -= c.BodyA.InvI * ((cp1.rA.X * p1y1 - cp1.rA.Y * p1x1) + (cp2.rA.X * p2y1 - cp2.rA.Y * p2x1));

                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x1;
                                c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y1;
                                wB += c.BodyB.InvI * ((cp1.rB.X * p1y1 - cp1.rB.Y * p1x1) + (cp2.rB.X * p2y1 - cp2.rB.Y * p2x1));

                                cp1.NormalImpulse = xx;
                                cp2.NormalImpulse = xy;

                                break;
                            }


                            xx = 0.0;
                            xy = -cp2.NormalMass * by;
                            vn1 = c.K.Col2.X * xy + bx;
                            vn2 = 0.0;

                            if (xy >= 0.0 && vn1 >= 0.0) {
                                var dx2 = xx - ax;
                                var dy2 = xy - ay;

                                var p1x2 = dx2 * c.Normal.X;
                                var p1y2 = dx2 * c.Normal.Y;

                                var p2x2 = dy2 * c.Normal.X;
                                var p2y2 = dy2 * c.Normal.Y;

                                var p12x2 = p1x2 + p2x2;
                                var p12y2 = p1y2 + p2y2;

                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x2;
                                c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y2;
                                wA -= c.BodyA.InvI * ((cp1.rA.X * p1y2 - cp1.rA.Y * p1x2) + (cp2.rA.X * p2y2 - cp2.rA.Y * p2x2));

                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x2;
                                c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y2;
                                wB += c.BodyB.InvI * ((cp1.rB.X * p1y2 - cp1.rB.Y * p1x2) + (cp2.rB.X * p2y2 - cp2.rB.Y * p2x2));

                                cp1.NormalImpulse = xx;
                                cp2.NormalImpulse = xy;

                                break;
                            }

                            xx = 0.0;
                            xy = 0.0;
                            vn1 = bx;
                            vn2 = by;

                            if (vn1 >= 0.0 && vn2 >= 0.0) {
                                var dx3 = xx - ax;
                                var dy3 = xy - ay;

                                var p1x3 = dx3 * c.Normal.X;
                                var p1y3 = dx3 * c.Normal.Y;

                                var p2x3 = dy3 * c.Normal.X;
                                var p2y3 = dy3 * c.Normal.Y;

                                var p12x3 = p1x3 + p2x3;
                                var p12y3 = p1y3 + p2y3;

                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x3;
                                c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y3;
                                wA -= c.BodyA.InvI * ((cp1.rA.X * p1y3 - cp1.rA.Y * p1x3) + (cp2.rA.X * p2y3 - cp2.rA.Y * p2x3));

                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x3;
                                c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y3;
                                wB += c.BodyB.InvI * ((cp1.rB.X * p1y3 - cp1.rB.Y * p1x3) + (cp2.rB.X * p2y3 - cp2.rB.Y * p2x3));

                                cp1.NormalImpulse = xx;
                                cp2.NormalImpulse = xy;

                                break;
                            }

                            break;
                        }
                    }

                    c.BodyA.AngularVelocityInternal = wA;
                    c.BodyB.AngularVelocityInternal = wB;
                }
            },
            StoreImpulses: function () {
                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var c = this.Constraints[System.Array.index(i, this.Constraints)];
                    if (c.BodyA.Penetrable || c.BodyB.Penetrable) {
                        continue;
                    }

                    var m = c.Manifold.$clone();

                    for (var j = 0; j < c.PointCount; j = (j + 1) | 0) {
                        var pj = m.Points.getItem(j).$clone();
                        var cp = c.Points[System.Array.index(j, c.Points)];

                        pj.NormalImpulse = cp.NormalImpulse;
                        pj.TangentImpulse = cp.TangentImpulse;

                        m.Points.setItem(j, pj.$clone());
                    }

                    c.Manifold = m.$clone();
                    this._contacts[System.Array.index(i, this._contacts)].Manifold = m.$clone();
                }
            },
            SolvePositionConstraints: function (baumgarte) {
                var minSeparation = 0.0;

                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var c = this.Constraints[System.Array.index(i, this.Constraints)];
                    if (c.BodyA.Penetrable || c.BodyB.Penetrable) {
                        continue;
                    }

                    var bodyA = c.BodyA;
                    var bodyB = c.BodyB;

                    var invMassA = bodyA.Mass * bodyA.InvMass;
                    var invIA = bodyA.Mass * bodyA.InvI;
                    var invMassB = bodyB.Mass * bodyB.InvMass;
                    var invIB = bodyB.Mass * bodyB.InvI;

                    for (var j = 0; j < c.PointCount; j = (j + 1) | 0) {
                        var normal = { v : new Microsoft.Xna.Framework.Vector2() };
                        var point = { v : new Microsoft.Xna.Framework.Vector2() };
                        var separation = { };

                        FarseerPhysics.Dynamics.Contacts.ContactSolver.Solve(c, j, normal, point, separation);

                        var rax = point.v.X - bodyA.Sweep.C.X;
                        var ray = point.v.Y - bodyA.Sweep.C.Y;

                        var rbx = point.v.X - bodyB.Sweep.C.X;
                        var rby = point.v.Y - bodyB.Sweep.C.Y;

                        minSeparation = Math.min(minSeparation, separation.v);

                        var C = Math.max(-0.2, Math.min(baumgarte * (separation.v + FarseerPhysics.Settings.LinearSlop), 0.0));

                        var rnA = rax * normal.v.Y - ray * normal.v.X;
                        var rnB = rbx * normal.v.Y - rby * normal.v.X;
                        var K = invMassA + invMassB + invIA * rnA * rnA + invIB * rnB * rnB;

                        var impulse = K > 0.0 ? -C / K : 0.0;

                        var px = impulse * normal.v.X;
                        var py = impulse * normal.v.Y;

                        bodyA.Sweep.C.X -= invMassA * px;
                        bodyA.Sweep.C.Y -= invMassA * py;
                        bodyA.Sweep.A -= invIA * (rax * py - ray * px);

                        bodyB.Sweep.C.X += invMassB * px;
                        bodyB.Sweep.C.Y += invMassB * py;
                        bodyB.Sweep.A += invIB * (rbx * py - rby * px);

                        bodyA.SynchronizeTransform();
                        bodyB.SynchronizeTransform();
                    }
                }

                return minSeparation >= -0.0075;
            }
        }
    });

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.OnSeparationEventHandler
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureB
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.OnCollisionEventHandler
     * @param   {FarseerPhysics.Dynamics.Fixture}             fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}             fixtureB    
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact
     * @return  {boolean}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.BeforeCollisionEventHandler
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureB
     * @return  {boolean}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.AfterCollisionEventHandler
     * @param   {FarseerPhysics.Dynamics.Fixture}             fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}             fixtureB    
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact
     * @return  {void}
     */

    /**
     * A fixture is used to attach a Shape to a body for collision detection. A fixture
     inherits its transform from its parent. Fixtures hold additional non-geometric data
     such as friction, collision filters, etc.
     Fixtures are created via Body.CreateFixture.
     Warning: You cannot reuse fixtures.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Fixture
     * @implements  System.IDisposable
     */
    Bridge.define("FarseerPhysics.Dynamics.Fixture", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                _fixtureIdCounter: 0
            }
        },
        fields: {
            /**
             * Fires after two shapes has collided and are solved. This gives you a chance to get the impact force.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @type FarseerPhysics.Dynamics.AfterCollisionEventHandler
             */
            AfterCollision: null,
            /**
             * Fires when two fixtures are close to each other.
             Due to how the broadphase works, this can be quite inaccurate as shapes are approximated using AABBs.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @type FarseerPhysics.Dynamics.BeforeCollisionEventHandler
             */
            BeforeCollision: null,
            /**
             * Fires when two shapes collide and a contact is created between them.
             Note that the first fixture argument is always the fixture that the delegate is subscribed to.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @type FarseerPhysics.Dynamics.OnCollisionEventHandler
             */
            OnCollision: null,
            /**
             * Fires when two shapes separate and a contact is removed between them.
             Note that the first fixture argument is always the fixture that the delegate is subscribed to.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @type FarseerPhysics.Dynamics.OnSeparationEventHandler
             */
            OnSeparation: null,
            Proxies: null,
            ProxyCount: 0,
            _collidesWith: 0,
            _collisionCategories: 0,
            _collisionGroup: 0,
            _collisionIgnores: null,
            _friction: 0,
            _restitution: 0,
            /**
             * Get the child Shape. You can modify the child Shape, however you should not change the
             number of vertices because this will crash some collision caching mechanisms.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function Shape
             * @type FarseerPhysics.Collision.Shapes.Shape
             */
            Shape: null,
            /**
             * Gets or sets a value indicating whether this fixture is a sensor.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function IsSensor
             * @type boolean
             */
            IsSensor: false,
            /**
             * Get the parent body of this fixture. This is null if the fixture is not attached.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function Body
             * @type FarseerPhysics.Dynamics.Body
             */
            Body: null,
            /**
             * Set the user data. Use this to store your application specific data.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function UserData
             * @type System.Object
             */
            UserData: null,
            /**
             * Gets a unique ID for this fixture.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function FixtureId
             * @type number
             */
            FixtureId: 0,
            IsDisposed: false
        },
        props: {
            /**
             * Defaults to 0
             If Settings.UseFPECollisionCategories is set to false:
             Collision groups allow a certain group of objects to never collide (negative)
             or always collide (positive). Zero means no collision group. Non-zero group
             filtering always wins against the mask bits.
             If Settings.UseFPECollisionCategories is set to true:
             If 2 fixtures are in the same collision group, they will not collide.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function CollisionGroup
             * @type number
             */
            CollisionGroup: {
                get: function () {
                    return this._collisionGroup;
                },
                set: function (value) {
                    if (this._collisionGroup === value) {
                        return;
                    }

                    this._collisionGroup = value;
                    this.Refilter();
                }
            },
            /**
             * Defaults to Category.All
             The collision mask bits. This states the categories that this
             fixture would accept for collision.
             Use Settings.UseFPECollisionCategories to change the behavior.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function CollidesWith
             * @type FarseerPhysics.Dynamics.Category
             */
            CollidesWith: {
                get: function () {
                    return this._collidesWith;
                },
                set: function (value) {
                    if (this._collidesWith === value) {
                        return;
                    }

                    this._collidesWith = value;
                    this.Refilter();
                }
            },
            /**
             * The collision categories this fixture is a part of.
             If Settings.UseFPECollisionCategories is set to false:
             Defaults to Category.Cat1
             If Settings.UseFPECollisionCategories is set to true:
             Defaults to Category.All
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function CollisionCategories
             * @type FarseerPhysics.Dynamics.Category
             */
            CollisionCategories: {
                get: function () {
                    return this._collisionCategories;
                },
                set: function (value) {
                    if (this._collisionCategories === value) {
                        return;
                    }

                    this._collisionCategories = value;
                    this.Refilter();
                }
            },
            /**
             * Get the type of the child Shape. You can use this to down cast to the concrete Shape.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function ShapeType
             * @type FarseerPhysics.Collision.Shapes.ShapeType
             */
            ShapeType: {
                get: function () {
                    return this.Shape.ShapeType;
                }
            },
            /**
             * Get or set the coefficient of friction.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function Friction
             * @type number
             */
            Friction: {
                get: function () {
                    return this._friction;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this._friction = value;
                }
            },
            /**
             * Get or set the coefficient of restitution.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function Restitution
             * @type number
             */
            Restitution: {
                get: function () {
                    return this._restitution;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this._restitution = value;
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            ctor: function () {
                this.$initialize();
            },
            $ctor1: function (body, shape) {
                FarseerPhysics.Dynamics.Fixture.$ctor2.call(this, body, shape, null);
            },
            $ctor2: function (body, shape, userData) {
                this.$initialize();
                if (FarseerPhysics.Settings.UseFPECollisionCategories) {
                    this._collisionCategories = FarseerPhysics.Dynamics.Category.All;
                } else {
                    this._collisionCategories = FarseerPhysics.Dynamics.Category.Cat1;
                }

                this._collidesWith = FarseerPhysics.Dynamics.Category.All;
                this._collisionGroup = 0;

                this.Friction = 0.2;
                this.Restitution = 0;

                this.IsSensor = false;

                this.Body = body;
                this.UserData = userData;

                if (FarseerPhysics.Settings.ConserveMemory) {
                    this.Shape = shape;
                } else {
                    this.Shape = shape.Clone();
                }

                this.RegisterFixture();
            }
        },
        methods: {
            Dispose: function () {
                if (!this.IsDisposed) {
                    this.Body.DestroyFixture(this);
                    this.IsDisposed = true;
                }
            },
            /**
             * Restores collisions between this fixture and the provided fixture.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Dynamics.Fixture}    fixture    The fixture.
             * @return  {void}
             */
            RestoreCollisionWith: function (fixture) {
                if (this._collisionIgnores == null) {
                    return;
                }

                if (this._collisionIgnores.containsKey(fixture.FixtureId)) {
                    this._collisionIgnores.set(fixture.FixtureId, false);
                    this.Refilter();
                }
            },
            /**
             * Ignores collisions between this fixture and the provided fixture.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Dynamics.Fixture}    fixture    The fixture.
             * @return  {void}
             */
            IgnoreCollisionWith: function (fixture) {
                if (this._collisionIgnores == null) {
                    this._collisionIgnores = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Boolean))();
                }

                if (this._collisionIgnores.containsKey(fixture.FixtureId)) {
                    this._collisionIgnores.set(fixture.FixtureId, true);
                } else {
                    this._collisionIgnores.add(fixture.FixtureId, true);
                }

                this.Refilter();
            },
            /**
             * Determines whether collisions are ignored between this fixture and the provided fixture.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Dynamics.Fixture}    fixture    The fixture.
             * @return  {boolean}                                       <pre><code>true</code></pre> if the fixture is ignored; otherwise, <pre><code>false</code></pre>.
             */
            IsFixtureIgnored: function (fixture) {
                if (this._collisionIgnores == null) {
                    return false;
                }

                if (this._collisionIgnores.containsKey(fixture.FixtureId)) {
                    return this._collisionIgnores.get(fixture.FixtureId);
                }

                return false;
            },
            /**
             * Contacts are persistant and will keep being persistant unless they are
             flagged for filtering.
             This methods flags all contacts associated with the body for filtering.
             *
             * @instance
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @return  {void}
             */
            Refilter: function () {
                var edge = this.Body.ContactList;
                while (edge != null) {
                    var contact = edge.Contact;
                    var fixtureA = contact.FixtureA;
                    var fixtureB = contact.FixtureB;
                    if (Bridge.referenceEquals(fixtureA, this) || Bridge.referenceEquals(fixtureB, this)) {
                        contact.FlagForFiltering();
                    }

                    edge = edge.Next;
                }

                var world = this.Body.World;

                if (world == null) {
                    return;
                }

                var broadPhase = world.ContactManager.BroadPhase;
                for (var i = 0; i < this.ProxyCount; i = (i + 1) | 0) {
                    broadPhase.FarseerPhysics$Collision$IBroadPhase$TouchProxy(this.Proxies[System.Array.index(i, this.Proxies)].ProxyId);
                }
            },
            RegisterFixture: function () {
                var $t;
                this.Proxies = System.Array.init(this.Shape.ChildCount, function (){
                    return new FarseerPhysics.Dynamics.FixtureProxy();
                }, FarseerPhysics.Dynamics.FixtureProxy);
                this.ProxyCount = 0;

                this.FixtureId = Bridge.identity(FarseerPhysics.Dynamics.Fixture._fixtureIdCounter, ($t = (FarseerPhysics.Dynamics.Fixture._fixtureIdCounter + 1) | 0, FarseerPhysics.Dynamics.Fixture._fixtureIdCounter = $t, $t));

                if ((this.Body.Flags & FarseerPhysics.Dynamics.BodyFlags.Enabled) === FarseerPhysics.Dynamics.BodyFlags.Enabled) {
                    var broadPhase = this.Body.World.ContactManager.BroadPhase;
                    this.CreateProxies(broadPhase, Bridge.ref(this.Body, "Xf"));
                }

                this.Body.FixtureList.add(this);

                if (this.Shape._density > 0.0) {
                    this.Body.ResetMassData();
                }

                this.Body.World.Flags |= FarseerPhysics.Dynamics.WorldFlags.NewFixture;

                if (!Bridge.staticEquals(this.Body.World.FixtureAdded, null)) {
                    this.Body.World.FixtureAdded(this);
                }
            },
            /**
             * Test a point for containment in this fixture.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {Microsoft.Xna.Framework.Vector2}    point    A point in world coordinates.
             * @return  {boolean}
             */
            TestPoint: function (point) {
                return this.Shape.TestPoint(Bridge.ref(this.Body, "Xf"), point);
            },
            /**
             * Cast a ray against this Shape.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {number}                                    childIndex    Index of the child.
             * @return  {boolean}
             */
            RayCast: function (output, input, childIndex) {
                return this.Shape.RayCast(output, input, Bridge.ref(this.Body, "Xf"), childIndex);
            },
            /**
             * Get the fixture's AABB. This AABB may be enlarge and/or stale.
             If you need a more accurate AABB, compute it using the Shape and
             the body transform.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Collision.AABB}    aabb          The aabb.
             * @param   {number}                           childIndex    Index of the child.
             * @return  {void}
             */
            GetAABB: function (aabb, childIndex) {
                System.Diagnostics.Debug.Assert(0 <= childIndex && childIndex < this.ProxyCount);
                aabb.v = this.Proxies[System.Array.index(childIndex, this.Proxies)].AABB.$clone();
            },
            Clone: function (body) {
                var $t;
                var fixture = new FarseerPhysics.Dynamics.Fixture.ctor();
                fixture.Body = body;

                if (FarseerPhysics.Settings.ConserveMemory) {
                    fixture.Shape = this.Shape;
                } else {
                    fixture.Shape = this.Shape.Clone();
                }

                fixture.UserData = this.UserData;
                fixture.Restitution = this.Restitution;
                fixture.Friction = this.Friction;
                fixture.IsSensor = this.IsSensor;
                fixture._collisionGroup = this.CollisionGroup;
                fixture._collisionCategories = this.CollisionCategories;
                fixture._collidesWith = this.CollidesWith;

                if (this._collisionIgnores != null) {
                    fixture._collisionIgnores = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Boolean))();

                    $t = Bridge.getEnumerator(this._collisionIgnores);
                    try {
                        while ($t.moveNext()) {
                            var pair = $t.Current;
                            fixture._collisionIgnores.add(pair.key, pair.value);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}

                fixture.RegisterFixture();
                return fixture;
            },
            DeepClone: function () {
                var fix = this.Clone(this.Body.Clone());
                return fix;
            },
            Destroy: function () {
                System.Diagnostics.Debug.Assert(this.ProxyCount === 0);

                this.Proxies = null;
                this.Shape = null;

                this.BeforeCollision = null;
                this.OnCollision = null;
                this.OnSeparation = null;
                this.AfterCollision = null;

                if (!Bridge.staticEquals(this.Body.World.FixtureRemoved, null)) {
                    this.Body.World.FixtureRemoved(this);
                }

                this.Body.World.FixtureAdded = null;
                this.Body.World.FixtureRemoved = null;
                this.OnSeparation = null;
                this.OnCollision = null;
            },
            CreateProxies: function (broadPhase, xf) {
                System.Diagnostics.Debug.Assert(this.ProxyCount === 0);

                this.ProxyCount = this.Shape.ChildCount;

                for (var i = 0; i < this.ProxyCount; i = (i + 1) | 0) {
                    var proxy = { v : new FarseerPhysics.Dynamics.FixtureProxy() };
                    this.Shape.ComputeAABB(Bridge.ref(proxy.v, "AABB"), xf, i);

                    proxy.v.Fixture = this;
                    proxy.v.ChildIndex = i;
                    proxy.v.ProxyId = broadPhase.FarseerPhysics$Collision$IBroadPhase$AddProxy(proxy);

                    this.Proxies[System.Array.index(i, this.Proxies)] = proxy.v.$clone();
                }
            },
            DestroyProxies: function (broadPhase) {
                for (var i = 0; i < this.ProxyCount; i = (i + 1) | 0) {
                    broadPhase.FarseerPhysics$Collision$IBroadPhase$RemoveProxy(this.Proxies[System.Array.index(i, this.Proxies)].ProxyId);
                    this.Proxies[System.Array.index(i, this.Proxies)].ProxyId = -1;
                }

                this.ProxyCount = 0;
            },
            Synchronize: function (broadPhase, transform1, transform2) {
                if (this.ProxyCount === 0) {
                    return;
                }

                for (var i = 0; i < this.ProxyCount; i = (i + 1) | 0) {
                    var proxy = this.Proxies[System.Array.index(i, this.Proxies)].$clone();

                    var aabb1 = { v : new FarseerPhysics.Collision.AABB() }, aabb2 = { v : new FarseerPhysics.Collision.AABB() };
                    this.Shape.ComputeAABB(aabb1, transform1, proxy.ChildIndex);
                    this.Shape.ComputeAABB(aabb2, transform2, proxy.ChildIndex);

                    proxy.AABB.Combine$1(aabb1, aabb2);

                    var displacement = Microsoft.Xna.Framework.Vector2.op_Subtraction(transform2.v.Position.$clone(), transform1.v.Position.$clone());

                    broadPhase.FarseerPhysics$Collision$IBroadPhase$MoveProxy(proxy.ProxyId, Bridge.ref(proxy, "AABB"), displacement.$clone());
                }
            },
            CompareTo: function (fixture) {
                return (this.CollidesWith === fixture.CollidesWith && this.CollisionCategories === fixture.CollisionCategories && this.CollisionGroup === fixture.CollisionGroup && this.Friction === fixture.Friction && this.IsSensor === fixture.IsSensor && this.Restitution === fixture.Restitution && this.Shape.CompareTo(fixture.Shape) && Bridge.referenceEquals(this.UserData, fixture.UserData));
            }
        }
    });

    /**
     * This proxy is used internally to connect fixtures to the broad-phase.
     *
     * @public
     * @class FarseerPhysics.Dynamics.FixtureProxy
     */
    Bridge.define("FarseerPhysics.Dynamics.FixtureProxy", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Dynamics.FixtureProxy(); }
            }
        },
        fields: {
            AABB: null,
            ChildIndex: 0,
            Fixture: null,
            ProxyId: 0
        },
        ctors: {
            init: function () {
                this.AABB = new FarseerPhysics.Collision.AABB();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5340810029, this.AABB, this.ChildIndex, this.Fixture, this.ProxyId]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Dynamics.FixtureProxy)) {
                    return false;
                }
                return Bridge.equals(this.AABB, o.AABB) && Bridge.equals(this.ChildIndex, o.ChildIndex) && Bridge.equals(this.Fixture, o.Fixture) && Bridge.equals(this.ProxyId, o.ProxyId);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Dynamics.FixtureProxy();
                s.AABB = this.AABB.$clone();
                s.ChildIndex = this.ChildIndex;
                s.Fixture = this.Fixture;
                s.ProxyId = this.ProxyId;
                return s;
            }
        }
    });

    /**
     * This is an internal class.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Island
     */
    Bridge.define("FarseerPhysics.Dynamics.Island", {
        statics: {
            fields: {
                LinTolSqr: 0,
                AngTolSqr: 0
            },
            ctors: {
                init: function () {
                    this.LinTolSqr = 0.0001;
                    this.AngTolSqr = 0.00121846993;
                }
            }
        },
        fields: {
            Bodies: null,
            BodyCount: 0,
            ContactCount: 0,
            JointCount: 0,
            _bodyCapacity: 0,
            _contactCapacity: 0,
            _contactManager: null,
            _contactSolver: null,
            _contacts: null,
            _jointCapacity: 0,
            _joints: null,
            JointUpdateTime: 0,
            _tmpTime: 0
        },
        ctors: {
            init: function () {
                this._contactSolver = new FarseerPhysics.Dynamics.Contacts.ContactSolver();
            }
        },
        methods: {
            Reset: function (bodyCapacity, contactCapacity, jointCapacity, contactManager) {
                this._bodyCapacity = bodyCapacity;
                this._contactCapacity = contactCapacity;
                this._jointCapacity = jointCapacity;

                this.BodyCount = 0;
                this.ContactCount = 0;
                this.JointCount = 0;

                this._contactManager = contactManager;

                if (this.Bodies == null || this.Bodies.length < bodyCapacity) {
                    this.Bodies = System.Array.init(bodyCapacity, null, FarseerPhysics.Dynamics.Body);
                }

                if (this._contacts == null || this._contacts.length < contactCapacity) {
                    this._contacts = System.Array.init(Bridge.Int.mul(contactCapacity, 2), null, FarseerPhysics.Dynamics.Contacts.Contact);
                }

                if (this._joints == null || this._joints.length < jointCapacity) {
                    this._joints = System.Array.init(Bridge.Int.mul(jointCapacity, 2), null, FarseerPhysics.Dynamics.Joints.Joint);
                }
            },
            Clear: function () {
                this.BodyCount = 0;
                this.ContactCount = 0;
                this.JointCount = 0;
            },
            Solve: function (step, gravity) {
                for (var i = 0; i < this.BodyCount; i = (i + 1) | 0) {
                    var b = this.Bodies[System.Array.index(i, this.Bodies)];

                    if (b.BodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                        continue;
                    }

                    if (b.IgnoreGravity) {
                        b.LinearVelocityInternal.X += step.v.dt * (b.InvMass * b.Force.X);
                        b.LinearVelocityInternal.Y += step.v.dt * (b.InvMass * b.Force.Y);
                        b.AngularVelocityInternal += step.v.dt * b.InvI * b.Torque;
                    } else {
                        b.LinearVelocityInternal.X += step.v.dt * (gravity.v.X + b.InvMass * b.Force.X);
                        b.LinearVelocityInternal.Y += step.v.dt * (gravity.v.Y + b.InvMass * b.Force.Y);
                        b.AngularVelocityInternal += step.v.dt * b.InvI * b.Torque;
                    }

                    b.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Multiply$1(b.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Clamp$2(1.0 - step.v.dt * b.LinearDamping, 0.0, 1.0));
                    b.AngularVelocityInternal *= FarseerPhysics.Common.MathUtils.Clamp$2(1.0 - step.v.dt * b.AngularDamping, 0.0, 1.0);
                }

                var i1 = -1;
                for (var i2 = 0; i2 < this.ContactCount; i2 = (i2 + 1) | 0) {
                    var fixtureA = this._contacts[System.Array.index(i2, this._contacts)].FixtureA;
                    var fixtureB = this._contacts[System.Array.index(i2, this._contacts)].FixtureB;
                    var bodyA = fixtureA.Body;
                    var bodyB = fixtureB.Body;
                    var nonStatic = bodyA.BodyType !== FarseerPhysics.Dynamics.BodyType.Static && bodyB.BodyType !== FarseerPhysics.Dynamics.BodyType.Static;
                    if (nonStatic) {
                        i1 = (i1 + 1) | 0;

                        var tmp = this._contacts[System.Array.index(i1, this._contacts)];
                        this._contacts[System.Array.index(i1, this._contacts)] = this._contacts[System.Array.index(i2, this._contacts)];
                        this._contacts[System.Array.index(i2, this._contacts)] = tmp;
                    }
                }

                this._contactSolver.Reset(this._contacts, this.ContactCount, step.v.dtRatio, FarseerPhysics.Settings.EnableWarmstarting);
                this._contactSolver.InitializeVelocityConstraints();

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._contactSolver.WarmStart();
                }


                for (var i3 = 0; i3 < this.JointCount; i3 = (i3 + 1) | 0) {
                    if (this._joints[System.Array.index(i3, this._joints)].Enabled) {
                        this._joints[System.Array.index(i3, this._joints)].InitVelocityConstraints(step);
                    }
                }


                for (var i4 = 0; i4 < FarseerPhysics.Settings.VelocityIterations; i4 = (i4 + 1) | 0) {
                    for (var j = 0; j < this.JointCount; j = (j + 1) | 0) {
                        var joint = this._joints[System.Array.index(j, this._joints)];

                        if (!joint.Enabled) {
                            continue;
                        }

                        joint.SolveVelocityConstraints(step);
                        joint.Validate(step.v.inv_dt);
                    }


                    this._contactSolver.SolveVelocityConstraints();
                }

                this._contactSolver.StoreImpulses();

                for (var i5 = 0; i5 < this.BodyCount; i5 = (i5 + 1) | 0) {
                    var b1 = this.Bodies[System.Array.index(i5, this.Bodies)];

                    if (b1.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        continue;
                    }

                    var translationX = step.v.dt * b1.LinearVelocityInternal.X;
                    var translationY = step.v.dt * b1.LinearVelocityInternal.Y;
                    var result = translationX * translationX + translationY * translationY;

                    if (result > FarseerPhysics.Settings.MaxTranslationSquared) {
                        var sq = Math.sqrt(result);

                        var ratio = FarseerPhysics.Settings.MaxTranslation / sq;
                        b1.LinearVelocityInternal.X *= ratio;
                        b1.LinearVelocityInternal.Y *= ratio;
                    }

                    var rotation = step.v.dt * b1.AngularVelocityInternal;
                    if (rotation * rotation > FarseerPhysics.Settings.MaxRotationSquared) {
                        var ratio1 = FarseerPhysics.Settings.MaxRotation / Math.abs(rotation);
                        b1.AngularVelocityInternal *= ratio1;
                    }

                    b1.Sweep.C0.X = b1.Sweep.C.X;
                    b1.Sweep.C0.Y = b1.Sweep.C.Y;
                    b1.Sweep.A0 = b1.Sweep.A;

                    b1.Sweep.C.X += step.v.dt * b1.LinearVelocityInternal.X;
                    b1.Sweep.C.Y += step.v.dt * b1.LinearVelocityInternal.Y;
                    b1.Sweep.A += step.v.dt * b1.AngularVelocityInternal;

                    b1.SynchronizeTransform();

                }

                for (var i6 = 0; i6 < FarseerPhysics.Settings.PositionIterations; i6 = (i6 + 1) | 0) {
                    var contactsOkay = this._contactSolver.SolvePositionConstraints(FarseerPhysics.Settings.ContactBaumgarte);
                    var jointsOkay = true;

                    for (var j1 = 0; j1 < this.JointCount; j1 = (j1 + 1) | 0) {
                        var joint1 = this._joints[System.Array.index(j1, this._joints)];
                        if (!joint1.Enabled) {
                            continue;
                        }

                        var jointOkay = joint1.SolvePositionConstraints();
                        jointsOkay = jointsOkay && jointOkay;
                    }

                    if (contactsOkay && jointsOkay) {
                        break;
                    }
                }


                this.Report(this._contactSolver.Constraints);

                if (FarseerPhysics.Settings.AllowSleep) {
                    var minSleepTime = FarseerPhysics.Settings.MaxFloat;

                    for (var i7 = 0; i7 < this.BodyCount; i7 = (i7 + 1) | 0) {
                        var b2 = this.Bodies[System.Array.index(i7, this.Bodies)];
                        if (b2.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                            continue;
                        }

                        if ((b2.Flags & FarseerPhysics.Dynamics.BodyFlags.AutoSleep) === 0) {
                            b2.SleepTime = 0.0;
                            minSleepTime = 0.0;
                        }

                        if ((b2.Flags & FarseerPhysics.Dynamics.BodyFlags.AutoSleep) === 0 || b2.AngularVelocityInternal * b2.AngularVelocityInternal > FarseerPhysics.Dynamics.Island.AngTolSqr || Microsoft.Xna.Framework.Vector2.Dot(b2.LinearVelocityInternal.$clone(), b2.LinearVelocityInternal.$clone()) > FarseerPhysics.Dynamics.Island.LinTolSqr) {
                            b2.SleepTime = 0.0;
                            minSleepTime = 0.0;
                        } else {
                            b2.SleepTime += step.v.dt;
                            minSleepTime = Math.min(minSleepTime, b2.SleepTime);
                        }
                    }

                    if (minSleepTime >= FarseerPhysics.Settings.TimeToSleep) {
                        for (var i8 = 0; i8 < this.BodyCount; i8 = (i8 + 1) | 0) {
                            var b3 = this.Bodies[System.Array.index(i8, this.Bodies)];
                            b3.Awake = false;
                        }
                    }
                }
            },
            SolveTOI: function (subStep) {
                this._contactSolver.Reset(this._contacts, this.ContactCount, subStep.v.dtRatio, false);

                var kTOIBaumgarte = 0.75;
                for (var i = 0; i < FarseerPhysics.Settings.TOIPositionIterations; i = (i + 1) | 0) {
                    var contactsOkay = this._contactSolver.SolvePositionConstraints(kTOIBaumgarte);
                    if (contactsOkay) {
                        break;
                    }

                    if (i === ((FarseerPhysics.Settings.TOIPositionIterations - 1) | 0)) {
                        i = (i + 0) | 0;
                    }
                }

                for (var i1 = 0; i1 < this.BodyCount; i1 = (i1 + 1) | 0) {
                    var body = this.Bodies[System.Array.index(i1, this.Bodies)];
                    body.Sweep.A0 = body.Sweep.A;
                    body.Sweep.C0 = body.Sweep.C.$clone();
                }

                this._contactSolver.InitializeVelocityConstraints();

                for (var i2 = 0; i2 < FarseerPhysics.Settings.TOIVelocityIterations; i2 = (i2 + 1) | 0) {
                    this._contactSolver.SolveVelocityConstraints();
                }


                for (var i3 = 0; i3 < this.BodyCount; i3 = (i3 + 1) | 0) {
                    var b = this.Bodies[System.Array.index(i3, this.Bodies)];

                    if (b.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        continue;
                    }

                    var translationx = subStep.v.dt * b.LinearVelocityInternal.X;
                    var translationy = subStep.v.dt * b.LinearVelocityInternal.Y;
                    var dot = translationx * translationx + translationy * translationy;
                    if (dot > FarseerPhysics.Settings.MaxTranslationSquared) {
                        var norm = 1.0 / Math.sqrt(dot);
                        var value = FarseerPhysics.Settings.MaxTranslation * subStep.v.inv_dt;
                        b.LinearVelocityInternal.X = value * (translationx * norm);
                        b.LinearVelocityInternal.Y = value * (translationy * norm);
                    }

                    var rotation = subStep.v.dt * b.AngularVelocity;
                    if (rotation * rotation > FarseerPhysics.Settings.MaxRotationSquared) {
                        if (rotation < 0.0) {
                            b.AngularVelocityInternal = -subStep.v.inv_dt * FarseerPhysics.Settings.MaxRotation;
                        } else {
                            b.AngularVelocityInternal = subStep.v.inv_dt * FarseerPhysics.Settings.MaxRotation;
                        }
                    }

                    b.Sweep.C.X += subStep.v.dt * b.LinearVelocityInternal.X;
                    b.Sweep.C.Y += subStep.v.dt * b.LinearVelocityInternal.Y;
                    b.Sweep.A += subStep.v.dt * b.AngularVelocityInternal;

                    b.SynchronizeTransform();

                }

                this.Report(this._contactSolver.Constraints);
            },
            Add: function (body) {
                System.Diagnostics.Debug.Assert(this.BodyCount < this._bodyCapacity);
                this.Bodies[System.Array.index(Bridge.identity(this.BodyCount, (this.BodyCount = (this.BodyCount + 1) | 0)), this.Bodies)] = body;
            },
            Add$1: function (contact) {
                System.Diagnostics.Debug.Assert(this.ContactCount < this._contactCapacity);
                this._contacts[System.Array.index(Bridge.identity(this.ContactCount, (this.ContactCount = (this.ContactCount + 1) | 0)), this._contacts)] = contact;
            },
            Add$2: function (joint) {
                System.Diagnostics.Debug.Assert(this.JointCount < this._jointCapacity);
                this._joints[System.Array.index(Bridge.identity(this.JointCount, (this.JointCount = (this.JointCount + 1) | 0)), this._joints)] = joint;
            },
            Report: function (constraints) {
                if (this._contactManager == null) {
                    return;
                }

                for (var i = 0; i < this.ContactCount; i = (i + 1) | 0) {
                    var c = this._contacts[System.Array.index(i, this._contacts)];

                    if (!Bridge.staticEquals(c.FixtureA.AfterCollision, null)) {
                        c.FixtureA.AfterCollision(c.FixtureA, c.FixtureB, c);
                    }

                    if (!Bridge.staticEquals(c.FixtureB.AfterCollision, null)) {
                        c.FixtureB.AfterCollision(c.FixtureB, c.FixtureA, c);
                    }

                    if (!Bridge.staticEquals(this._contactManager.PostSolve, null)) {
                        var cc = constraints[System.Array.index(i, constraints)];

                        this._contactManager.PostSolve(c, cc);
                    }
                }
            }
        }
    });

    /**
     * @memberof System
     * @callback System.Action
     * @param   {FarseerPhysics.Dynamics.Joints.Joint}    arg1    
     * @param   {number}                                  arg2
     * @return  {void}
     */

    Bridge.define("FarseerPhysics.Dynamics.Joints.Joint", {
        fields: {
            /**
             * The Breakpoint simply indicates the maximum Value the JointError can be before it breaks.
             The default value is float.MaxValue
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @type number
             */
            Breakpoint: 0,
            EdgeA: null,
            EdgeB: null,
            Enabled: false,
            InvIA: 0,
            InvIB: 0,
            InvMassA: 0,
            InvMassB: 0,
            IslandFlag: false,
            LocalCenterA: null,
            LocalCenterB: null,
            /**
             * Gets or sets the type of the joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function JointType
             * @type FarseerPhysics.Dynamics.Joints.JointType
             */
            JointType: 0,
            /**
             * Get the first body attached to this joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function BodyA
             * @type FarseerPhysics.Dynamics.Body
             */
            BodyA: null,
            /**
             * Get the second body attached to this joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function BodyB
             * @type FarseerPhysics.Dynamics.Body
             */
            BodyB: null,
            /**
             * Set the user data pointer.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function UserData
             * @type System.Object
             */
            UserData: null,
            /**
             * Set this flag to true if the attached bodies should collide.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function CollideConnected
             * @type boolean
             */
            CollideConnected: false
        },
        events: {
            /**
             * Fires when the joint is broken.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.Joint
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function addBroke
             * @param   {System.Action}    value
             * @return  {void}
             */
            /**
             * Fires when the joint is broken.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.Joint
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function removeBroke
             * @param   {System.Action}    value
             * @return  {void}
             */
            Broke: null
        },
        props: {
            /**
             * Short-cut function to determine if either body is inactive.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function Active
             * @type boolean
             */
            Active: {
                get: function () {
                    return this.BodyA.Enabled && this.BodyB.Enabled;
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalCenterA = new Microsoft.Xna.Framework.Vector2();
                this.LocalCenterB = new Microsoft.Xna.Framework.Vector2();
                this.Breakpoint = 3.40282347E+38;
                this.EdgeA = new FarseerPhysics.Dynamics.Joints.JointEdge();
                this.EdgeB = new FarseerPhysics.Dynamics.Joints.JointEdge();
                this.Enabled = true;
            },
            ctor: function () {
                this.$initialize();
            },
            $ctor2: function (body, bodyB) {
                this.$initialize();
                System.Diagnostics.Debug.Assert(!Bridge.referenceEquals(body, bodyB));

                this.BodyA = body;
                this.BodyB = bodyB;

                this.CollideConnected = false;
            },
            /**
             * Constructor for fixed joint
             *
             * @instance
             * @protected
             * @this FarseerPhysics.Dynamics.Joints.Joint
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @param   {FarseerPhysics.Dynamics.Body}    body
             * @return  {void}
             */
            $ctor1: function (body) {
                this.$initialize();
                this.BodyA = body;

                this.CollideConnected = false;
            }
        },
        methods: {
            WakeBodies: function () {
                this.BodyA.Awake = true;
                if (this.BodyB != null) {
                    this.BodyB.Awake = true;
                }
            },
            /**
             * Return true if the joint is a fixed type.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.Joint
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @return  {boolean}
             */
            IsFixedType: function () {
                return this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedDistance || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedLine || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedMouse || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedAngle || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedFriction;
            },
            Validate: function (invDT) {
                if (!this.Enabled) {
                    return;
                }

                var jointError = this.GetReactionForce(invDT).Length();
                if (Math.abs(jointError) <= this.Breakpoint) {
                    return;
                }

                this.Enabled = false;

                if (!Bridge.staticEquals(this.Broke, null)) {
                    this.Broke(this, jointError);
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.Jacobian", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Dynamics.Joints.Jacobian(); }
            }
        },
        fields: {
            AngularA: 0,
            AngularB: 0,
            LinearA: null,
            LinearB: null
        },
        ctors: {
            init: function () {
                this.LinearA = new Microsoft.Xna.Framework.Vector2();
                this.LinearB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            SetZero: function () {
                this.LinearA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.AngularA = 0.0;
                this.LinearB = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.AngularB = 0.0;
            },
            Set: function (x1, a1, x2, a2) {
                this.LinearA = x1.$clone();
                this.AngularA = a1;
                this.LinearB = x2.$clone();
                this.AngularB = a2;
            },
            Compute: function (x1, a1, x2, a2) {
                return Microsoft.Xna.Framework.Vector2.Dot(this.LinearA.$clone(), x1.$clone()) + this.AngularA * a1 + Microsoft.Xna.Framework.Vector2.Dot(this.LinearB.$clone(), x2.$clone()) + this.AngularB * a2;
            },
            getHashCode: function () {
                var h = Bridge.addHash([3720661676, this.AngularA, this.AngularB, this.LinearA, this.LinearB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Dynamics.Joints.Jacobian)) {
                    return false;
                }
                return Bridge.equals(this.AngularA, o.AngularA) && Bridge.equals(this.AngularB, o.AngularB) && Bridge.equals(this.LinearA, o.LinearA) && Bridge.equals(this.LinearB, o.LinearB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Dynamics.Joints.Jacobian();
                s.AngularA = this.AngularA;
                s.AngularB = this.AngularB;
                s.LinearA = this.LinearA.$clone();
                s.LinearB = this.LinearB.$clone();
                return s;
            }
        }
    });

    /** @namespace FarseerPhysics.Dynamics.Joints */

    /**
     * A joint edge is used to connect bodies and joints together
     in a joint graph where each body is a node and each joint
     is an edge. A joint edge belongs to a doubly linked list
     maintained in each attached body. Each joint has two joint
     nodes, one for each attached body.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.JointEdge
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.JointEdge", {
        fields: {
            /**
             * The joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.JointEdge
             * @type FarseerPhysics.Dynamics.Joints.Joint
             */
            Joint: null,
            /**
             * The next joint edge in the body's joint list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.JointEdge
             * @type FarseerPhysics.Dynamics.Joints.JointEdge
             */
            Next: null,
            /**
             * Provides quick access to the other body attached.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.JointEdge
             * @type FarseerPhysics.Dynamics.Body
             */
            Other: null,
            /**
             * The previous joint edge in the body's joint list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.JointEdge
             * @type FarseerPhysics.Dynamics.Joints.JointEdge
             */
            Prev: null
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.JointType", {
        $kind: "enum",
        statics: {
            fields: {
                Revolute: 0,
                Prismatic: 1,
                Distance: 2,
                Pulley: 3,
                Gear: 4,
                Line: 5,
                Weld: 6,
                Friction: 7,
                Slider: 8,
                Angle: 9,
                Rope: 10,
                FixedMouse: 11,
                FixedRevolute: 12,
                FixedDistance: 13,
                FixedLine: 14,
                FixedPrismatic: 15,
                FixedAngle: 16,
                FixedFriction: 17
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.LimitState", {
        $kind: "enum",
        statics: {
            fields: {
                Inactive: 0,
                AtLower: 1,
                AtUpper: 2,
                Equal: 3
            }
        }
    });

    /**
     * This is an internal structure.
     *
     * @public
     * @class FarseerPhysics.Dynamics.TimeStep
     */
    Bridge.define("FarseerPhysics.Dynamics.TimeStep", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Dynamics.TimeStep(); }
            }
        },
        fields: {
            /**
             * Time step (Delta time)
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.TimeStep
             * @type number
             */
            dt: 0,
            /**
             * dt * inv_dt0
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.TimeStep
             * @type number
             */
            dtRatio: 0,
            /**
             * Inverse time step (0 if dt == 0).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.TimeStep
             * @type number
             */
            inv_dt: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3587366311, this.dt, this.dtRatio, this.inv_dt]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Dynamics.TimeStep)) {
                    return false;
                }
                return Bridge.equals(this.dt, o.dt) && Bridge.equals(this.dtRatio, o.dtRatio) && Bridge.equals(this.inv_dt, o.inv_dt);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Dynamics.TimeStep();
                s.dt = this.dt;
                s.dtRatio = this.dtRatio;
                s.inv_dt = this.inv_dt;
                return s;
            }
        }
    });

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.RayCastCallback
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixture     
     * @param   {Microsoft.Xna.Framework.Vector2}    point       
     * @param   {Microsoft.Xna.Framework.Vector2}    normal      
     * @param   {number}                             fraction
     * @return  {number}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.JointDelegate
     * @param   {FarseerPhysics.Dynamics.Joints.Joint}    joint
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.FixtureDelegate
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixture
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.BodyDelegate
     * @param   {FarseerPhysics.Dynamics.Body}    body
     * @return  {void}
     */

    /**
     * The world class manages all physics entities, dynamic simulation,
     and asynchronous queries.
     *
     * @public
     * @class FarseerPhysics.Dynamics.World
     */
    Bridge.define("FarseerPhysics.Dynamics.World", {
        fields: {
            /**
             * Fires whenever a body has been added
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.BodyDelegate
             */
            BodyAdded: null,
            /**
             * Fires whenever a body has been removed
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.BodyDelegate
             */
            BodyRemoved: null,
            ContactPool: null,
            /**
             * Fires whenever a fixture has been added
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.FixtureDelegate
             */
            FixtureAdded: null,
            /**
             * Fires whenever a fixture has been removed
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.FixtureDelegate
             */
            FixtureRemoved: null,
            Flags: 0,
            /**
             * Fires whenever a joint has been added
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.JointDelegate
             */
            JointAdded: null,
            /**
             * Fires whenever a joint has been removed
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.JointDelegate
             */
            JointRemoved: null,
            ControllerAdded: null,
            ControllerRemoved: null,
            _invDt0: 0,
            Island: null,
            _stack: null,
            _stepComplete: false,
            _bodyAddList: null,
            _bodyRemoveList: null,
            _jointAddList: null,
            _jointRemoveList: null,
            _input: null,
            /**
             * If false, the whole simulation stops. It still processes added and removed geometries.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @default true
             * @type boolean
             */
            Enabled: false,
            ControllerList: null,
            BreakableBodyList: null,
            UpdateTime: 0,
            ContinuousPhysicsTime: 0,
            ControllersUpdateTime: 0,
            AddRemoveTime: 0,
            ContactsUpdateTime: 0,
            SolveUpdateTime: 0,
            /**
             * Change the global gravity vector.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type Microsoft.Xna.Framework.Vector2
             */
            Gravity: null,
            /**
             * Get the contact manager for testing.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function ContactManager
             * @type FarseerPhysics.Dynamics.ContactManager
             */
            ContactManager: null,
            /**
             * Get the world body list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function BodyList
             * @type System.Collections.Generic.List$1
             */
            BodyList: null,
            /**
             * Get the world joint list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function JointList
             * @type System.Collections.Generic.List$1
             */
            JointList: null
        },
        props: {
            /**
             * Get the number of broad-phase proxies.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.World
             * @function ProxyCount
             * @type number
             */
            ProxyCount: {
                get: function () {
                    return this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$ProxyCount;
                }
            },
            /**
             * Set flag to control automatic clearing of forces after each time step.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function AutoClearForces
             * @type boolean
             */
            AutoClearForces: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.WorldFlags.ClearForces) === FarseerPhysics.Dynamics.WorldFlags.ClearForces;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.WorldFlags.ClearForces;
                    } else {
                        this.Flags &= -5;
                    }
                }
            },
            /**
             * Get the world contact list. With the returned contact, use Contact.GetNext to get
             the next contact in the world list. A null contact indicates the end of the list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.World
             * @function ContactList
             * @type System.Collections.Generic.List$1
             */
            ContactList: {
                get: function () {
                    return this.ContactManager.ContactList;
                }
            },
            /**
             * Enable/disable single stepped continuous physics. For testing.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function EnableSubStepping
             * @type boolean
             */
            EnableSubStepping: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.WorldFlags.SubStepping) === FarseerPhysics.Dynamics.WorldFlags.SubStepping;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.WorldFlags.SubStepping;
                    } else {
                        this.Flags &= -17;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.Gravity = new Microsoft.Xna.Framework.Vector2();
                this.ContactPool = new (System.Collections.Generic.Queue$1(FarseerPhysics.Dynamics.Contacts.Contact)).$ctor2(256);
                this.Island = new FarseerPhysics.Dynamics.Island();
                this._stack = System.Array.init(64, null, FarseerPhysics.Dynamics.Body);
                this._bodyAddList = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Dynamics.Body)).ctor();
                this._bodyRemoveList = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Dynamics.Body)).ctor();
                this._jointAddList = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Dynamics.Joints.Joint)).ctor();
                this._jointRemoveList = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Dynamics.Joints.Joint)).ctor();
                this._input = new FarseerPhysics.Collision.TOIInput();
                this.Enabled = true;
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @return  {void}
             */
            ctor: function () {
                this.$initialize();
                this.Flags = FarseerPhysics.Dynamics.WorldFlags.ClearForces;

                this.ControllerList = new (System.Collections.Generic.List$1(FarseerPhysics.Controllers.Controller)).ctor();
                this.BreakableBodyList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.BreakableBody)).ctor();
                this.BodyList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body)).$ctor2(32);
                this.JointList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Joints.Joint)).$ctor2(32);
            },
            $ctor2: function (gravity, span) {
                FarseerPhysics.Dynamics.World.ctor.call(this);
                this.Gravity = gravity.$clone();
                this.ContactManager = new FarseerPhysics.Dynamics.ContactManager(new QuadTreeBroadPhase(span.$clone()));
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {Microsoft.Xna.Framework.Vector2}    gravity    The gravity.
             * @return  {void}
             */
            $ctor1: function (gravity) {
                FarseerPhysics.Dynamics.World.ctor.call(this);
                this.ContactManager = new FarseerPhysics.Dynamics.ContactManager(new FarseerPhysics.Collision.DynamicTreeBroadPhase());
                this.Gravity = gravity.$clone();
            }
        },
        methods: {
            /**
             * Add a rigid body.
             *
             * @instance
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.Body}    body
             * @return  {void}
             */
            AddBody: function (body) {
                System.Diagnostics.Debug.Assert$1(!this._bodyAddList.contains(body), "You are adding the same body more than once.");

                if (!this._bodyAddList.contains(body)) {
                    this._bodyAddList.add(body);
                }
            },
            /**
             * Destroy a rigid body.
             Warning: This automatically deletes all associated shapes and joints.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.Body}    body    The body.
             * @return  {void}
             */
            RemoveBody: function (body) {
                System.Diagnostics.Debug.Assert$1(!this._bodyRemoveList.contains(body), "The body is already marked for removal. You are removing the body more than once.");

                if (!this._bodyRemoveList.contains(body)) {
                    this._bodyRemoveList.add(body);
                }
            },
            /**
             * Create a joint to constrain bodies together. This may cause the connected bodies to cease colliding.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.Joints.Joint}    joint    The joint.
             * @return  {void}
             */
            AddJoint: function (joint) {
                System.Diagnostics.Debug.Assert$1(!this._jointAddList.contains(joint), "You are adding the same joint more than once.");

                if (!this._jointAddList.contains(joint)) {
                    this._jointAddList.add(joint);
                }
            },
            RemoveJoint$1: function (joint, doCheck) {
                if (doCheck) {
                    System.Diagnostics.Debug.Assert$1(!this._jointRemoveList.contains(joint), "The joint is already marked for removal. You are removing the joint more than once.");
                }

                if (!this._jointRemoveList.contains(joint)) {
                    this._jointRemoveList.add(joint);
                }
            },
            /**
             * Destroy a joint. This may cause the connected bodies to begin colliding.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.Joints.Joint}    joint    The joint.
             * @return  {void}
             */
            RemoveJoint: function (joint) {
                this.RemoveJoint$1(joint, true);
            },
            /**
             * All adds and removes are cached by the World duing a World step.
             To process the changes before the world updates again, call this method.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @return  {void}
             */
            ProcessChanges: function () {
                this.ProcessAddedBodies();
                this.ProcessAddedJoints();

                this.ProcessRemovedBodies();
                this.ProcessRemovedJoints();
            },
            ProcessRemovedJoints: function () {
                var $t;
                if (this._jointRemoveList.Count > 0) {
                    $t = Bridge.getEnumerator(this._jointRemoveList);
                    try {
                        while ($t.moveNext()) {
                            var joint = $t.Current;
                            var collideConnected = joint.CollideConnected;

                            this.JointList.remove(joint);

                            var bodyA = joint.BodyA;
                            var bodyB = joint.BodyB;

                            bodyA.Awake = true;

                            if (!joint.IsFixedType()) {
                                bodyB.Awake = true;
                            }

                            if (joint.EdgeA.Prev != null) {
                                joint.EdgeA.Prev.Next = joint.EdgeA.Next;
                            }

                            if (joint.EdgeA.Next != null) {
                                joint.EdgeA.Next.Prev = joint.EdgeA.Prev;
                            }

                            if (Bridge.referenceEquals(joint.EdgeA, bodyA.JointList)) {
                                bodyA.JointList = joint.EdgeA.Next;
                            }

                            joint.EdgeA.Prev = null;
                            joint.EdgeA.Next = null;

                            if (!joint.IsFixedType()) {
                                if (joint.EdgeB.Prev != null) {
                                    joint.EdgeB.Prev.Next = joint.EdgeB.Next;
                                }

                                if (joint.EdgeB.Next != null) {
                                    joint.EdgeB.Next.Prev = joint.EdgeB.Prev;
                                }

                                if (Bridge.referenceEquals(joint.EdgeB, bodyB.JointList)) {
                                    bodyB.JointList = joint.EdgeB.Next;
                                }

                                joint.EdgeB.Prev = null;
                                joint.EdgeB.Next = null;
                            }

                            if (!joint.IsFixedType()) {
                                if (collideConnected === false) {
                                    var edge = bodyB.ContactList;
                                    while (edge != null) {
                                        if (Bridge.referenceEquals(edge.Other, bodyA)) {
                                            edge.Contact.FlagForFiltering();
                                        }

                                        edge = edge.Next;
                                    }
                                }
                            }

                            if (!Bridge.staticEquals(this.JointRemoved, null)) {
                                this.JointRemoved(joint);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._jointRemoveList.clear();
                }
            },
            ProcessAddedJoints: function () {
                var $t;
                if (this._jointAddList.Count > 0) {
                    $t = Bridge.getEnumerator(this._jointAddList);
                    try {
                        while ($t.moveNext()) {
                            var joint = $t.Current;
                            this.JointList.add(joint);

                            joint.EdgeA.Joint = joint;
                            joint.EdgeA.Other = joint.BodyB;
                            joint.EdgeA.Prev = null;
                            joint.EdgeA.Next = joint.BodyA.JointList;

                            if (joint.BodyA.JointList != null) {
                                joint.BodyA.JointList.Prev = joint.EdgeA;
                            }

                            joint.BodyA.JointList = joint.EdgeA;

                            if (!joint.IsFixedType()) {
                                joint.EdgeB.Joint = joint;
                                joint.EdgeB.Other = joint.BodyA;
                                joint.EdgeB.Prev = null;
                                joint.EdgeB.Next = joint.BodyB.JointList;

                                if (joint.BodyB.JointList != null) {
                                    joint.BodyB.JointList.Prev = joint.EdgeB;
                                }

                                joint.BodyB.JointList = joint.EdgeB;

                                var bodyA = joint.BodyA;
                                var bodyB = joint.BodyB;

                                if (joint.CollideConnected === false) {
                                    var edge = bodyB.ContactList;
                                    while (edge != null) {
                                        if (Bridge.referenceEquals(edge.Other, bodyA)) {
                                            edge.Contact.FlagForFiltering();
                                        }

                                        edge = edge.Next;
                                    }
                                }
                            }

                            if (!Bridge.staticEquals(this.JointAdded, null)) {
                                this.JointAdded(joint);
                            }

                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._jointAddList.clear();
                }
            },
            ProcessAddedBodies: function () {
                var $t;
                if (this._bodyAddList.Count > 0) {
                    $t = Bridge.getEnumerator(this._bodyAddList);
                    try {
                        while ($t.moveNext()) {
                            var body = $t.Current;
                            this.BodyList.add(body);

                            if (!Bridge.staticEquals(this.BodyAdded, null)) {
                                this.BodyAdded(body);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._bodyAddList.clear();
                }
            },
            ProcessRemovedBodies: function () {
                var $t;
                if (this._bodyRemoveList.Count > 0) {
                    $t = Bridge.getEnumerator(this._bodyRemoveList);
                    try {
                        while ($t.moveNext()) {
                            var body = $t.Current;
                            System.Diagnostics.Debug.Assert(this.BodyList.Count > 0);

                            System.Diagnostics.Debug.Assert(this.BodyList.contains(body));

                            var je = body.JointList;
                            while (je != null) {
                                var je0 = je;
                                je = je.Next;

                                this.RemoveJoint$1(je0.Joint, false);
                            }
                            body.JointList = null;

                            var ce = body.ContactList;
                            while (ce != null) {
                                var ce0 = ce;
                                ce = ce.Next;
                                this.ContactManager.Destroy(ce0.Contact);
                            }
                            body.ContactList = null;

                            for (var i = 0; i < body.FixtureList.Count; i = (i + 1) | 0) {
                                body.FixtureList.getItem(i).DestroyProxies(this.ContactManager.BroadPhase);
                                body.FixtureList.getItem(i).Destroy();
                            }

                            body.FixtureList = null;

                            this.BodyList.remove(body);

                            if (!Bridge.staticEquals(this.BodyRemoved, null)) {
                                this.BodyRemoved(body);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._bodyRemoveList.clear();
                }
            },
            /**
             * Take a time step. This performs collision detection, integration,
             and consraint solution.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {number}    dt    The amount of time to simulate, this should not vary.
             * @return  {void}
             */
            Step: function (dt) {

                this.ProcessChanges();

                if (dt === 0 || !this.Enabled) {
                    return;
                }

                if ((this.Flags & FarseerPhysics.Dynamics.WorldFlags.NewFixture) === FarseerPhysics.Dynamics.WorldFlags.NewFixture) {
                    this.ContactManager.FindNewContacts();
                    this.Flags &= -2;
                }

                var step = { v : new FarseerPhysics.Dynamics.TimeStep() };
                step.v.inv_dt = 1.0 / dt;
                step.v.dt = dt;
                step.v.dtRatio = this._invDt0 * dt;

                for (var i = 0; i < this.ControllerList.Count; i = (i + 1) | 0) {
                    this.ControllerList.getItem(i).Update(dt);
                }


                this.ContactManager.Collide();

                this.Solve(step);


                if (FarseerPhysics.Settings.ContinuousPhysics) {
                    this.SolveTOI(step);
                }

                this._invDt0 = step.v.inv_dt;

                if ((this.Flags & FarseerPhysics.Dynamics.WorldFlags.ClearForces) !== 0) {
                    this.ClearForces();
                }

                for (var i1 = 0; i1 < this.BreakableBodyList.Count; i1 = (i1 + 1) | 0) {
                    this.BreakableBodyList.getItem(i1).Update();
                }
            },
            /**
             * Call this after you are done with time steps to clear the forces. You normally
             call this after each call to Step, unless you are performing sub-steps. By default,
             forces will be automatically cleared, so you don't need to call this function.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @return  {void}
             */
            ClearForces: function () {
                for (var i = 0; i < this.BodyList.Count; i = (i + 1) | 0) {
                    var body = this.BodyList.getItem(i);
                    body.Force = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    body.Torque = 0.0;
                }
            },
            /**
             * Query the world for all fixtures that potentially overlap the
             provided AABB.
             Inside the callback:
             Return true: Continues the query
             Return false: Terminate the query
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {System.Func}                      callback    A user implemented callback class.
             * @param   {FarseerPhysics.Collision.AABB}    aabb        The aabb query box.
             * @return  {void}
             */
            QueryAABB: function (callback, aabb) {
                this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$Query(Bridge.fn.bind(this, function (proxyId) {
                    var proxy = this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$GetProxy(proxyId);
                    return callback(proxy.Fixture);
                }), aabb);
            },
            /**
             * Ray-cast the world for all fixtures in the path of the ray. Your callback
             controls whether you get the closest point, any point, or n-points.
             The ray-cast ignores shapes that contain the starting point.
             Inside the callback:
             return -1: ignore this fixture and continue
             return 0: terminate the ray cast
             return fraction: clip the ray to this point
             return 1: don't clip the ray and continue
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.RayCastCallback}    callback    A user implemented callback class.
             * @param   {Microsoft.Xna.Framework.Vector2}            point1      The ray starting point.
             * @param   {Microsoft.Xna.Framework.Vector2}            point2      The ray ending point.
             * @return  {void}
             */
            RayCast: function (callback, point1, point2) {
                var input = { v : new FarseerPhysics.Collision.RayCastInput() };
                input.v.MaxFraction = 1.0;
                input.v.Point1 = point1.$clone();
                input.v.Point2 = point2.$clone();

                this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$RayCast(Bridge.fn.bind(this, function (rayCastInput, proxyId) {
                    rayCastInput = {v:rayCastInput};
                    var proxy = this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$GetProxy(proxyId);
                    var fixture = proxy.Fixture;
                    var index = proxy.ChildIndex;
                    var output = { v : new FarseerPhysics.Collision.RayCastOutput() };
                    var hit = fixture.RayCast(output, rayCastInput, index);

                    if (hit) {
                        var fraction = output.v.Fraction;
                        var point = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2((1.0 - fraction), input.v.Point1.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(fraction, input.v.Point2.$clone()));
                        return callback(fixture, point.$clone(), output.v.Normal.$clone(), fraction);
                    }

                    return input.v.MaxFraction;
                }), input);
            },
            Solve: function (step) {
                var $t, $t1, $t2, $t3;
                this.Island.Reset(this.BodyList.Count, this.ContactManager.ContactList.Count, this.JointList.Count, this.ContactManager);

                $t = Bridge.getEnumerator(this.BodyList);
                try {
                    while ($t.moveNext()) {
                        var b = $t.Current;
                        b.Flags &= -2;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                for (var i = 0; i < this.ContactManager.ContactList.Count; i = (i + 1) | 0) {
                    var c = this.ContactManager.ContactList.getItem(i);
                    c.Flags &= -2;
                }
                $t1 = Bridge.getEnumerator(this.JointList);
                try {
                    while ($t1.moveNext()) {
                        var j = $t1.Current;
                        j.IslandFlag = false;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                var stackSize = this.BodyList.Count;
                if (stackSize > this._stack.length) {
                    this._stack = System.Array.init(Math.max(Bridge.Int.mul(this._stack.length, 2), stackSize), null, FarseerPhysics.Dynamics.Body);
                }

                for (var index = (this.BodyList.Count - 1) | 0; index >= 0; index = (index - 1) | 0) {
                    var seed = this.BodyList.getItem(index);
                    if ((seed.Flags & (FarseerPhysics.Dynamics.BodyFlags.Island)) !== FarseerPhysics.Dynamics.BodyFlags.None) {
                        continue;
                    }

                    if (seed.Awake === false || seed.Enabled === false) {
                        continue;
                    }

                    if (seed.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        continue;
                    }

                    this.Island.Clear();
                    var stackCount = 0;
                    this._stack[System.Array.index(Bridge.identity(stackCount, (stackCount = (stackCount + 1) | 0)), this._stack)] = seed;
                    seed.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;

                    while (stackCount > 0) {
                        var b1 = this._stack[System.Array.index(((stackCount = (stackCount - 1) | 0)), this._stack)];
                        System.Diagnostics.Debug.Assert(b1.Enabled);
                        this.Island.Add(b1);

                        b1.Awake = true;

                        if (b1.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                            continue;
                        }

                        for (var ce = b1.ContactList; ce != null; ce = ce.Next) {
                            var contact = ce.Contact;

                            if ((contact.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Island) !== FarseerPhysics.Dynamics.Contacts.ContactFlags.None) {
                                continue;
                            }

                            if (!ce.Contact.Enabled || !ce.Contact.IsTouching()) {
                                continue;
                            }

                            var sensorA = contact.FixtureA.IsSensor;
                            var sensorB = contact.FixtureB.IsSensor;
                            if (sensorA || sensorB) {
                                continue;
                            }

                            this.Island.Add$1(contact);
                            contact.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Island;

                            var other = ce.Other;

                            if ((other.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) !== FarseerPhysics.Dynamics.BodyFlags.None) {
                                continue;
                            }

                            System.Diagnostics.Debug.Assert(stackCount < stackSize);
                            this._stack[System.Array.index(Bridge.identity(stackCount, (stackCount = (stackCount + 1) | 0)), this._stack)] = other;
                            other.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;
                        }

                        for (var je = b1.JointList; je != null; je = je.Next) {
                            if (je.Joint.IslandFlag) {
                                continue;
                            }

                            var other1 = je.Other;

                            if (other1 != null) {
                                if (other1.Enabled === false) {
                                    continue;
                                }

                                this.Island.Add$2(je.Joint);
                                je.Joint.IslandFlag = true;

                                if ((other1.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) !== FarseerPhysics.Dynamics.BodyFlags.None) {
                                    continue;
                                }

                                System.Diagnostics.Debug.Assert(stackCount < stackSize);
                                this._stack[System.Array.index(Bridge.identity(stackCount, (stackCount = (stackCount + 1) | 0)), this._stack)] = other1;
                                other1.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;
                            } else {
                                this.Island.Add$2(je.Joint);
                                je.Joint.IslandFlag = true;
                            }
                        }
                    }

                    this.Island.Solve(step, Bridge.ref(this, "Gravity"));

                    for (var i1 = 0; i1 < this.Island.BodyCount; i1 = (i1 + 1) | 0) {
                        var b2 = ($t2 = this.Island.Bodies)[System.Array.index(i1, $t2)];
                        if (b2.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                            b2.Flags &= -2;
                        }
                    }
                }

                $t3 = Bridge.getEnumerator(this.BodyList);
                try {
                    while ($t3.moveNext()) {
                        var b3 = $t3.Current;
                        if ((b3.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) !== FarseerPhysics.Dynamics.BodyFlags.Island) {
                            continue;
                        }

                        if (b3.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                            continue;
                        }

                        b3.SynchronizeFixtures();
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }
                this.ContactManager.FindNewContacts();
            },
            /**
             * Find TOI contacts and solve them.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.TimeStep}    step    The step.
             * @return  {void}
             */
            SolveTOI: function (step) {
                var $t;
                this.Island.Reset(100, FarseerPhysics.Settings.MaxTOIContacts, 0, this.ContactManager);

                if (this._stepComplete) {
                    for (var i = 0; i < this.BodyList.Count; i = (i + 1) | 0) {
                        this.BodyList.getItem(i).Flags &= -2;
                        this.BodyList.getItem(i).Sweep.Alpha0 = 0.0;
                    }

                    for (var i1 = 0; i1 < this.ContactManager.ContactList.Count; i1 = (i1 + 1) | 0) {
                        var c = this.ContactManager.ContactList.getItem(i1);

                        c.Flags &= -34;
                        c.TOICount = 0;
                        c.TOI = 1.0;
                    }
                }

                for (; ; ) {
                    var minContact = null;
                    var minAlpha = 1.0;

                    for (var i2 = 0; i2 < this.ContactManager.ContactList.Count; i2 = (i2 + 1) | 0) {
                        var c1 = this.ContactManager.ContactList.getItem(i2);

                        if (c1.Enabled === false) {
                            continue;
                        }

                        if (c1.TOICount > FarseerPhysics.Settings.MaxSubSteps) {
                            continue;
                        }

                        var alpha;
                        if ((c1.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.TOI) === FarseerPhysics.Dynamics.Contacts.ContactFlags.TOI) {
                            alpha = c1.TOI;
                        } else {
                            var fA = c1.FixtureA;
                            var fB = c1.FixtureB;

                            if (fA.IsSensor || fB.IsSensor) {
                                continue;
                            }

                            var bA = fA.Body;
                            var bB = fB.Body;

                            var typeA = bA.BodyType;
                            var typeB = bB.BodyType;
                            System.Diagnostics.Debug.Assert(typeA === FarseerPhysics.Dynamics.BodyType.Dynamic || typeB === FarseerPhysics.Dynamics.BodyType.Dynamic);

                            var awakeA = bA.Awake && typeA !== FarseerPhysics.Dynamics.BodyType.Static;
                            var awakeB = bB.Awake && typeB !== FarseerPhysics.Dynamics.BodyType.Static;

                            if (awakeA === false && awakeB === false) {
                                continue;
                            }

                            var collideA = (bA.IsBullet || typeA !== FarseerPhysics.Dynamics.BodyType.Dynamic) && !bA.IgnoreCCD;
                            var collideB = (bB.IsBullet || typeB !== FarseerPhysics.Dynamics.BodyType.Dynamic) && !bB.IgnoreCCD;

                            if (collideA === false && collideB === false) {
                                continue;
                            }

                            var alpha0 = bA.Sweep.Alpha0;

                            if (bA.Sweep.Alpha0 < bB.Sweep.Alpha0) {
                                alpha0 = bB.Sweep.Alpha0;
                                bA.Sweep.Advance(alpha0);
                            } else if (bB.Sweep.Alpha0 < bA.Sweep.Alpha0) {
                                alpha0 = bA.Sweep.Alpha0;
                                bB.Sweep.Advance(alpha0);
                            }

                            System.Diagnostics.Debug.Assert(alpha0 < 1.0);

                            this._input.ProxyA.Set(fA.Shape, c1.ChildIndexA);
                            this._input.ProxyB.Set(fB.Shape, c1.ChildIndexB);
                            this._input.SweepA = bA.Sweep.$clone();
                            this._input.SweepB = bB.Sweep.$clone();
                            this._input.TMax = 1.0;

                            var output = { v : new FarseerPhysics.Collision.TOIOutput() };
                            FarseerPhysics.Collision.TimeOfImpact.CalculateTimeOfImpact(output, this._input);

                            var beta = output.v.T;
                            if (output.v.State === FarseerPhysics.Collision.TOIOutputState.Touching) {
                                alpha = Math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);
                            } else {
                                alpha = 1.0;
                            }

                            c1.TOI = alpha;
                            c1.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.TOI;
                        }

                        if (alpha < minAlpha) {
                            minContact = c1;
                            minAlpha = alpha;
                        }
                    }

                    if (minContact == null || 0.9999988 < minAlpha) {
                        this._stepComplete = true;
                        break;
                    }

                    var fA1 = minContact.FixtureA;
                    var fB1 = minContact.FixtureB;
                    var bA1 = fA1.Body;
                    var bB1 = fB1.Body;

                    var backup1 = bA1.Sweep.$clone();
                    var backup2 = bB1.Sweep.$clone();

                    bA1.Advance(minAlpha);
                    bB1.Advance(minAlpha);

                    minContact.Update(this.ContactManager);
                    minContact.Flags &= -33;
                    minContact.TOICount = (minContact.TOICount + 1) | 0;

                    if (minContact.Enabled === false || minContact.IsTouching() === false) {
                        minContact.Enabled = false;
                        bA1.Sweep = backup1.$clone();
                        bB1.Sweep = backup2.$clone();
                        bA1.SynchronizeTransform();
                        bB1.SynchronizeTransform();
                        continue;
                    }

                    bA1.Awake = true;
                    bB1.Awake = true;

                    this.Island.Clear();
                    this.Island.Add(bA1);
                    this.Island.Add(bB1);
                    this.Island.Add$1(minContact);

                    bA1.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;
                    bB1.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;
                    minContact.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Island;

                    var bodies = System.Array.init([bA1, bB1], FarseerPhysics.Dynamics.Body);
                    for (var i3 = 0; i3 < 2; i3 = (i3 + 1) | 0) {
                        var body = bodies[System.Array.index(i3, bodies)];
                        if (body.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic) {
                            for (var ce = body.ContactList; ce != null; ce = ce.Next) {
                                var contact = ce.Contact;

                                if ((contact.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Island) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Island) {
                                    continue;
                                }

                                var other = ce.Other;
                                if (other.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic && body.IsBullet === false && other.IsBullet === false) {
                                    continue;
                                }

                                if (contact.FixtureA.IsSensor || contact.FixtureB.IsSensor) {
                                    continue;
                                }

                                var backup = other.Sweep.$clone();
                                if ((other.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) === 0) {
                                    other.Advance(minAlpha);
                                }

                                contact.Update(this.ContactManager);

                                if (contact.Enabled === false) {
                                    other.Sweep = backup.$clone();
                                    other.SynchronizeTransform();
                                    continue;
                                }

                                if (contact.IsTouching() === false) {
                                    other.Sweep = backup.$clone();
                                    other.SynchronizeTransform();
                                    continue;
                                }

                                contact.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Island;
                                this.Island.Add$1(contact);

                                if ((other.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) === FarseerPhysics.Dynamics.BodyFlags.Island) {
                                    continue;
                                }

                                other.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;

                                if (other.BodyType !== FarseerPhysics.Dynamics.BodyType.Static) {
                                    other.Awake = true;
                                }

                                this.Island.Add(other);
                            }
                        }
                    }

                    var subStep = { v : new FarseerPhysics.Dynamics.TimeStep() };
                    subStep.v.dt = (1.0 - minAlpha) * step.v.dt;
                    subStep.v.inv_dt = 1.0 / subStep.v.dt;
                    subStep.v.dtRatio = 1.0;
                    this.Island.SolveTOI(subStep);

                    for (var i4 = 0; i4 < this.Island.BodyCount; i4 = (i4 + 1) | 0) {
                        var body1 = ($t = this.Island.Bodies)[System.Array.index(i4, $t)];
                        body1.Flags &= -2;

                        if (body1.BodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                            continue;
                        }

                        body1.SynchronizeFixtures();

                        for (var ce1 = body1.ContactList; ce1 != null; ce1 = ce1.Next) {
                            ce1.Contact.Flags &= -34;
                        }
                    }

                    this.ContactManager.FindNewContacts();

                    if (this.EnableSubStepping) {
                        this._stepComplete = false;
                        break;
                    }
                }
            },
            AddController: function (controller) {
                System.Diagnostics.Debug.Assert$1(!this.ControllerList.contains(controller), "You are adding the same controller more than once.");

                controller.World = this;
                this.ControllerList.add(controller);

                if (!Bridge.staticEquals(this.ControllerAdded, null)) {
                    this.ControllerAdded(controller);
                }
            },
            RemoveController: function (controller) {
                System.Diagnostics.Debug.Assert$1(this.ControllerList.contains(controller), "You are removing a controller that is not in the simulation.");

                if (this.ControllerList.contains(controller)) {
                    this.ControllerList.remove(controller);

                    if (!Bridge.staticEquals(this.ControllerRemoved, null)) {
                        this.ControllerRemoved(controller);
                    }
                }
            },
            AddBreakableBody: function (breakableBody) {
                this.BreakableBodyList.add(breakableBody);
            },
            RemoveBreakableBody: function (breakableBody) {
                System.Diagnostics.Debug.Assert(this.BreakableBodyList.contains(breakableBody));

                this.BreakableBodyList.remove(breakableBody);
            },
            TestPoint: function (point) {
                point = {v:point};
                var aabb = { v : new FarseerPhysics.Collision.AABB() };
                var d = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.Epsilon, FarseerPhysics.Settings.Epsilon);
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), d.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(point.v.$clone(), d.$clone());

                var myFixture = null;

                this.QueryAABB(function (fixture) {
                    var inside = fixture.TestPoint(point);
                    if (inside) {
                        myFixture = fixture;
                        return false;
                    }

                    return true;
                }, aabb);

                return myFixture;
            },
            /**
             * Returns a list of fixtures that are at the specified point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {Microsoft.Xna.Framework.Vector2}      point    The point.
             * @return  {System.Collections.Generic.List$1}
             */
            TestPointAll: function (point) {
                point = {v:point};
                var aabb = { v : new FarseerPhysics.Collision.AABB() };
                var d = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.Epsilon, FarseerPhysics.Settings.Epsilon);
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), d.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(point.v.$clone(), d.$clone());

                var fixtures = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).ctor();

                this.QueryAABB(function (fixture) {
                    var inside = fixture.TestPoint(point);
                    if (inside) {
                        fixtures.add(fixture);
                    }

                    return true;
                }, aabb);

                return fixtures;
            },
            Clear: function () {
                this.ProcessChanges();

                for (var i = (this.BodyList.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    this.RemoveBody(this.BodyList.getItem(i));
                }

                for (var i1 = (this.ControllerList.Count - 1) | 0; i1 >= 0; i1 = (i1 - 1) | 0) {
                    this.RemoveController(this.ControllerList.getItem(i1));
                }

                for (var i2 = (this.BreakableBodyList.Count - 1) | 0; i2 >= 0; i2 = (i2 - 1) | 0) {
                    this.RemoveBreakableBody(this.BreakableBodyList.getItem(i2));
                }

                this.ProcessChanges();
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.WorldFlags", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Flag that indicates a new fixture has been added to the world.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.WorldFlags
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Dynamics.WorldFlags
                 */
                NewFixture: 1,
                /**
                 * Flag that clear the forces after each time step.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.WorldFlags
                 * @constant
                 * @default 4
                 * @type FarseerPhysics.Dynamics.WorldFlags
                 */
                ClearForces: 4,
                SubStepping: 16
            }
        },
        $flags: true
    });

    Bridge.define("FarseerPhysics.Factories.BodyFactory", {
        statics: {
            methods: {
                CreateBody: function (world) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBody$3(world, null);
                },
                CreateBody$3: function (world, userData) {
                    var body = new FarseerPhysics.Dynamics.Body.$ctor2(world, userData);
                    return body;
                },
                CreateBody$1: function (world, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBody$2(world, position.$clone(), null);
                },
                CreateBody$2: function (world, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$3(world, userData);
                    body.Position = position.$clone();
                    return body;
                },
                CreateEdge: function (world, start, end) {
                    return FarseerPhysics.Factories.BodyFactory.CreateEdge$1(world, start.$clone(), end.$clone(), null);
                },
                CreateEdge$1: function (world, start, end, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody(world);
                    FarseerPhysics.Factories.FixtureFactory.AttachEdge$1(start.$clone(), end.$clone(), body, userData);
                    return body;
                },
                CreateLoopShape: function (world, vertices) {
                    return FarseerPhysics.Factories.BodyFactory.CreateLoopShape$3(world, vertices, null);
                },
                CreateLoopShape$3: function (world, vertices, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateLoopShape$2(world, vertices, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateLoopShape$1: function (world, vertices, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateLoopShape$2(world, vertices, position.$clone(), null);
                },
                CreateLoopShape$2: function (world, vertices, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachLoopShape$1(vertices, body, userData);
                    return body;
                },
                CreateRectangle: function (world, width, height, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRectangle$3(world, width, height, density, null);
                },
                CreateRectangle$3: function (world, width, height, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRectangle$2(world, width, height, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateRectangle$1: function (world, width, height, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRectangle$2(world, width, height, density, position.$clone(), null);
                },
                CreateRectangle$2: function (world, width, height, density, position, userData) {
                    if (width <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("width", "Width must be more than 0 meters");
                    }

                    if (height <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("height", "Height must be more than 0 meters");
                    }

                    var newBody = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    var rectangleVertices = FarseerPhysics.Common.PolygonTools.CreateRectangle(width / 2, height / 2);
                    var rectangleShape = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(rectangleVertices, density);
                    newBody.CreateFixture$1(rectangleShape, userData);

                    return newBody;
                },
                CreateCircle: function (world, radius, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCircle$3(world, radius, density, null);
                },
                CreateCircle$3: function (world, radius, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCircle$2(world, radius, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateCircle$1: function (world, radius, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCircle$2(world, radius, density, position.$clone(), null);
                },
                CreateCircle$2: function (world, radius, density, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachCircle$3(radius, density, body, userData);
                    return body;
                },
                CreateEllipse: function (world, xRadius, yRadius, edges, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateEllipse$3(world, xRadius, yRadius, edges, density, null);
                },
                CreateEllipse$3: function (world, xRadius, yRadius, edges, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateEllipse$2(world, xRadius, yRadius, edges, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateEllipse$1: function (world, xRadius, yRadius, edges, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateEllipse$2(world, xRadius, yRadius, edges, density, position.$clone(), null);
                },
                CreateEllipse$2: function (world, xRadius, yRadius, edges, density, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachEllipse$1(xRadius, yRadius, edges, density, body, userData);
                    return body;
                },
                CreatePolygon: function (world, vertices, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon$3(world, vertices, density, null);
                },
                CreatePolygon$3: function (world, vertices, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon$2(world, vertices, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreatePolygon$1: function (world, vertices, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon$2(world, vertices, density, position.$clone(), null);
                },
                CreatePolygon$2: function (world, vertices, density, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachPolygon$1(vertices, density, body, userData);
                    return body;
                },
                CreateCompoundPolygon: function (world, list, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, list, density, Bridge.box(FarseerPhysics.Dynamics.BodyType.Static, FarseerPhysics.Dynamics.BodyType, System.Enum.toStringFn(FarseerPhysics.Dynamics.BodyType)));
                },
                CreateCompoundPolygon$3: function (world, list, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$2(world, list, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateCompoundPolygon$1: function (world, list, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$2(world, list, density, position.$clone(), null);
                },
                CreateCompoundPolygon$2: function (world, list, density, position, userData) {
                    var polygonBody = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachCompoundPolygon$1(list, density, polygonBody, userData);
                    return polygonBody;
                },
                CreateGear: function (world, radius, numberOfTeeth, tipPercentage, toothHeight, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateGear$1(world, radius, numberOfTeeth, tipPercentage, toothHeight, density, null);
                },
                CreateGear$1: function (world, radius, numberOfTeeth, tipPercentage, toothHeight, density, userData) {
                    var gearPolygon = FarseerPhysics.Common.PolygonTools.CreateGear(radius, numberOfTeeth, tipPercentage, toothHeight);

                    if (!gearPolygon.IsConvex()) {
                        var list = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(gearPolygon);

                        return FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, list, density, userData);
                    }

                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon$3(world, gearPolygon, density, userData);
                },
                /**
                 * Creates a capsule.
                 Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.BodyFactory
                 * @memberof FarseerPhysics.Factories.BodyFactory
                 * @param   {FarseerPhysics.Dynamics.World}      world           The world.
                 * @param   {number}                             height          The height.
                 * @param   {number}                             topRadius       The top radius.
                 * @param   {number}                             topEdges        The top edges.
                 * @param   {number}                             bottomRadius    The bottom radius.
                 * @param   {number}                             bottomEdges     The bottom edges.
                 * @param   {number}                             density         The density.
                 * @param   {Microsoft.Xna.Framework.Vector2}    position        The position.
                 * @param   {System.Object}                      userData
                 * @return  {FarseerPhysics.Dynamics.Body}
                 */
                CreateCapsule$1: function (world, height, topRadius, topEdges, bottomRadius, bottomEdges, density, position, userData) {
                    var verts = FarseerPhysics.Common.PolygonTools.CreateCapsule$1(height, topRadius, topEdges, bottomRadius, bottomEdges);

                    var body;

                    if (verts.Count >= FarseerPhysics.Settings.MaxPolygonVertices) {
                        var vertList = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(verts);
                        body = FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, vertList, density, userData);
                        body.Position = position.$clone();

                        return body;
                    }

                    body = FarseerPhysics.Factories.BodyFactory.CreatePolygon$3(world, verts, density, userData);
                    body.Position = position.$clone();

                    return body;
                },
                CreateCapsule: function (world, height, topRadius, topEdges, bottomRadius, bottomEdges, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCapsule$1(world, height, topRadius, topEdges, bottomRadius, bottomEdges, density, position.$clone(), null);
                },
                CreateCapsule$2: function (world, height, endRadius, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCapsule$3(world, height, endRadius, density, null);
                },
                CreateCapsule$3: function (world, height, endRadius, density, userData) {
                    var rectangle = FarseerPhysics.Common.PolygonTools.CreateRectangle(endRadius, height / 2);

                    var list = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                    list.add(rectangle);

                    var body = FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, list, density, userData);

                    var topCircle = new FarseerPhysics.Collision.Shapes.CircleShape.$ctor1(endRadius, density);
                    topCircle.Position = new Microsoft.Xna.Framework.Vector2.$ctor2(0, height / 2);
                    body.CreateFixture$1(topCircle, userData);

                    var bottomCircle = new FarseerPhysics.Collision.Shapes.CircleShape.$ctor1(endRadius, density);
                    bottomCircle.Position = new Microsoft.Xna.Framework.Vector2.$ctor2(0, -(height / 2));
                    body.CreateFixture$1(bottomCircle, userData);
                    return body;
                },
                /**
                 * Creates a rounded rectangle.
                 Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.BodyFactory
                 * @memberof FarseerPhysics.Factories.BodyFactory
                 * @param   {FarseerPhysics.Dynamics.World}      world       The world.
                 * @param   {number}                             width       The width.
                 * @param   {number}                             height      The height.
                 * @param   {number}                             xRadius     The x radius.
                 * @param   {number}                             yRadius     The y radius.
                 * @param   {number}                             segments    The segments.
                 * @param   {number}                             density     The density.
                 * @param   {Microsoft.Xna.Framework.Vector2}    position    The position.
                 * @param   {System.Object}                      userData
                 * @return  {FarseerPhysics.Dynamics.Body}
                 */
                CreateRoundedRectangle$2: function (world, width, height, xRadius, yRadius, segments, density, position, userData) {
                    var verts = FarseerPhysics.Common.PolygonTools.CreateRoundedRectangle(width, height, xRadius, yRadius, segments);

                    if (verts.Count >= FarseerPhysics.Settings.MaxPolygonVertices) {
                        var vertList = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(verts);
                        var body = FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, vertList, density, userData);
                        body.Position = position.$clone();
                        return body;
                    }

                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon(world, verts, density);
                },
                CreateRoundedRectangle$1: function (world, width, height, xRadius, yRadius, segments, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRoundedRectangle$2(world, width, height, xRadius, yRadius, segments, density, position.$clone(), null);
                },
                CreateRoundedRectangle: function (world, width, height, xRadius, yRadius, segments, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRoundedRectangle$3(world, width, height, xRadius, yRadius, segments, density, null);
                },
                CreateRoundedRectangle$3: function (world, width, height, xRadius, yRadius, segments, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRoundedRectangle$2(world, width, height, xRadius, yRadius, segments, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateBreakableBody: function (world, vertices, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBreakableBody$3(world, vertices, density, null);
                },
                CreateBreakableBody$3: function (world, vertices, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBreakableBody$2(world, vertices, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                /**
                 * Creates a breakable body. You would want to remove collinear points before using this.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.BodyFactory
                 * @memberof FarseerPhysics.Factories.BodyFactory
                 * @param   {FarseerPhysics.Dynamics.World}            world       The world.
                 * @param   {FarseerPhysics.Common.Vertices}           vertices    The vertices.
                 * @param   {number}                                   density     The density.
                 * @param   {Microsoft.Xna.Framework.Vector2}          position    The position.
                 * @param   {System.Object}                            userData
                 * @return  {FarseerPhysics.Dynamics.BreakableBody}
                 */
                CreateBreakableBody$2: function (world, vertices, density, position, userData) {
                    var triangles = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(vertices);

                    var breakableBody = new FarseerPhysics.Dynamics.BreakableBody.$ctor1(triangles, world, density, userData);
                    breakableBody.MainBody.Position = position.$clone();
                    world.AddBreakableBody(breakableBody);

                    return breakableBody;
                },
                CreateBreakableBody$1: function (world, vertices, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBreakableBody$2(world, vertices, density, position.$clone(), null);
                },
                CreateLineArc: function (world, radians, sides, radius, position, angle, closed) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody(world);
                    FarseerPhysics.Factories.FixtureFactory.AttachLineArc(radians, sides, radius, position.$clone(), angle, closed, body);
                    return body;
                },
                CreateSolidArc: function (world, density, radians, sides, radius, position, angle) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody(world);
                    FarseerPhysics.Factories.FixtureFactory.AttachSolidArc(density, radians, sides, radius, position.$clone(), angle, body);
                    return body;
                }
            }
        }
    });

    /** @namespace FarseerPhysics.Factories */

    /**
     * An easy to use factory for creating bodies
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Factories.FixtureFactory
     */
    Bridge.define("FarseerPhysics.Factories.FixtureFactory", {
        statics: {
            methods: {
                AttachEdge: function (start, end, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachEdge$1(start.$clone(), end.$clone(), body, null);
                },
                AttachEdge$1: function (start, end, body, userData) {
                    var edgeShape = new FarseerPhysics.Collision.Shapes.EdgeShape.$ctor1(start.$clone(), end.$clone());
                    return body.CreateFixture$1(edgeShape, userData);
                },
                AttachLoopShape: function (vertices, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachLoopShape$1(vertices, body, null);
                },
                AttachLoopShape$1: function (vertices, body, userData) {
                    var shape = new FarseerPhysics.Collision.Shapes.LoopShape.$ctor1(vertices);
                    return body.CreateFixture$1(shape, userData);
                },
                AttachRectangle$1: function (width, height, density, offset, body, userData) {
                    offset = {v:offset};
                    var rectangleVertices = FarseerPhysics.Common.PolygonTools.CreateRectangle(width / 2, height / 2);
                    rectangleVertices.Translate$1(offset);
                    var rectangleShape = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(rectangleVertices, density);
                    return body.CreateFixture$1(rectangleShape, userData);
                },
                AttachRectangle: function (width, height, density, offset, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachRectangle$1(width, height, density, offset.$clone(), body, null);
                },
                AttachCircle: function (radius, density, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachCircle$3(radius, density, body, null);
                },
                AttachCircle$3: function (radius, density, body, userData) {
                    if (radius <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("radius", "Radius must be more than 0 meters");
                    }

                    var circleShape = new FarseerPhysics.Collision.Shapes.CircleShape.$ctor1(radius, density);
                    return body.CreateFixture$1(circleShape, userData);
                },
                AttachCircle$1: function (radius, density, body, offset) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachCircle$2(radius, density, body, offset.$clone(), null);
                },
                AttachCircle$2: function (radius, density, body, offset, userData) {
                    if (radius <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("radius", "Radius must be more than 0 meters");
                    }

                    var circleShape = new FarseerPhysics.Collision.Shapes.CircleShape.$ctor1(radius, density);
                    circleShape.Position = offset.$clone();
                    return body.CreateFixture$1(circleShape, userData);
                },
                AttachPolygon: function (vertices, density, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachPolygon$1(vertices, density, body, null);
                },
                AttachPolygon$1: function (vertices, density, body, userData) {
                    if (vertices.Count <= 1) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("vertices", "Too few points to be a polygon");
                    }

                    var polygon = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(vertices, density);
                    return body.CreateFixture$1(polygon, userData);
                },
                AttachEllipse: function (xRadius, yRadius, edges, density, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachEllipse$1(xRadius, yRadius, edges, density, body, null);
                },
                AttachEllipse$1: function (xRadius, yRadius, edges, density, body, userData) {
                    if (xRadius <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("xRadius", "X-radius must be more than 0");
                    }

                    if (yRadius <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("yRadius", "Y-radius must be more than 0");
                    }

                    var ellipseVertices = FarseerPhysics.Common.PolygonTools.CreateEllipse(xRadius, yRadius, edges);
                    var polygonShape = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(ellipseVertices, density);
                    return body.CreateFixture$1(polygonShape, userData);
                },
                AttachCompoundPolygon: function (list, density, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachCompoundPolygon$1(list, density, body, null);
                },
                AttachCompoundPolygon$1: function (list, density, body, userData) {
                    var $t;
                    var res = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(list.Count);

                    $t = Bridge.getEnumerator(list);
                    try {
                        while ($t.moveNext()) {
                            var vertices = $t.Current;
                            if (vertices.Count === 2) {
                                var shape = new FarseerPhysics.Collision.Shapes.EdgeShape.$ctor1(vertices.getItem(0).$clone(), vertices.getItem(1).$clone());
                                res.add(body.CreateFixture$1(shape, userData));
                            } else {
                                var shape1 = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(vertices, density);
                                res.add(body.CreateFixture$1(shape1, userData));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return res;
                },
                AttachLineArc: function (radians, sides, radius, position, angle, closed, body) {
                    position = {v:position};
                    var arc = FarseerPhysics.Common.PolygonTools.CreateArc(radians, sides, radius);
                    arc.Rotate((Microsoft.Xna.Framework.MathHelper.Pi - radians) / 2 + angle);
                    arc.Translate$1(position);

                    var fixtures = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(arc.Count);

                    if (closed) {
                        fixtures.add(FarseerPhysics.Factories.FixtureFactory.AttachLoopShape(arc, body));
                    }

                    for (var i = 1; i < arc.Count; i = (i + 1) | 0) {
                        fixtures.add(FarseerPhysics.Factories.FixtureFactory.AttachEdge(arc.getItem(i).$clone(), arc.getItem(((i - 1) | 0)).$clone(), body));
                    }

                    return fixtures;
                },
                AttachSolidArc: function (density, radians, sides, radius, position, angle, body) {
                    position = {v:position};
                    var arc = FarseerPhysics.Common.PolygonTools.CreateArc(radians, sides, radius);
                    arc.Rotate((Microsoft.Xna.Framework.MathHelper.Pi - radians) / 2 + angle);

                    arc.Translate$1(position);

                    arc.add(arc.getItem(0).$clone());

                    var triangles = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(arc);

                    return FarseerPhysics.Factories.FixtureFactory.AttachCompoundPolygon(triangles, density, body);
                }
            }
        }
    });

    /**
     * An easy to use factory for using joints.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Factories.JointFactory
     */
    Bridge.define("FarseerPhysics.Factories.JointFactory", {
        statics: {
            methods: {
                /**
                 * Creates a revolute joint.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.Body}                    bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                    bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}                 localAnchorB    The anchor of bodyB in local coordinates
                 * @return  {FarseerPhysics.Dynamics.Joints.RevoluteJoint}
                 */
                CreateRevoluteJoint: function (bodyA, bodyB, localAnchorB) {
                    var localanchorA = bodyA.GetLocalPoint(bodyB.GetWorldPoint(localAnchorB.$clone()));
                    var joint = new FarseerPhysics.Dynamics.Joints.RevoluteJoint.$ctor1(bodyA, bodyB, localanchorA.$clone(), localAnchorB.$clone());
                    return joint;
                },
                /**
                 * Creates a revolute joint and adds it to the world
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                   world     
                 * @param   {FarseerPhysics.Dynamics.Body}                    bodyA     
                 * @param   {FarseerPhysics.Dynamics.Body}                    bodyB     
                 * @param   {Microsoft.Xna.Framework.Vector2}                 anchor
                 * @return  {FarseerPhysics.Dynamics.Joints.RevoluteJoint}
                 */
                CreateRevoluteJoint$1: function (world, bodyA, bodyB, anchor) {
                    var joint = FarseerPhysics.Factories.JointFactory.CreateRevoluteJoint(bodyA, bodyB, anchor.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                /**
                 * Creates the fixed revolute joint.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                        world          The world.
                 * @param   {FarseerPhysics.Dynamics.Body}                         body           The body.
                 * @param   {Microsoft.Xna.Framework.Vector2}                      bodyAnchor     The body anchor.
                 * @param   {Microsoft.Xna.Framework.Vector2}                      worldAnchor    The world anchor.
                 * @return  {FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint}
                 */
                CreateFixedRevoluteJoint: function (world, body, bodyAnchor, worldAnchor) {
                    var fixedRevoluteJoint = new FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint(body, bodyAnchor.$clone(), worldAnchor.$clone());
                    world.AddJoint(fixedRevoluteJoint);
                    return fixedRevoluteJoint;
                },
                /**
                 * Creates a weld joint
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyA          
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyB          
                 * @param   {Microsoft.Xna.Framework.Vector2}             localAnchor
                 * @return  {FarseerPhysics.Dynamics.Joints.WeldJoint}
                 */
                CreateWeldJoint: function (bodyA, bodyB, localAnchor) {
                    var joint = new FarseerPhysics.Dynamics.Joints.WeldJoint.$ctor1(bodyA, bodyB, bodyA.GetLocalPoint(localAnchor.$clone()), bodyB.GetLocalPoint(localAnchor.$clone()));
                    return joint;
                },
                /**
                 * Creates a weld joint and adds it to the world
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}               world           
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}             localanchorB
                 * @return  {FarseerPhysics.Dynamics.Joints.WeldJoint}
                 */
                CreateWeldJoint$1: function (world, bodyA, bodyB, localanchorB) {
                    var joint = FarseerPhysics.Factories.JointFactory.CreateWeldJoint(bodyA, bodyB, localanchorB.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                CreateWeldJoint$2: function (world, bodyA, bodyB, localAnchorA, localAnchorB) {
                    var weldJoint = new FarseerPhysics.Dynamics.Joints.WeldJoint.$ctor1(bodyA, bodyB, localAnchorA.$clone(), localAnchorB.$clone());
                    world.AddJoint(weldJoint);
                    return weldJoint;
                },
                /**
                 * Creates a prsimatic joint
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.Body}                     bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                     bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}                  localanchorB    
                 * @param   {Microsoft.Xna.Framework.Vector2}                  axis
                 * @return  {FarseerPhysics.Dynamics.Joints.PrismaticJoint}
                 */
                CreatePrismaticJoint: function (bodyA, bodyB, localanchorB, axis) {
                    var localanchorA = bodyA.GetLocalPoint(bodyB.GetWorldPoint(localanchorB.$clone()));
                    var joint = new FarseerPhysics.Dynamics.Joints.PrismaticJoint.$ctor1(bodyA, bodyB, localanchorA.$clone(), localanchorB.$clone(), axis.$clone());
                    return joint;
                },
                /**
                 * Creates a prismatic joint and adds it to the world
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                    world           
                 * @param   {FarseerPhysics.Dynamics.Body}                     bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                     bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}                  localanchorB    
                 * @param   {Microsoft.Xna.Framework.Vector2}                  axis
                 * @return  {FarseerPhysics.Dynamics.Joints.PrismaticJoint}
                 */
                CreatePrismaticJoint$1: function (world, bodyA, bodyB, localanchorB, axis) {
                    var joint = FarseerPhysics.Factories.JointFactory.CreatePrismaticJoint(bodyA, bodyB, localanchorB.$clone(), axis.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                CreateFixedPrismaticJoint: function (world, body, worldAnchor, axis) {
                    var joint = new FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint(body, worldAnchor.$clone(), axis.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                /**
                 * Creates a line joint
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyA     
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyB     
                 * @param   {Microsoft.Xna.Framework.Vector2}             anchor    
                 * @param   {Microsoft.Xna.Framework.Vector2}             axis
                 * @return  {FarseerPhysics.Dynamics.Joints.LineJoint}
                 */
                CreateLineJoint: function (bodyA, bodyB, anchor, axis) {
                    var joint = new FarseerPhysics.Dynamics.Joints.LineJoint.$ctor1(bodyA, bodyB, anchor.$clone(), axis.$clone());
                    return joint;
                },
                /**
                 * Creates a line joint and adds it to the world
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}               world           
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}             localanchorB    
                 * @param   {Microsoft.Xna.Framework.Vector2}             axis
                 * @return  {FarseerPhysics.Dynamics.Joints.LineJoint}
                 */
                CreateLineJoint$1: function (world, bodyA, bodyB, localanchorB, axis) {
                    var joint = FarseerPhysics.Factories.JointFactory.CreateLineJoint(bodyA, bodyB, localanchorB.$clone(), axis.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                /**
                 * Creates an angle joint.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                world    The world.
                 * @param   {FarseerPhysics.Dynamics.Body}                 bodyA    The first body.
                 * @param   {FarseerPhysics.Dynamics.Body}                 bodyB    The second body.
                 * @return  {FarseerPhysics.Dynamics.Joints.AngleJoint}
                 */
                CreateAngleJoint: function (world, bodyA, bodyB) {
                    var angleJoint = new FarseerPhysics.Dynamics.Joints.AngleJoint.$ctor1(bodyA, bodyB);
                    world.AddJoint(angleJoint);

                    return angleJoint;
                },
                /**
                 * Creates a fixed angle joint.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                     world    The world.
                 * @param   {FarseerPhysics.Dynamics.Body}                      body     The body.
                 * @return  {FarseerPhysics.Dynamics.Joints.FixedAngleJoint}
                 */
                CreateFixedAngleJoint: function (world, body) {
                    var angleJoint = new FarseerPhysics.Dynamics.Joints.FixedAngleJoint(body);
                    world.AddJoint(angleJoint);

                    return angleJoint;
                },
                CreateDistanceJoint: function (world, bodyA, bodyB, anchorA, anchorB) {
                    var distanceJoint = new FarseerPhysics.Dynamics.Joints.DistanceJoint.$ctor1(bodyA, bodyB, anchorA.$clone(), anchorB.$clone());
                    world.AddJoint(distanceJoint);
                    return distanceJoint;
                },
                CreateFixedDistanceJoint: function (world, body, localAnchor, worldAnchor) {
                    var distanceJoint = new FarseerPhysics.Dynamics.Joints.FixedDistanceJoint(body, localAnchor.$clone(), worldAnchor.$clone());
                    world.AddJoint(distanceJoint);
                    return distanceJoint;
                },
                CreateFrictionJoint: function (world, bodyA, bodyB, anchorA, anchorB) {
                    var frictionJoint = new FarseerPhysics.Dynamics.Joints.FrictionJoint.$ctor1(bodyA, bodyB, anchorA.$clone(), anchorB.$clone());
                    world.AddJoint(frictionJoint);
                    return frictionJoint;
                },
                CreateFixedFrictionJoint: function (world, body, bodyAnchor) {
                    var frictionJoint = new FarseerPhysics.Dynamics.Joints.FixedFrictionJoint(body, bodyAnchor.$clone());
                    world.AddJoint(frictionJoint);
                    return frictionJoint;
                },
                CreateGearJoint: function (world, jointA, jointB, ratio) {
                    var gearJoint = new FarseerPhysics.Dynamics.Joints.GearJoint(jointA, jointB, ratio);
                    world.AddJoint(gearJoint);
                    return gearJoint;
                },
                CreatePulleyJoint: function (world, bodyA, bodyB, groundAnchorA, groundAnchorB, anchorA, anchorB, ratio) {
                    var pulleyJoint = new FarseerPhysics.Dynamics.Joints.PulleyJoint.$ctor1(bodyA, bodyB, groundAnchorA.$clone(), groundAnchorB.$clone(), anchorA.$clone(), anchorB.$clone(), ratio);
                    world.AddJoint(pulleyJoint);
                    return pulleyJoint;
                },
                CreateSliderJoint: function (world, bodyA, bodyB, anchorA, anchorB, minLength, maxLength) {
                    var sliderJoint = new FarseerPhysics.Dynamics.Joints.SliderJoint.$ctor1(bodyA, bodyB, anchorA.$clone(), anchorB.$clone(), minLength, maxLength);
                    world.AddJoint(sliderJoint);
                    return sliderJoint;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Settings", {
        statics: {
            fields: {
                MaxFloat: 0,
                Epsilon: 0,
                Pi: 0,
                /**
                 * Enabling diagnistics causes the engine to gather timing information.
                 You can see how much time it took to solve the contacts, solve CCD
                 and update the controllers.
                 NOTE: If you are using a debug view that shows performance counters,
                 you might want to enable this.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default true
                 * @type boolean
                 */
                EnableDiagnostics: false,
                /**
                 * The number of velocity iterations used in the solver.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 8
                 * @type number
                 */
                VelocityIterations: 0,
                /**
                 * The number of position iterations used in the solver.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 3
                 * @type number
                 */
                PositionIterations: 0,
                /**
                 * Enable/Disable Continuous Collision Detection (CCD)
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default true
                 * @type boolean
                 */
                ContinuousPhysics: false,
                /**
                 * The number of velocity iterations in the TOI solver
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 8
                 * @type number
                 */
                TOIVelocityIterations: 0,
                /**
                 * The number of position iterations in the TOI solver
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 20
                 * @type number
                 */
                TOIPositionIterations: 0,
                /**
                 * Maximum number of sub-steps per contact in continuous physics simulation.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 8
                 * @type number
                 */
                MaxSubSteps: 0,
                /**
                 * Enable/Disable warmstarting
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default true
                 * @type boolean
                 */
                EnableWarmstarting: false,
                /**
                 * Enable/Disable sleeping
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default true
                 * @type boolean
                 */
                AllowSleep: false,
                /**
                 * The maximum number of vertices on a convex polygon.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 30
                 * @type number
                 */
                MaxPolygonVertices: 0,
                /**
                 * Farseer Physics Engine has a different way of filtering fixtures than Box2d.
                 We have both FPE and Box2D filtering in the engine. If you are upgrading
                 from earlier versions of FPE, set this to true.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @type boolean
                 */
                UseFPECollisionCategories: false,
                /**
                 * Conserve memory makes sure that objects are used by reference instead of cloned.
                 When you give a vertices collection to a PolygonShape, it will by default copy the vertices
                 instead of using the original reference. This is to ensure that objects modified outside the engine
                 does not affect the engine itself, however, this uses extra memory. This behavior
                 can be turned off by setting ConserveMemory to true.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default false
                 * @type boolean
                 */
                ConserveMemory: false,
                /**
                 * The maximum number of contact points between two convex shapes.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 2
                 * @type number
                 */
                MaxManifoldPoints: 0,
                /**
                 * This is used to fatten AABBs in the dynamic tree. This allows proxies
                 to move by a small amount without triggering a tree adjustment.
                 This is in meters.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.1
                 * @type number
                 */
                AABBExtension: 0,
                /**
                 * This is used to fatten AABBs in the dynamic tree. This is used to predict
                 the future position based on the current displacement.
                 This is a dimensionless multiplier.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 2.0
                 * @type number
                 */
                AABBMultiplier: 0,
                /**
                 * A small length used as a collision and constraint tolerance. Usually it is
                 chosen to be numerically significant, but visually insignificant.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.005
                 * @type number
                 */
                LinearSlop: 0,
                /**
                 * A small angle used as a collision and constraint tolerance. Usually it is
                 chosen to be numerically significant, but visually insignificant.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.03490659
                 * @type number
                 */
                AngularSlop: 0,
                /**
                 * The radius of the polygon/edge shape skin. This should not be modified. Making
                 this smaller means polygons will have an insufficient buffer for continuous collision.
                 Making it larger may create artifacts for vertex collision.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.01
                 * @type number
                 */
                PolygonRadius: 0,
                /**
                 * Maximum number of contacts to be handled to solve a TOI impact.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 50
                 * @type number
                 */
                MaxTOIContacts: 0,
                /**
                 * A velocity threshold for elastic collisions. Any collision with a relative linear
                 velocity below this threshold will be treated as inelastic.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 1.0
                 * @type number
                 */
                VelocityThreshold: 0,
                /**
                 * The maximum linear position correction used when solving constraints. This helps to
                 prevent overshoot.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.2
                 * @type number
                 */
                MaxLinearCorrection: 0,
                /**
                 * The maximum angular position correction used when solving constraints. This helps to
                 prevent overshoot.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.139626354
                 * @type number
                 */
                MaxAngularCorrection: 0,
                /**
                 * This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
                 that overlap is removed in one time step. However using values close to 1 often lead
                 to overshoot.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.2
                 * @type number
                 */
                ContactBaumgarte: 0,
                /**
                 * The time that a body must be still before it will go to sleep.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.5
                 * @type number
                 */
                TimeToSleep: 0,
                /**
                 * A body cannot sleep if its linear velocity is above this tolerance.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.01
                 * @type number
                 */
                LinearSleepTolerance: 0,
                /**
                 * A body cannot sleep if its angular velocity is above this tolerance.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.03490659
                 * @type number
                 */
                AngularSleepTolerance: 0,
                /**
                 * The maximum linear velocity of a body. This limit is very large and is used
                 to prevent numerical problems. You shouldn't need to adjust this.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 2.0
                 * @type number
                 */
                MaxTranslation: 0,
                MaxTranslationSquared: 0,
                /**
                 * The maximum angular velocity of a body. This limit is very large and is used
                 to prevent numerical problems. You shouldn't need to adjust this.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 1.57079637
                 * @type number
                 */
                MaxRotation: 0,
                MaxRotationSquared: 0
            },
            ctors: {
                init: function () {
                    this.MaxFloat = 3.40282347E+38;
                    this.Epsilon = 1.1920929E-07;
                    this.Pi = 3.14159274;
                    this.EnableDiagnostics = true;
                    this.VelocityIterations = 8;
                    this.PositionIterations = 3;
                    this.ContinuousPhysics = true;
                    this.TOIVelocityIterations = 8;
                    this.TOIPositionIterations = 20;
                    this.MaxSubSteps = 8;
                    this.EnableWarmstarting = true;
                    this.AllowSleep = true;
                    this.MaxPolygonVertices = 30;
                    this.ConserveMemory = false;
                    this.MaxManifoldPoints = 2;
                    this.AABBExtension = 0.1;
                    this.AABBMultiplier = 2.0;
                    this.LinearSlop = 0.005;
                    this.AngularSlop = (0.03490659);
                    this.PolygonRadius = (0.01);
                    this.MaxTOIContacts = 50;
                    this.VelocityThreshold = 1.0;
                    this.MaxLinearCorrection = 0.2;
                    this.MaxAngularCorrection = (0.139626354);
                    this.ContactBaumgarte = 0.2;
                    this.TimeToSleep = 0.5;
                    this.LinearSleepTolerance = 0.01;
                    this.AngularSleepTolerance = (0.03490659);
                    this.MaxTranslation = 2.0;
                    this.MaxTranslationSquared = (4.0);
                    this.MaxRotation = (1.57079637);
                    this.MaxRotationSquared = (2.46740127);
                }
            },
            methods: {
                /**
                 * Friction mixing law. Feel free to customize this.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Settings
                 * @memberof FarseerPhysics.Settings
                 * @param   {number}    friction1    The friction1.
                 * @param   {number}    friction2    The friction2.
                 * @return  {number}
                 */
                MixFriction: function (friction1, friction2) {
                    return Math.sqrt(friction1 * friction2);
                },
                /**
                 * Restitution mixing law. Feel free to customize this.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Settings
                 * @memberof FarseerPhysics.Settings
                 * @param   {number}    restitution1    The restitution1.
                 * @param   {number}    restitution2    The restitution2.
                 * @return  {number}
                 */
                MixRestitution: function (restitution1, restitution2) {
                    return restitution1 > restitution2 ? restitution1 : restitution2;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Utility.Camera2D", {
        statics: {
            fields: {
                _minZoom: 0,
                _maxZoom: 0,
                _graphics: null
            },
            ctors: {
                init: function () {
                    this._minZoom = 0.02;
                    this._maxZoom = 20.0;
                }
            }
        },
        fields: {
            _batchView: null,
            _currentPosition: null,
            _currentRotation: 0,
            _currentZoom: 0,
            _maxPosition: null,
            _maxRotation: 0,
            _minPosition: null,
            _minRotation: 0,
            _positionTracking: false,
            _projection: null,
            _rotationTracking: false,
            _targetPosition: null,
            _targetRotation: 0,
            _trackingBody: null,
            _translateCenter: null,
            _view: null
        },
        props: {
            View: {
                get: function () {
                    return this._batchView.$clone();
                }
            },
            SimView: {
                get: function () {
                    return this._view.$clone();
                }
            },
            SimProjection: {
                get: function () {
                    return this._projection.$clone();
                }
            },
            /**
             * The current position of the camera.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function Position
             * @type Microsoft.Xna.Framework.Vector2
             */
            Position: {
                get: function () {
                    return FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits(this._currentPosition.$clone());
                },
                set: function (value) {
                    this._targetPosition = FarseerPhysics.Utility.ConvertUnits.ToSimUnits(value.$clone());
                    if (Microsoft.Xna.Framework.Vector2.op_Inequality(this._minPosition.$clone(), this._maxPosition.$clone())) {
                        Microsoft.Xna.Framework.Vector2.Clamp$1(Bridge.ref(this, "_targetPosition"), Bridge.ref(this, "_minPosition"), Bridge.ref(this, "_maxPosition"), Bridge.ref(this, "_targetPosition"));
                    }
                }
            },
            /**
             * The furthest up, and the furthest left the camera can go.
             if this value equals maxPosition, then no clamping will be 
             applied (unless you override that function).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function MinPosition
             * @type Microsoft.Xna.Framework.Vector2
             */
            MinPosition: {
                get: function () {
                    return FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits(this._minPosition.$clone());
                },
                set: function (value) {
                    this._minPosition = FarseerPhysics.Utility.ConvertUnits.ToSimUnits(value.$clone());
                }
            },
            /**
             * the furthest down, and the furthest right the camera will go.
             if this value equals minPosition, then no clamping will be 
             applied (unless you override that function).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function MaxPosition
             * @type Microsoft.Xna.Framework.Vector2
             */
            MaxPosition: {
                get: function () {
                    return FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits(this._maxPosition.$clone());
                },
                set: function (value) {
                    this._maxPosition = FarseerPhysics.Utility.ConvertUnits.ToSimUnits(value.$clone());
                }
            },
            /**
             * The current rotation of the camera in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function Rotation
             * @type number
             */
            Rotation: {
                get: function () {
                    return this._currentRotation;
                },
                set: function (value) {
                    this._targetRotation = value % Microsoft.Xna.Framework.MathHelper.TwoPi;
                    if (this._minRotation !== this._maxRotation) {
                        this._targetRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(this._targetRotation, this._minRotation, this._maxRotation);
                    }
                }
            },
            /**
             * Gets or sets the minimum rotation in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function MinRotation
             * @type number
             */
            MinRotation: {
                get: function () {
                    return this._minRotation;
                },
                set: function (value) {
                    this._minRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(value, -3.14159274, 0.0);
                }
            },
            /**
             * Gets or sets the maximum rotation in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function MaxRotation
             * @type number
             */
            MaxRotation: {
                get: function () {
                    return this._maxRotation;
                },
                set: function (value) {
                    this._maxRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(value, 0.0, Microsoft.Xna.Framework.MathHelper.Pi);
                }
            },
            /**
             * The current rotation of the camera in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function Zoom
             * @type number
             */
            Zoom: {
                get: function () {
                    return this._currentZoom;
                },
                set: function (value) {
                    this._currentZoom = value;
                    this._currentZoom = Microsoft.Xna.Framework.MathHelper.Clamp$1(this._currentZoom, FarseerPhysics.Utility.Camera2D._minZoom, FarseerPhysics.Utility.Camera2D._maxZoom);
                }
            },
            /**
             * the body that this camera is currently tracking. 
             Null if not tracking any.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function TrackingBody
             * @type FarseerPhysics.Dynamics.Body
             */
            TrackingBody: {
                get: function () {
                    return this._trackingBody;
                },
                set: function (value) {
                    this._trackingBody = value;
                    if (this._trackingBody != null) {
                        this._positionTracking = true;
                    }
                }
            },
            EnablePositionTracking: {
                get: function () {
                    return this._positionTracking;
                },
                set: function (value) {
                    if (value && this._trackingBody != null) {
                        this._positionTracking = true;
                    } else {
                        this._positionTracking = false;
                    }
                }
            },
            EnableRotationTracking: {
                get: function () {
                    return this._rotationTracking;
                },
                set: function (value) {
                    if (value && this._trackingBody != null) {
                        this._rotationTracking = true;
                    } else {
                        this._rotationTracking = false;
                    }
                }
            },
            EnableTracking: {
                set: function (value) {
                    this.EnablePositionTracking = value;
                    this.EnableRotationTracking = value;
                }
            }
        },
        ctors: {
            init: function () {
                this._batchView = new Microsoft.Xna.Framework.Matrix();
                this._currentPosition = new Microsoft.Xna.Framework.Vector2();
                this._maxPosition = new Microsoft.Xna.Framework.Vector2();
                this._minPosition = new Microsoft.Xna.Framework.Vector2();
                this._projection = new Microsoft.Xna.Framework.Matrix();
                this._targetPosition = new Microsoft.Xna.Framework.Vector2();
                this._translateCenter = new Microsoft.Xna.Framework.Vector2();
                this._view = new Microsoft.Xna.Framework.Matrix();
            },
            /**
             * The constructor for the Camera2D class.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.Camera2D
             * @memberof FarseerPhysics.Utility.Camera2D
             * @param   {Microsoft.Xna.Framework.Graphics.GraphicsDevice}    graphics
             * @return  {void}
             */
            ctor: function (graphics) {
                this.$initialize();
                FarseerPhysics.Utility.Camera2D._graphics = graphics;
                this._projection = Microsoft.Xna.Framework.Matrix.CreateOrthographicOffCenter$1(0.0, FarseerPhysics.Utility.ConvertUnits.ToSimUnits$5(FarseerPhysics.Utility.Camera2D._graphics.Viewport.Width), FarseerPhysics.Utility.ConvertUnits.ToSimUnits$5(FarseerPhysics.Utility.Camera2D._graphics.Viewport.Height), 0.0, 0.0, 1.0);
                this._view = Microsoft.Xna.Framework.Matrix.Identity.$clone();
                this._batchView = Microsoft.Xna.Framework.Matrix.Identity.$clone();

                this._translateCenter = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Utility.ConvertUnits.ToSimUnits$6(FarseerPhysics.Utility.Camera2D._graphics.Viewport.Width / 2.0), FarseerPhysics.Utility.ConvertUnits.ToSimUnits$6(FarseerPhysics.Utility.Camera2D._graphics.Viewport.Height / 2.0));

                this.ResetCamera();
            }
        },
        methods: {
            MoveCamera: function (amount) {
                this._currentPosition = Microsoft.Xna.Framework.Vector2.op_Addition(this._currentPosition.$clone(), amount.$clone());
                if (Microsoft.Xna.Framework.Vector2.op_Inequality(this._minPosition.$clone(), this._maxPosition.$clone())) {
                    Microsoft.Xna.Framework.Vector2.Clamp$1(Bridge.ref(this, "_currentPosition"), Bridge.ref(this, "_minPosition"), Bridge.ref(this, "_maxPosition"), Bridge.ref(this, "_currentPosition"));
                }
                this._targetPosition = this._currentPosition.$clone();
                this._positionTracking = false;
                this._rotationTracking = false;
            },
            RotateCamera: function (amount) {
                this._currentRotation += amount;
                if (this._minRotation !== this._maxRotation) {
                    this._currentRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(this._currentRotation, this._minRotation, this._maxRotation);
                }
                this._targetRotation = this._currentRotation;
                this._positionTracking = false;
                this._rotationTracking = false;
            },
            /**
             * Resets the camera to default values.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.Camera2D
             * @memberof FarseerPhysics.Utility.Camera2D
             * @return  {void}
             */
            ResetCamera: function () {
                this._currentPosition = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this._targetPosition = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this._minPosition = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this._maxPosition = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                this._currentRotation = 0.0;
                this._targetRotation = 0.0;
                this._minRotation = -3.14159274;
                this._maxRotation = Microsoft.Xna.Framework.MathHelper.Pi;

                this._positionTracking = false;
                this._rotationTracking = false;

                this._currentZoom = 1.0;

                this.SetView();
            },
            Jump2Target: function () {
                this._currentPosition = this._targetPosition.$clone();
                this._currentRotation = this._targetRotation;

                this.SetView();
            },
            SetView: function () {
                var matRotation = Microsoft.Xna.Framework.Matrix.CreateRotationZ(this._currentRotation);
                var matZoom = Microsoft.Xna.Framework.Matrix.CreateScale$1(this._currentZoom);
                var translateCenter = new Microsoft.Xna.Framework.Vector3.$ctor1(this._translateCenter.$clone(), 0.0);
                var translateBody = new Microsoft.Xna.Framework.Vector3.$ctor1(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this._currentPosition.$clone()), 0.0);

                this._view = Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.CreateTranslation(translateBody.$clone()), matRotation.$clone()), matZoom.$clone()), Microsoft.Xna.Framework.Matrix.CreateTranslation(translateCenter.$clone()));

                translateCenter = FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits$2(translateCenter.$clone());
                translateBody = FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits$2(translateBody.$clone());

                this._batchView = Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.CreateTranslation(translateBody.$clone()), matRotation.$clone()), matZoom.$clone()), Microsoft.Xna.Framework.Matrix.CreateTranslation(translateCenter.$clone()));
            },
            /**
             * Moves the camera forward one timestep.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.Camera2D
             * @memberof FarseerPhysics.Utility.Camera2D
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime
             * @return  {void}
             */
            Update: function (gameTime) {
                if (this._trackingBody != null) {
                    if (this._positionTracking) {
                        this._targetPosition = this._trackingBody.Position.$clone();
                        if (Microsoft.Xna.Framework.Vector2.op_Inequality(this._minPosition.$clone(), this._maxPosition.$clone())) {
                            Microsoft.Xna.Framework.Vector2.Clamp$1(Bridge.ref(this, "_targetPosition"), Bridge.ref(this, "_minPosition"), Bridge.ref(this, "_maxPosition"), Bridge.ref(this, "_targetPosition"));
                        }
                    }
                    if (this._rotationTracking) {
                        this._targetRotation = -this._trackingBody.Rotation % Microsoft.Xna.Framework.MathHelper.TwoPi;
                        if (this._minRotation !== this._maxRotation) {
                            this._targetRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(this._targetRotation, this._minRotation, this._maxRotation);
                        }
                    }
                }
                var delta = Microsoft.Xna.Framework.Vector2.op_Subtraction(this._targetPosition.$clone(), this._currentPosition.$clone());
                var distance = delta.Length();
                if (distance > 0.0) {
                    delta = Microsoft.Xna.Framework.Vector2.op_Division$1(delta.$clone(), distance);
                }
                var inertia;
                if (distance < 10.0) {
                    inertia = Math.pow(distance / 10.0, 2.0);
                } else {
                    inertia = 1.0;
                }

                var rotDelta = this._targetRotation - this._currentRotation;

                var rotInertia;
                if (Math.abs(rotDelta) < 5.0) {
                    rotInertia = Math.pow(rotDelta / 5.0, 2.0);
                } else {
                    rotInertia = 1.0;
                }
                if (Math.abs(rotDelta) > 0.0) {
                    rotDelta /= Math.abs(rotDelta);
                }

                this._currentPosition = Microsoft.Xna.Framework.Vector2.op_Addition(this._currentPosition.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$2(100.0, delta.$clone()), inertia), gameTime.ElapsedGameTime.getTotalSeconds()));
                this._currentRotation += 80.0 * rotDelta * rotInertia * gameTime.ElapsedGameTime.getTotalSeconds();

                this.SetView();
            },
            ConvertScreenToWorld: function (location) {
                var t = new Microsoft.Xna.Framework.Vector3.$ctor1(location.$clone(), 0);

                t = FarseerPhysics.Utility.Camera2D._graphics.Viewport.Unproject(t.$clone(), this._projection.$clone(), this._view.$clone(), Microsoft.Xna.Framework.Matrix.Identity.$clone());

                return new Microsoft.Xna.Framework.Vector2.$ctor2(t.X, t.Y);
            },
            ConvertWorldToScreen: function (location) {
                var t = new Microsoft.Xna.Framework.Vector3.$ctor1(location.$clone(), 0);

                t = FarseerPhysics.Utility.Camera2D._graphics.Viewport.Project(t.$clone(), this._projection.$clone(), this._view.$clone(), Microsoft.Xna.Framework.Matrix.Identity.$clone());

                return new Microsoft.Xna.Framework.Vector2.$ctor2(t.X, t.Y);
            }
        }
    });

    Bridge.define("FarseerPhysics.Utility.Common", {
        statics: {
            methods: {
                GetCompoundPolygonVertices: function (_polygonTexture, _scale, origin) {
                    var $t;
                    var data = System.Array.init(Bridge.Int.mul(_polygonTexture.Width, _polygonTexture.Height), 0, System.UInt32);
                    _polygonTexture.GetData(System.UInt32, data);

                    var textureVertices = FarseerPhysics.Common.PolygonTools.CreatePolygon$1(data, _polygonTexture.Width, false);

                    var centroid = { v : Microsoft.Xna.Framework.Vector2.op_UnaryNegation(textureVertices.GetCentroid()) };
                    textureVertices.Translate$1(centroid);

                    origin.v = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(centroid.v.$clone());

                    textureVertices = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByDistance(textureVertices, 4.0);

                    var list = FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(textureVertices);

                    var vertScale = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor1(FarseerPhysics.Utility.ConvertUnits.ToSimUnits$5(1)), _scale) };
                    $t = Bridge.getEnumerator(list);
                    try {
                        while ($t.moveNext()) {
                            var vertices = $t.Current;
                            vertices.Scale(vertScale);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return list;
                },
                GetPolygonVertices: function (_polygonTexture, _scale, origin) {
                    var data = System.Array.init(Bridge.Int.mul(_polygonTexture.Width, _polygonTexture.Height), 0, System.UInt32);
                    _polygonTexture.GetData(System.UInt32, data);

                    var textureVertices = FarseerPhysics.Common.PolygonTools.CreatePolygon$1(data, _polygonTexture.Width, false);

                    var centroid = { v : Microsoft.Xna.Framework.Vector2.op_UnaryNegation(textureVertices.GetCentroid()) };
                    textureVertices.Translate$1(centroid);

                    origin.v = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(centroid.v.$clone());

                    textureVertices = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify$1(textureVertices, 10.0);
                    var vertScale = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor1(FarseerPhysics.Utility.ConvertUnits.ToSimUnits$5(1)), _scale) };
                    textureVertices.Scale(vertScale);

                    return textureVertices;
                },
                GetAlpha: function (opacity) {
                    return new Microsoft.Xna.Framework.Color.$ctor9(opacity, opacity, opacity, opacity);
                },
                IsRectangleTouch: function (position, origin, rectWidth, rectHeight) {
                    return (position.X >= origin.X - rectWidth / 2 && position.X <= origin.X + rectWidth / 2 && position.Y >= origin.Y - rectHeight / 2 && position.Y <= origin.Y + rectHeight / 2);
                }
            }
        }
    });

    /** @namespace FarseerPhysics.Utility */

    /**
     * Convert units between display and simulation units.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Utility.ConvertUnits
     */
    Bridge.define("FarseerPhysics.Utility.ConvertUnits", {
        statics: {
            fields: {
                _displayUnitsToSimUnitsRatio: 0,
                _simUnitsToDisplayUnitsRatio: 0
            },
            ctors: {
                init: function () {
                    this._displayUnitsToSimUnitsRatio = 100.0;
                    this._simUnitsToDisplayUnitsRatio = 1 / FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                }
            },
            methods: {
                SetDisplayUnitToSimUnitRatio: function (displayUnitsPerSimUnit) {
                    FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio = displayUnitsPerSimUnit;
                    FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio = 1 / displayUnitsPerSimUnit;
                },
                ToDisplayUnits$4: function (simUnits) {
                    return simUnits * FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                },
                ToDisplayUnits$3: function (simUnits) {
                    return simUnits * FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                },
                ToDisplayUnits: function (simUnits) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(simUnits.$clone(), FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio);
                },
                ToDisplayUnits$5: function (simUnits, displayUnits) {
                    Microsoft.Xna.Framework.Vector2.Multiply$3(simUnits, FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio, displayUnits);
                },
                ToDisplayUnits$2: function (simUnits) {
                    return Microsoft.Xna.Framework.Vector3.op_Multiply$1(simUnits.$clone(), FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio);
                },
                ToDisplayUnits$1: function (x, y) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x, y), FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio);
                },
                ToDisplayUnits$6: function (x, y, displayUnits) {
                    displayUnits.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    displayUnits.v.X = x * FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                    displayUnits.v.Y = y * FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                },
                ToSimUnits$6: function (displayUnits) {
                    return displayUnits * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                },
                ToSimUnits$4: function (displayUnits) {
                    return displayUnits * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                },
                ToSimUnits$5: function (displayUnits) {
                    return displayUnits * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                },
                ToSimUnits: function (displayUnits) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(displayUnits.$clone(), FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio);
                },
                ToSimUnits$3: function (displayUnits) {
                    return Microsoft.Xna.Framework.Vector3.op_Multiply$1(displayUnits.$clone(), FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio);
                },
                ToSimUnits$7: function (displayUnits, simUnits) {
                    Microsoft.Xna.Framework.Vector2.Multiply$3(displayUnits, FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio, simUnits);
                },
                ToSimUnits$2: function (x, y) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x, y), FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio);
                },
                ToSimUnits$1: function (x, y) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x, y), FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio);
                },
                ToSimUnits$8: function (x, y, simUnits) {
                    simUnits.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    simUnits.v.X = x * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                    simUnits.v.Y = y * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                }
            }
        }
    });

    /**
     * A screen is a single layer that has update and draw logic, and which
     can be combined with other layers to build up a complex menu system.
     For instance the main menu, the options menu, the "are you sure you
     want to quit" message box, and the main game itself are all implemented
     as screens.
     *
     * @abstract
     * @public
     * @class FarseerPhysics.Utility.GameScreen
     */
    Bridge.define("FarseerPhysics.Utility.GameScreen", {
        fields: {
            _enabledGestures: 0,
            _otherScreenHasFocus: false,
            HasCursor: false,
            HasVirtualStick: false,
            /**
             * Normally when one screen is brought up over the top of another,
             the first screen will transition off to make room for the new
             one. This property indicates whether the screen is only a small
             popup, in which case screens underneath it do not need to bother
             transitioning off.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function IsPopup
             * @type boolean
             */
            IsPopup: false,
            /**
             * Indicates how long the screen takes to
             transition on when it is activated.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function TransitionOnTime
             * @type System.TimeSpan
             */
            TransitionOnTime: null,
            /**
             * Indicates how long the screen takes to
             transition off when it is deactivated.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function TransitionOffTime
             * @type System.TimeSpan
             */
            TransitionOffTime: null,
            /**
             * Gets the current position of the screen transition, ranging
             from zero (fully active, no transition) to one (transitioned
             fully off to nothing).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function TransitionPosition
             * @type number
             */
            TransitionPosition: 0,
            /**
             * Gets the current screen transition state.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function ScreenState
             * @type FarseerPhysics.Utility.ScreenState
             */
            ScreenState: 0,
            /**
             * There are two possible reasons why a screen might be transitioning
             off. It could be temporarily going away to make room for another
             screen that is on top of it, or it could be going away for good.
             This property indicates whether the screen is exiting for real:
             if set, the screen will automatically remove itself as soon as the
             transition finishes.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function IsExiting
             * @type boolean
             */
            IsExiting: false,
            /**
             * Gets the manager that this screen belongs to.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function ScreenManager
             * @type FarseerPhysics.Utility.ScreenManager
             */
            ScreenManager: null
        },
        props: {
            /**
             * Gets the current alpha of the screen transition, ranging
             from 1 (fully active, no transition) to 0 (transitioned
             fully off to nothing).
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function TransitionAlpha
             * @type number
             */
            TransitionAlpha: {
                get: function () {
                    return 1.0 - this.TransitionPosition;
                }
            },
            /**
             * Checks whether this screen is active and can respond to user input.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function IsActive
             * @type boolean
             */
            IsActive: {
                get: function () {
                    return !this._otherScreenHasFocus && (this.ScreenState === FarseerPhysics.Utility.ScreenState.TransitionOn || this.ScreenState === FarseerPhysics.Utility.ScreenState.Active);
                }
            },
            /**
             * Gets the gestures the screen is interested in. Screens should be as specific
             as possible with gestures to increase the accuracy of the gesture engine.
             For example, most menus only need Tap or perhaps Tap and VerticalDrag to operate.
             These gestures are handled by the ScreenManager when screens change and
             all gestures are placed in the InputState passed to the HandleInput method.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function EnabledGestures
             * @type Microsoft.Xna.Framework.Input.Touch.GestureType
             */
            EnabledGestures: {
                get: function () {
                    return this._enabledGestures;
                },
                set: function (value) {
                    this._enabledGestures = value;

                    if (this.ScreenState === FarseerPhysics.Utility.ScreenState.Active) {
                        Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures = value;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.TransitionOnTime = new System.TimeSpan();
                this.TransitionOffTime = new System.TimeSpan();
                this._enabledGestures = Microsoft.Xna.Framework.Input.Touch.GestureType.None;
            },
            ctor: function () {
                this.$initialize();
                this.ScreenState = FarseerPhysics.Utility.ScreenState.TransitionOn;
                this.TransitionPosition = 1;
                this.TransitionOffTime = System.TimeSpan.zero;
                this.TransitionOnTime = System.TimeSpan.zero;
                this.HasCursor = false;
                this.HasVirtualStick = false;
            }
        },
        methods: {
            /**
             * Load graphics content for the screen.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @return  {void}
             */
            LoadContent: function () { },
            /**
             * Unload content for the screen.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @return  {void}
             */
            UnloadContent: function () { },
            /**
             * Allows the screen to run logic, such as updating the transition position.
             Unlike HandleInput, this method is called regardless of whether the screen
             is active, hidden, or in the middle of a transition.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime                
             * @param   {boolean}                             otherScreenHasFocus     
             * @param   {boolean}                             coveredByOtherScreen
             * @return  {void}
             */
            Update: function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {
                this._otherScreenHasFocus = otherScreenHasFocus;

                if (this.IsExiting) {
                    this.ScreenState = FarseerPhysics.Utility.ScreenState.TransitionOff;

                    if (!this.UpdateTransition(gameTime, this.TransitionOffTime, 1)) {
                        this.ScreenManager.RemoveScreen(this);
                    }
                } else if (coveredByOtherScreen) {
                    if (this.UpdateTransition(gameTime, this.TransitionOffTime, 1)) {
                        this.ScreenState = FarseerPhysics.Utility.ScreenState.TransitionOff;
                    } else {
                        this.ScreenState = FarseerPhysics.Utility.ScreenState.Hidden;
                    }
                } else {
                    if (this.UpdateTransition(gameTime, this.TransitionOnTime, -1)) {
                        this.ScreenState = FarseerPhysics.Utility.ScreenState.TransitionOn;
                    } else {
                        this.ScreenState = FarseerPhysics.Utility.ScreenState.Active;
                    }
                }
            },
            /**
             * Helper for updating the screen transition position.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime     
             * @param   {System.TimeSpan}                     time         
             * @param   {number}                              direction
             * @return  {boolean}
             */
            UpdateTransition: function (gameTime, time, direction) {
                var transitionDelta;

                if (System.TimeSpan.eq(time, System.TimeSpan.zero)) {
                    transitionDelta = 1.0;
                } else {
                    transitionDelta = gameTime.ElapsedGameTime.getTotalMilliseconds() / time.getTotalMilliseconds();
                }

                this.TransitionPosition += transitionDelta * direction;

                if (((direction < 0) && (this.TransitionPosition <= 0)) || ((direction > 0) && (this.TransitionPosition >= 1))) {
                    this.TransitionPosition = Microsoft.Xna.Framework.MathHelper.Clamp$1(this.TransitionPosition, 0, 1);
                    return false;
                }

                return true;
            },
            /**
             * This is called when the screen should draw itself.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime
             * @return  {void}
             */
            Draw: function (gameTime) { },
            /**
             * Tells the screen to go away. Unlike ScreenManager.RemoveScreen, which
             instantly kills the screen, this method respects the transition timings
             and will give the screen a chance to gradually transition off.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @return  {void}
             */
            ExitScreen: function () {
                if (System.TimeSpan.eq(this.TransitionOffTime, System.TimeSpan.zero)) {
                    this.ScreenManager.RemoveScreen(this);
                } else {
                    this.IsExiting = true;
                }
            }
        }
    });

    /**
     * The screen manager is a component which manages one or more GameScreen
     instances. It maintains a stack of screens, calls their Update and Draw
     methods at the appropriate times, and automatically routes input to the
     topmost active screen.
     *
     * @public
     * @class FarseerPhysics.Utility.ScreenManager
     * @augments Microsoft.Xna.Framework.DrawableGameComponent
     */
    Bridge.define("FarseerPhysics.Utility.ScreenManager", {
        inherits: [Microsoft.Xna.Framework.DrawableGameComponent],
        fields: {
            _contentManager: null,
            _isInitialized: false,
            _screens: null,
            _screensToUpdate: null,
            _spriteBatch: null,
            _transitions: null
        },
        props: {
            /**
             * A default SpriteBatch shared by all the screens. This saves
             each screen having to bother creating their own local instance.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @function SpriteBatch
             * @type Microsoft.Xna.Framework.Graphics.SpriteBatch
             */
            SpriteBatch: {
                get: function () {
                    return this._spriteBatch;
                }
            },
            Content: {
                get: function () {
                    return this._contentManager;
                }
            }
        },
        alias: [
            "Initialize", "Microsoft$Xna$Framework$IGameComponent$Initialize",
            "Draw", "Microsoft$Xna$Framework$IDrawable$Draw"
        ],
        ctors: {
            /**
             * Constructs a new screen manager component.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {Microsoft.Xna.Framework.Game}    game
             * @return  {void}
             */
            ctor: function (game) {
                this.$initialize();
                Microsoft.Xna.Framework.DrawableGameComponent.ctor.call(this, game);
                Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures = Microsoft.Xna.Framework.Input.Touch.GestureType.None;
                this._contentManager = game.Content;
                this._contentManager.RootDirectory = "Content";

                this._screens = new (System.Collections.Generic.List$1(FarseerPhysics.Utility.GameScreen)).ctor();
                this._screensToUpdate = new (System.Collections.Generic.List$1(FarseerPhysics.Utility.GameScreen)).ctor();
                this._transitions = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Graphics.RenderTarget2D)).ctor();
            }
        },
        methods: {
            /**
             * Initializes the screen manager component.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @return  {void}
             */
            Initialize: function () {
                Microsoft.Xna.Framework.DrawableGameComponent.prototype.Initialize.call(this);

                this._isInitialized = true;
            },
            /**
             * Load your graphics content.
             *
             * @instance
             * @protected
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @return  {void}
             */
            LoadContent: function () {
                var $t;
                this._spriteBatch = new Microsoft.Xna.Framework.Graphics.SpriteBatch(this.GraphicsDevice);

                $t = Bridge.getEnumerator(this._screens);
                try {
                    while ($t.moveNext()) {
                        var screen = $t.Current;
                        screen.LoadContent();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            /**
             * Unload your graphics content.
             *
             * @instance
             * @protected
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @return  {void}
             */
            UnloadContent: function () {
                var $t;
                $t = Bridge.getEnumerator(this._screens);
                try {
                    while ($t.moveNext()) {
                        var screen = $t.Current;
                        screen.UnloadContent();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            /**
             * Allows each screen to run logic.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime
             * @return  {void}
             */
            Update: function (gameTime) {
                var $t;

                this._screensToUpdate.clear();

                $t = Bridge.getEnumerator(this._screens);
                try {
                    while ($t.moveNext()) {
                        var screen = $t.Current;
                        this._screensToUpdate.add(screen);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var otherScreenHasFocus = !this.Game.IsActive;
                var coveredByOtherScreen = false;

                while (this._screensToUpdate.Count > 0) {
                    var screen1 = this._screensToUpdate.getItem(((this._screensToUpdate.Count - 1) | 0));

                    this._screensToUpdate.removeAt(((this._screensToUpdate.Count - 1) | 0));

                    screen1.Update(gameTime, otherScreenHasFocus, coveredByOtherScreen);

                    if (screen1.ScreenState === FarseerPhysics.Utility.ScreenState.TransitionOn || screen1.ScreenState === FarseerPhysics.Utility.ScreenState.Active) {
                        if (!otherScreenHasFocus) {
                            otherScreenHasFocus = true;
                        }

                        if (!screen1.IsPopup) {
                            coveredByOtherScreen = true;
                        }
                    }
                }
            },
            /**
             * Tells each screen to draw itself.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime
             * @return  {void}
             */
            Draw: function (gameTime) {
                var $t;
                this.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.Black.$clone());
                $t = Bridge.getEnumerator(this._screens);
                try {
                    while ($t.moveNext()) {
                        var screen = $t.Current;
                        screen.Draw(gameTime);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            /**
             * Adds a new screen to the screen manager.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {FarseerPhysics.Utility.GameScreen}    screen
             * @return  {void}
             */
            AddScreen: function (screen) {
                screen.ScreenManager = this;
                screen.IsExiting = false;

                if (this._isInitialized) {
                    screen.LoadContent();
                }

                this._screens.add(screen);

                Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures = screen.EnabledGestures;
            },
            /**
             * Removes a screen from the screen manager. You should normally
             use GameScreen.ExitScreen instead of calling this directly, so
             the screen can gradually transition off rather than just being
             instantly removed.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {FarseerPhysics.Utility.GameScreen}    screen
             * @return  {void}
             */
            RemoveScreen: function (screen) {
                if (this._isInitialized) {
                    screen.UnloadContent();
                }

                this._screens.remove(screen);
                this._screensToUpdate.remove(screen);

                if (this._screens.Count > 0) {
                    Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures = this._screens.getItem(((this._screens.Count - 1) | 0)).EnabledGestures;
                }
            },
            /**
             * Expose an array holding all the screens. We return a copy rather
             than the real master list, because screens should only ever be added
             or removed using the AddScreen and RemoveScreen methods.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @return  {Array.<FarseerPhysics.Utility.GameScreen>}
             */
            GetScreens: function () {
                return this._screens.ToArray();
            }
        }
    });

    /**
     * Enum describes the screen transition state.
     *
     * @public
     * @class FarseerPhysics.Utility.ScreenState
     */
    Bridge.define("FarseerPhysics.Utility.ScreenState", {
        $kind: "enum",
        statics: {
            fields: {
                TransitionOn: 0,
                Active: 1,
                TransitionOff: 2,
                Hidden: 3
            }
        }
    });

    Bridge.define("FarseerPhysics.Utility.Sprite", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Utility.Sprite(); }
            }
        },
        fields: {
            Origin: null,
            Texture: null
        },
        ctors: {
            init: function () {
                this.Origin = new Microsoft.Xna.Framework.Vector2();
            },
            $ctor2: function (texture, origin) {
                this.$initialize();
                this.Texture = texture;
                this.Origin = origin.$clone();
            },
            $ctor1: function (sprite) {
                this.$initialize();
                this.Texture = sprite;
                this.Origin = new Microsoft.Xna.Framework.Vector2.$ctor2(sprite.Width / 2.0, sprite.Height / 2.0);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([1769133511, this.Origin, this.Texture]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Utility.Sprite)) {
                    return false;
                }
                return Bridge.equals(this.Origin, o.Origin) && Bridge.equals(this.Texture, o.Texture);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Utility.Sprite();
                s.Origin = this.Origin.$clone();
                s.Texture = this.Texture;
                return s;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.DelaunayTriangle", {
        fields: {
            EdgeIsConstrained: null,
            EdgeIsDelaunay: null,
            Neighbors: null,
            Points: null,
            IsInterior: false
        },
        ctors: {
            init: function () {
                this.EdgeIsConstrained = new Poly2Tri.Triangulation.Util.FixedBitArray3();
                this.EdgeIsDelaunay = new Poly2Tri.Triangulation.Util.FixedBitArray3();
                this.Neighbors = new (Poly2Tri.Triangulation.Util.FixedArray3$1(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle))();
                this.Points = new (Poly2Tri.Triangulation.Util.FixedArray3$1(Poly2Tri.Triangulation.TriangulationPoint))();
            },
            ctor: function (p1, p2, p3) {
                this.$initialize();
                this.Points.setItem(0, p1);
                this.Points.setItem(1, p2);
                this.Points.setItem(2, p3);
            }
        },
        methods: {
            IndexOf: function (p) {
                var i = this.Points.IndexOf(p);
                if (i === -1) {
                    throw new System.Exception("Calling index with a point that doesn't exist in triangle");
                }
                return i;
            },
            IndexCW: function (p) {
                var index = this.IndexOf(p);
                switch (index) {
                    case 0: 
                        return 2;
                    case 1: 
                        return 0;
                    default: 
                        return 1;
                }
            },
            IndexCCW: function (p) {
                var index = this.IndexOf(p);
                switch (index) {
                    case 0: 
                        return 1;
                    case 1: 
                        return 2;
                    default: 
                        return 0;
                }
            },
            Contains$1: function (p) {
                return (Bridge.referenceEquals(p, this.Points.getItem(0)) || Bridge.referenceEquals(p, this.Points.getItem(1)) || Bridge.referenceEquals(p, this.Points.getItem(2)));
            },
            Contains: function (e) {
                return (this.Contains$1(e.P) && this.Contains$1(e.Q));
            },
            Contains$2: function (p, q) {
                return (this.Contains$1(p) && this.Contains$1(q));
            },
            /**
             * Update neighbor pointers
             *
             * @instance
             * @private
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}           p1    Point 1 of the shared edge
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}           p2    Point 2 of the shared edge
             * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t     This triangle's new neighbor
             * @return  {void}
             */
            MarkNeighbor$1: function (p1, p2, t) {
                if ((Bridge.referenceEquals(p1, this.Points.getItem(2)) && Bridge.referenceEquals(p2, this.Points.getItem(1))) || (Bridge.referenceEquals(p1, this.Points.getItem(1)) && Bridge.referenceEquals(p2, this.Points.getItem(2)))) {
                    this.Neighbors.setItem(0, t);
                } else if ((Bridge.referenceEquals(p1, this.Points.getItem(0)) && Bridge.referenceEquals(p2, this.Points.getItem(2))) || (Bridge.referenceEquals(p1, this.Points.getItem(2)) && Bridge.referenceEquals(p2, this.Points.getItem(0)))) {
                    this.Neighbors.setItem(1, t);
                } else if ((Bridge.referenceEquals(p1, this.Points.getItem(0)) && Bridge.referenceEquals(p2, this.Points.getItem(1))) || (Bridge.referenceEquals(p1, this.Points.getItem(1)) && Bridge.referenceEquals(p2, this.Points.getItem(0)))) {
                    this.Neighbors.setItem(2, t);
                } else {
                    System.Diagnostics.Debug.WriteLine$2("Neighbor error, please report!");
                }
            },
            /**
             * Exhaustive search to update neighbor pointers
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t
             * @return  {void}
             */
            MarkNeighbor: function (t) {
                if (t.Contains$2(this.Points.getItem(1), this.Points.getItem(2))) {
                    this.Neighbors.setItem(0, t);
                    t.MarkNeighbor$1(this.Points.getItem(1), this.Points.getItem(2), this);
                } else if (t.Contains$2(this.Points.getItem(0), this.Points.getItem(2))) {
                    this.Neighbors.setItem(1, t);
                    t.MarkNeighbor$1(this.Points.getItem(0), this.Points.getItem(2), this);
                } else if (t.Contains$2(this.Points.getItem(0), this.Points.getItem(1))) {
                    this.Neighbors.setItem(2, t);
                    t.MarkNeighbor$1(this.Points.getItem(0), this.Points.getItem(1), this);
                } else {
                    System.Diagnostics.Debug.WriteLine$2("markNeighbor failed");
                }
            },
            ClearNeighbors: function () {
                var $t, $t1;
                this.Neighbors.setItem(0, ($t = ($t1 = null, this.Neighbors.setItem(2, $t1), $t1), this.Neighbors.setItem(1, $t), $t));
            },
            ClearNeighbor: function (triangle) {
                if (Bridge.referenceEquals(this.Neighbors.getItem(0), triangle)) {
                    this.Neighbors.setItem(0, null);
                } else if (Bridge.referenceEquals(this.Neighbors.getItem(1), triangle)) {
                    this.Neighbors.setItem(1, null);
                } else {
                    this.Neighbors.setItem(2, null);
                }
            },
            Clear: function () {
                var $t, $t1;
                var t;
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    t = this.Neighbors.getItem(i);
                    if (t != null) {
                        t.ClearNeighbor(this);
                    }
                }
                this.ClearNeighbors();
                this.Points.setItem(0, ($t = ($t1 = null, this.Points.setItem(2, $t1), $t1), this.Points.setItem(1, $t), $t));
            },
            /**
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t    Opposite triangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}           p    The point in t that isn't shared between the triangles
             * @return  {Poly2Tri.Triangulation.TriangulationPoint}
             */
            OppositePoint: function (t, p) {
                System.Diagnostics.Debug.Assert$1(!Bridge.referenceEquals(t, this), "self-pointer error");
                return this.PointCW(t.PointCW(p));
            },
            NeighborCW: function (point) {
                return this.Neighbors.getItem((((this.Points.IndexOf(point) + 1) | 0)) % 3);
            },
            NeighborCCW: function (point) {
                return this.Neighbors.getItem((((this.Points.IndexOf(point) + 2) | 0)) % 3);
            },
            NeighborAcross: function (point) {
                return this.Neighbors.getItem(this.Points.IndexOf(point));
            },
            PointCCW: function (point) {
                return this.Points.getItem((((this.IndexOf(point) + 1) | 0)) % 3);
            },
            PointCW: function (point) {
                return this.Points.getItem((((this.IndexOf(point) + 2) | 0)) % 3);
            },
            RotateCW: function () {
                var t = this.Points.getItem(2);
                this.Points.setItem(2, this.Points.getItem(1));
                this.Points.setItem(1, this.Points.getItem(0));
                this.Points.setItem(0, t);
            },
            /**
             * Legalize triangle by rotating clockwise around oPoint
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    oPoint    The origin point to rotate around
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    nPoint    ???
             * @return  {void}
             */
            Legalize: function (oPoint, nPoint) {
                this.RotateCW();
                this.Points.setItem(this.IndexCCW(oPoint), nPoint);
            },
            toString: function () {
                return System.String.concat(System.String.concat(this.Points.getItem(0), ",", this.Points.getItem(1)) + ",", this.Points.getItem(2));
            },
            /**
             * Finalize edge marking
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @return  {void}
             */
            MarkNeighborEdges: function () {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.EdgeIsConstrained.getItem(i) && this.Neighbors.getItem(i) != null) {
                        this.Neighbors.getItem(i).MarkConstrainedEdge$1(this.Points.getItem((((i + 1) | 0)) % 3), this.Points.getItem((((i + 2) | 0)) % 3));
                    }
                }
            },
            MarkEdge: function (triangle) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.EdgeIsConstrained.getItem(i)) {
                        triangle.MarkConstrainedEdge$1(this.Points.getItem((((i + 1) | 0)) % 3), this.Points.getItem((((i + 2) | 0)) % 3));
                    }
                }
            },
            MarkEdge$1: function (tList) {
                var $t;
                $t = Bridge.getEnumerator(tList);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        for (var i = 0; i < 3; i = (i + 1) | 0) {
                            if (t.EdgeIsConstrained.getItem(i)) {
                                this.MarkConstrainedEdge$1(t.Points.getItem((((i + 1) | 0)) % 3), t.Points.getItem((((i + 2) | 0)) % 3));
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            MarkConstrainedEdge$2: function (index) {
                this.EdgeIsConstrained.setItem(index, true);
            },
            MarkConstrainedEdge: function (edge) {
                this.MarkConstrainedEdge$1(edge.P, edge.Q);
            },
            /**
             * Mark edge as constrained
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p    
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    q
             * @return  {void}
             */
            MarkConstrainedEdge$1: function (p, q) {
                var i = this.EdgeIndex(p, q);
                if (i !== -1) {
                    this.EdgeIsConstrained.setItem(i, true);
                }
            },
            Area: function () {
                var b = this.Points.getItem(0).X - this.Points.getItem(1).X;
                var h = this.Points.getItem(2).Y - this.Points.getItem(1).Y;

                return Math.abs((b * h * 0.5));
            },
            Centroid: function () {
                var cx = (this.Points.getItem(0).X + this.Points.getItem(1).X + this.Points.getItem(2).X) / 3.0;
                var cy = (this.Points.getItem(0).Y + this.Points.getItem(1).Y + this.Points.getItem(2).Y) / 3.0;
                return new Poly2Tri.Triangulation.TriangulationPoint(cx, cy);
            },
            /**
             * Get the index of the neighbor that shares this edge (or -1 if it isn't shared)
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p1    
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p2
             * @return  {number}                                             index of the shared edge or -1 if edge isn't shared
             */
            EdgeIndex: function (p1, p2) {
                var i1 = this.Points.IndexOf(p1);
                var i2 = this.Points.IndexOf(p2);

                var a = (i1 === 0 || i2 === 0);
                var b = (i1 === 1 || i2 === 1);
                var c = (i1 === 2 || i2 === 2);

                if (b && c) {
                    return 0;
                }
                if (a && c) {
                    return 1;
                }
                if (a && b) {
                    return 2;
                }
                return -1;
            },
            GetConstrainedEdgeCCW: function (p) {
                return this.EdgeIsConstrained.getItem((((this.IndexOf(p) + 2) | 0)) % 3);
            },
            GetConstrainedEdgeCW: function (p) {
                return this.EdgeIsConstrained.getItem((((this.IndexOf(p) + 1) | 0)) % 3);
            },
            GetConstrainedEdgeAcross: function (p) {
                return this.EdgeIsConstrained.getItem(this.IndexOf(p));
            },
            SetConstrainedEdgeCCW: function (p, ce) {
                this.EdgeIsConstrained.setItem((((this.IndexOf(p) + 2) | 0)) % 3, ce);
            },
            SetConstrainedEdgeCW: function (p, ce) {
                this.EdgeIsConstrained.setItem((((this.IndexOf(p) + 1) | 0)) % 3, ce);
            },
            SetConstrainedEdgeAcross: function (p, ce) {
                this.EdgeIsConstrained.setItem(this.IndexOf(p), ce);
            },
            GetDelaunayEdgeCCW: function (p) {
                return this.EdgeIsDelaunay.getItem((((this.IndexOf(p) + 2) | 0)) % 3);
            },
            GetDelaunayEdgeCW: function (p) {
                return this.EdgeIsDelaunay.getItem((((this.IndexOf(p) + 1) | 0)) % 3);
            },
            GetDelaunayEdgeAcross: function (p) {
                return this.EdgeIsDelaunay.getItem(this.IndexOf(p));
            },
            SetDelaunayEdgeCCW: function (p, ce) {
                this.EdgeIsDelaunay.setItem((((this.IndexOf(p) + 2) | 0)) % 3, ce);
            },
            SetDelaunayEdgeCW: function (p, ce) {
                this.EdgeIsDelaunay.setItem((((this.IndexOf(p) + 1) | 0)) % 3, ce);
            },
            SetDelaunayEdgeAcross: function (p, ce) {
                this.EdgeIsDelaunay.setItem(this.IndexOf(p), ce);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront", {
        fields: {
            Head: null,
            Search: null,
            Tail: null
        },
        ctors: {
            ctor: function (head, tail) {
                this.$initialize();
                this.Head = head;
                this.Tail = tail;
                this.Search = head;
                this.AddNode(head);
                this.AddNode(tail);
            }
        },
        methods: {
            AddNode: function (node) { },
            RemoveNode: function (node) { },
            toString: function () {
                var sb = new System.Text.StringBuilder();
                var node = this.Head;
                while (!Bridge.referenceEquals(node, this.Tail)) {
                    sb.append(node.Point.X).append("->");
                    node = node.Next;
                }
                sb.append(this.Tail.Point.X);
                return sb.toString();
            },
            /**
             * MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of AdvancingFrontNodes near x
                  Removed an overload that depended on this being exact
             *
             * @instance
             * @private
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @param   {number}                                                      x
             * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
             */
            FindSearchNode: function (x) {
                return this.Search;
            },
            /**
             * We use a balancing tree to locate a node smaller or equal to given key value
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}                   point
             * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
             */
            LocateNode: function (point) {
                return this.LocateNode$1(point.X);
            },
            LocateNode$1: function (x) {
                var node = this.FindSearchNode(x);
                if (x < node.Value) {
                    while (((node = node.Prev)) != null) {
                        if (x >= node.Value) {
                            this.Search = node;
                            return node;
                        }
                    }
                } else {
                    while (((node = node.Next)) != null) {
                        if (x < node.Value) {
                            this.Search = node.Prev;
                            return node.Prev;
                        }
                    }
                }
                return null;
            },
            /**
             * This implementation will use simple node traversal algorithm to find a point on the front
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}                   point
             * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
             */
            LocatePoint: function (point) {
                var px = point.X;
                var node = this.FindSearchNode(px);
                var nx = node.Point.X;

                if (px === nx) {
                    if (!Bridge.referenceEquals(point, node.Point)) {
                        if (Bridge.referenceEquals(point, node.Prev.Point)) {
                            node = node.Prev;
                        } else if (Bridge.referenceEquals(point, node.Next.Point)) {
                            node = node.Next;
                        } else {
                            throw new System.Exception("Failed to find Node for given afront point");
                        }
                    }
                } else if (px < nx) {
                    while (((node = node.Prev)) != null) {
                        if (Bridge.referenceEquals(point, node.Point)) {
                            break;
                        }
                    }
                } else {
                    while (((node = node.Next)) != null) {
                        if (Bridge.referenceEquals(point, node.Point)) {
                            break;
                        }
                    }
                }
                this.Search = node;
                return node;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode", {
        fields: {
            Next: null,
            Point: null,
            Prev: null,
            Triangle: null,
            Value: 0
        },
        props: {
            HasNext: {
                get: function () {
                    return this.Next != null;
                }
            },
            HasPrev: {
                get: function () {
                    return this.Prev != null;
                }
            }
        },
        ctors: {
            ctor: function (point) {
                this.$initialize();
                this.Point = point;
                this.Value = point.X;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep", {
        statics: {
            fields: {
                PI_div2: 0,
                PI_3div4: 0
            },
            ctors: {
                init: function () {
                    this.PI_div2 = 1.5707963267948966;
                    this.PI_3div4 = 2.3561944901923448;
                }
            },
            methods: {
                /**
                 * Triangulate simple polygon with holes
                 *
                 * @static
                 * @public
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx
                 * @return  {void}
                 */
                Triangulate: function (tcx) {
                    tcx.CreateAdvancingFront();

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Sweep(tcx);

                    if (tcx.TriangulationMode === Poly2Tri.Triangulation.TriangulationMode.Polygon) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FinalizationPolygon(tcx);
                    } else {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FinalizationConvexHull(tcx);
                    }

                    tcx.Done();
                },
                /**
                 * Start sweeping the Y-sorted point set from bottom to top
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx
                 * @return  {void}
                 */
                Sweep: function (tcx) {
                    var $t;
                    var points = tcx.Points;
                    var point;
                    var node;

                    for (var i = 1; i < points.Count; i = (i + 1) | 0) {
                        point = points.getItem(i);

                        node = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PointEvent(tcx, point);

                        if (point.HasEdges) {
                            $t = Bridge.getEnumerator(point.Edges);
                            try {
                                while ($t.moveNext()) {
                                    var e = $t.Current;
                                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent(tcx, e, node);
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }}
                        tcx.Update(null);
                    }
                },
                /**
                 * If this is a Delaunay Triangulation of a pointset we need to fill so the triangle mesh gets a ConvexHull
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx
                 * @return  {void}
                 */
                FinalizationConvexHull: function (tcx) {
                    var n1, n2;
                    var t1, t2;
                    var first, p1;

                    n1 = tcx.aFront.Head.Next;
                    n2 = n1.Next;
                    first = n1.Point;

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.TurnAdvancingFrontConvex(tcx, n1, n2);



                    n1 = tcx.aFront.Tail.Prev;
                    if (n1.Triangle.Contains$1(n1.Next.Point) && n1.Triangle.Contains$1(n1.Prev.Point)) {
                        t1 = n1.Triangle.NeighborAcross(n1.Point);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(n1.Triangle, n1.Point, t1, t1.OppositePoint(n1.Triangle, n1.Point));
                        tcx.MapTriangleToNodes(n1.Triangle);
                        tcx.MapTriangleToNodes(t1);
                    }
                    n1 = tcx.aFront.Head.Next;
                    if (n1.Triangle.Contains$1(n1.Prev.Point) && n1.Triangle.Contains$1(n1.Next.Point)) {
                        t1 = n1.Triangle.NeighborAcross(n1.Point);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(n1.Triangle, n1.Point, t1, t1.OppositePoint(n1.Triangle, n1.Point));
                        tcx.MapTriangleToNodes(n1.Triangle);
                        tcx.MapTriangleToNodes(t1);
                    }

                    first = tcx.aFront.Head.Point;
                    n2 = tcx.aFront.Tail.Prev;
                    t1 = n2.Triangle;
                    p1 = n2.Point;
                    n2.Triangle = null;
                    do {
                        tcx.RemoveFromList(t1);
                        p1 = t1.PointCCW(p1);
                        if (Bridge.referenceEquals(p1, first)) {
                            break;
                        }
                        t2 = t1.NeighborCCW(p1);
                        t1.Clear();
                        t1 = t2;
                    } while (true);

                    first = tcx.aFront.Head.Next.Point;
                    p1 = t1.PointCW(tcx.aFront.Head.Point);
                    t2 = t1.NeighborCW(tcx.aFront.Head.Point);
                    t1.Clear();
                    t1 = t2;
                    while (!Bridge.referenceEquals(p1, first)) {
                        tcx.RemoveFromList(t1);
                        p1 = t1.PointCCW(p1);
                        t2 = t1.NeighborCCW(p1);
                        t1.Clear();
                        t1 = t2;
                    }

                    tcx.aFront.Head = tcx.aFront.Head.Next;
                    tcx.aFront.Head.Prev = null;
                    tcx.aFront.Tail = tcx.aFront.Tail.Prev;
                    tcx.aFront.Tail.Next = null;

                    tcx.FinalizeTriangulation();
                },
                /**
                 * We will traverse the entire advancing front and fill it to form a convex hull.
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx    
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    b      
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    c
                 * @return  {void}
                 */
                TurnAdvancingFrontConvex: function (tcx, b, c) {
                    var first = b;
                    while (!Bridge.referenceEquals(c, tcx.aFront.Tail)) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(b.Point, c.Point, c.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, c);
                            c = c.Next;
                        } else {
                            if (!Bridge.referenceEquals(b, first) && Poly2Tri.Triangulation.TriangulationUtil.Orient2d(b.Prev.Point, b.Point, c.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, b);
                                b = b.Prev;
                            } else {
                                b = c;
                                c = c.Next;
                            }
                        }
                    }
                },
                FinalizationPolygon: function (tcx) {
                    var t = tcx.aFront.Head.Next.Triangle;
                    var p = tcx.aFront.Head.Next.Point;
                    while (!t.GetConstrainedEdgeCW(p)) {
                        t = t.NeighborCCW(p);
                    }

                    tcx.MeshClean(t);
                },
                /**
                 * Find closes node to the left of the new point and
                 create a new triangle. If needed new holes and basins
                 will be filled to.
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx      
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}                   point
                 * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
                 */
                PointEvent: function (tcx, point) {
                    var node, newNode;

                    node = tcx.LocateNode(point);
                    newNode = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NewFrontTriangle(tcx, point, node);

                    if (point.X <= node.Point.X + Poly2Tri.Triangulation.TriangulationUtil.EPSILON) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node);
                    }

                    tcx.AddNode(newNode);

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillAdvancingFront(tcx, newNode);
                    return newNode;
                },
                /**
                 * Creates a new front triangle and legalize it
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx      
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}                   point    
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node
                 * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
                 */
                NewFrontTriangle: function (tcx, point, node) {
                    var newNode;
                    var triangle;

                    triangle = new Poly2Tri.Triangulation.Delaunay.DelaunayTriangle(point, node.Point, node.Next.Point);
                    triangle.MarkNeighbor(node.Triangle);
                    tcx.Triangles.add(triangle);

                    newNode = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode(point);
                    newNode.Next = node.Next;
                    newNode.Prev = node;
                    node.Next.Prev = newNode;
                    node.Next = newNode;

                    tcx.AddNode(newNode);

                    if (!Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, triangle)) {
                        tcx.MapTriangleToNodes(triangle);
                    }

                    return newNode;
                },
                EdgeEvent: function (tcx, edge, node) {
                    try {
                        tcx.EdgeEvent.ConstrainedEdge = edge;
                        tcx.EdgeEvent.Right = edge.P.X > edge.Q.X;

                        if (Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.IsEdgeSideOfTriangle(node.Triangle, edge.P, edge.Q)) {
                            return;
                        }

                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillEdgeEvent(tcx, edge, node);

                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, edge.P, edge.Q, node.Triangle, edge.Q);
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        var e;
                        if (Bridge.is($e1, Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException)) {
                            e = $e1;
                            System.Diagnostics.Debug.WriteLine$2(System.String.format("Skipping Edge: {0}", [e.Message]));
                        } else {
                            throw $e1;
                        }
                    }
                },
                EdgeEvent$1: function (tcx, ep, eq, triangle, point) {
                    var p1, p2;

                    if (Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.IsEdgeSideOfTriangle(triangle, ep, eq)) {
                        return;
                    }

                    p1 = triangle.PointCCW(point);
                    var o1 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(eq, p1, ep);
                    if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.Collinear) {
                        if (triangle.Contains$2(eq, p1)) {
                            triangle.MarkConstrainedEdge$1(eq, p1);
                            tcx.EdgeEvent.ConstrainedEdge.Q = p1;
                            triangle = triangle.NeighborAcross(point);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, ep, p1, triangle, p1);
                        } else {
                            throw new Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException("EdgeEvent - Point on constrained edge not supported yet");
                        }
                        if (tcx.IsDebugEnabled) {
                            System.Diagnostics.Debug.WriteLine$2("EdgeEvent - Point on constrained edge");
                        }
                        return;
                    }

                    p2 = triangle.PointCW(point);
                    var o2 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(eq, p2, ep);
                    if (o2 === FarseerPhysics.Common.Decomposition.CDT.Orientation.Collinear) {
                        if (triangle.Contains$2(eq, p2)) {
                            triangle.MarkConstrainedEdge$1(eq, p2);
                            tcx.EdgeEvent.ConstrainedEdge.Q = p2;
                            triangle = triangle.NeighborAcross(point);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, ep, p2, triangle, p2);
                        } else {
                            throw new Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException("EdgeEvent - Point on constrained edge not supported yet");
                        }
                        if (tcx.IsDebugEnabled) {
                            System.Diagnostics.Debug.WriteLine$2("EdgeEvent - Point on constrained edge");
                        }
                        return;
                    }

                    if (o1 === o2) {
                        if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            triangle = triangle.NeighborCCW(point);
                        } else {
                            triangle = triangle.NeighborCW(point);
                        }
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, ep, eq, triangle, point);
                    } else {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx, ep, eq, triangle, point);
                    }
                },
                FillEdgeEvent: function (tcx, edge, node) {
                    if (tcx.EdgeEvent.Right) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightAboveEdgeEvent(tcx, edge, node);
                    } else {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftAboveEdgeEvent(tcx, edge, node);
                    }
                },
                FillRightConcaveEdgeEvent: function (tcx, edge, node) {
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node.Next);
                    if (!Bridge.referenceEquals(node.Next.Point, edge.P)) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Next.Point, edge.P) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Next.Point, node.Next.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx, edge, node);
                            } else {
                            }
                        }
                    }
                },
                FillRightConvexEdgeEvent: function (tcx, edge, node) {
                    if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Next.Point, node.Next.Next.Point, node.Next.Next.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx, edge, node.Next);
                    } else {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Next.Next.Point, edge.P) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConvexEdgeEvent(tcx, edge, node.Next);
                        } else {
                        }
                    }
                },
                FillRightBelowEdgeEvent: function (tcx, edge, node) {
                    if (node.Point.X < edge.P.X) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Next.Point, node.Next.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx, edge, node);
                        } else {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConvexEdgeEvent(tcx, edge, node);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightBelowEdgeEvent(tcx, edge, node);
                        }
                    }
                },
                FillRightAboveEdgeEvent: function (tcx, edge, node) {
                    while (node.Next.Point.X < edge.P.X) {
                        var o1 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Next.Point, edge.P);
                        if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightBelowEdgeEvent(tcx, edge, node);
                        } else {
                            node = node.Next;
                        }
                    }
                },
                FillLeftConvexEdgeEvent: function (tcx, edge, node) {
                    if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Prev.Point, node.Prev.Prev.Point, node.Prev.Prev.Prev.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx, edge, node.Prev);
                    } else {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Prev.Prev.Point, edge.P) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConvexEdgeEvent(tcx, edge, node.Prev);
                        } else {
                        }
                    }
                },
                FillLeftConcaveEdgeEvent: function (tcx, edge, node) {
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node.Prev);
                    if (!Bridge.referenceEquals(node.Prev.Point, edge.P)) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Prev.Point, edge.P) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Prev.Point, node.Prev.Prev.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx, edge, node);
                            } else {
                            }
                        }
                    }
                },
                FillLeftBelowEdgeEvent: function (tcx, edge, node) {
                    if (node.Point.X > edge.P.X) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Prev.Point, node.Prev.Prev.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx, edge, node);
                        } else {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConvexEdgeEvent(tcx, edge, node);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftBelowEdgeEvent(tcx, edge, node);
                        }
                    }
                },
                FillLeftAboveEdgeEvent: function (tcx, edge, node) {
                    while (node.Prev.Point.X > edge.P.X) {
                        var o1 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Prev.Point, edge.P);
                        if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftBelowEdgeEvent(tcx, edge, node);
                        } else {
                            node = node.Prev;
                        }
                    }
                },
                IsEdgeSideOfTriangle: function (triangle, ep, eq) {
                    var index;
                    index = triangle.EdgeIndex(ep, eq);
                    if (index !== -1) {
                        triangle.MarkConstrainedEdge$2(index);
                        triangle = triangle.Neighbors.getItem(index);
                        if (triangle != null) {
                            triangle.MarkConstrainedEdge$1(ep, eq);
                        }
                        return true;
                    }
                    return false;
                },
                FlipEdgeEvent: function (tcx, ep, eq, t, p) {
                    var op, newP;
                    var ot;
                    var inScanArea;

                    ot = t.NeighborAcross(p);
                    op = ot.OppositePoint(t, p);

                    if (ot == null) {
                        throw new System.InvalidOperationException.$ctor1("[BUG:FIXME] FLIP failed due to missing triangle");
                    }

                    inScanArea = Poly2Tri.Triangulation.TriangulationUtil.InScanArea(p, t.PointCCW(p), t.PointCW(p), op);
                    if (inScanArea) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(t, p, ot, op);
                        tcx.MapTriangleToNodes(t);
                        tcx.MapTriangleToNodes(ot);

                        if (Bridge.referenceEquals(p, eq) && Bridge.referenceEquals(op, ep)) {
                            if (Bridge.referenceEquals(eq, tcx.EdgeEvent.ConstrainedEdge.Q) && Bridge.referenceEquals(ep, tcx.EdgeEvent.ConstrainedEdge.P)) {
                                if (tcx.IsDebugEnabled) {
                                    System.Console.WriteLine("[FLIP] - constrained edge done");
                                }
                                t.MarkConstrainedEdge$1(ep, eq);
                                ot.MarkConstrainedEdge$1(ep, eq);
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, t);
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, ot);
                            } else {
                                if (tcx.IsDebugEnabled) {
                                    System.Console.WriteLine("[FLIP] - subedge done");
                                }
                            }
                        } else {
                            if (tcx.IsDebugEnabled) {
                                System.Console.WriteLine("[FLIP] - flipping and continuing with triangle still crossing edge");
                            }
                            var o = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(eq, op, ep);
                            t = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipTriangle(tcx, o, t, ot, p, op);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx, ep, eq, t, p);
                        }
                    } else {
                        newP = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipPoint(ep, eq, ot, op);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, ep, eq, t, p);
                    }
                },
                /**
                 * When we need to traverse from one triangle to the next we need 
                 the point in current triangle that is the opposite point to the next
                 triangle.
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           ep    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           eq    
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    ot    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           op
                 * @return  {Poly2Tri.Triangulation.TriangulationPoint}
                 */
                NextFlipPoint: function (ep, eq, ot, op) {
                    var o2d = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(eq, op, ep);
                    if (o2d === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                        return ot.PointCCW(op);
                    } else if (o2d === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                        return ot.PointCW(op);
                    } else {
                        throw new Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException("Point on constrained edge not supported yet");
                    }
                },
                /**
                 * After a flip we have two triangles and know that only one will still be
                 intersecting the edge. So decide which to contiune with and legalize the other
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx    
                 * @param   {FarseerPhysics.Common.Decomposition.CDT.Orientation}     o      should be the result of an TriangulationUtil.orient2d( eq, op, ep )
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}        t      triangle 1
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}        ot     triangle 2
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}               p      a point shared by both triangles
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}               op     another point shared by both triangles
                 * @return  {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}               returns the triangle still intersecting the edge
                 */
                NextFlipTriangle: function (tcx, o, t, ot, p, op) {
                    var edgeIndex;
                    if (o === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                        edgeIndex = ot.EdgeIndex(p, op);
                        ot.EdgeIsDelaunay.setItem(edgeIndex, true);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, ot);
                        ot.EdgeIsDelaunay.Clear();
                        return t;
                    }
                    edgeIndex = t.EdgeIndex(p, op);
                    t.EdgeIsDelaunay.setItem(edgeIndex, true);
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, t);
                    t.EdgeIsDelaunay.Clear();
                    return ot;
                },
                
                FlipScanEdgeEvent: function (tcx, ep, eq, flipTriangle, t, p) {
                    var ot;
                    var op, newP;
                    var inScanArea;

                    ot = t.NeighborAcross(p);
                    op = ot.OppositePoint(t, p);

                    if (ot == null) {
                        throw new System.Exception("[BUG:FIXME] FLIP failed due to missing triangle");
                    }

                    inScanArea = Poly2Tri.Triangulation.TriangulationUtil.InScanArea(eq, flipTriangle.PointCCW(eq), flipTriangle.PointCW(eq), op);
                    if (inScanArea) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx, eq, op, ot, op);
                    } else {
                        newP = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipPoint(ep, eq, ot, op);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(tcx, ep, eq, flipTriangle, ot, newP);
                    }
                },
                /**
                 * Fills holes in the Advancing Front
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx    
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    n
                 * @return  {void}
                 */
                FillAdvancingFront: function (tcx, n) {
                    var node;
                    var angle;

                    node = n.Next;
                    while (node.HasNext) {
                        angle = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.HoleAngle(node);
                        if (angle > Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PI_div2 || angle < -1.5707963267948966) {
                            break;
                        }
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node);
                        node = node.Next;
                    }

                    node = n.Prev;
                    while (node.HasPrev) {
                        angle = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.HoleAngle(node);
                        if (angle > Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PI_div2 || angle < -1.5707963267948966) {
                            break;
                        }
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node);
                        node = node.Prev;
                    }

                    if (n.HasNext && n.Next.HasNext) {
                        angle = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.BasinAngle(n);
                        if (angle < Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PI_3div4) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasin(tcx, n);
                        }
                    }
                },
                
                FillBasin: function (tcx, node) {
                    if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Next.Point, node.Next.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                        tcx.Basin.leftNode = node;
                    } else {
                        tcx.Basin.leftNode = node.Next;
                    }

                    tcx.Basin.bottomNode = tcx.Basin.leftNode;
                    while (tcx.Basin.bottomNode.HasNext && tcx.Basin.bottomNode.Point.Y >= tcx.Basin.bottomNode.Next.Point.Y) {
                        tcx.Basin.bottomNode = tcx.Basin.bottomNode.Next;
                    }

                    if (Bridge.referenceEquals(tcx.Basin.bottomNode, tcx.Basin.leftNode)) {
                        return;
                    }

                    tcx.Basin.rightNode = tcx.Basin.bottomNode;
                    while (tcx.Basin.rightNode.HasNext && tcx.Basin.rightNode.Point.Y < tcx.Basin.rightNode.Next.Point.Y) {
                        tcx.Basin.rightNode = tcx.Basin.rightNode.Next;
                    }

                    if (Bridge.referenceEquals(tcx.Basin.rightNode, tcx.Basin.bottomNode)) {
                        return;
                    }

                    tcx.Basin.width = tcx.Basin.rightNode.Point.X - tcx.Basin.leftNode.Point.X;
                    tcx.Basin.leftHighest = tcx.Basin.leftNode.Point.Y > tcx.Basin.rightNode.Point.Y;

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasinReq(tcx, tcx.Basin.bottomNode);
                },
                /**
                 * Recursive algorithm to fill a Basin with triangles
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx     
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node
                 * @return  {void}
                 */
                FillBasinReq: function (tcx, node) {
                    if (Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.IsShallow(tcx, node)) {
                        return;
                    }

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node);
                    if (Bridge.referenceEquals(node.Prev, tcx.Basin.leftNode) && Bridge.referenceEquals(node.Next, tcx.Basin.rightNode)) {
                        return;
                    } else if (Bridge.referenceEquals(node.Prev, tcx.Basin.leftNode)) {
                        var o = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Next.Point, node.Next.Next.Point);
                        if (o === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            return;
                        }
                        node = node.Next;
                    } else if (Bridge.referenceEquals(node.Next, tcx.Basin.rightNode)) {
                        var o1 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Prev.Point, node.Prev.Prev.Point);
                        if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            return;
                        }
                        node = node.Prev;
                    } else {
                        if (node.Prev.Point.Y < node.Next.Point.Y) {
                            node = node.Prev;
                        } else {
                            node = node.Next;
                        }
                    }
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasinReq(tcx, node);
                },
                IsShallow: function (tcx, node) {
                    var height;

                    if (tcx.Basin.leftHighest) {
                        height = tcx.Basin.leftNode.Point.Y - node.Point.Y;
                    } else {
                        height = tcx.Basin.rightNode.Point.Y - node.Point.Y;
                    }
                    if (tcx.Basin.width > height) {
                        return true;
                    }
                    return false;
                },
                /**
                 * ???
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node    middle node
                 * @return  {number}                                                              the angle between 3 front nodes
                 */
                HoleAngle: function (node) {
                    /* Complex plane
                      ab = cosA +i*sinA
                      ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
                      atan2(y,x) computes the principal value of the argument function
                      applied to the complex number x+iy
                      Where x = ax*bx + ay*by
                            y = ax*by - ay*bx
                    */
                    var px = node.Point.X;
                    var py = node.Point.Y;
                    var ax = node.Next.Point.X - px;
                    var ay = node.Next.Point.Y - py;
                    var bx = node.Prev.Point.X - px;
                    var by = node.Prev.Point.Y - py;
                    return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
                },
                /**
                 * The basin angle is decided against the horizontal line [1,0]
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node
                 * @return  {number}
                 */
                BasinAngle: function (node) {
                    var ax = node.Point.X - node.Next.Next.Point.X;
                    var ay = node.Point.Y - node.Next.Next.Point.Y;
                    return Math.atan2(ay, ax);
                },
                /**
                 * Adds a triangle to the advancing front to fill a hole.
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx     
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node    middle node, that is the bottom of the hole
                 * @return  {void}
                 */
                Fill: function (tcx, node) {
                    var triangle = new Poly2Tri.Triangulation.Delaunay.DelaunayTriangle(node.Prev.Point, node.Point, node.Next.Point);
                    triangle.MarkNeighbor(node.Prev.Triangle);
                    triangle.MarkNeighbor(node.Triangle);
                    tcx.Triangles.add(triangle);

                    node.Prev.Next = node.Next;
                    node.Next.Prev = node.Prev;
                    tcx.RemoveNode(node);

                    if (!Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, triangle)) {
                        tcx.MapTriangleToNodes(triangle);
                    }
                },
                /**
                 * Returns true if triangle was legalized
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx    
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}        t
                 * @return  {boolean}
                 */
                Legalize: function (tcx, t) {
                    var oi;
                    var inside;
                    var p, op;
                    var ot;

                    for (var i = 0; i < 3; i = (i + 1) | 0) {
                        if (t.EdgeIsDelaunay.getItem(i)) {
                            continue;
                        }

                        ot = t.Neighbors.getItem(i);
                        if (ot != null) {
                            p = t.Points.getItem(i);
                            op = ot.OppositePoint(t, p);
                            oi = ot.IndexOf(op);
                            if (ot.EdgeIsConstrained.getItem(oi) || ot.EdgeIsDelaunay.getItem(oi)) {
                                t.EdgeIsConstrained.setItem(i, ot.EdgeIsConstrained.getItem(oi));
                                continue;
                            }

                            inside = Poly2Tri.Triangulation.TriangulationUtil.SmartIncircle(p, t.PointCCW(p), t.PointCW(p), op);

                            if (inside) {
                                var notLegalized;

                                t.EdgeIsDelaunay.setItem(i, true);
                                ot.EdgeIsDelaunay.setItem(oi, true);

                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(t, p, ot, op);


                                notLegalized = !Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, t);

                                if (notLegalized) {
                                    tcx.MapTriangleToNodes(t);
                                }
                                notLegalized = !Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, ot);
                                if (notLegalized) {
                                    tcx.MapTriangleToNodes(ot);
                                }

                                t.EdgeIsDelaunay.setItem(i, false);
                                ot.EdgeIsDelaunay.setItem(oi, false);

                                return true;
                            }
                        }
                    }
                    return false;
                },
                /**
                 * Rotates a triangle pair one vertex CW
                       n2                    n2
                  P +-----+             P +-----+
                    | t  /|               |\  t |  
                    |   / |               | \   |
                  n1|  /  |n3           n1|  \  |n3
                    | /   |    after CW   |   \ |
                    |/ oT |               | oT \|
                    +-----+ oP            +-----+
                       n4                    n4
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t     
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           p     
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    ot    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           op
                 * @return  {void}
                 */
                RotateTrianglePair: function (t, p, ot, op) {
                    var n1, n2, n3, n4;
                    n1 = t.NeighborCCW(p);
                    n2 = t.NeighborCW(p);
                    n3 = ot.NeighborCCW(op);
                    n4 = ot.NeighborCW(op);

                    var ce1, ce2, ce3, ce4;
                    ce1 = t.GetConstrainedEdgeCCW(p);
                    ce2 = t.GetConstrainedEdgeCW(p);
                    ce3 = ot.GetConstrainedEdgeCCW(op);
                    ce4 = ot.GetConstrainedEdgeCW(op);

                    var de1, de2, de3, de4;
                    de1 = t.GetDelaunayEdgeCCW(p);
                    de2 = t.GetDelaunayEdgeCW(p);
                    de3 = ot.GetDelaunayEdgeCCW(op);
                    de4 = ot.GetDelaunayEdgeCW(op);

                    t.Legalize(p, op);
                    ot.Legalize(op, p);

                    ot.SetDelaunayEdgeCCW(p, de1);
                    t.SetDelaunayEdgeCW(p, de2);
                    t.SetDelaunayEdgeCCW(op, de3);
                    ot.SetDelaunayEdgeCW(op, de4);

                    ot.SetConstrainedEdgeCCW(p, ce1);
                    t.SetConstrainedEdgeCW(p, ce2);
                    t.SetConstrainedEdgeCCW(op, ce3);
                    ot.SetConstrainedEdgeCW(op, ce4);

                    t.Neighbors.Clear();
                    ot.Neighbors.Clear();
                    if (n1 != null) {
                        ot.MarkNeighbor(n1);
                    }
                    if (n2 != null) {
                        t.MarkNeighbor(n2);
                    }
                    if (n3 != null) {
                        t.MarkNeighbor(n3);
                    }
                    if (n4 != null) {
                        ot.MarkNeighbor(n4);
                    }
                    t.MarkNeighbor(ot);
                }
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationConstraint", {
        fields: {
            P: null,
            Q: null
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationContext", {
        fields: {
            Points: null,
            Triangles: null,
            _stepTime: 0,
            TriangulationMode: 0,
            Triangulatable: null,
            WaitUntilNotified: false,
            Terminated: false,
            StepCount: 0,
            IsDebugEnabled: false
        },
        ctors: {
            init: function () {
                this.Points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).$ctor2(200);
                this.Triangles = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)).ctor();
                this._stepTime = -1;
            },
            ctor: function () {
                this.$initialize();
                this.Terminated = false;
            }
        },
        methods: {
            Done: function () {
                this.StepCount = (this.StepCount + 1) | 0;
            },
            PrepareTriangulation: function (t) {
                this.Triangulatable = t;
                this.TriangulationMode = t.Poly2Tri$Triangulation$Triangulatable$TriangulationMode;
                t.Poly2Tri$Triangulation$Triangulatable$PrepareTriangulation(this);
            },
            Update: function (message) { },
            Clear: function () {
                this.Points.clear();
                this.Terminated = false;
                this.StepCount = 0;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.DTSweepBasin", {
        $kind: "nested class",
        fields: {
            bottomNode: null,
            leftHighest: false,
            leftNode: null,
            rightNode: null,
            width: 0
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.DTSweepEdgeEvent", {
        $kind: "nested class",
        fields: {
            ConstrainedEdge: null,
            Right: false
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationPoint", {
        fields: {
            X: 0,
            Y: 0,
            Edges: null
        },
        props: {
            Xf: {
                get: function () {
                    return this.X;
                },
                set: function (value) {
                    this.X = value;
                }
            },
            Yf: {
                get: function () {
                    return this.Y;
                },
                set: function (value) {
                    this.Y = value;
                }
            },
            HasEdges: {
                get: function () {
                    return this.Edges != null;
                }
            }
        },
        ctors: {
            ctor: function (x, y) {
                this.$initialize();
                this.X = x;
                this.Y = y;
            }
        },
        methods: {
            toString: function () {
                return "[" + System.Double.format(this.X) + "," + System.Double.format(this.Y) + "]";
            },
            AddEdge: function (e) {
                if (this.Edges == null) {
                    this.Edges = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint)).ctor();
                }
                this.Edges.add(e);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException", {
        inherits: [System.NotImplementedException],
        ctors: {
            ctor: function (message) {
                this.$initialize();
                System.NotImplementedException.$ctor1.call(this, message);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Triangulatable", {
        $kind: "interface"
    });

    Bridge.define("Poly2Tri.Triangulation.Polygon.PolygonSet", {
        fields: {
            _polygons: null
        },
        props: {
            Polygons: {
                get: function () {
                    return this._polygons;
                }
            }
        },
        ctors: {
            init: function () {
                this._polygons = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Polygon.Polygon)).ctor();
            },
            ctor: function () {
                this.$initialize();
            },
            $ctor1: function (poly) {
                this.$initialize();
                this._polygons.add(poly);
            }
        },
        methods: {
            Add: function (p) {
                this._polygons.add(p);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationMode", {
        $kind: "enum",
        statics: {
            fields: {
                Unconstrained: 0,
                Constrained: 1,
                Polygon: 2
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationUtil", {
        statics: {
            fields: {
                EPSILON: 0
            },
            ctors: {
                init: function () {
                    this.EPSILON = 1E-12;
                }
            },
            methods: {
                /**
                 * Requirements:
                 1. a,b and c form a triangle.
                 2. a and d is know to be on opposite side of bc
                 <pre><code>a
                                +
                               / \
                              /   \
                            b/     \c
                            +-------+ 
                           /    B    \  
                          /           \</code></pre>
                    Facts:
                  d has to be in area B to have a chance to be inside the circle formed by a,b and c
                  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW
                  This preknowledge gives us a way to optimize the incircle test
                 *
                 * @static
                 * @public
                 * @this Poly2Tri.Triangulation.TriangulationUtil
                 * @memberof Poly2Tri.Triangulation.TriangulationUtil
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}    pa    triangle point, opposite d
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}    pb    triangle point
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}    pc    triangle point
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}    pd    point opposite a
                 * @return  {boolean}                                            true if d is inside circle, false if on circle edge
                 */
                SmartIncircle: function (pa, pb, pc, pd) {
                    var pdx = pd.X;
                    var pdy = pd.Y;
                    var adx = pa.X - pdx;
                    var ady = pa.Y - pdy;
                    var bdx = pb.X - pdx;
                    var bdy = pb.Y - pdy;

                    var adxbdy = adx * bdy;
                    var bdxady = bdx * ady;
                    var oabd = adxbdy - bdxady;
                    if (oabd <= 0) {
                        return false;
                    }

                    var cdx = pc.X - pdx;
                    var cdy = pc.Y - pdy;

                    var cdxady = cdx * ady;
                    var adxcdy = adx * cdy;
                    var ocad = cdxady - adxcdy;
                    if (ocad <= 0) {
                        return false;
                    }

                    var bdxcdy = bdx * cdy;
                    var cdxbdy = cdx * bdy;

                    var alift = adx * adx + ady * ady;
                    var blift = bdx * bdx + bdy * bdy;
                    var clift = cdx * cdx + cdy * cdy;

                    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;

                    return det > 0;
                },
                InScanArea: function (pa, pb, pc, pd) {
                    var pdx = pd.X;
                    var pdy = pd.Y;
                    var adx = pa.X - pdx;
                    var ady = pa.Y - pdy;
                    var bdx = pb.X - pdx;
                    var bdy = pb.Y - pdy;

                    var adxbdy = adx * bdy;
                    var bdxady = bdx * ady;
                    var oabd = adxbdy - bdxady;
                    if (oabd <= 0) {
                        return false;
                    }

                    var cdx = pc.X - pdx;
                    var cdy = pc.Y - pdy;

                    var cdxady = cdx * ady;
                    var adxcdy = adx * cdy;
                    var ocad = cdxady - adxcdy;
                    if (ocad <= 0) {
                        return false;
                    }
                    return true;
                },
                /**
                 * @static
                 * @public
                 * @this Poly2Tri.Triangulation.TriangulationUtil
                 * @memberof Poly2Tri.Triangulation.TriangulationUtil
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}              pa    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}              pb    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}              pc
                 * @return  {FarseerPhysics.Common.Decomposition.CDT.Orientation}
                 */
                Orient2d: function (pa, pb, pc) {
                    var detleft = (pa.X - pc.X) * (pb.Y - pc.Y);
                    var detright = (pa.Y - pc.Y) * (pb.X - pc.X);
                    var val = detleft - detright;
                    if (val > -Poly2Tri.Triangulation.TriangulationUtil.EPSILON && val < Poly2Tri.Triangulation.TriangulationUtil.EPSILON) {
                        return FarseerPhysics.Common.Decomposition.CDT.Orientation.Collinear;
                    } else if (val > 0) {
                        return FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW;
                    }
                    return FarseerPhysics.Common.Decomposition.CDT.Orientation.CW;
                }
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Util.FixedArray3$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T)],
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (Poly2Tri.Triangulation.Util.FixedArray3$1(T))(); }
            }
        },
        fields: {
            _0: Bridge.getDefaultValue(T),
            _1: Bridge.getDefaultValue(T),
            _2: Bridge.getDefaultValue(T)
        },
        alias: ["GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._0;
                    case 1: 
                        return this._1;
                    case 2: 
                        return this._2;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._0 = value;
                        break;
                    case 1: 
                        this._1 = value;
                        break;
                    case 2: 
                        this._2 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            GetEnumerator: function () {
                return Bridge.getEnumerator(this.Enumerate(), T);
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return this.GetEnumerator();
            },
            Contains: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.getItem(i), value)) {
                        return true;
                    }
                }
                return false;
            },
            IndexOf: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.getItem(i), value)) {
                        return i;
                    }
                }
                return -1;
            },
            Clear: function () {
                this._0 = (this._1 = (this._2 = null));
            },
            Clear$1: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.getItem(i), value)) {
                        this.setItem(i, null);
                    }
                }
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < 3 ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.getItem(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            getHashCode: function () {
                var h = Bridge.addHash([3625853963, this._0, this._1, this._2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Poly2Tri.Triangulation.Util.FixedArray3$1(T))) {
                    return false;
                }
                return Bridge.equals(this._0, o._0) && Bridge.equals(this._1, o._1) && Bridge.equals(this._2, o._2);
            },
            $clone: function (to) {
                var s = to || new (Poly2Tri.Triangulation.Util.FixedArray3$1(T))();
                s._0 = this._0;
                s._1 = this._1;
                s._2 = this._2;
                return s;
            }
        }
    }; });

    Bridge.define("Poly2Tri.Triangulation.Util.FixedBitArray3", {
        inherits: [System.Collections.Generic.IEnumerable$1(System.Boolean)],
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new Poly2Tri.Triangulation.Util.FixedBitArray3(); }
            }
        },
        fields: {
            _0: false,
            _1: false,
            _2: false
        },
        alias: ["GetEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Boolean$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._0;
                    case 1: 
                        return this._1;
                    case 2: 
                        return this._2;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._0 = value;
                        break;
                    case 1: 
                        this._1 = value;
                        break;
                    case 2: 
                        this._2 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            GetEnumerator: function () {
                return Bridge.getEnumerator(this.Enumerate(), System.Boolean);
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return this.GetEnumerator();
            },
            Contains: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.getItem(i) === value) {
                        return true;
                    }
                }
                return false;
            },
            IndexOf: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.getItem(i) === value) {
                        return i;
                    }
                }
                return -1;
            },
            Clear: function () {
                this._0 = (this._1 = (this._2 = false));
            },
            Clear$1: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.getItem(i) === value) {
                        this.setItem(i, false);
                    }
                }
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Boolean))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Boolean))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < 3 ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.getItem(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            getHashCode: function () {
                var h = Bridge.addHash([5290348900, this._0, this._1, this._2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Poly2Tri.Triangulation.Util.FixedBitArray3)) {
                    return false;
                }
                return Bridge.equals(this._0, o._0) && Bridge.equals(this._1, o._1) && Bridge.equals(this._2, o._2);
            },
            $clone: function (to) {
                var s = to || new Poly2Tri.Triangulation.Util.FixedBitArray3();
                s._0 = this._0;
                s._1 = this._1;
                s._2 = this._2;
                return s;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Util.PointGenerator", {
        statics: {
            fields: {
                RNG: null
            },
            ctors: {
                init: function () {
                    this.RNG = new System.Random.ctor();
                }
            },
            methods: {
                UniformDistribution: function (n, scale) {
                    var points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                    for (var i = 0; i < n; i = (i + 1) | 0) {
                        points.add(new Poly2Tri.Triangulation.TriangulationPoint(scale * (0.5 - Poly2Tri.Triangulation.Util.PointGenerator.RNG.NextDouble()), scale * (0.5 - Poly2Tri.Triangulation.Util.PointGenerator.RNG.NextDouble())));
                    }
                    return points;
                },
                UniformGrid: function (n, scale) {
                    var x = 0;
                    var size = scale / n;
                    var halfScale = 0.5 * scale;

                    var points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                    for (var i = 0; i < ((n + 1) | 0); i = (i + 1) | 0) {
                        x = halfScale - i * size;
                        for (var j = 0; j < ((n + 1) | 0); j = (j + 1) | 0) {
                            points.add(new Poly2Tri.Triangulation.TriangulationPoint(x, halfScale - j * size));
                        }
                    }
                    return points;
                }
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Util.PolygonGenerator", {
        statics: {
            fields: {
                RNG: null,
                PI_2: 0
            },
            ctors: {
                init: function () {
                    this.RNG = new System.Random.ctor();
                    this.PI_2 = 6.2831853071795862;
                }
            },
            methods: {
                RandomCircleSweep: function (scale, vertexCount) {
                    var point;
                    var points;
                    var radius = scale / 4;

                    points = System.Array.init(vertexCount, null, Poly2Tri.Triangulation.Polygon.PolygonPoint);
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        do {
                            if (i % 250 === 0) {
                                radius += scale / 2 * (0.5 - Poly2Tri.Triangulation.Util.PolygonGenerator.RNG.NextDouble());
                            } else if (i % 50 === 0) {
                                radius += scale / 5 * (0.5 - Poly2Tri.Triangulation.Util.PolygonGenerator.RNG.NextDouble());
                            } else {
                                radius += 25 * scale / vertexCount * (0.5 - Poly2Tri.Triangulation.Util.PolygonGenerator.RNG.NextDouble());
                            }
                            radius = radius > scale / 2 ? scale / 2 : radius;
                            radius = radius < scale / 10 ? scale / 10 : radius;
                        } while (radius < scale / 10 || radius > scale / 2);
                        point = new Poly2Tri.Triangulation.Polygon.PolygonPoint(radius * Math.cos((Poly2Tri.Triangulation.Util.PolygonGenerator.PI_2 * i) / vertexCount), radius * Math.sin((Poly2Tri.Triangulation.Util.PolygonGenerator.PI_2 * i) / vertexCount));
                        points[System.Array.index(i, points)] = point;
                    }
                    return new Poly2Tri.Triangulation.Polygon.Polygon.$ctor2(points);
                },
                RandomCircleSweep2: function (scale, vertexCount) {
                    var point;
                    var points;
                    var radius = scale / 4;

                    points = System.Array.init(vertexCount, null, Poly2Tri.Triangulation.Polygon.PolygonPoint);
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        do {
                            radius += scale / 5 * (0.5 - Poly2Tri.Triangulation.Util.PolygonGenerator.RNG.NextDouble());
                            radius = radius > scale / 2 ? scale / 2 : radius;
                            radius = radius < scale / 10 ? scale / 10 : radius;
                        } while (radius < scale / 10 || radius > scale / 2);
                        point = new Poly2Tri.Triangulation.Polygon.PolygonPoint(radius * Math.cos((Poly2Tri.Triangulation.Util.PolygonGenerator.PI_2 * i) / vertexCount), radius * Math.sin((Poly2Tri.Triangulation.Util.PolygonGenerator.PI_2 * i) / vertexCount));
                        points[System.Array.index(i, points)] = point;
                    }
                    return new Poly2Tri.Triangulation.Polygon.Polygon.$ctor2(points);
                }
            }
        }
    });

    Bridge.define("QuadTree$1", function (T) { return {
        statics: {
            methods: {
                /**
                 * tests if ray intersects AABB
                 *
                 * @static
                 * @public
                 * @this QuadTree$1
                 * @memberof QuadTree$1
                 * @param   {FarseerPhysics.Collision.AABB}      aabb    
                 * @param   {Microsoft.Xna.Framework.Vector2}    p1      
                 * @param   {Microsoft.Xna.Framework.Vector2}    p2
                 * @return  {boolean}
                 */
                RayCastAABB: function (aabb, p1, p2) {
                    p1 = {v:p1};
                    p2 = {v:p2};
                    var segmentAABB = new FarseerPhysics.Collision.AABB.ctor();
                    {
                        Microsoft.Xna.Framework.Vector2.Min$1(p1, p2, Bridge.ref(segmentAABB, "LowerBound"));
                        Microsoft.Xna.Framework.Vector2.Max$1(p1, p2, Bridge.ref(segmentAABB, "UpperBound"));
                    }
                    if (!FarseerPhysics.Collision.AABB.TestOverlap(aabb.$clone(), segmentAABB.$clone())) {
                        return false;
                    }

                    var rayDir = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.v.$clone(), p1.v.$clone());
                    var rayPos = p1.v.$clone();

                    var norm = new Microsoft.Xna.Framework.Vector2.$ctor2(-rayDir.Y, rayDir.X);
                    if (norm.Length() === 0.0) {
                        return true;
                    }
                    norm.Normalize();

                    var dPos = Microsoft.Xna.Framework.Vector2.Dot(rayPos.$clone(), norm.$clone());

                    var verts = aabb.GetVertices();
                    var d0 = Microsoft.Xna.Framework.Vector2.Dot(verts[System.Array.index(0, verts)].$clone(), norm.$clone()) - dPos;
                    for (var i = 1; i < 4; i = (i + 1) | 0) {
                        var d = Microsoft.Xna.Framework.Vector2.Dot(verts[System.Array.index(i, verts)].$clone(), norm.$clone()) - dPos;
                        if (Bridge.Int.sign(d) !== Bridge.Int.sign(d0)) {
                            return true;
                        }
                    }

                    return false;
                }
            }
        },
        fields: {
            MaxBucket: 0,
            MaxDepth: 0,
            Nodes: null,
            Span: null,
            SubTrees: null
        },
        props: {
            IsPartitioned: {
                get: function () {
                    return this.SubTrees != null;
                }
            }
        },
        ctors: {
            init: function () {
                this.Span = new FarseerPhysics.Collision.AABB();
            },
            ctor: function (span, maxbucket, maxdepth) {
                this.$initialize();
                this.Span = span.$clone();
                this.Nodes = new (System.Collections.Generic.List$1(Element$1(T))).ctor();

                this.MaxBucket = maxbucket;
                this.MaxDepth = maxdepth;
            }
        },
        methods: {
            /**
             * returns the quadrant of span that entirely contains test. if none, return 0.
             *
             * @instance
             * @private
             * @this QuadTree$1
             * @memberof QuadTree$1
             * @param   {FarseerPhysics.Collision.AABB}    span    
             * @param   {FarseerPhysics.Collision.AABB}    test
             * @return  {number}
             */
            Partition: function (span, test) {
                test = {v:test};
                if (span.Q1.Contains(test)) {
                    return 1;
                }
                if (span.Q2.Contains(test)) {
                    return 2;
                }
                if (span.Q3.Contains(test)) {
                    return 3;
                }
                if (span.Q4.Contains(test)) {
                    return 4;
                }

                return 0;
            },
            AddNode: function (node) {
                var $t;
                if (!this.IsPartitioned) {
                    if (this.Nodes.Count >= this.MaxBucket && this.MaxDepth > 0) {
                        this.Nodes.add(node);

                        this.SubTrees = System.Array.init(4, null, QuadTree$1(T));
                        this.SubTrees[System.Array.index(0, this.SubTrees)] = new (QuadTree$1(T))(this.Span.Q1.$clone(), this.MaxBucket, ((this.MaxDepth - 1) | 0));
                        this.SubTrees[System.Array.index(1, this.SubTrees)] = new (QuadTree$1(T))(this.Span.Q2.$clone(), this.MaxBucket, ((this.MaxDepth - 1) | 0));
                        this.SubTrees[System.Array.index(2, this.SubTrees)] = new (QuadTree$1(T))(this.Span.Q3.$clone(), this.MaxBucket, ((this.MaxDepth - 1) | 0));
                        this.SubTrees[System.Array.index(3, this.SubTrees)] = new (QuadTree$1(T))(this.Span.Q4.$clone(), this.MaxBucket, ((this.MaxDepth - 1) | 0));

                        var remNodes = new (System.Collections.Generic.List$1(Element$1(T))).ctor();

                        $t = Bridge.getEnumerator(this.Nodes);
                        try {
                            while ($t.moveNext()) {
                                var n = $t.Current;
                                switch (this.Partition(this.Span.$clone(), n.Span.$clone())) {
                                    case 1: 
                                        this.SubTrees[System.Array.index(0, this.SubTrees)].AddNode(n);
                                        break;
                                    case 2: 
                                        this.SubTrees[System.Array.index(1, this.SubTrees)].AddNode(n);
                                        break;
                                    case 3: 
                                        this.SubTrees[System.Array.index(2, this.SubTrees)].AddNode(n);
                                        break;
                                    case 4: 
                                        this.SubTrees[System.Array.index(3, this.SubTrees)].AddNode(n);
                                        break;
                                    default: 
                                        n.Parent = this;
                                        remNodes.add(n);
                                        break;
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        this.Nodes = remNodes;
                    } else {
                        node.Parent = this;
                        this.Nodes.add(node);
                    }
                } else {
                    switch (this.Partition(this.Span.$clone(), node.Span.$clone())) {
                        case 1: 
                            this.SubTrees[System.Array.index(0, this.SubTrees)].AddNode(node);
                            break;
                        case 2: 
                            this.SubTrees[System.Array.index(1, this.SubTrees)].AddNode(node);
                            break;
                        case 3: 
                            this.SubTrees[System.Array.index(2, this.SubTrees)].AddNode(node);
                            break;
                        case 4: 
                            this.SubTrees[System.Array.index(3, this.SubTrees)].AddNode(node);
                            break;
                        default: 
                            node.Parent = this;
                            this.Nodes.add(node);
                            break;
                    }
                }
            },
            QueryAABB: function (callback, searchR) {
                var $t, $t1;
                var stack = new (System.Collections.Generic.Stack$1(QuadTree$1(T))).ctor();
                stack.Push(this);

                while (stack.Count > 0) {
                    var qt = stack.Pop();
                    if (!FarseerPhysics.Collision.AABB.TestOverlap$1(searchR, Bridge.ref(qt, "Span"))) {
                        continue;
                    }

                    $t = Bridge.getEnumerator(qt.Nodes);
                    try {
                        while ($t.moveNext()) {
                            var n = $t.Current;
                            if (FarseerPhysics.Collision.AABB.TestOverlap$1(searchR, Bridge.ref(n, "Span"))) {
                                if (!callback(n)) {
                                    return;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    if (qt.IsPartitioned) {
                        $t1 = Bridge.getEnumerator(qt.SubTrees);
                        try {
                            while ($t1.moveNext()) {
                                var st = $t1.Current;
                                stack.Push(st);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }}
                }
            },
            RayCast: function (callback, input) {
                var $t, $t1;
                var stack = new (System.Collections.Generic.Stack$1(QuadTree$1(T))).ctor();
                stack.Push(this);

                var maxFraction = input.v.MaxFraction;
                var p1 = input.v.Point1.$clone();
                var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$1((Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), input.v.Point1.$clone())), maxFraction));

                while (stack.Count > 0) {
                    var qt = stack.Pop();

                    if (!QuadTree$1(T).RayCastAABB(qt.Span.$clone(), p1.$clone(), p2.$clone())) {
                        continue;
                    }

                    $t = Bridge.getEnumerator(qt.Nodes);
                    try {
                        while ($t.moveNext()) {
                            var n = $t.Current;
                            if (!QuadTree$1(T).RayCastAABB(n.Span.$clone(), p1.$clone(), p2.$clone())) {
                                continue;
                            }

                            var subInput = new FarseerPhysics.Collision.RayCastInput();
                            subInput.Point1 = input.v.Point1.$clone();
                            subInput.Point2 = input.v.Point2.$clone();
                            subInput.MaxFraction = maxFraction;

                            var value = callback(subInput.$clone(), n);
                            if (value === 0.0) {
                                return;
                            }

                            if (value <= 0.0) {
                                continue;
                            }

                            maxFraction = value;
                            p2 = Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$1((Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), input.v.Point1.$clone())), maxFraction));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }if (this.IsPartitioned) {
                        $t1 = Bridge.getEnumerator(qt.SubTrees);
                        try {
                            while ($t1.moveNext()) {
                                var st = $t1.Current;
                                stack.Push(st);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }}
                }
            },
            GetAllNodesR: function (nodes) {
                var $t;
                nodes.v.AddRange(this.Nodes);

                if (this.IsPartitioned) {
                    $t = Bridge.getEnumerator(this.SubTrees);
                    try {
                        while ($t.moveNext()) {
                            var st = $t.Current;
                            st.GetAllNodesR(nodes);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}
            },
            RemoveNode: function (node) {
                node.Parent.Nodes.remove(node);
            },
            Reconstruct: function () {
                var allNodes = { v : new (System.Collections.Generic.List$1(Element$1(T))).ctor() };
                this.GetAllNodesR(allNodes);

                this.Clear();

                allNodes.v.ForEach(Bridge.fn.cacheBind(this, this.AddNode));
            },
            Clear: function () {
                this.Nodes.clear();
                this.SubTrees = null;
            }
        }
    }; });

    /**
     * The broad-phase is used for computing pairs and performing volume queries and ray casts.
     This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
     It is up to the client to consume the new pairs and to track subsequent overlap.
     *
     * @public
     * @class FarseerPhysics.Collision.DynamicTreeBroadPhase
     * @implements  FarseerPhysics.Collision.IBroadPhase
     */
    Bridge.define("FarseerPhysics.Collision.DynamicTreeBroadPhase", {
        inherits: [FarseerPhysics.Collision.IBroadPhase],
        fields: {
            _moveBuffer: null,
            _moveCapacity: 0,
            _moveCount: 0,
            _pairBuffer: null,
            _pairCapacity: 0,
            _pairCount: 0,
            _proxyCount: 0,
            _queryCallback: null,
            _queryProxyId: 0,
            _tree: null
        },
        props: {
            /**
             * Get the number of proxies.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @function ProxyCount
             * @type number
             */
            ProxyCount: {
                get: function () {
                    return this._proxyCount;
                }
            }
        },
        alias: [
            "ProxyCount", "FarseerPhysics$Collision$IBroadPhase$ProxyCount",
            "AddProxy", "FarseerPhysics$Collision$IBroadPhase$AddProxy",
            "RemoveProxy", "FarseerPhysics$Collision$IBroadPhase$RemoveProxy",
            "MoveProxy", "FarseerPhysics$Collision$IBroadPhase$MoveProxy",
            "GetFatAABB", "FarseerPhysics$Collision$IBroadPhase$GetFatAABB",
            "GetProxy", "FarseerPhysics$Collision$IBroadPhase$GetProxy",
            "TestOverlap", "FarseerPhysics$Collision$IBroadPhase$TestOverlap",
            "UpdatePairs", "FarseerPhysics$Collision$IBroadPhase$UpdatePairs",
            "Query", "FarseerPhysics$Collision$IBroadPhase$Query",
            "RayCast", "FarseerPhysics$Collision$IBroadPhase$RayCast",
            "TouchProxy", "FarseerPhysics$Collision$IBroadPhase$TouchProxy"
        ],
        ctors: {
            init: function () {
                this._tree = new (FarseerPhysics.Collision.DynamicTree$1(FarseerPhysics.Dynamics.FixtureProxy))();
            },
            ctor: function () {
                this.$initialize();
                this._queryCallback = Bridge.fn.cacheBind(this, this.QueryCallback);

                this._pairCapacity = 16;
                this._pairBuffer = System.Array.init(this._pairCapacity, function (){
                    return new FarseerPhysics.Collision.Pair();
                }, FarseerPhysics.Collision.Pair);

                this._moveCapacity = 16;
                this._moveBuffer = System.Array.init(this._moveCapacity, 0, System.Int32);
            }
        },
        methods: {
            /**
             * Create a proxy with an initial AABB. Pairs are not reported until
             UpdatePairs is called.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {FarseerPhysics.Dynamics.FixtureProxy}    proxy    The user data.
             * @return  {number}
             */
            AddProxy: function (proxy) {
                var proxyId = this._tree.AddProxy(Bridge.ref(proxy.v, "AABB"), proxy.v.$clone());
                this._proxyCount = (this._proxyCount + 1) | 0;
                this.BufferMove(proxyId);
                return proxyId;
            },
            /**
             * Destroy a proxy. It is up to the client to remove any pairs.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {number}    proxyId    The proxy id.
             * @return  {void}
             */
            RemoveProxy: function (proxyId) {
                this.UnBufferMove(proxyId);
                this._proxyCount = (this._proxyCount - 1) | 0;
                this._tree.RemoveProxy(proxyId);
            },
            MoveProxy: function (proxyId, aabb, displacement) {
                var buffer = this._tree.MoveProxy(proxyId, aabb, displacement.$clone());
                if (buffer) {
                    this.BufferMove(proxyId);
                }
            },
            /**
             * Get the AABB for a proxy.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {number}                           proxyId    The proxy id.
             * @param   {FarseerPhysics.Collision.AABB}    aabb       The aabb.
             * @return  {void}
             */
            GetFatAABB: function (proxyId, aabb) {
                this._tree.GetFatAABB(proxyId, aabb);
            },
            /**
             * Get user data from a proxy. Returns null if the id is invalid.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {number}                                  proxyId    The proxy id.
             * @return  {FarseerPhysics.Dynamics.FixtureProxy}
             */
            GetProxy: function (proxyId) {
                return this._tree.GetUserData(proxyId);
            },
            /**
             * Test overlap of fat AABBs.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {number}     proxyIdA    The proxy id A.
             * @param   {number}     proxyIdB    The proxy id B.
             * @return  {boolean}
             */
            TestOverlap: function (proxyIdA, proxyIdB) {
                var aabbA = { v : new FarseerPhysics.Collision.AABB() }, aabbB = { v : new FarseerPhysics.Collision.AABB() };
                this._tree.GetFatAABB(proxyIdA, aabbA);
                this._tree.GetFatAABB(proxyIdB, aabbB);
                return FarseerPhysics.Collision.AABB.TestOverlap$1(aabbA, aabbB);
            },
            /**
             * Update the pairs. This results in pair callbacks. This can only add pairs.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {FarseerPhysics.Dynamics.BroadphaseDelegate}    callback    The callback.
             * @return  {void}
             */
            UpdatePairs: function (callback) {
                this._pairCount = 0;

                for (var j = 0; j < this._moveCount; j = (j + 1) | 0) {
                    this._queryProxyId = this._moveBuffer[System.Array.index(j, this._moveBuffer)];
                    if (this._queryProxyId === -1) {
                        continue;
                    }

                    var fatAABB = { v : new FarseerPhysics.Collision.AABB() };
                    this._tree.GetFatAABB(this._queryProxyId, fatAABB);

                    this._tree.Query(this._queryCallback, fatAABB);
                }

                this._moveCount = 0;

                System.Array.sort(this._pairBuffer, 0, this._pairCount);

                var i = 0;
                while (i < this._pairCount) {
                    var primaryPair = this._pairBuffer[System.Array.index(i, this._pairBuffer)].$clone();
                    var userDataA = { v : this._tree.GetUserData(primaryPair.ProxyIdA).$clone() };
                    var userDataB = { v : this._tree.GetUserData(primaryPair.ProxyIdB).$clone() };

                    callback(userDataA, userDataB);
                    i = (i + 1) | 0;

                    while (i < this._pairCount) {
                        var pair = this._pairBuffer[System.Array.index(i, this._pairBuffer)].$clone();
                        if (pair.ProxyIdA !== primaryPair.ProxyIdA || pair.ProxyIdB !== primaryPair.ProxyIdB) {
                            break;
                        }
                        i = (i + 1) | 0;
                    }
                }

                this._tree.Rebalance(4);
            },
            /**
             * Query an AABB for overlapping proxies. The callback class
             is called for each proxy that overlaps the supplied AABB.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {System.Func}                      callback    The callback.
             * @param   {FarseerPhysics.Collision.AABB}    aabb        The aabb.
             * @return  {void}
             */
            Query: function (callback, aabb) {
                this._tree.Query(callback, aabb);
            },
            /**
             * Ray-cast against the proxies in the tree. This relies on the callback
             to perform a exact ray-cast in the case were the proxy contains a shape.
             The callback also performs the any collision filtering. This has performance
             roughly equal to k * log(n), where k is the number of collisions and n is the
             number of proxies in the tree.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {System.Func}                              callback    A callback class that is called for each proxy that is hit by the ray.
             * @param   {FarseerPhysics.Collision.RayCastInput}    input       The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
             * @return  {void}
             */
            RayCast: function (callback, input) {
                this._tree.RayCast(callback, input);
            },
            TouchProxy: function (proxyId) {
                this.BufferMove(proxyId);
            },
            /**
             * Compute the height of the embedded tree.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @return  {number}
             */
            ComputeHeight: function () {
                return this._tree.ComputeHeight();
            },
            BufferMove: function (proxyId) {
                if (this._moveCount === this._moveCapacity) {
                    var oldBuffer = this._moveBuffer;
                    this._moveCapacity = Bridge.Int.mul(this._moveCapacity, 2);
                    this._moveBuffer = System.Array.init(this._moveCapacity, 0, System.Int32);
                    System.Array.copy(oldBuffer, 0, this._moveBuffer, 0, this._moveCount);
                }

                this._moveBuffer[System.Array.index(this._moveCount, this._moveBuffer)] = proxyId;
                this._moveCount = (this._moveCount + 1) | 0;
            },
            UnBufferMove: function (proxyId) {
                for (var i = 0; i < this._moveCount; i = (i + 1) | 0) {
                    if (this._moveBuffer[System.Array.index(i, this._moveBuffer)] === proxyId) {
                        this._moveBuffer[System.Array.index(i, this._moveBuffer)] = -1;
                        return;
                    }
                }
            },
            QueryCallback: function (proxyId) {
                if (proxyId === this._queryProxyId) {
                    return true;
                }

                if (this._pairCount === this._pairCapacity) {
                    var oldBuffer = this._pairBuffer;
                    this._pairCapacity = Bridge.Int.mul(this._pairCapacity, 2);
                    this._pairBuffer = System.Array.init(this._pairCapacity, function (){
                        return new FarseerPhysics.Collision.Pair();
                    }, FarseerPhysics.Collision.Pair);
                    System.Array.copy(oldBuffer, 0, this._pairBuffer, 0, this._pairCount);
                }

                this._pairBuffer[System.Array.index(this._pairCount, this._pairBuffer)].ProxyIdA = Math.min(proxyId, this._queryProxyId);
                this._pairBuffer[System.Array.index(this._pairCount, this._pairBuffer)].ProxyIdB = Math.max(proxyId, this._queryProxyId);
                this._pairCount = (this._pairCount + 1) | 0;

                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Shapes.CircleShape", {
        inherits: [FarseerPhysics.Collision.Shapes.Shape],
        fields: {
            _position: null
        },
        props: {
            ChildCount: {
                get: function () {
                    return 1;
                }
            },
            Position: {
                get: function () {
                    return this._position.$clone();
                },
                set: function (value) {
                    this._position = value.$clone();
                    this.ComputeProperties();
                }
            }
        },
        ctors: {
            init: function () {
                this._position = new Microsoft.Xna.Framework.Vector2();
            },
            $ctor1: function (radius, density) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, density);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Circle;
                this._radius = radius;
                this._position = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.ComputeProperties();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Circle;
                this._radius = 0.0;
                this._position = Microsoft.Xna.Framework.Vector2.Zero.$clone();
            }
        },
        methods: {
            Clone: function () {
                var shape = new FarseerPhysics.Collision.Shapes.CircleShape.ctor();
                shape._radius = this.Radius;
                shape._density = this._density;
                shape._position = this._position.$clone();
                shape.ShapeType = this.ShapeType;
                shape.MassData = this.MassData.$clone();
                return shape;
            },
            /**
             * Test a point for containment in this shape. This only works for convex shapes.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.CircleShape
             * @memberof FarseerPhysics.Collision.Shapes.CircleShape
             * @param   {FarseerPhysics.Common.Transform}    transform    The shape world transform.
             * @param   {Microsoft.Xna.Framework.Vector2}    point        a point in world coordinates.
             * @return  {boolean}                                         True if the point is inside the shape
             */
            TestPoint: function (transform, point) {
                var center = Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.Position.$clone(), FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(transform.v, "R"), this.Position.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), center.$clone());
                return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), d.$clone()) <= this.Radius * this.Radius;
            },
            /**
             * Cast a ray against a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.CircleShape
             * @memberof FarseerPhysics.Collision.Shapes.CircleShape
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {FarseerPhysics.Common.Transform}           transform     The transform to be applied to the shape.
             * @param   {number}                                    childIndex    The child shape index.
             * @return  {boolean}                                                 True if the ray-cast hits the shape
             */
            RayCast: function (output, input, transform, childIndex) {

                output.v = new FarseerPhysics.Collision.RayCastOutput();

                var position = Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.Position.$clone(), FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(transform.v, "R"), this.Position.$clone()));
                var s = Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(), position.$clone());
                var b = Microsoft.Xna.Framework.Vector2.Dot(s.$clone(), s.$clone()) - this.Radius * this.Radius;

                var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), input.v.Point1.$clone());
                var c = Microsoft.Xna.Framework.Vector2.Dot(s.$clone(), r.$clone());
                var rr = Microsoft.Xna.Framework.Vector2.Dot(r.$clone(), r.$clone());
                var sigma = c * c - rr * b;

                if (sigma < 0.0 || rr < FarseerPhysics.Settings.Epsilon) {
                    return false;
                }

                var a = -(c + Math.sqrt(sigma));

                if (0.0 <= a && a <= input.v.MaxFraction * rr) {
                    a /= rr;
                    output.v.Fraction = a;
                    var norm = (Microsoft.Xna.Framework.Vector2.op_Addition(s.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(a, r.$clone())));
                    norm.Normalize();
                    output.v.Normal = norm.$clone();
                    return true;
                }

                return false;
            },
            /**
             * Given a transform, compute the associated axis aligned bounding box for a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.CircleShape
             * @memberof FarseerPhysics.Collision.Shapes.CircleShape
             * @param   {FarseerPhysics.Collision.AABB}      aabb          The aabb results.
             * @param   {FarseerPhysics.Common.Transform}    transform     The world transform of the shape.
             * @param   {number}                             childIndex    The child shape index.
             * @return  {void}
             */
            ComputeAABB: function (aabb, transform, childIndex) {
                var p = Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.Position.$clone(), FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(transform.v, "R"), this.Position.$clone()));
                aabb.v.LowerBound = new Microsoft.Xna.Framework.Vector2.$ctor2(p.X - this.Radius, p.Y - this.Radius);
                aabb.v.UpperBound = new Microsoft.Xna.Framework.Vector2.$ctor2(p.X + this.Radius, p.Y + this.Radius);
            },
            /**
             * Compute the mass properties of this shape using its dimensions and density.
             The inertia tensor is computed about the local origin, not the centroid.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.CircleShape
             * @memberof FarseerPhysics.Collision.Shapes.CircleShape
             * @return  {void}
             */
            ComputeProperties: function () {
                var area = FarseerPhysics.Settings.Pi * this.Radius * this.Radius;
                this.MassData.Area = area;
                this.MassData.Mass = this.Density * area;
                this.MassData.Centroid = this.Position.$clone();

                this.MassData.Inertia = this.MassData.Mass * (0.5 * this.Radius * this.Radius + Microsoft.Xna.Framework.Vector2.Dot(this.Position.$clone(), this.Position.$clone()));
            },
            CompareTo$1: function (shape) {
                return (this.Radius === shape.Radius && Microsoft.Xna.Framework.Vector2.op_Equality(this.Position.$clone(), shape.Position.$clone()));
            },
            ComputeSubmergedArea: function (normal, offset, xf, sc) {
                xf = {v:xf};
                sc.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                var p = FarseerPhysics.Common.MathUtils.Multiply$2(xf, this.Position.$clone());
                var l = -(Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(), p.$clone()) - offset);
                if (l < -this.Radius + FarseerPhysics.Settings.Epsilon) {
                    return 0;
                }
                if (l > this.Radius) {
                    sc.v = p.$clone();
                    return FarseerPhysics.Settings.Pi * this.Radius * this.Radius;
                }

                var r2 = this.Radius * this.Radius;
                var l2 = l * l;
                var area = r2 * ((Math.asin(l / this.Radius) + 1.57079637) + l * Math.sqrt(r2 - l2));
                var com = -0.6666667 * Math.pow(r2 - l2, 1.5) / area;

                sc.v.X = p.X + normal.X * com;
                sc.v.Y = p.Y + normal.Y * com;

                return area;
            }
        }
    });

    /**
     * A line segment (edge) Shape. These can be connected in chains or loops
     to other edge Shapes. The connectivity information is used to ensure
     correct contact normals.
     *
     * @public
     * @class FarseerPhysics.Collision.Shapes.EdgeShape
     * @augments FarseerPhysics.Collision.Shapes.Shape
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.EdgeShape", {
        inherits: [FarseerPhysics.Collision.Shapes.Shape],
        fields: {
            HasVertex0: false,
            HasVertex3: false,
            /**
             * Optional adjacent vertices. These are used for smooth collision.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @type Microsoft.Xna.Framework.Vector2
             */
            Vertex0: null,
            /**
             * Optional adjacent vertices. These are used for smooth collision.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @type Microsoft.Xna.Framework.Vector2
             */
            Vertex3: null,
            /**
             * Edge start vertex
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @type Microsoft.Xna.Framework.Vector2
             */
            _vertex1: null,
            /**
             * Edge end vertex
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @type Microsoft.Xna.Framework.Vector2
             */
            _vertex2: null
        },
        props: {
            ChildCount: {
                get: function () {
                    return 1;
                }
            },
            /**
             * These are the edge vertices
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @function Vertex1
             * @type Microsoft.Xna.Framework.Vector2
             */
            Vertex1: {
                get: function () {
                    return this._vertex1.$clone();
                },
                set: function (value) {
                    this._vertex1 = value.$clone();
                    this.ComputeProperties();
                }
            },
            /**
             * These are the edge vertices
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @function Vertex2
             * @type Microsoft.Xna.Framework.Vector2
             */
            Vertex2: {
                get: function () {
                    return this._vertex2.$clone();
                },
                set: function (value) {
                    this._vertex2 = value.$clone();
                    this.ComputeProperties();
                }
            }
        },
        ctors: {
            init: function () {
                this.Vertex0 = new Microsoft.Xna.Framework.Vector2();
                this.Vertex3 = new Microsoft.Xna.Framework.Vector2();
                this._vertex1 = new Microsoft.Xna.Framework.Vector2();
                this._vertex2 = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Edge;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
            },
            $ctor1: function (start, end) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Edge;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
                this.Set(start.$clone(), end.$clone());
            }
        },
        methods: {
            /**
             * Set this as an isolated edge.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @param   {Microsoft.Xna.Framework.Vector2}    start    The start.
             * @param   {Microsoft.Xna.Framework.Vector2}    end      The end.
             * @return  {void}
             */
            Set: function (start, end) {
                this._vertex1 = start.$clone();
                this._vertex2 = end.$clone();
                this.HasVertex0 = false;
                this.HasVertex3 = false;

                this.ComputeProperties();
            },
            Clone: function () {
                var edge = new FarseerPhysics.Collision.Shapes.EdgeShape.ctor();
                edge._radius = this._radius;
                edge._density = this._density;
                edge.HasVertex0 = this.HasVertex0;
                edge.HasVertex3 = this.HasVertex3;
                edge.Vertex0 = this.Vertex0.$clone();
                edge._vertex1 = this._vertex1.$clone();
                edge._vertex2 = this._vertex2.$clone();
                edge.Vertex3 = this.Vertex3.$clone();
                edge.MassData = this.MassData.$clone();
                return edge;
            },
            /**
             * Test a point for containment in this shape. This only works for convex shapes.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @param   {FarseerPhysics.Common.Transform}    transform    The shape world transform.
             * @param   {Microsoft.Xna.Framework.Vector2}    point        a point in world coordinates.
             * @return  {boolean}                                         True if the point is inside the shape
             */
            TestPoint: function (transform, point) {
                return false;
            },
            /**
             * Cast a ray against a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {FarseerPhysics.Common.Transform}           transform     The transform to be applied to the shape.
             * @param   {number}                                    childIndex    The child shape index.
             * @return  {boolean}                                                 True if the ray-cast hits the shape
             */
            RayCast: function (output, input, transform, childIndex) {

                output.v = new FarseerPhysics.Collision.RayCastOutput();

                var p1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(), transform.v.Position.$clone()));
                var p2 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), transform.v.Position.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());

                var v1 = this._vertex1.$clone();
                var v2 = this._vertex2.$clone();
                var e = Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone());
                var normal = new Microsoft.Xna.Framework.Vector2.$ctor2(e.Y, -e.X);
                normal.Normalize();

                var numerator = Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), p1.$clone()));
                var denominator = Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(), d.$clone());

                if (denominator === 0.0) {
                    return false;
                }

                var t = numerator / denominator;
                if (t < 0.0 || 1.0 < t) {
                    return false;
                }

                var q = Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(t, d.$clone()));

                var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone());
                var rr = Microsoft.Xna.Framework.Vector2.Dot(r.$clone(), r.$clone());
                if (rr === 0.0) {
                    return false;
                }

                var s = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(q.$clone(), v1.$clone()), r.$clone()) / rr;
                if (s < 0.0 || 1.0 < s) {
                    return false;
                }

                output.v.Fraction = t;
                if (numerator > 0.0) {
                    output.v.Normal = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.$clone());
                } else {
                    output.v.Normal = normal.$clone();
                }
                return true;
            },
            /**
             * Given a transform, compute the associated axis aligned bounding box for a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @param   {FarseerPhysics.Collision.AABB}      aabb          The aabb results.
             * @param   {FarseerPhysics.Common.Transform}    transform     The world transform of the shape.
             * @param   {number}                             childIndex    The child shape index.
             * @return  {void}
             */
            ComputeAABB: function (aabb, transform, childIndex) {
                var v1 = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this._vertex1.$clone());
                var v2 = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this._vertex2.$clone());

                var lower = Microsoft.Xna.Framework.Vector2.Min(v1.$clone(), v2.$clone());
                var upper = Microsoft.Xna.Framework.Vector2.Max(v1.$clone(), v2.$clone());

                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Radius, this.Radius);
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(lower.$clone(), r.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(upper.$clone(), r.$clone());
            },
            /**
             * Compute the mass properties of this shape using its dimensions and density.
             The inertia tensor is computed about the local origin, not the centroid.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @return  {void}
             */
            ComputeProperties: function () {
                this.MassData.Centroid = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(this._vertex1.$clone(), this._vertex2.$clone())));
            },
            ComputeSubmergedArea: function (normal, offset, xf, sc) {
                sc.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return 0;
            },
            CompareTo$1: function (shape) {
                return (this.HasVertex0 === shape.HasVertex0 && this.HasVertex3 === shape.HasVertex3 && Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex0.$clone(), shape.Vertex0.$clone()) && Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex1.$clone(), shape.Vertex1.$clone()) && Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex2.$clone(), shape.Vertex2.$clone()) && Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex3.$clone(), shape.Vertex3.$clone()));
            }
        }
    });

    /**
     * A loop Shape is a free form sequence of line segments that form a circular list.
     The loop may cross upon itself, but this is not recommended for smooth collision.
     The loop has double sided collision, so you can use inside and outside collision.
     Therefore, you may use any winding order.
     *
     * @public
     * @class FarseerPhysics.Collision.Shapes.LoopShape
     * @augments FarseerPhysics.Collision.Shapes.Shape
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.LoopShape", {
        inherits: [FarseerPhysics.Collision.Shapes.Shape],
        statics: {
            fields: {
                _edgeShape: null
            },
            ctors: {
                init: function () {
                    this._edgeShape = new FarseerPhysics.Collision.Shapes.EdgeShape.ctor();
                }
            }
        },
        fields: {
            /**
             * The vertices. These are not owned/freed by the loop Shape.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @type FarseerPhysics.Common.Vertices
             */
            Vertices: null
        },
        props: {
            ChildCount: {
                get: function () {
                    return this.Vertices.Count;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Loop;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
            },
            $ctor1: function (vertices) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Loop;
                this._radius = FarseerPhysics.Settings.PolygonRadius;

                if (FarseerPhysics.Settings.ConserveMemory) {
                    this.Vertices = vertices;
                } else {
                    this.Vertices = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                }
            }
        },
        methods: {
            Clone: function () {
                var loop = new FarseerPhysics.Collision.Shapes.LoopShape.ctor();
                loop._density = this._density;
                loop._radius = this._radius;
                loop.Vertices = this.Vertices;
                loop.MassData = this.MassData.$clone();
                return loop;
            },
            /**
             * Get a child edge.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @param   {FarseerPhysics.Collision.Shapes.EdgeShape}    edge     The edge.
             * @param   {number}                                       index    The index.
             * @return  {void}
             */
            GetChildEdge: function (edge, index) {
                System.Diagnostics.Debug.Assert(2 <= this.Vertices.Count);
                System.Diagnostics.Debug.Assert(0 <= index && index < this.Vertices.Count);
                edge.v.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Edge;
                edge.v._radius = this._radius;
                edge.v.HasVertex0 = true;
                edge.v.HasVertex3 = true;

                var i0 = ((index - 1) | 0) >= 0 ? ((index - 1) | 0) : ((this.Vertices.Count - 1) | 0);
                var i1 = index;
                var i2 = ((index + 1) | 0) < this.Vertices.Count ? ((index + 1) | 0) : 0;
                var i3 = (index + 2) | 0;
                while (i3 >= this.Vertices.Count) {
                    i3 = (i3 - this.Vertices.Count) | 0;
                }

                edge.v.Vertex0 = this.Vertices.getItem(i0).$clone();
                edge.v.Vertex1 = this.Vertices.getItem(i1).$clone();
                edge.v.Vertex2 = this.Vertices.getItem(i2).$clone();
                edge.v.Vertex3 = this.Vertices.getItem(i3).$clone();
            },
            /**
             * Test a point for containment in this shape. This only works for convex shapes.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @param   {FarseerPhysics.Common.Transform}    transform    The shape world transform.
             * @param   {Microsoft.Xna.Framework.Vector2}    point        a point in world coordinates.
             * @return  {boolean}                                         True if the point is inside the shape
             */
            TestPoint: function (transform, point) {
                return false;
            },
            /**
             * Cast a ray against a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {FarseerPhysics.Common.Transform}           transform     The transform to be applied to the shape.
             * @param   {number}                                    childIndex    The child shape index.
             * @return  {boolean}                                                 True if the ray-cast hits the shape
             */
            RayCast: function (output, input, transform, childIndex) {
                System.Diagnostics.Debug.Assert(childIndex < this.Vertices.Count);

                var i1 = childIndex;
                var i2 = (childIndex + 1) | 0;
                if (i2 === this.Vertices.Count) {
                    i2 = 0;
                }

                FarseerPhysics.Collision.Shapes.LoopShape._edgeShape.Vertex1 = this.Vertices.getItem(i1).$clone();
                FarseerPhysics.Collision.Shapes.LoopShape._edgeShape.Vertex2 = this.Vertices.getItem(i2).$clone();

                return FarseerPhysics.Collision.Shapes.LoopShape._edgeShape.RayCast(output, input, transform, 0);
            },
            /**
             * Given a transform, compute the associated axis aligned bounding box for a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @param   {FarseerPhysics.Collision.AABB}      aabb          The aabb results.
             * @param   {FarseerPhysics.Common.Transform}    transform     The world transform of the shape.
             * @param   {number}                             childIndex    The child shape index.
             * @return  {void}
             */
            ComputeAABB: function (aabb, transform, childIndex) {
                System.Diagnostics.Debug.Assert(childIndex < this.Vertices.Count);

                var i1 = childIndex;
                var i2 = (childIndex + 1) | 0;
                if (i2 === this.Vertices.Count) {
                    i2 = 0;
                }

                var v1 = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this.Vertices.getItem(i1).$clone());
                var v2 = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this.Vertices.getItem(i2).$clone());

                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.Min(v1.$clone(), v2.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.Max(v1.$clone(), v2.$clone());
            },
            /**
             * Chains have zero mass.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @return  {void}
             */
            ComputeProperties: function () { },
            ComputeSubmergedArea: function (normal, offset, xf, sc) {
                sc.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return 0;
            }
        }
    });

    /**
     * Represents a simple non-selfintersecting convex polygon.
     If you want to have concave polygons, you will have to use the {@link } or the {@link }
     to decompose the concave polygon into 2 or more convex polygons.
     *
     * @public
     * @class FarseerPhysics.Collision.Shapes.PolygonShape
     * @augments FarseerPhysics.Collision.Shapes.Shape
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.PolygonShape", {
        inherits: [FarseerPhysics.Collision.Shapes.Shape],
        fields: {
            Normals: null,
            Vertices: null
        },
        props: {
            ChildCount: {
                get: function () {
                    return 1;
                }
            }
        },
        ctors: {
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
             * @param   {number}                            density     The density.
             * @return  {void}
             */
            $ctor1: function (vertices, density) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, density);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Polygon;
                this._radius = FarseerPhysics.Settings.PolygonRadius;

                this.Set(vertices);
            },
            $ctor2: function (density) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, density);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Polygon;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
                this.Normals = new FarseerPhysics.Common.Vertices.ctor();
                this.Vertices = new FarseerPhysics.Common.Vertices.ctor();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Polygon;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
                this.Normals = new FarseerPhysics.Common.Vertices.ctor();
                this.Vertices = new FarseerPhysics.Common.Vertices.ctor();
            }
        },
        methods: {
            Clone: function () {
                var clone = new FarseerPhysics.Collision.Shapes.PolygonShape.ctor();
                clone.ShapeType = this.ShapeType;
                clone._radius = this._radius;
                clone._density = this._density;

                if (FarseerPhysics.Settings.ConserveMemory) {
                    clone.Vertices = this.Vertices;
                    clone.Normals = this.Normals;
                } else {
                    clone.Vertices = new FarseerPhysics.Common.Vertices.$ctor2(this.Vertices);
                    clone.Normals = new FarseerPhysics.Common.Vertices.$ctor2(this.Normals);
                }

                clone.MassData = this.MassData.$clone();
                return clone;
            },
            /**
             * Copy vertices. This assumes the vertices define a convex polygon.
             It is assumed that the exterior is the the right of each edge.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
             * @return  {void}
             */
            Set: function (vertices) {
                System.Diagnostics.Debug.Assert(vertices.Count >= 3 && vertices.Count <= FarseerPhysics.Settings.MaxPolygonVertices);

                if (FarseerPhysics.Settings.ConserveMemory) {
                    this.Vertices = vertices;
                } else {
                    this.Vertices = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                }

                this.Normals = new FarseerPhysics.Common.Vertices.$ctor3(vertices.Count);

                for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                    var i1 = i;
                    var i2 = ((i + 1) | 0) < vertices.Count ? ((i + 1) | 0) : 0;
                    var edge = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(i2).$clone(), this.Vertices.getItem(i1).$clone());
                    System.Diagnostics.Debug.Assert(edge.LengthSquared() > 1.42108547E-14);

                    var temp = new Microsoft.Xna.Framework.Vector2.$ctor2(edge.Y, -edge.X);
                    temp.Normalize();
                    this.Normals.add(temp.$clone());
                }

                for (var i3 = 0; i3 < this.Vertices.Count; i3 = (i3 + 1) | 0) {
                    var i11 = i3;
                    var i21 = ((i3 + 1) | 0) < this.Vertices.Count ? ((i3 + 1) | 0) : 0;
                    var edge1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(i21).$clone(), this.Vertices.getItem(i11).$clone());

                    for (var j = 0; j < vertices.Count; j = (j + 1) | 0) {
                        if (j === i11 || j === i21) {
                            continue;
                        }

                        var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(j).$clone(), this.Vertices.getItem(i11).$clone());

                        var s = edge1.X * r.Y - edge1.Y * r.X;

                        System.Diagnostics.Debug.Assert(s > 0.0);
                    }
                }

                this.ComputeProperties();
            },
            /**
             * Compute the mass properties of this shape using its dimensions and density.
             The inertia tensor is computed about the local origin, not the centroid.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @return  {void}
             */
            ComputeProperties: function () {

                System.Diagnostics.Debug.Assert(this.Vertices.Count >= 3);

                if (this._density <= 0) {
                    return;
                }

                var center = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var area = 0.0;
                var I = 0.0;

                var pRef = Microsoft.Xna.Framework.Vector2.Zero.$clone();


                var inv3 = 0.333333343;

                for (var i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var p1 = pRef.$clone();
                    var p2 = this.Vertices.getItem(i).$clone();
                    var p3 = ((i + 1) | 0) < this.Vertices.Count ? this.Vertices.getItem(((i + 1) | 0)).$clone() : this.Vertices.getItem(0).$clone();

                    var e1 = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone()) };
                    var e2 = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(p3.$clone(), p1.$clone()) };

                    var d = { };
                    FarseerPhysics.Common.MathUtils.Cross$3(e1, e2, d);

                    var triangleArea = 0.5 * d.v;
                    area += triangleArea;

                    center = Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea * inv3, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), p2.$clone()), p3.$clone()))));

                    var px = p1.X, py = p1.Y;
                    var ex1 = e1.v.X, ey1 = e1.v.Y;
                    var ex2 = e2.v.X, ey2 = e2.v.Y;

                    var intx2 = inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
                    var inty2 = inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;

                    I += d.v * (intx2 + inty2);
                }

                System.Diagnostics.Debug.Assert(area > FarseerPhysics.Settings.Epsilon);

                this.MassData.Area = area;

                this.MassData.Mass = this._density * area;

                center = Microsoft.Xna.Framework.Vector2.op_Multiply$1(center.$clone(), 1.0 / area);
                this.MassData.Centroid = center.$clone();

                this.MassData.Inertia = this._density * I;
            },
            /**
             * Build vertices to represent an axis-aligned box.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {number}    halfWidth     The half-width.
             * @param   {number}    halfHeight    The half-height.
             * @return  {void}
             */
            SetAsBox: function (halfWidth, halfHeight) {
                this.Set(FarseerPhysics.Common.PolygonTools.CreateRectangle(halfWidth, halfHeight));
            },
            /**
             * Build vertices to represent an oriented box.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {number}                             halfWidth     The half-width..
             * @param   {number}                             halfHeight    The half-height.
             * @param   {Microsoft.Xna.Framework.Vector2}    center        The center of the box in local coordinates.
             * @param   {number}                             angle         The rotation of the box in local coordinates.
             * @return  {void}
             */
            SetAsBox$1: function (halfWidth, halfHeight, center, angle) {
                this.Set(FarseerPhysics.Common.PolygonTools.CreateRectangle$1(halfWidth, halfHeight, center.$clone(), angle));
            },
            /**
             * Test a point for containment in this shape. This only works for convex shapes.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Common.Transform}    transform    The shape world transform.
             * @param   {Microsoft.Xna.Framework.Vector2}    point        a point in world coordinates.
             * @return  {boolean}                                         True if the point is inside the shape
             */
            TestPoint: function (transform, point) {
                var pLocal = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), transform.v.Position.$clone()));

                for (var i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var dot = Microsoft.Xna.Framework.Vector2.Dot(this.Normals.getItem(i).$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(pLocal.$clone(), this.Vertices.getItem(i).$clone()));
                    if (dot > 0.0) {
                        return false;
                    }
                }

                return true;
            },
            /**
             * Cast a ray against a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {FarseerPhysics.Common.Transform}           transform     The transform to be applied to the shape.
             * @param   {number}                                    childIndex    The child shape index.
             * @return  {boolean}                                                 True if the ray-cast hits the shape
             */
            RayCast: function (output, input, transform, childIndex) {
                output.v = new FarseerPhysics.Collision.RayCastOutput();

                var p1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(), transform.v.Position.$clone()));
                var p2 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), transform.v.Position.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());

                var lower = 0.0, upper = input.v.MaxFraction;

                var index = -1;

                for (var i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var numerator = Microsoft.Xna.Framework.Vector2.Dot(this.Normals.getItem(i).$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(i).$clone(), p1.$clone()));
                    var denominator = Microsoft.Xna.Framework.Vector2.Dot(this.Normals.getItem(i).$clone(), d.$clone());

                    if (denominator === 0.0) {
                        if (numerator < 0.0) {
                            return false;
                        }
                    } else {
                        if (denominator < 0.0 && numerator < lower * denominator) {
                            lower = numerator / denominator;
                            index = i;
                        } else if (denominator > 0.0 && numerator < upper * denominator) {
                            upper = numerator / denominator;
                        }
                    }

                    if (upper < lower) {
                        return false;
                    }
                }

                System.Diagnostics.Debug.Assert(0.0 <= lower && lower <= input.v.MaxFraction);

                if (index >= 0) {
                    output.v.Fraction = lower;
                    output.v.Normal = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(transform.v, "R"), this.Normals.getItem(index).$clone());
                    return true;
                }

                return false;
            },
            /**
             * Given a transform, compute the associated axis aligned bounding box for a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Collision.AABB}      aabb          The aabb results.
             * @param   {FarseerPhysics.Common.Transform}    transform     The world transform of the shape.
             * @param   {number}                             childIndex    The child shape index.
             * @return  {void}
             */
            ComputeAABB: function (aabb, transform, childIndex) {
                var lower = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this.Vertices.getItem(0).$clone());
                var upper = lower.$clone();

                for (var i = 1; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var v = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this.Vertices.getItem(i).$clone());
                    lower = Microsoft.Xna.Framework.Vector2.Min(lower.$clone(), v.$clone());
                    upper = Microsoft.Xna.Framework.Vector2.Max(upper.$clone(), v.$clone());
                }

                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Radius, this.Radius);
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(lower.$clone(), r.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(upper.$clone(), r.$clone());
            },
            CompareTo$1: function (shape) {
                if (this.Vertices.Count !== shape.Vertices.Count) {
                    return false;
                }

                for (var i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    if (Microsoft.Xna.Framework.Vector2.op_Inequality(this.Vertices.getItem(i).$clone(), shape.Vertices.getItem(i).$clone())) {
                        return false;
                    }
                }

                return (this.Radius === shape.Radius && FarseerPhysics.Collision.Shapes.MassData.op_Equality(this.MassData.$clone(), shape.MassData.$clone()));
            },
            ComputeSubmergedArea: function (normal, offset, xf, sc) {
                xf = {v:xf};
                sc.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                var normalL = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xf.v, "R"), normal.$clone());
                var offsetL = offset - Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(), xf.v.Position.$clone());

                var depths = System.Array.init(FarseerPhysics.Settings.MaxPolygonVertices, 0, System.Single);
                var diveCount = 0;
                var intoIndex = -1;
                var outoIndex = -1;

                var lastSubmerged = false;
                var i;
                for (i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    depths[System.Array.index(i, depths)] = Microsoft.Xna.Framework.Vector2.Dot(normalL.$clone(), this.Vertices.getItem(i).$clone()) - offsetL;
                    var isSubmerged = depths[System.Array.index(i, depths)] < -1.1920929E-07;
                    if (i > 0) {
                        if (isSubmerged) {
                            if (!lastSubmerged) {
                                intoIndex = (i - 1) | 0;
                                diveCount = (diveCount + 1) | 0;
                            }
                        } else {
                            if (lastSubmerged) {
                                outoIndex = (i - 1) | 0;
                                diveCount = (diveCount + 1) | 0;
                            }
                        }
                    }
                    lastSubmerged = isSubmerged;
                }
                switch (diveCount) {
                    case 0: 
                        if (lastSubmerged) {
                            sc.v = FarseerPhysics.Common.MathUtils.Multiply$2(xf, this.MassData.Centroid.$clone());
                            return this.MassData.Mass / this.Density;
                        } else {
                            return 0;
                        }
                        break;
                    case 1: 
                        if (intoIndex === -1) {
                            intoIndex = (this.Vertices.Count - 1) | 0;
                        } else {
                            outoIndex = (this.Vertices.Count - 1) | 0;
                        }
                        break;
                }
                var intoIndex2 = (((intoIndex + 1) | 0)) % this.Vertices.Count;
                var outoIndex2 = (((outoIndex + 1) | 0)) % this.Vertices.Count;

                var intoLambda = (0 - depths[System.Array.index(intoIndex, depths)]) / (depths[System.Array.index(intoIndex2, depths)] - depths[System.Array.index(intoIndex, depths)]);
                var outoLambda = (0 - depths[System.Array.index(outoIndex, depths)]) / (depths[System.Array.index(outoIndex2, depths)] - depths[System.Array.index(outoIndex, depths)]);

                var intoVec = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Vertices.getItem(intoIndex).$clone().X * (1 - intoLambda) + this.Vertices.getItem(intoIndex2).$clone().X * intoLambda, this.Vertices.getItem(intoIndex).$clone().Y * (1 - intoLambda) + this.Vertices.getItem(intoIndex2).$clone().Y * intoLambda);
                var outoVec = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Vertices.getItem(outoIndex).$clone().X * (1 - outoLambda) + this.Vertices.getItem(outoIndex2).$clone().X * outoLambda, this.Vertices.getItem(outoIndex).$clone().Y * (1 - outoLambda) + this.Vertices.getItem(outoIndex2).$clone().Y * outoLambda);

                var area = 0;
                var center = new Microsoft.Xna.Framework.Vector2.$ctor2(0, 0);
                var p2 = this.Vertices.getItem(intoIndex2).$clone();
                var p3 = new Microsoft.Xna.Framework.Vector2();

                var k_inv3 = 0.333333343;

                i = intoIndex2;
                while (i !== outoIndex2) {
                    i = (((i + 1) | 0)) % this.Vertices.Count;
                    if (i === outoIndex2) {
                        p3 = outoVec.$clone();
                    } else {
                        p3 = this.Vertices.getItem(i).$clone();
                    }
                    {
                        var e1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), intoVec.$clone());
                        var e2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p3.$clone(), intoVec.$clone());

                        var D = FarseerPhysics.Common.MathUtils.Cross$2(e1.$clone(), e2.$clone());

                        var triangleArea = 0.5 * D;

                        area += triangleArea;

                        center = Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea * k_inv3, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(intoVec.$clone(), p2.$clone()), p3.$clone()))));
                    }
                    p2 = p3.$clone();
                }

                center = Microsoft.Xna.Framework.Vector2.op_Multiply$1(center.$clone(), 1.0 / area);

                sc.v = FarseerPhysics.Common.MathUtils.Multiply$2(xf, center.$clone());

                return area;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Sink", {
        inherits: [FarseerPhysics.Common.Decomposition.Node],
        statics: {
            methods: {
                Isink: function (trapezoid) {
                    if (trapezoid.Sink == null) {
                        return new FarseerPhysics.Common.Decomposition.Sink(trapezoid);
                    }
                    return trapezoid.Sink;
                }
            }
        },
        fields: {
            Trapezoid: null
        },
        ctors: {
            ctor: function (trapezoid) {
                this.$initialize();
                FarseerPhysics.Common.Decomposition.Node.ctor.call(this, null, null);
                this.Trapezoid = trapezoid;
                trapezoid.Sink = this;
            }
        },
        methods: {
            Locate: function (edge) {
                return this;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.XNode", {
        inherits: [FarseerPhysics.Common.Decomposition.Node],
        fields: {
            _point: null
        },
        ctors: {
            ctor: function (point, lChild, rChild) {
                this.$initialize();
                FarseerPhysics.Common.Decomposition.Node.ctor.call(this, lChild, rChild);
                this._point = point;
            }
        },
        methods: {
            Locate: function (edge) {
                if (edge.P.X >= this._point.X) {
                    return this.RightChild.Locate(edge);
                }
                return this.LeftChild.Locate(edge);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.YNode", {
        inherits: [FarseerPhysics.Common.Decomposition.Node],
        fields: {
            _edge: null
        },
        ctors: {
            ctor: function (edge, lChild, rChild) {
                this.$initialize();
                FarseerPhysics.Common.Decomposition.Node.ctor.call(this, lChild, rChild);
                this._edge = edge;
            }
        },
        methods: {
            Locate: function (edge) {
                if (this._edge.IsAbove(edge.P)) {
                    return this.RightChild.Locate(edge);
                }

                if (this._edge.IsBelow(edge.P)) {
                    return this.LeftChild.Locate(edge);
                }

                if (edge.Slope < this._edge.Slope) {
                    return this.RightChild.Locate(edge);
                }

                return this.LeftChild.Locate(edge);
            }
        }
    });

    /**
     * Detected vertices of a single polygon.
     *
     * @public
     * @class FarseerPhysics.Common.DetectedVertices
     * @augments FarseerPhysics.Common.Vertices
     */
    Bridge.define("FarseerPhysics.Common.DetectedVertices", {
        inherits: [FarseerPhysics.Common.Vertices],
        fields: {
            _holes: null
        },
        props: {
            Holes: {
                get: function () {
                    return this._holes;
                },
                set: function (value) {
                    this._holes = value;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Common.Vertices.ctor.call(this);
            },
            $ctor1: function (vertices) {
                this.$initialize();
                FarseerPhysics.Common.Vertices.$ctor2.call(this, vertices);
            }
        },
        methods: {
            Transform: function (transform) {
                transform = {v:transform};
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    this.setItem(i, Microsoft.Xna.Framework.Vector2.Transform(this.getItem(i).$clone(), transform.v.$clone()));
                }

                var temp = null;
                if (this._holes != null && this._holes.Count > 0) {
                    for (var i1 = 0; i1 < this._holes.Count; i1 = (i1 + 1) | 0) {
                        temp = this._holes.getItem(i1).ToArray();
                        Microsoft.Xna.Framework.Vector2.Transform$4(temp, transform, temp);

                        this._holes.setItem(i1, new FarseerPhysics.Common.Vertices.$ctor1(temp));
                    }
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PhysicsLogic.PhysicsLogic", {
        inherits: [FarseerPhysics.Dynamics.FilterData],
        fields: {
            _type: 0,
            World: null
        },
        ctors: {
            ctor: function (world, type) {
                this.$initialize();
                FarseerPhysics.Dynamics.FilterData.ctor.call(this);
                this._type = type;
                this.World = world;
            }
        },
        methods: {
            IsActiveOn: function (body) {
                if (body.PhysicsLogicFilter.IsPhysicsLogicIgnored(this._type)) {
                    return false;
                }

                return FarseerPhysics.Dynamics.FilterData.prototype.IsActiveOn.call(this, body);
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.Controller", {
        inherits: [FarseerPhysics.Dynamics.FilterData],
        fields: {
            Enabled: false,
            World: null,
            _type: 0
        },
        ctors: {
            ctor: function (controllerType) {
                this.$initialize();
                FarseerPhysics.Dynamics.FilterData.ctor.call(this);
                this._type = controllerType;
            }
        },
        methods: {
            IsActiveOn: function (body) {
                if (body.ControllerFilter.IsControllerIgnored(this._type)) {
                    return false;
                }

                return FarseerPhysics.Dynamics.FilterData.prototype.IsActiveOn.call(this, body);
            }
        }
    });

    /**
     * Maintains a fixed angle between two bodies
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.AngleJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.AngleJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            BiasFactor: 0,
            MaxImpulse: 0,
            Softness: 0,
            _bias: 0,
            _jointError: 0,
            _massFactor: 0,
            _targetAngle: 0
        },
        props: {
            TargetAngle: {
                get: function () {
                    return this._targetAngle;
                },
                set: function (value) {
                    if (value !== this._targetAngle) {
                        this._targetAngle = value;
                        this.WakeBodies();
                    }
                }
            },
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.Position.$clone();
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.Position.$clone();
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Angle;
            },
            $ctor1: function (bodyA, bodyB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Angle;
                this.TargetAngle = 0;
                this.BiasFactor = 0.2;
                this.Softness = 0.0;
                this.MaxImpulse = 3.40282347E+38;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.Zero.$clone();
            },
            GetReactionTorque: function (inv_dt) {
                return 0;
            },
            InitVelocityConstraints: function (step) {
                this._jointError = (this.BodyB.Sweep.A - this.BodyA.Sweep.A - this.TargetAngle);

                this._bias = -this.BiasFactor * step.v.inv_dt * this._jointError;

                this._massFactor = (1 - this.Softness) / (this.BodyA.InvI + this.BodyB.InvI);
            },
            SolveVelocityConstraints: function (step) {
                var $t, $t1;
                var p = (this._bias - this.BodyB.AngularVelocity + this.BodyA.AngularVelocity) * this._massFactor;
                $t = this.BodyA;
                $t.AngularVelocity -= this.BodyA.InvI * Bridge.Int.sign(p) * Math.min(Math.abs(p), this.MaxImpulse);
                $t1 = this.BodyB;
                $t1.AngularVelocity += this.BodyB.InvI * Bridge.Int.sign(p) * Math.min(Math.abs(p), this.MaxImpulse);
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    /**
     * A distance joint rains two points on two bodies
     to remain at a fixed distance from each other. You can view
     this as a massless, rigid rod.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.DistanceJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.DistanceJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            /**
             * The local anchor point relative to bodyA's origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalAnchorA: null,
            /**
             * The local anchor point relative to bodyB's origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalAnchorB: null,
            _bias: 0,
            _gamma: 0,
            _impulse: 0,
            _mass: 0,
            _tmpFloat1: 0,
            _tmpVector1: null,
            _u: null,
            /**
             * The natural length between the anchor points.
             Manipulating the length can lead to non-physical behavior when the frequency is zero.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @function Length
             * @type number
             */
            Length: 0,
            /**
             * The mass-spring-damper frequency in Hertz.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @function Frequency
             * @type number
             */
            Frequency: 0,
            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @function DampingRatio
             * @type number
             */
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._tmpVector1 = new Microsoft.Xna.Framework.Vector2();
                this._u = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Distance;
            },
            /**
             * This requires defining an
             anchor point on both bodies and the non-zero length of the
             distance joint. If you don't supply a length, the local anchor points
             is used so that the initial configuration can violate the constraint
             slightly. This helps when saving and loading a game.
             @warning Do not use a zero or short length.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second body anchor
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Distance;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.WorldAnchorB.$clone(), this.WorldAnchorA.$clone());
                this.Length = d.Length();
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var F = Microsoft.Xna.Framework.Vector2.op_Multiply$2((inv_dt * this._impulse), this._u.$clone());
                return F.$clone();
            },
            GetReactionTorque: function (inv_dt) {
                return 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b1.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b2.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };
                this._u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.v.$clone()), b1.Sweep.C.$clone()), r1.v.$clone());

                var length = this._u.Length();
                if (length > FarseerPhysics.Settings.LinearSlop) {
                    this._u = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(), 1.0 / length);
                } else {
                    this._u = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                var cr1u = { }, cr2u = { };
                FarseerPhysics.Common.MathUtils.Cross$3(r1, Bridge.ref(this, "_u"), cr1u);
                FarseerPhysics.Common.MathUtils.Cross$3(r2, Bridge.ref(this, "_u"), cr2u);
                var invMass = b1.InvMass + b1.InvI * cr1u.v * cr1u.v + b2.InvMass + b2.InvI * cr2u.v * cr2u.v;
                System.Diagnostics.Debug.Assert(invMass > FarseerPhysics.Settings.Epsilon);
                this._mass = invMass !== 0.0 ? 1.0 / invMass : 0.0;

                if (this.Frequency > 0.0) {
                    var C = length - this.Length;

                    var omega = 6.28318548 * this.Frequency;

                    var d = 2.0 * this._mass * this.DampingRatio * omega;

                    var k = this._mass * omega * omega;

                    this._gamma = step.v.dt * (d + step.v.dt * k);
                    this._gamma = this._gamma !== 0.0 ? 1.0 / this._gamma : 0.0;
                    this._bias = C * step.v.dt * k * this._gamma;

                    this._mass = invMass + this._gamma;
                    this._mass = this._mass !== 0.0 ? 1.0 / this._mass : 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;

                    var P = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u.$clone()) };
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                    b1.AngularVelocityInternal -= b1.InvI * this._tmpFloat1;
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                    b2.AngularVelocityInternal += b2.InvI * this._tmpFloat1;
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };

                FarseerPhysics.Common.MathUtils.Cross$4(b1.AngularVelocityInternal, r1, Bridge.ref(this, "_tmpVector1"));
                var v1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), this._tmpVector1.$clone());
                FarseerPhysics.Common.MathUtils.Cross$4(b2.AngularVelocityInternal, r2, Bridge.ref(this, "_tmpVector1"));
                var v2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), this._tmpVector1.$clone());
                var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone()));

                var impulse = -this._mass * (Cdot + this._bias + this._gamma * this._impulse);
                this._impulse += impulse;

                var P = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone()) };
                b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.v.$clone()));
                FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                b1.AngularVelocityInternal -= b1.InvI * this._tmpFloat1;
                b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.v.$clone()));
                FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                b2.AngularVelocityInternal += b2.InvI * this._tmpFloat1;
            },
            SolvePositionConstraints: function () {
                if (this.Frequency > 0.0) {
                    return true;
                }

                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.v.$clone()), b1.Sweep.C.$clone()), r1.v.$clone());

                var length = d.Length();

                if (length === 0.0) {
                    return true;
                }

                d = Microsoft.Xna.Framework.Vector2.op_Division$1(d.$clone(), length);
                var C = length - this.Length;
                C = FarseerPhysics.Common.MathUtils.Clamp$2(C, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);

                var impulse = -this._mass * C;
                this._u = d.$clone();
                var P = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone()) };

                b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.v.$clone()));
                FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                b1.Sweep.A -= b1.InvI * this._tmpFloat1;
                b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.v.$clone()));
                FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                b2.Sweep.A += b2.InvI * this._tmpFloat1;

                b1.SynchronizeTransform();
                b2.SynchronizeTransform();

                return Math.abs(C) < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedAngleJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            BiasFactor: 0,
            MaxImpulse: 0,
            Softness: 0,
            _bias: 0,
            _jointError: 0,
            _massFactor: 0,
            _targetAngle: 0
        },
        props: {
            TargetAngle: {
                get: function () {
                    return this._targetAngle;
                },
                set: function (value) {
                    if (value !== this._targetAngle) {
                        this._targetAngle = value;
                        this.WakeBodies();
                    }
                }
            },
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.Position.$clone();
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyA.Position.$clone();
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            ctor: function (bodyA) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, bodyA);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedAngle;
                this.TargetAngle = 0;
                this.BiasFactor = 0.2;
                this.Softness = 0.0;
                this.MaxImpulse = 3.40282347E+38;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.Zero.$clone();
            },
            GetReactionTorque: function (inv_dt) {
                return 0;
            },
            InitVelocityConstraints: function (step) {
                this._jointError = this.BodyA.Sweep.A - this.TargetAngle;

                this._bias = -this.BiasFactor * step.v.inv_dt * this._jointError;

                this._massFactor = (1 - this.Softness) / (this.BodyA.InvI);
            },
            SolveVelocityConstraints: function (step) {
                var $t;
                var p = (this._bias - this.BodyA.AngularVelocity) * this._massFactor;
                $t = this.BodyA;
                $t.AngularVelocity += this.BodyA.InvI * Bridge.Int.sign(p) * Math.min(Math.abs(p), this.MaxImpulse);
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    /**
     * A distance joint rains two points on two bodies
     to remain at a fixed distance from each other. You can view
     this as a massless, rigid rod.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedDistanceJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            /**
             * The local anchor point relative to bodyA's origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalAnchorA: null,
            _bias: 0,
            _gamma: 0,
            _impulse: 0,
            _mass: 0,
            _u: null,
            _worldAnchorB: null,
            /**
             * The natural length between the anchor points.
             Manipulating the length can lead to non-physical behavior when the frequency is zero.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @function Length
             * @type number
             */
            Length: 0,
            /**
             * The mass-spring-damper frequency in Hertz.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @function Frequency
             * @type number
             */
            Frequency: 0,
            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @function DampingRatio
             * @type number
             */
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this._worldAnchorB.$clone();
                },
                set: function (value) {
                    this._worldAnchorB = value.$clone();
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this._u = new Microsoft.Xna.Framework.Vector2();
                this._worldAnchorB = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * This requires defining an
             anchor point on both bodies and the non-zero length of the
             distance joint. If you don't supply a length, the local anchor points
             is used so that the initial configuration can violate the constraint
             slightly. This helps when saving and loading a game.
             @warning Do not use a zero or short length.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @param   {FarseerPhysics.Dynamics.Body}       body           The body.
             * @param   {Microsoft.Xna.Framework.Vector2}    bodyAnchor     The body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    worldAnchor    The world anchor.
             * @return  {void}
             */
            ctor: function (body, bodyAnchor, worldAnchor) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedDistance;

                this.LocalAnchorA = bodyAnchor.$clone();
                this._worldAnchorB = worldAnchor.$clone();

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.WorldAnchorB.$clone(), this.WorldAnchorA.$clone());
                this.Length = d.Length();
            }
        },
        methods: {
            GetReactionForce: function (invDt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2((invDt * this._impulse), this._u.$clone());
            },
            GetReactionTorque: function (invDt) {
                return 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = this._worldAnchorB.$clone();
                this._u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(r2.$clone(), b1.Sweep.C.$clone()), r1.$clone());

                var length = this._u.Length();
                if (length > FarseerPhysics.Settings.LinearSlop) {
                    this._u = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(), 1.0 / length);
                } else {
                    this._u = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                var cr1u = FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), this._u.$clone());
                var cr2u = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._u.$clone());
                var invMass = b1.InvMass + b1.InvI * cr1u * cr1u + 0 * cr2u * cr2u;
                System.Diagnostics.Debug.Assert(invMass > FarseerPhysics.Settings.Epsilon);
                this._mass = invMass !== 0.0 ? 1.0 / invMass : 0.0;

                if (this.Frequency > 0.0) {
                    var C = length - this.Length;

                    var omega = 6.28318548 * this.Frequency;

                    var d = 2.0 * this._mass * this.DampingRatio * omega;

                    var k = this._mass * omega * omega;

                    this._gamma = step.v.dt * (d + step.v.dt * k);
                    this._gamma = this._gamma !== 0.0 ? 1.0 / this._gamma : 0.0;
                    this._bias = C * step.v.dt * k * this._gamma;

                    this._mass = invMass + this._gamma;
                    this._mass = this._mass !== 0.0 ? 1.0 / this._mass : 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                    b1.AngularVelocityInternal -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));

                var v1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b1.AngularVelocityInternal, r1.$clone()));
                var v2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone()));

                var impulse = -this._mass * (Cdot + this._bias + this._gamma * this._impulse);
                this._impulse += impulse;

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());
                b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                b1.AngularVelocityInternal -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
            },
            SolvePositionConstraints: function () {
                if (this.Frequency > 0.0) {
                    return true;
                }

                var b1 = this.BodyA;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = this._worldAnchorB.$clone();

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(r2.$clone(), b1.Sweep.C.$clone()), r1.$clone());

                var length = d.Length();

                if (length === 0.0) {
                    return true;
                }

                d = Microsoft.Xna.Framework.Vector2.op_Division$1(d.$clone(), length);
                var C = length - this.Length;
                C = FarseerPhysics.Common.MathUtils.Clamp$2(C, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);

                var impulse = -this._mass * C;
                this._u = d.$clone();
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());

                b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                b1.Sweep.A -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());

                b1.SynchronizeTransform();

                return Math.abs(C) < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    /**
     * Friction joint. This is used for top-down friction.
     It provides 2D translational friction and angular friction.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedFrictionJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedFrictionJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            /**
             * The maximum friction force in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedFrictionJoint
             * @type number
             */
            MaxForce: 0,
            /**
             * The maximum friction torque in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedFrictionJoint
             * @type number
             */
            MaxTorque: 0,
            _angularImpulse: 0,
            _angularMass: 0,
            _linearImpulse: null,
            _linearMass: null
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this._linearImpulse = new Microsoft.Xna.Framework.Vector2();
                this._linearMass = new FarseerPhysics.Common.Mat22();
            },
            ctor: function (body, localAnchorA) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedFriction;
                this.LocalAnchorA = localAnchorA.$clone();

                var gravity = 10.0;

                var radius = Math.sqrt(2.0 * (body.Inertia / body.Mass));

                this.MaxForce = body.Mass * gravity;
                this.MaxTorque = body.Mass * radius * gravity;
            }
        },
        methods: {
            GetReactionForce: function (invDT) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDT, this._linearImpulse.$clone());
            },
            GetReactionTorque: function (invDT) {
                return invDT * this._angularImpulse;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;

                var xfA = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));



                var mA = bA.InvMass;
                var iA = bA.InvI;

                var K1 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K1.v.Col1.X = mA;
                K1.v.Col2.X = 0.0;
                K1.v.Col1.Y = 0.0;
                K1.v.Col2.Y = mA;

                var K2 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K2.v.Col1.X = iA * rA.Y * rA.Y;
                K2.v.Col2.X = -iA * rA.X * rA.Y;
                K2.v.Col1.Y = -iA * rA.X * rA.Y;
                K2.v.Col2.Y = iA * rA.X * rA.X;

                var K12 = { v : new FarseerPhysics.Common.Mat22() };
                FarseerPhysics.Common.Mat22.Add(K1, K2, K12);

                this._linearMass = K12.v.Inverse.$clone();

                this._angularMass = iA;
                if (this._angularMass > 0.0) {
                    this._angularMass = 1.0 / this._angularMass;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(), step.v.dtRatio);
                    this._angularImpulse *= step.v.dtRatio;

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._linearImpulse.X, this._linearImpulse.Y);

                    bA.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                    bA.AngularVelocityInternal -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + this._angularImpulse);
                } else {
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    this._angularImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;

                var vA = bA.LinearVelocityInternal.$clone();
                var wA = bA.AngularVelocityInternal;

                var mA = bA.InvMass;
                var iA = bA.InvI;

                var xfA = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));

                {
                    var Cdot = -wA;
                    var impulse = -this._angularMass * Cdot;

                    var oldImpulse = this._angularImpulse;
                    var maxImpulse = step.v.dt * this.MaxTorque;
                    this._angularImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._angularImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._angularImpulse - oldImpulse;

                    wA -= iA * impulse;
                }

                {
                    var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(vA.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(wA, rA.$clone()));

                    var impulse1 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(this, "_linearMass"), Cdot1.$clone()));
                    var oldImpulse1 = this._linearImpulse.$clone();
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Addition(this._linearImpulse.$clone(), impulse1.$clone());

                    var maxImpulse1 = step.v.dt * this.MaxForce;

                    if (this._linearImpulse.LengthSquared() > maxImpulse1 * maxImpulse1) {
                        this._linearImpulse.Normalize();
                        this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(), maxImpulse1);
                    }

                    impulse1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this._linearImpulse.$clone(), oldImpulse1.$clone());

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, impulse1.$clone()));
                    wA -= iA * FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), impulse1.$clone());
                }

                bA.LinearVelocityInternal = vA.$clone();
                bA.AngularVelocityInternal = wA;
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedLineJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _ax: null,
            _ay: null,
            _bias: 0,
            _enableMotor: false,
            _gamma: 0,
            _impulse: 0,
            _localXAxis: null,
            _localYAxisA: null,
            _mass: 0,
            _maxMotorTorque: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _sAx: 0,
            _sAy: 0,
            _sBx: 0,
            _sBy: 0,
            _springImpulse: 0,
            _springMass: 0,
            LocalAnchorA: null,
            LocalAnchorB: null,
            Frequency: 0,
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.LocalAnchorA.$clone();
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            JointTranslation: {
                get: function () {
                    var bA = this.BodyA;
                    var bB = this.BodyB;

                    var pA = bA.GetWorldPoint(this.LocalAnchorA.$clone());
                    var pB = bB.GetWorldPoint(this.LocalAnchorB.$clone());
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(pB.$clone(), pA.$clone());
                    var axis = bA.GetWorldVector(this.LocalXAxis.$clone());

                    var translation = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), axis.$clone());
                    return translation;
                }
            },
            JointSpeed: {
                get: function () {
                    var wA = this.BodyA.AngularVelocityInternal;
                    var wB = this.BodyB.AngularVelocityInternal;
                    return wB - wA;
                }
            },
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._enableMotor = value;
                }
            },
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._motorSpeed = value;
                }
            },
            MaxMotorTorque: {
                get: function () {
                    return this._maxMotorTorque;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._maxMotorTorque = value;
                }
            },
            LocalXAxis: {
                get: function () {
                    return this._localXAxis.$clone();
                },
                set: function (value) {
                    this._localXAxis = value.$clone();
                    this._localYAxisA = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis.$clone());
                }
            }
        },
        ctors: {
            init: function () {
                this._ax = new Microsoft.Xna.Framework.Vector2();
                this._ay = new Microsoft.Xna.Framework.Vector2();
                this._localXAxis = new Microsoft.Xna.Framework.Vector2();
                this._localYAxisA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedLine;
            },
            $ctor1: function (body, worldAnchor, axis) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedLine;

                this.BodyB = this.BodyA;

                this.LocalAnchorA = worldAnchor.$clone();
                this.LocalAnchorB = this.BodyB.GetLocalPoint(worldAnchor.$clone());
                this.LocalXAxis = axis.$clone();
            }
        },
        methods: {
            GetReactionForce: function (invDt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._ay.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse, this._ax.$clone()))));
            },
            GetReactionTorque: function (invDt) {
                return invDt * this._motorImpulse;
            },
            InitVelocityConstraints: function (step) {
                var bB = this.BodyB;

                this.LocalCenterA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.LocalCenterB = bB.LocalCenter.$clone();

                var xfB = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xfB);

                var rA = this.LocalAnchorA.$clone();
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), rB.$clone()), rA.$clone());

                this.InvMassA = 0.0;
                this.InvIA = 0.0;
                this.InvMassB = bB.InvMass;
                this.InvIB = bB.InvI;

                {
                    this._ay = this._localYAxisA.$clone();
                    this._sAy = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), this._ay.$clone());
                    this._sBy = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), this._ay.$clone());

                    this._mass = this.InvMassA + this.InvMassB + this.InvIA * this._sAy * this._sAy + this.InvIB * this._sBy * this._sBy;

                    if (this._mass > 0.0) {
                        this._mass = 1.0 / this._mass;
                    }
                }

                this._springMass = 0.0;
                if (this.Frequency > 0.0) {
                    this._ax = this.LocalXAxis.$clone();
                    this._sAx = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), this._ax.$clone());
                    this._sBx = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), this._ax.$clone());

                    var invMass = this.InvMassA + this.InvMassB + this.InvIA * this._sAx * this._sAx + this.InvIB * this._sBx * this._sBx;

                    if (invMass > 0.0) {
                        this._springMass = 1.0 / invMass;

                        var C = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), this._ax.$clone());

                        var omega = 6.28318548 * this.Frequency;

                        var da = 2.0 * this._springMass * this.DampingRatio * omega;

                        var k = this._springMass * omega * omega;

                        this._gamma = step.v.dt * (da + step.v.dt * k);
                        if (this._gamma > 0.0) {
                            this._gamma = 1.0 / this._gamma;
                        }

                        this._bias = C * step.v.dt * k * this._gamma;

                        this._springMass = invMass + this._gamma;
                        if (this._springMass > 0.0) {
                            this._springMass = 1.0 / this._springMass;
                        }
                    }
                } else {
                    this._springImpulse = 0.0;
                    this._springMass = 0.0;
                }

                if (this._enableMotor) {
                    this._motorMass = this.InvIA + this.InvIB;
                    if (this._motorMass > 0.0) {
                        this._motorMass = 1.0 / this._motorMass;
                    }
                } else {
                    this._motorMass = 0.0;
                    this._motorImpulse = 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;
                    this._springImpulse *= step.v.dtRatio;
                    this._motorImpulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._ay.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse, this._ax.$clone()));
                    var LB = this._impulse * this._sBy + this._springImpulse * this._sBx + this._motorImpulse;

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    bB.AngularVelocityInternal += this.InvIB * LB;
                } else {
                    this._impulse = 0.0;
                    this._springImpulse = 0.0;
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bB = this.BodyB;

                var vA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var wA = 0.0;
                var vB = bB.LinearVelocityInternal.$clone();
                var wB = bB.AngularVelocityInternal;

                {
                    var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._ax.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone())) + this._sBx * wB - this._sAx * wA;
                    var impulse = -this._springMass * (Cdot + this._bias + this._gamma * this._springImpulse);
                    this._springImpulse += impulse;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._ax.$clone());
                    var LA = impulse * this._sAx;
                    var LB = impulse * this._sBx;

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    wA -= this.InvIA * LA;

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    wB += this.InvIB * LB;
                }

                {
                    var Cdot1 = wB - wA - this._motorSpeed;
                    var impulse1 = -this._motorMass * Cdot1;

                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorTorque;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse1, -maxImpulse, maxImpulse);
                    impulse1 = this._motorImpulse - oldImpulse;

                    wA -= this.InvIA * impulse1;
                    wB += this.InvIB * impulse1;
                }

                {
                    var Cdot2 = Microsoft.Xna.Framework.Vector2.Dot(this._ay.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone())) + this._sBy * wB - this._sAy * wA;
                    var impulse2 = this._mass * (-Cdot2);
                    this._impulse += impulse2;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse2, this._ay.$clone());
                    var LB1 = impulse2 * this._sBy;

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P1.$clone()));
                    wB += this.InvIB * LB1;
                }

                bB.LinearVelocityInternal = vB.$clone();
                bB.AngularVelocityInternal = wB;
            },
            SolvePositionConstraints: function () {
                var bB = this.BodyB;

                var xA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var angleA = 0.0;

                var xB = bB.Sweep.C.$clone();
                var angleB = bB.Sweep.A;

                var RA = { v : new FarseerPhysics.Common.Mat22.$ctor2(angleA) };
                var RB = { v : new FarseerPhysics.Common.Mat22.$ctor2(angleB) };

                var rA = FarseerPhysics.Common.MathUtils.Multiply(RA, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(RB, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(xB.$clone(), rB.$clone()), xA.$clone()), rA.$clone());

                var ay = FarseerPhysics.Common.MathUtils.Multiply(RA, this._localYAxisA.$clone());

                var sBy = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), ay.$clone());

                var C = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), ay.$clone());

                var k = this.InvMassA + this.InvMassB + this.InvIA * this._sAy * this._sAy + this.InvIB * this._sBy * this._sBy;

                var impulse;
                if (k !== 0.0) {
                    impulse = -C / k;
                } else {
                    impulse = 0.0;
                }

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, ay.$clone());
                var LB = impulse * sBy;

                xB = Microsoft.Xna.Framework.Vector2.op_Addition(xB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                angleB += this.InvIB * LB;

                bB.Sweep.C = xB.$clone();
                bB.Sweep.A = angleB;
                bB.SynchronizeTransform();

                return Math.abs(C) <= FarseerPhysics.Settings.LinearSlop;
            },
            GetMotorTorque: function (invDt) {
                return invDt * this._motorImpulse;
            }
        }
    });

    /**
     * A mouse joint is used to make a point on a body track a
     specified world point. This a soft constraint with a maximum
     force. This allows the constraint to stretch and without
     applying huge forces.
     NOTE: this joint is not documented in the manual because it was
     developed to be used in the testbed. If you want to learn how to
     use the mouse joint, look at the testbed.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedMouseJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedMouseJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            _C: null,
            _beta: 0,
            _gamma: 0,
            _impulse: null,
            _mass: null,
            _worldAnchor: null,
            /**
             * The maximum constraint force that can be exerted
             to move the candidate body. Usually you will express
             as some multiple of the weight (multiplier * mass * gravity).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @function MaxForce
             * @type number
             */
            MaxForce: 0,
            /**
             * The response speed.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @function Frequency
             * @type number
             */
            Frequency: 0,
            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @function DampingRatio
             * @type number
             */
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this._worldAnchor.$clone();
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this._worldAnchor = value.$clone();
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this._C = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector2();
                this._mass = new FarseerPhysics.Common.Mat22();
                this._worldAnchor = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * This requires a world target point,
             tuning parameters, and the time step.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @memberof FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @param   {FarseerPhysics.Dynamics.Body}       body           The body.
             * @param   {Microsoft.Xna.Framework.Vector2}    worldAnchor    The target.
             * @return  {void}
             */
            ctor: function (body, worldAnchor) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedMouse;
                this.Frequency = 5.0;
                this.DampingRatio = 0.7;

                System.Diagnostics.Debug.Assert(FarseerPhysics.Common.MathUtils.IsValid(worldAnchor));

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                this.BodyA.GetTransform(xf1);

                this._worldAnchor = worldAnchor.$clone();
                this.LocalAnchorA = this.BodyA.GetLocalPoint(worldAnchor.$clone());
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, this._impulse.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b = this.BodyA;

                var mass = b.Mass;

                var omega = 6.28318548 * this.Frequency;

                var d = 2.0 * mass * this.DampingRatio * omega;

                var k = mass * (omega * omega);

                System.Diagnostics.Debug.Assert(d + step.v.dt * k > FarseerPhysics.Settings.Epsilon);

                this._gamma = step.v.dt * (d + step.v.dt * k);
                if (this._gamma !== 0.0) {
                    this._gamma = 1.0 / this._gamma;
                }

                this._beta = step.v.dt * k * this._gamma;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b.GetTransform(xf1);
                var r = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b.LocalCenter.$clone()));

                var invMass = b.InvMass;
                var invI = b.InvI;

                var K1 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invMass, 0.0), new Microsoft.Xna.Framework.Vector2.$ctor2(0.0, invMass)) };
                var K2 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI * r.Y * r.Y, -invI * r.X * r.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(-invI * r.X * r.Y, invI * r.X * r.X)) };

                var K = { v : new FarseerPhysics.Common.Mat22() };
                FarseerPhysics.Common.Mat22.Add(K1, K2, K);

                K.v.Col1.X += this._gamma;
                K.v.Col2.Y += this._gamma;

                this._mass = K.v.Inverse.$clone();

                this._C = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b.Sweep.C.$clone(), r.$clone()), this._worldAnchor.$clone());

                b.AngularVelocityInternal *= 0.98;

                this._impulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                b.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(invMass, this._impulse.$clone()));
                b.AngularVelocityInternal += invI * FarseerPhysics.Common.MathUtils.Cross$2(r.$clone(), this._impulse.$clone());
            },
            SolveVelocityConstraints: function (step) {
                var b = this.BodyA;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b.GetTransform(xf1);

                var r = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b.LocalCenter.$clone()));

                var Cdot = Microsoft.Xna.Framework.Vector2.op_Addition(b.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b.AngularVelocityInternal, r.$clone()));
                var impulse = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(this, "_mass"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation((Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(Cdot.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._beta, this._C.$clone())), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._gamma, this._impulse.$clone())))));

                var oldImpulse = this._impulse.$clone();
                this._impulse = Microsoft.Xna.Framework.Vector2.op_Addition(this._impulse.$clone(), impulse.$clone());
                var maxImpulse = step.v.dt * this.MaxForce;
                if (this._impulse.LengthSquared() > maxImpulse * maxImpulse) {
                    this._impulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._impulse.$clone(), maxImpulse / this._impulse.Length());
                }
                impulse = Microsoft.Xna.Framework.Vector2.op_Subtraction(this._impulse.$clone(), oldImpulse.$clone());

                b.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b.InvMass, impulse.$clone()));
                b.AngularVelocityInternal += b.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r.$clone(), impulse.$clone());
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    /**
     * A prismatic joint. This joint provides one degree of freedom: translation
     along an axis fixed in body1. Relative rotation is prevented. You can
     use a joint limit to restrict the range of motion and a joint motor to
     drive the motion or to model joint friction.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _K: null,
            _a1: 0,
            _a2: 0,
            _axis: null,
            _enableLimit: false,
            _enableMotor: false,
            _impulse: null,
            _limitState: 0,
            _localXAxis1: null,
            _localYAxis1: null,
            _lowerTranslation: 0,
            _maxMotorForce: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _perp: null,
            _refAngle: 0,
            _s1: 0,
            _s2: 0,
            _upperTranslation: 0,
            LocalAnchorA: null,
            LocalAnchorB: null,
            /**
             * Get the current motor force, usually in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function MotorForce
             * @type number
             */
            MotorForce: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.LocalAnchorA.$clone();
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            /**
             * Get the current joint translation, usually in meters.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function JointTranslation
             * @type number
             */
            JointTranslation: {
                get: function () {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone()), this.LocalAnchorA.$clone());
                    var axis = this._localXAxis1.$clone();

                    return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), axis.$clone());
                }
            },
            /**
             * Get the current joint translation speed, usually in meters per second.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function JointSpeed
             * @type number
             */
            JointSpeed: {
                get: function () {
                    var xf2 = { v : new FarseerPhysics.Common.Transform() };
                    this.BodyB.GetTransform(xf2);

                    var r1 = this.LocalAnchorA.$clone();
                    var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.BodyB.LocalCenter.$clone()));
                    var p1 = r1.$clone();
                    var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(this.BodyB.Sweep.C.$clone(), r2.$clone());
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());
                    var axis = this._localXAxis1.$clone();

                    var v1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    var v2 = this.BodyB.LinearVelocityInternal.$clone();
                    var w1 = 0.0;
                    var w2 = this.BodyB.AngularVelocityInternal;

                    var speed = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w1, axis.$clone())) + Microsoft.Xna.Framework.Vector2.Dot(axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w2, r2.$clone())), v1.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(w1, r1.$clone())));
                    return speed;
                }
            },
            /**
             * Is the joint limit enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function LimitEnabled
             * @type boolean
             */
            LimitEnabled: {
                get: function () {
                    return this._enableLimit;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(this.BodyA.FixedRotation === false, "Warning: limits does currently not work with fixed rotation");

                    this.WakeBodies();
                    this._enableLimit = value;
                }
            },
            /**
             * Get the lower joint limit, usually in meters.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function LowerLimit
             * @type number
             */
            LowerLimit: {
                get: function () {
                    return this._lowerTranslation;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._lowerTranslation = value;
                }
            },
            /**
             * Get the upper joint limit, usually in meters.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function UpperLimit
             * @type number
             */
            UpperLimit: {
                get: function () {
                    return this._upperTranslation;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._upperTranslation = value;
                }
            },
            /**
             * Is the joint motor enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function MotorEnabled
             * @type boolean
             */
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableMotor = value;
                }
            },
            /**
             * Set the motor speed, usually in meters per second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function MotorSpeed
             * @type number
             */
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorSpeed = value;
                }
            },
            /**
             * Set the maximum motor force, usually in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function MaxMotorForce
             * @type number
             */
            MaxMotorForce: {
                set: function (value) {
                    this.WakeBodies();
                    this._maxMotorForce = value;
                }
            },
            LocalXAxis1: {
                get: function () {
                    return this._localXAxis1.$clone();
                },
                set: function (value) {
                    this._localXAxis1 = value.$clone();
                    this._localYAxis1 = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis1.$clone());
                }
            }
        },
        ctors: {
            init: function () {
                this._K = new FarseerPhysics.Common.Mat33();
                this._axis = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._localXAxis1 = new Microsoft.Xna.Framework.Vector2();
                this._localYAxis1 = new Microsoft.Xna.Framework.Vector2();
                this._perp = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * This requires defining a line of
             motion using an axis and an anchor point. The definition uses local
             anchor points and a local axis so that the initial configuration
             can violate the constraint slightly. The joint translation is zero
             when the local anchor points coincide in world space. Using local
             anchors and a local axis helps when saving and loading a game.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @param   {FarseerPhysics.Dynamics.Body}       body           The body.
             * @param   {Microsoft.Xna.Framework.Vector2}    worldAnchor    The anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    axis           The axis.
             * @return  {void}
             */
            ctor: function (body, worldAnchor, axis) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic;

                this.BodyB = this.BodyA;

                this.LocalAnchorA = worldAnchor.$clone();
                this.LocalAnchorB = this.BodyB.GetLocalPoint(worldAnchor.$clone());

                this._localXAxis1 = axis.$clone();
                this._localYAxis1 = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis1.$clone());
                this._refAngle = this.BodyB.Rotation;

                this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this.MotorForce + this._impulse.Z), this._axis.$clone()))));
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Y;
            },
            InitVelocityConstraints: function (step) {
                var bB = this.BodyB;

                this.LocalCenterA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.LocalCenterB = bB.LocalCenter.$clone();

                var xf2 = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xf2);

                var r1 = this.LocalAnchorA.$clone();
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), r2.$clone()), r1.$clone());

                this.InvMassA = 0.0;
                this.InvIA = 0.0;
                this.InvMassB = bB.InvMass;
                this.InvIB = bB.InvI;

                {
                    this._axis = this._localXAxis1.$clone();
                    this._a1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._axis.$clone());
                    this._a2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._axis.$clone());

                    this._motorMass = this.InvMassA + this.InvMassB + this.InvIA * this._a1 * this._a1 + this.InvIB * this._a2 * this._a2;

                    if (this._motorMass > FarseerPhysics.Settings.Epsilon) {
                        this._motorMass = 1.0 / this._motorMass;
                    }
                }

                {
                    this._perp = this._localYAxis1.$clone();

                    this._s1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._perp.$clone());
                    this._s2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._perp.$clone());

                    var m1 = this.InvMassA, m2 = this.InvMassB;
                    var i1 = this.InvIA, i2 = this.InvIB;

                    var k11 = m1 + m2 + i1 * this._s1 * this._s1 + i2 * this._s2 * this._s2;
                    var k12 = i1 * this._s1 + i2 * this._s2;
                    var k13 = i1 * this._s1 * this._a1 + i2 * this._s2 * this._a2;
                    var k22 = i1 + i2;
                    var k23 = i1 * this._a1 + i2 * this._a2;
                    var k33 = m1 + m2 + i1 * this._a1 * this._a1 + i2 * this._a2 * this._a2;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k11, k12, k13);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k12, k22, k23);
                    this._K.Col3 = new Microsoft.Xna.Framework.Vector3.$ctor3(k13, k23, k33);
                }

                if (this._enableLimit) {
                    var jointTranslation = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), d.$clone());
                    if (Math.abs(this._upperTranslation - this._lowerTranslation) < 0.01) {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Equal;
                    } else if (jointTranslation <= this._lowerTranslation) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                            this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtLower;
                            this._impulse.Z = 0.0;
                        }
                    } else if (jointTranslation >= this._upperTranslation) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                            this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                            this._impulse.Z = 0.0;
                        }
                    } else {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                        this._impulse.Z = 0.0;
                    }
                } else {
                    this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (this._enableMotor === false) {
                    this.MotorForce = 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                    this.MotorForce *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this.MotorForce + this._impulse.Z), this._axis.$clone()));
                    var L2 = this._impulse.X * this._s2 + this._impulse.Y + (this.MotorForce + this._impulse.Z) * this._a2;

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    bB.AngularVelocityInternal += this.InvIB * L2;
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                    this.MotorForce = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bB = this.BodyB;

                var v1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var w1 = 0.0;
                var v2 = bB.LinearVelocityInternal.$clone();
                var w2 = bB.AngularVelocityInternal;

                if (this._enableMotor && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                    var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._a2 * w2 - this._a1 * w1;
                    var impulse = this._motorMass * (this._motorSpeed - Cdot);
                    var oldImpulse = this.MotorForce;
                    var maxImpulse = step.v.dt * this._maxMotorForce;
                    this.MotorForce = FarseerPhysics.Common.MathUtils.Clamp$2(this.MotorForce + impulse, -maxImpulse, maxImpulse);
                    impulse = this.MotorForce - oldImpulse;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._axis.$clone());
                    var L1 = impulse * this._a1;
                    var L2 = impulse * this._a2;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    w1 -= this.InvIA * L1;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    w2 += this.InvIB * L2;
                }

                var Cdot1 = new Microsoft.Xna.Framework.Vector2.$ctor2(Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._s2 * w2 - this._s1 * w1, w2 - w1);

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var Cdot2 = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._a2 * w2 - this._a1 * w1;
                    var Cdot3 = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                    var f1 = this._impulse.$clone();
                    var df = this._K.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), df.$clone());

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        this._impulse.Z = Math.max(this._impulse.Z, 0.0);
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        this._impulse.Z = Math.min(this._impulse.Z, 0.0);
                    }

                    var b = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this._impulse.Z - f1.Z), new Microsoft.Xna.Framework.Vector2.$ctor2(this._K.Col3.X, this._K.Col3.Y)));
                    var f2r = Microsoft.Xna.Framework.Vector2.op_Addition(this._K.Solve22(b.$clone()), new Microsoft.Xna.Framework.Vector2.$ctor2(f1.X, f1.Y));
                    this._impulse.X = f2r.X;
                    this._impulse.Y = f2r.Y;

                    df = Microsoft.Xna.Framework.Vector3.op_Subtraction(this._impulse.$clone(), f1.$clone());

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.Z, this._axis.$clone()));
                    var L21 = df.X * this._s2 + df.Y + df.Z * this._a2;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P1.$clone()));
                    w2 += this.InvIB * L21;
                } else {
                    var df1 = this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                    this._impulse.X += df1.X;
                    this._impulse.Y += df1.Y;

                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(df1.X, this._perp.$clone());
                    var L22 = df1.X * this._s2 + df1.Y;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P2.$clone()));
                    w2 += this.InvIB * L22;
                }

                bB.LinearVelocityInternal = v2.$clone();
                bB.AngularVelocityInternal = w2;
            },
            SolvePositionConstraints: function () {
                var b2 = this.BodyB;

                var c1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var a1 = 0.0;

                var c2 = b2.Sweep.C.$clone();
                var a2 = b2.Sweep.A;

                var linearError = 0.0;
                var active = false;
                var C2 = 0.0;

                var R1 = { v : new FarseerPhysics.Common.Mat22.$ctor2(a1) };
                var R2 = { v : new FarseerPhysics.Common.Mat22.$ctor2(a2) };

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(R1, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(R2, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(c2.$clone(), r2.$clone()), c1.$clone()), r1.$clone());

                if (this._enableLimit) {
                    this._axis = FarseerPhysics.Common.MathUtils.Multiply(R1, this._localXAxis1.$clone());

                    this._a1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._axis.$clone());
                    this._a2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._axis.$clone());

                    var translation = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), d.$clone());
                    if (Math.abs(this._upperTranslation - this._lowerTranslation) < 0.01) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);
                        linearError = Math.abs(translation);
                        active = true;
                    } else if (translation <= this._lowerTranslation) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation - this._lowerTranslation + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                        linearError = this._lowerTranslation - translation;
                        active = true;
                    } else if (translation >= this._upperTranslation) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation - this._upperTranslation - FarseerPhysics.Settings.LinearSlop, 0.0, FarseerPhysics.Settings.MaxLinearCorrection);
                        linearError = translation - this._upperTranslation;
                        active = true;
                    }
                }

                this._perp = FarseerPhysics.Common.MathUtils.Multiply(R1, this._localYAxis1.$clone());

                this._s1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._perp.$clone());
                this._s2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._perp.$clone());

                var impulse = new Microsoft.Xna.Framework.Vector3();
                var C1 = new Microsoft.Xna.Framework.Vector2.$ctor2(Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(), d.$clone()), a2 - a1 - this._refAngle);

                linearError = Math.max(linearError, Math.abs(C1.X));
                var angularError = Math.abs(C1.Y);

                if (active) {
                    var m1 = this.InvMassA, m2 = this.InvMassB;
                    var i1 = this.InvIA, i2 = this.InvIB;

                    var k11 = m1 + m2 + i1 * this._s1 * this._s1 + i2 * this._s2 * this._s2;
                    var k12 = i1 * this._s1 + i2 * this._s2;
                    var k13 = i1 * this._s1 * this._a1 + i2 * this._s2 * this._a2;
                    var k22 = i1 + i2;
                    var k23 = i1 * this._a1 + i2 * this._a2;
                    var k33 = m1 + m2 + i1 * this._a1 * this._a1 + i2 * this._a2 * this._a2;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k11, k12, k13);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k12, k22, k23);
                    this._K.Col3 = new Microsoft.Xna.Framework.Vector3.$ctor3(k13, k23, k33);

                    var C = new Microsoft.Xna.Framework.Vector3.$ctor3(-C1.X, -C1.Y, -C2);
                    impulse = this._K.Solve33(C.$clone());
                } else {
                    var m11 = this.InvMassA, m21 = this.InvMassB;
                    var i11 = this.InvIA, i21 = this.InvIB;

                    var k111 = m11 + m21 + i11 * this._s1 * this._s1 + i21 * this._s2 * this._s2;
                    var k121 = i11 * this._s1 + i21 * this._s2;
                    var k221 = i11 + i21;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k111, k121, 0.0);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k121, k221, 0.0);

                    var impulse1 = this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C1.$clone()));
                    impulse.X = impulse1.X;
                    impulse.Y = impulse1.Y;
                    impulse.Z = 0.0;
                }

                var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.Z, this._axis.$clone()));
                var L2 = impulse.X * this._s2 + impulse.Y + impulse.Z * this._a2;

                c2 = Microsoft.Xna.Framework.Vector2.op_Addition(c2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                a2 += this.InvIB * L2;

                b2.Sweep.C = c2.$clone();
                b2.Sweep.A = a2;
                b2.SynchronizeTransform();

                return linearError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    /**
     * A revolute joint rains to bodies to share a common point while they
     are free to rotate about the point. The relative rotation about the shared
     point is the joint angle. You can limit the relative rotation with
     a joint limit that specifies a lower and upper angle. You can use a motor
     to drive the relative rotation about the shared point. A maximum motor torque
     is provided so that infinite forces are not generated.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _enableLimit: false,
            _enableMotor: false,
            _impulse: null,
            _limitState: 0,
            _lowerAngle: 0,
            _mass: null,
            _maxMotorTorque: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _upperAngle: 0,
            _worldAnchor: null,
            LocalAnchorA: null,
            ReferenceAngle: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this._worldAnchor.$clone();
                },
                set: function (value) {
                    this._worldAnchor = value.$clone();
                }
            },
            /**
             * Get the current joint angle in radians.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function JointAngle
             * @type number
             */
            JointAngle: {
                get: function () {
                    return this.BodyA.Sweep.A - this.ReferenceAngle;
                }
            },
            /**
             * Get the current joint angle speed in radians per second.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function JointSpeed
             * @type number
             */
            JointSpeed: {
                get: function () {
                    return this.BodyA.AngularVelocityInternal;
                }
            },
            /**
             * Is the joint limit enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function LimitEnabled
             * @type boolean
             */
            LimitEnabled: {
                get: function () {
                    return this._enableLimit;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableLimit = value;
                }
            },
            /**
             * Get the lower joint limit in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function LowerLimit
             * @type number
             */
            LowerLimit: {
                get: function () {
                    return this._lowerAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._lowerAngle = value;
                }
            },
            /**
             * Get the upper joint limit in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function UpperLimit
             * @type number
             */
            UpperLimit: {
                get: function () {
                    return this._upperAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._upperAngle = value;
                }
            },
            /**
             * Is the joint motor enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function MotorEnabled
             * @type boolean
             */
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableMotor = value;
                }
            },
            /**
             * Set the motor speed in radians per second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function MotorSpeed
             * @type number
             */
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorSpeed = value;
                }
            },
            /**
             * Set the maximum motor torque, usually in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function MaxMotorTorque
             * @type number
             */
            MaxMotorTorque: {
                get: function () {
                    return this._maxMotorTorque;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._maxMotorTorque = value;
                }
            },
            /**
             * Get the current motor torque, usually in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function MotorTorque
             * @type number
             */
            MotorTorque: {
                get: function () {
                    return this._motorImpulse;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorImpulse = value;
                }
            }
        },
        ctors: {
            init: function () {
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._mass = new FarseerPhysics.Common.Mat33();
                this._worldAnchor = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * Initialize the bodies, anchors, and reference angle using the world
             anchor.
             This requires defining an
             anchor point where the bodies are joined. The definition
             uses local anchor points so that the initial configuration
             can violate the constraint slightly. You also need to
             specify the initial relative angle for joint limits. This
             helps when saving and loading a game.
             The local anchor points are measured from the body's origin
             rather than the center of mass because:
             1. you might not know where the center of mass will be.
             2. if you add/remove shapes from a body and recompute the mass,
             the joints will be broken.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @param   {FarseerPhysics.Dynamics.Body}       body           The body.
             * @param   {Microsoft.Xna.Framework.Vector2}    bodyAnchor     The body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    worldAnchor    The world anchor.
             * @return  {void}
             */
            ctor: function (body, bodyAnchor, worldAnchor) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute;

                this.LocalAnchorA = bodyAnchor.$clone();
                this._worldAnchor = worldAnchor.$clone();

                this.ReferenceAngle = -this.BodyA.Rotation;

                this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();

                this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y));
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Z;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;

                if (this._enableMotor || this._enableLimit) {
                    System.Diagnostics.Debug.Assert(b1.InvI > 0.0);
                }

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = this._worldAnchor.$clone();



                var m1 = b1.InvMass;
                var m2 = 0;
                var i1 = b1.InvI;
                var i2 = 0;

                this._mass.Col1.X = m1 + m2 + r1.Y * r1.Y * i1 + r2.Y * r2.Y * i2;
                this._mass.Col2.X = -r1.Y * r1.X * i1 - r2.Y * r2.X * i2;
                this._mass.Col3.X = -r1.Y * i1 - r2.Y * i2;
                this._mass.Col1.Y = this._mass.Col2.X;
                this._mass.Col2.Y = m1 + m2 + r1.X * r1.X * i1 + r2.X * r2.X * i2;
                this._mass.Col3.Y = r1.X * i1 + r2.X * i2;
                this._mass.Col1.Z = this._mass.Col3.X;
                this._mass.Col2.Z = this._mass.Col3.Y;
                this._mass.Col3.Z = i1 + i2;

                this._motorMass = i1 + i2;
                if (this._motorMass > 0.0) {
                    this._motorMass = 1.0 / this._motorMass;
                }

                if (this._enableMotor === false) {
                    this._motorImpulse = 0.0;
                }

                if (this._enableLimit) {
                    var jointAngle = 0 - b1.Sweep.A - this.ReferenceAngle;
                    if (Math.abs(this._upperAngle - this._lowerAngle) < 0.06981318) {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Equal;
                    } else if (jointAngle <= this._lowerAngle) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                            this._impulse.Z = 0.0;
                        }
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtLower;
                    } else if (jointAngle >= this._upperAngle) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                            this._impulse.Z = 0.0;
                        }
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                    } else {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                        this._impulse.Z = 0.0;
                    }
                } else {
                    this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                    this._motorImpulse *= step.v.dtRatio;

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y);

                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, P.$clone()));
                    b1.AngularVelocityInternal -= i1 * (FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone()) + this._motorImpulse + this._impulse.Z);
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;

                var v1 = b1.LinearVelocityInternal.$clone();
                var w1 = b1.AngularVelocityInternal;
                var v2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var w2 = 0;

                var m1 = b1.InvMass;
                var i1 = b1.InvI;

                if (this._enableMotor && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                    var Cdot = w2 - w1 - this._motorSpeed;
                    var impulse = this._motorMass * (-Cdot);
                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorTorque;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._motorImpulse - oldImpulse;

                    w1 -= i1 * impulse;
                }

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var xf1 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf1);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var r2 = this._worldAnchor.$clone();

                    var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w2, r2.$clone())), v1.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(w1, r1.$clone()));
                    var Cdot2 = w2 - w1;
                    var Cdot3 = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                    var impulse1 = this._mass.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                        this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), impulse1.$clone());
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        var newImpulse = this._impulse.Z + impulse1.Z;
                        if (newImpulse < 0.0) {
                            var reduced = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                            impulse1.X = reduced.X;
                            impulse1.Y = reduced.Y;
                            impulse1.Z = -this._impulse.Z;
                            this._impulse.X += reduced.X;
                            this._impulse.Y += reduced.Y;
                            this._impulse.Z = 0.0;
                        }
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        var newImpulse1 = this._impulse.Z + impulse1.Z;
                        if (newImpulse1 > 0.0) {
                            var reduced1 = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                            impulse1.X = reduced1.X;
                            impulse1.Y = reduced1.Y;
                            impulse1.Z = -this._impulse.Z;
                            this._impulse.X += reduced1.X;
                            this._impulse.Y += reduced1.Y;
                            this._impulse.Z = 0.0;
                        }
                    }

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(impulse1.X, impulse1.Y);

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, P.$clone()));
                    w1 -= i1 * (FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone()) + impulse1.Z);
                } else {
                    var xf11 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf11);

                    var r11 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf11.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var r21 = this._worldAnchor.$clone();

                    var Cdot4 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w2, r21.$clone())), v1.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(w1, r11.$clone()));
                    var impulse2 = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot4.$clone()));

                    this._impulse.X += impulse2.X;
                    this._impulse.Y += impulse2.Y;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, impulse2.$clone()));
                    w1 -= i1 * FarseerPhysics.Common.MathUtils.Cross$2(r11.$clone(), impulse2.$clone());
                }

                b1.LinearVelocityInternal = v1.$clone();
                b1.AngularVelocityInternal = w1;
            },
            SolvePositionConstraints: function () {

                var b1 = this.BodyA;

                var angularError = 0.0;
                var positionError;

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var angle = 0 - b1.Sweep.A - this.ReferenceAngle;
                    var limitImpulse = 0.0;

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                        var C = FarseerPhysics.Common.MathUtils.Clamp$2(angle - this._lowerAngle, -0.139626354, FarseerPhysics.Settings.MaxAngularCorrection);
                        limitImpulse = -this._motorMass * C;
                        angularError = Math.abs(C);
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        var C1 = angle - this._lowerAngle;
                        angularError = -C1;

                        C1 = FarseerPhysics.Common.MathUtils.Clamp$2(C1 + FarseerPhysics.Settings.AngularSlop, -0.139626354, 0.0);
                        limitImpulse = -this._motorMass * C1;
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        var C2 = angle - this._upperAngle;
                        angularError = C2;

                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(C2 - FarseerPhysics.Settings.AngularSlop, 0.0, FarseerPhysics.Settings.MaxAngularCorrection);
                        limitImpulse = -this._motorMass * C2;
                    }

                    b1.Sweep.A -= b1.InvI * limitImpulse;

                    b1.SynchronizeTransform();
                }

                {
                    var xf1 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf1);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var r2 = this._worldAnchor.$clone();

                    var C3 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());
                    positionError = C3.Length();

                    var invMass1 = b1.InvMass;
                    var invMass2 = 0;
                    var invI1 = b1.InvI;
                    var invI2 = 0;

                    var k_allowedStretch = 0.049999997;
                    if (C3.LengthSquared() > 0.00249999971) {
                        var u = C3.$clone();
                        u.Normalize();
                        var k = invMass1 + invMass2;
                        System.Diagnostics.Debug.Assert(k > FarseerPhysics.Settings.Epsilon);
                        var m = 1.0 / k;
                        var impulse2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(m, (Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C3.$clone())));
                        var k_beta = 0.5;
                        b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(k_beta * invMass1, impulse2.$clone()));

                        C3 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());
                    }

                    var K1 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invMass1 + invMass2, 0.0), new Microsoft.Xna.Framework.Vector2.$ctor2(0.0, invMass1 + invMass2)) };
                    var K2 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI1 * r1.Y * r1.Y, -invI1 * r1.X * r1.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(-invI1 * r1.X * r1.Y, invI1 * r1.X * r1.X)) };
                    var K3 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI2 * r2.Y * r2.Y, 0.0 * r2.X * r2.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(0.0 * r2.X * r2.Y, invI2 * r2.X * r2.X)) };

                    var Ka = { v : new FarseerPhysics.Common.Mat22() };
                    FarseerPhysics.Common.Mat22.Add(K1, K2, Ka);

                    var K = { v : new FarseerPhysics.Common.Mat22() };
                    FarseerPhysics.Common.Mat22.Add(Ka, K3, K);

                    var impulse = K.v.Solve(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C3.$clone()));

                    b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, impulse.$clone()));
                    b1.Sweep.A -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), impulse.$clone());

                    b1.SynchronizeTransform();
                }

                return positionError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    /**
     * Friction joint. This is used for top-down friction.
     It provides 2D translational friction and angular friction.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FrictionJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FrictionJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _angularImpulse: 0,
            _angularMass: 0,
            _linearImpulse: null,
            _linearMass: null,
            /**
             * The maximum friction force in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FrictionJoint
             * @function MaxForce
             * @type number
             */
            MaxForce: 0,
            /**
             * The maximum friction torque in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FrictionJoint
             * @function MaxTorque
             * @type number
             */
            MaxTorque: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._linearImpulse = new Microsoft.Xna.Framework.Vector2();
                this._linearMass = new FarseerPhysics.Common.Mat22();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Friction;
            },
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Friction;
                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, this._linearImpulse.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._angularImpulse;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));



                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                var K1 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K1.v.Col1.X = mA + mB;
                K1.v.Col2.X = 0.0;
                K1.v.Col1.Y = 0.0;
                K1.v.Col2.Y = mA + mB;

                var K2 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K2.v.Col1.X = iA * rA.Y * rA.Y;
                K2.v.Col2.X = -iA * rA.X * rA.Y;
                K2.v.Col1.Y = -iA * rA.X * rA.Y;
                K2.v.Col2.Y = iA * rA.X * rA.X;

                var K3 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K3.v.Col1.X = iB * rB.Y * rB.Y;
                K3.v.Col2.X = -iB * rB.X * rB.Y;
                K3.v.Col1.Y = -iB * rB.X * rB.Y;
                K3.v.Col2.Y = iB * rB.X * rB.X;

                var K12 = { v : new FarseerPhysics.Common.Mat22() };
                FarseerPhysics.Common.Mat22.Add(K1, K2, K12);

                var K = { v : new FarseerPhysics.Common.Mat22() };
                FarseerPhysics.Common.Mat22.Add(K12, K3, K);

                this._linearMass = K.v.Inverse.$clone();

                this._angularMass = iA + iB;
                if (this._angularMass > 0.0) {
                    this._angularMass = 1.0 / this._angularMass;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(), step.v.dtRatio);
                    this._angularImpulse *= step.v.dtRatio;

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._linearImpulse.X, this._linearImpulse.Y);

                    bA.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                    bA.AngularVelocityInternal -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + this._angularImpulse);

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, P.$clone()));
                    bB.AngularVelocityInternal += iB * (FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone()) + this._angularImpulse);
                } else {
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    this._angularImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var vA = bA.LinearVelocityInternal.$clone();
                var wA = bA.AngularVelocityInternal;
                var vB = bB.LinearVelocityInternal.$clone();
                var wB = bB.AngularVelocityInternal;

                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                {
                    var Cdot = wB - wA;
                    var impulse = -this._angularMass * Cdot;

                    var oldImpulse = this._angularImpulse;
                    var maxImpulse = step.v.dt * this.MaxTorque;
                    this._angularImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._angularImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._angularImpulse - oldImpulse;

                    wA -= iA * impulse;
                    wB += iB * impulse;
                }

                {
                    var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(wB, rB.$clone())), vA.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(wA, rA.$clone()));

                    var impulse1 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(this, "_linearMass"), Cdot1.$clone()));
                    var oldImpulse1 = this._linearImpulse.$clone();
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Addition(this._linearImpulse.$clone(), impulse1.$clone());

                    var maxImpulse1 = step.v.dt * this.MaxForce;

                    if (this._linearImpulse.LengthSquared() > maxImpulse1 * maxImpulse1) {
                        this._linearImpulse.Normalize();
                        this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(), maxImpulse1);
                    }

                    impulse1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this._linearImpulse.$clone(), oldImpulse1.$clone());

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, impulse1.$clone()));
                    wA -= iA * FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), impulse1.$clone());

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, impulse1.$clone()));
                    wB += iB * FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), impulse1.$clone());
                }

                bA.LinearVelocityInternal = vA.$clone();
                bA.AngularVelocityInternal = wA;
                bB.LinearVelocityInternal = vB.$clone();
                bB.AngularVelocityInternal = wB;
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    /**
     * A gear joint is used to connect two joints together. Either joint
     can be a revolute or prismatic joint. You specify a gear ratio
     to bind the motions together:
     coordinate1 + ratio * coordinate2 = ant
     The ratio can be negative or positive. If one joint is a revolute joint
     and the other joint is a prismatic joint, then the ratio will have units
     of length or units of 1/length.
     @warning The revolute and prismatic joints must be attached to
     fixed bodies (which must be body1 on those joints).
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.GearJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.GearJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _J: null,
            _ant: 0,
            _fixedPrismatic1: null,
            _fixedPrismatic2: null,
            _fixedRevolute1: null,
            _fixedRevolute2: null,
            _impulse: 0,
            _mass: 0,
            _prismatic1: null,
            _prismatic2: null,
            _revolute1: null,
            _revolute2: null,
            /**
             * The gear ratio.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.GearJoint
             * @function Ratio
             * @type number
             */
            Ratio: 0,
            /**
             * The first revolute/prismatic joint attached to the gear joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.GearJoint
             * @function JointA
             * @type FarseerPhysics.Dynamics.Joints.Joint
             */
            JointA: null,
            /**
             * The second revolute/prismatic joint attached to the gear joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.GearJoint
             * @function JointB
             * @type FarseerPhysics.Dynamics.Joints.Joint
             */
            JointB: null,
            LocalAnchor1: null,
            LocalAnchor2: null
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchor1.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchor2.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this._J = new FarseerPhysics.Dynamics.Joints.Jacobian();
                this.LocalAnchor1 = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchor2 = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * Requires two existing revolute or prismatic joints (any combination will work).
             The provided joints must attach a dynamic body to a static body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.GearJoint
             * @memberof FarseerPhysics.Dynamics.Joints.GearJoint
             * @param   {FarseerPhysics.Dynamics.Joints.Joint}    jointA    The first joint.
             * @param   {FarseerPhysics.Dynamics.Joints.Joint}    jointB    The second joint.
             * @param   {number}                                  ratio     The ratio.
             * @return  {void}
             */
            ctor: function (jointA, jointB, ratio) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, jointA.BodyA, jointA.BodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Gear;
                this.JointA = jointA;
                this.JointB = jointB;
                this.Ratio = ratio;

                var type1 = jointA.JointType;
                var type2 = jointB.JointType;

                System.Diagnostics.Debug.Assert(type1 === FarseerPhysics.Dynamics.Joints.JointType.Revolute || type1 === FarseerPhysics.Dynamics.Joints.JointType.Prismatic || type1 === FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute || type1 === FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic);
                System.Diagnostics.Debug.Assert(type2 === FarseerPhysics.Dynamics.Joints.JointType.Revolute || type2 === FarseerPhysics.Dynamics.Joints.JointType.Prismatic || type2 === FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute || type2 === FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic);

                if (type1 === FarseerPhysics.Dynamics.Joints.JointType.Revolute || type1 === FarseerPhysics.Dynamics.Joints.JointType.Prismatic) {
                    System.Diagnostics.Debug.Assert(jointA.BodyA.BodyType === FarseerPhysics.Dynamics.BodyType.Static);
                }
                if (type2 === FarseerPhysics.Dynamics.Joints.JointType.Revolute || type2 === FarseerPhysics.Dynamics.Joints.JointType.Prismatic) {
                    System.Diagnostics.Debug.Assert(jointB.BodyA.BodyType === FarseerPhysics.Dynamics.BodyType.Static);
                }

                var coordinate1 = 0.0, coordinate2 = 0.0;

                switch (type1) {
                    case FarseerPhysics.Dynamics.Joints.JointType.Revolute: 
                        this.BodyA = jointA.BodyB;
                        this._revolute1 = Bridge.cast(jointA, FarseerPhysics.Dynamics.Joints.RevoluteJoint);
                        this.LocalAnchor1 = this._revolute1.LocalAnchorB.$clone();
                        coordinate1 = this._revolute1.JointAngle;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.Prismatic: 
                        this.BodyA = jointA.BodyB;
                        this._prismatic1 = Bridge.cast(jointA, FarseerPhysics.Dynamics.Joints.PrismaticJoint);
                        this.LocalAnchor1 = this._prismatic1.LocalAnchorB.$clone();
                        coordinate1 = this._prismatic1.JointTranslation;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute: 
                        this.BodyA = jointA.BodyA;
                        this._fixedRevolute1 = Bridge.cast(jointA, FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint);
                        this.LocalAnchor1 = this._fixedRevolute1.LocalAnchorA.$clone();
                        coordinate1 = this._fixedRevolute1.JointAngle;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic: 
                        this.BodyA = jointA.BodyA;
                        this._fixedPrismatic1 = Bridge.cast(jointA, FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint);
                        this.LocalAnchor1 = this._fixedPrismatic1.LocalAnchorA.$clone();
                        coordinate1 = this._fixedPrismatic1.JointTranslation;
                        break;
                }

                switch (type2) {
                    case FarseerPhysics.Dynamics.Joints.JointType.Revolute: 
                        this.BodyB = jointB.BodyB;
                        this._revolute2 = Bridge.cast(jointB, FarseerPhysics.Dynamics.Joints.RevoluteJoint);
                        this.LocalAnchor2 = this._revolute2.LocalAnchorB.$clone();
                        coordinate2 = this._revolute2.JointAngle;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.Prismatic: 
                        this.BodyB = jointB.BodyB;
                        this._prismatic2 = Bridge.cast(jointB, FarseerPhysics.Dynamics.Joints.PrismaticJoint);
                        this.LocalAnchor2 = this._prismatic2.LocalAnchorB.$clone();
                        coordinate2 = this._prismatic2.JointTranslation;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute: 
                        this.BodyB = jointB.BodyA;
                        this._fixedRevolute2 = Bridge.cast(jointB, FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint);
                        this.LocalAnchor2 = this._fixedRevolute2.LocalAnchorA.$clone();
                        coordinate2 = this._fixedRevolute2.JointAngle;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic: 
                        this.BodyB = jointB.BodyA;
                        this._fixedPrismatic2 = Bridge.cast(jointB, FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint);
                        this.LocalAnchor2 = this._fixedPrismatic2.LocalAnchorA.$clone();
                        coordinate2 = this._fixedPrismatic2.JointTranslation;
                        break;
                }

                this._ant = coordinate1 + this.Ratio * coordinate2;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._J.LinearB.$clone());
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, P.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                this.BodyB.GetTransform(xf1);

                var r = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchor2.$clone(), this.BodyB.LocalCenter.$clone()));
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._J.LinearB.$clone());
                var L = this._impulse * this._J.AngularB - FarseerPhysics.Common.MathUtils.Cross$2(r.$clone(), P.$clone());
                return inv_dt * L;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var K = 0.0;
                this._J.SetZero();

                if (this._revolute1 != null || this._fixedRevolute1 != null) {
                    this._J.AngularA = -1.0;
                    K += b1.InvI;
                } else {
                    var ug = new Microsoft.Xna.Framework.Vector2();
                    if (this._prismatic1 != null) {
                        ug = this._prismatic1.LocalXAxis1.$clone();
                    } else {
                        ug = this._fixedPrismatic1.LocalXAxis1.$clone();
                    }

                    var xf1 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf1);


                    var r = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchor1.$clone(), b1.LocalCenter.$clone()));
                    var crug = FarseerPhysics.Common.MathUtils.Cross$2(r.$clone(), ug.$clone());
                    this._J.LinearA = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(ug.$clone());
                    this._J.AngularA = -crug;
                    K += b1.InvMass + b1.InvI * crug * crug;
                }

                if (this._revolute2 != null || this._fixedRevolute2 != null) {
                    this._J.AngularB = -this.Ratio;
                    K += this.Ratio * this.Ratio * b2.InvI;
                } else {
                    var ug1 = new Microsoft.Xna.Framework.Vector2();
                    if (this._prismatic2 != null) {
                        ug1 = this._prismatic2.LocalXAxis1.$clone();
                    } else {
                        ug1 = this._fixedPrismatic2.LocalXAxis1.$clone();
                    }

                    var xf2 = { v : new FarseerPhysics.Common.Transform() };
                    b2.GetTransform(xf2);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchor2.$clone(), b2.LocalCenter.$clone()));
                    var crug1 = FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), ug1.$clone());
                    this._J.LinearB = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio, ug1.$clone());
                    this._J.AngularB = -this.Ratio * crug1;
                    K += this.Ratio * this.Ratio * (b2.InvMass + b2.InvI * crug1 * crug1);
                }

                System.Diagnostics.Debug.Assert(K > 0.0);
                this._mass = K > 0.0 ? 1.0 / K : 0.0;

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass * this._impulse, this._J.LinearA.$clone()));
                    b1.AngularVelocityInternal += b1.InvI * this._impulse * this._J.AngularA;
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass * this._impulse, this._J.LinearB.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * this._impulse * this._J.AngularB;
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var Cdot = this._J.Compute(b1.LinearVelocityInternal.$clone(), b1.AngularVelocityInternal, b2.LinearVelocityInternal.$clone(), b2.AngularVelocityInternal);

                var impulse = this._mass * (-Cdot);
                this._impulse += impulse;

                b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass * impulse, this._J.LinearA.$clone()));
                b1.AngularVelocityInternal += b1.InvI * impulse * this._J.AngularA;
                b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass * impulse, this._J.LinearB.$clone()));
                b2.AngularVelocityInternal += b2.InvI * impulse * this._J.AngularB;
            },
            SolvePositionConstraints: function () {
                var linearError = 0.0;

                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var coordinate1 = 0.0, coordinate2 = 0.0;
                if (this._revolute1 != null) {
                    coordinate1 = this._revolute1.JointAngle;
                } else if (this._fixedRevolute1 != null) {
                    coordinate1 = this._fixedRevolute1.JointAngle;
                } else if (this._prismatic1 != null) {
                    coordinate1 = this._prismatic1.JointTranslation;
                } else if (this._fixedPrismatic1 != null) {
                    coordinate1 = this._fixedPrismatic1.JointTranslation;
                }

                if (this._revolute2 != null) {
                    coordinate2 = this._revolute2.JointAngle;
                } else if (this._fixedRevolute2 != null) {
                    coordinate2 = this._fixedRevolute2.JointAngle;
                } else if (this._prismatic2 != null) {
                    coordinate2 = this._prismatic2.JointTranslation;
                } else if (this._fixedPrismatic2 != null) {
                    coordinate2 = this._fixedPrismatic2.JointTranslation;
                }

                var C = this._ant - (coordinate1 + this.Ratio * coordinate2);

                var impulse = this._mass * (-C);

                b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass * impulse, this._J.LinearA.$clone()));
                b1.Sweep.A += b1.InvI * impulse * this._J.AngularA;
                b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass * impulse, this._J.LinearB.$clone()));
                b2.Sweep.A += b2.InvI * impulse * this._J.AngularB;

                b1.SynchronizeTransform();
                b2.SynchronizeTransform();

                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.LineJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _ax: null,
            _ay: null,
            _bias: 0,
            _enableMotor: false,
            _gamma: 0,
            _impulse: 0,
            _localXAxis: null,
            _localYAxisA: null,
            _mass: 0,
            _maxMotorTorque: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _sAx: 0,
            _sAy: 0,
            _sBx: 0,
            _sBy: 0,
            _springImpulse: 0,
            _springMass: 0,
            LocalAnchorA: null,
            LocalAnchorB: null,
            Frequency: 0,
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            JointTranslation: {
                get: function () {
                    var bA = this.BodyA;
                    var bB = this.BodyB;

                    var pA = bA.GetWorldPoint(this.LocalAnchorA.$clone());
                    var pB = bB.GetWorldPoint(this.LocalAnchorB.$clone());
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(pB.$clone(), pA.$clone());
                    var axis = bA.GetWorldVector(this.LocalXAxis.$clone());

                    var translation = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), axis.$clone());
                    return translation;
                }
            },
            JointSpeed: {
                get: function () {
                    var wA = this.BodyA.AngularVelocityInternal;
                    var wB = this.BodyB.AngularVelocityInternal;
                    return wB - wA;
                }
            },
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._enableMotor = value;
                }
            },
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._motorSpeed = value;
                }
            },
            MaxMotorTorque: {
                get: function () {
                    return this._maxMotorTorque;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._maxMotorTorque = value;
                }
            },
            LocalXAxis: {
                get: function () {
                    return this._localXAxis.$clone();
                },
                set: function (value) {
                    this._localXAxis = value.$clone();
                    this._localYAxisA = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis.$clone());
                }
            }
        },
        ctors: {
            init: function () {
                this._ax = new Microsoft.Xna.Framework.Vector2();
                this._ay = new Microsoft.Xna.Framework.Vector2();
                this._localXAxis = new Microsoft.Xna.Framework.Vector2();
                this._localYAxisA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Line;
            },
            $ctor1: function (bA, bB, anchor, axis) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bA, bB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Line;

                this.LocalAnchorA = bA.GetLocalPoint(anchor.$clone());
                this.LocalAnchorB = bB.GetLocalPoint(anchor.$clone());
                this.LocalXAxis = bA.GetLocalVector(axis.$clone());
            }
        },
        methods: {
            GetReactionForce: function (invDt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._ay.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse, this._ax.$clone()))));
            },
            GetReactionTorque: function (invDt) {
                return invDt * this._motorImpulse;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                this.LocalCenterA = bA.LocalCenter.$clone();
                this.LocalCenterB = bB.LocalCenter.$clone();

                var xfA = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                var xfB = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), rB.$clone()), bA.Sweep.C.$clone()), rA.$clone());

                this.InvMassA = bA.InvMass;
                this.InvIA = bA.InvI;
                this.InvMassB = bB.InvMass;
                this.InvIB = bB.InvI;

                {
                    this._ay = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), this._localYAxisA.$clone());
                    this._sAy = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), this._ay.$clone());
                    this._sBy = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), this._ay.$clone());

                    this._mass = this.InvMassA + this.InvMassB + this.InvIA * this._sAy * this._sAy + this.InvIB * this._sBy * this._sBy;

                    if (this._mass > 0.0) {
                        this._mass = 1.0 / this._mass;
                    }
                }

                this._springMass = 0.0;
                if (this.Frequency > 0.0) {
                    this._ax = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), this.LocalXAxis.$clone());
                    this._sAx = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), this._ax.$clone());
                    this._sBx = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), this._ax.$clone());

                    var invMass = this.InvMassA + this.InvMassB + this.InvIA * this._sAx * this._sAx + this.InvIB * this._sBx * this._sBx;

                    if (invMass > 0.0) {
                        this._springMass = 1.0 / invMass;

                        var C = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), this._ax.$clone());

                        var omega = 6.28318548 * this.Frequency;

                        var da = 2.0 * this._springMass * this.DampingRatio * omega;

                        var k = this._springMass * omega * omega;

                        this._gamma = step.v.dt * (da + step.v.dt * k);
                        if (this._gamma > 0.0) {
                            this._gamma = 1.0 / this._gamma;
                        }

                        this._bias = C * step.v.dt * k * this._gamma;

                        this._springMass = invMass + this._gamma;
                        if (this._springMass > 0.0) {
                            this._springMass = 1.0 / this._springMass;
                        }
                    }
                } else {
                    this._springImpulse = 0.0;
                    this._springMass = 0.0;
                }

                if (this._enableMotor) {
                    this._motorMass = this.InvIA + this.InvIB;
                    if (this._motorMass > 0.0) {
                        this._motorMass = 1.0 / this._motorMass;
                    }
                } else {
                    this._motorMass = 0.0;
                    this._motorImpulse = 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;
                    this._springImpulse *= step.v.dtRatio;
                    this._motorImpulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._ay.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse, this._ax.$clone()));
                    var LA = this._impulse * this._sAy + this._springImpulse * this._sAx + this._motorImpulse;
                    var LB = this._impulse * this._sBy + this._springImpulse * this._sBx + this._motorImpulse;

                    bA.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    bA.AngularVelocityInternal -= this.InvIA * LA;

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    bB.AngularVelocityInternal += this.InvIB * LB;
                } else {
                    this._impulse = 0.0;
                    this._springImpulse = 0.0;
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var vA = bA.LinearVelocity.$clone();
                var wA = bA.AngularVelocityInternal;
                var vB = bB.LinearVelocityInternal.$clone();
                var wB = bB.AngularVelocityInternal;

                {
                    var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._ax.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone())) + this._sBx * wB - this._sAx * wA;
                    var impulse = -this._springMass * (Cdot + this._bias + this._gamma * this._springImpulse);
                    this._springImpulse += impulse;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._ax.$clone());
                    var LA = impulse * this._sAx;
                    var LB = impulse * this._sBx;

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    wA -= this.InvIA * LA;

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    wB += this.InvIB * LB;
                }

                {
                    var Cdot1 = wB - wA - this._motorSpeed;
                    var impulse1 = -this._motorMass * Cdot1;

                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorTorque;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse1, -maxImpulse, maxImpulse);
                    impulse1 = this._motorImpulse - oldImpulse;

                    wA -= this.InvIA * impulse1;
                    wB += this.InvIB * impulse1;
                }

                {
                    var Cdot2 = Microsoft.Xna.Framework.Vector2.Dot(this._ay.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone())) + this._sBy * wB - this._sAy * wA;
                    var impulse2 = this._mass * (-Cdot2);
                    this._impulse += impulse2;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse2, this._ay.$clone());
                    var LA1 = impulse2 * this._sAy;
                    var LB1 = impulse2 * this._sBy;

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P1.$clone()));
                    wA -= this.InvIA * LA1;

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P1.$clone()));
                    wB += this.InvIB * LB1;
                }

                bA.LinearVelocityInternal = vA.$clone();
                bA.AngularVelocityInternal = wA;
                bB.LinearVelocityInternal = vB.$clone();
                bB.AngularVelocityInternal = wB;
            },
            SolvePositionConstraints: function () {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xA = bA.Sweep.C.$clone();
                var angleA = bA.Sweep.A;

                var xB = bB.Sweep.C.$clone();
                var angleB = bB.Sweep.A;

                var RA = { v : new FarseerPhysics.Common.Mat22.$ctor2(angleA) };
                var RB = { v : new FarseerPhysics.Common.Mat22.$ctor2(angleB) };

                var rA = FarseerPhysics.Common.MathUtils.Multiply(RA, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(RB, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(xB.$clone(), rB.$clone()), xA.$clone()), rA.$clone());

                var ay = FarseerPhysics.Common.MathUtils.Multiply(RA, this._localYAxisA.$clone());

                var sAy = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), ay.$clone());
                var sBy = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), ay.$clone());

                var C = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), ay.$clone());

                var k = this.InvMassA + this.InvMassB + this.InvIA * this._sAy * this._sAy + this.InvIB * this._sBy * this._sBy;

                var impulse;
                if (k !== 0.0) {
                    impulse = -C / k;
                } else {
                    impulse = 0.0;
                }

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, ay.$clone());
                var LA = impulse * sAy;
                var LB = impulse * sBy;

                xA = Microsoft.Xna.Framework.Vector2.op_Subtraction(xA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                angleA -= this.InvIA * LA;
                xB = Microsoft.Xna.Framework.Vector2.op_Addition(xB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                angleB += this.InvIB * LB;

                bA.Sweep.C = xA.$clone();
                bA.Sweep.A = angleA;
                bB.Sweep.C = xB.$clone();
                bB.Sweep.A = angleB;
                bA.SynchronizeTransform();
                bB.SynchronizeTransform();

                return Math.abs(C) <= FarseerPhysics.Settings.LinearSlop;
            },
            GetMotorTorque: function (invDt) {
                return invDt * this._motorImpulse;
            }
        }
    });

    /**
     * A prismatic joint. This joint provides one degree of freedom: translation
     along an axis fixed in body1. Relative rotation is prevented. You can
     use a joint limit to restrict the range of motion and a joint motor to
     drive the motion or to model joint friction.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.PrismaticJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.PrismaticJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _K: null,
            _a1: 0,
            _a2: 0,
            _axis: null,
            _enableLimit: false,
            _enableMotor: false,
            _impulse: null,
            _limitState: 0,
            _localXAxis1: null,
            _localYAxis1: null,
            _lowerTranslation: 0,
            _maxMotorForce: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _perp: null,
            _refAngle: 0,
            _s1: 0,
            _s2: 0,
            _upperTranslation: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            /**
             * Get the current joint translation, usually in meters.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function JointTranslation
             * @type number
             */
            JointTranslation: {
                get: function () {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone()), this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone()));
                    var axis = this.BodyA.GetWorldVector$1(Bridge.ref(this, "_localXAxis1"));

                    return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), axis.$clone());
                }
            },
            /**
             * Get the current joint translation speed, usually in meters per second.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function JointSpeed
             * @type number
             */
            JointSpeed: {
                get: function () {
                    var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                    this.BodyA.GetTransform(xf1);
                    this.BodyB.GetTransform(xf2);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.BodyA.LocalCenter.$clone()));
                    var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.BodyB.LocalCenter.$clone()));
                    var p1 = Microsoft.Xna.Framework.Vector2.op_Addition(this.BodyA.Sweep.C.$clone(), r1.$clone());
                    var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(this.BodyB.Sweep.C.$clone(), r2.$clone());
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());
                    var axis = this.BodyA.GetWorldVector$1(Bridge.ref(this, "_localXAxis1"));

                    var v1 = this.BodyA.LinearVelocityInternal.$clone();
                    var v2 = this.BodyB.LinearVelocityInternal.$clone();
                    var w1 = this.BodyA.AngularVelocityInternal;
                    var w2 = this.BodyB.AngularVelocityInternal;

                    var speed = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w1, axis.$clone())) + Microsoft.Xna.Framework.Vector2.Dot(axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w2, r2.$clone())), v1.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(w1, r1.$clone())));
                    return speed;
                }
            },
            /**
             * Is the joint limit enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function LimitEnabled
             * @type boolean
             */
            LimitEnabled: {
                get: function () {
                    return this._enableLimit;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(this.BodyA.FixedRotation === false || this.BodyB.FixedRotation === false, "Warning: limits does currently not work with fixed rotation");

                    this.WakeBodies();
                    this._enableLimit = value;
                }
            },
            /**
             * Get the lower joint limit, usually in meters.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function LowerLimit
             * @type number
             */
            LowerLimit: {
                get: function () {
                    return this._lowerTranslation;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._lowerTranslation = value;
                }
            },
            /**
             * Get the upper joint limit, usually in meters.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function UpperLimit
             * @type number
             */
            UpperLimit: {
                get: function () {
                    return this._upperTranslation;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._upperTranslation = value;
                }
            },
            /**
             * Is the joint motor enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function MotorEnabled
             * @type boolean
             */
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableMotor = value;
                }
            },
            /**
             * Set the motor speed, usually in meters per second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function MotorSpeed
             * @type number
             */
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorSpeed = value;
                }
            },
            /**
             * Set the maximum motor force, usually in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function MaxMotorForce
             * @type number
             */
            MaxMotorForce: {
                get: function () {
                    return this._maxMotorForce;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._maxMotorForce = value;
                }
            },
            /**
             * Get the current motor force, usually in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function MotorForce
             * @type number
             */
            MotorForce: {
                get: function () {
                    return this._motorImpulse;
                },
                set: function (value) {
                    this._motorImpulse = value;
                }
            },
            LocalXAxis1: {
                get: function () {
                    return this._localXAxis1.$clone();
                },
                set: function (value) {
                    this._localXAxis1 = this.BodyA.GetLocalVector(value.$clone());
                    this._localYAxis1 = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis1.$clone());
                }
            },
            ReferenceAngle: {
                get: function () {
                    return this._refAngle;
                },
                set: function (value) {
                    this._refAngle = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._K = new FarseerPhysics.Common.Mat33();
                this._axis = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._localXAxis1 = new Microsoft.Xna.Framework.Vector2();
                this._localYAxis1 = new Microsoft.Xna.Framework.Vector2();
                this._perp = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Prismatic;
            },
            /**
             * This requires defining a line of
             motion using an axis and an anchor point. The definition uses local
             anchor points and a local axis so that the initial configuration
             can violate the constraint slightly. The joint translation is zero
             when the local anchor points coincide in world space. Using local
             anchors and a local axis helps when saving and loading a game.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body.
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    axis            The axis.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB, axis) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Prismatic;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                this._localXAxis1 = this.BodyA.GetLocalVector(axis.$clone());
                this._localYAxis1 = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis1.$clone());
                this._refAngle = this.BodyB.Rotation - this.BodyA.Rotation;

                this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this._motorImpulse + this._impulse.Z), this._axis.$clone()))));
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Y;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                this.LocalCenterA = b1.LocalCenter.$clone();
                this.LocalCenterB = b2.LocalCenter.$clone();

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());

                this.InvMassA = b1.InvMass;
                this.InvIA = b1.InvI;
                this.InvMassB = b2.InvMass;
                this.InvIB = b2.InvI;

                {
                    this._axis = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), this._localXAxis1.$clone());
                    this._a1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._axis.$clone());
                    this._a2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._axis.$clone());

                    this._motorMass = this.InvMassA + this.InvMassB + this.InvIA * this._a1 * this._a1 + this.InvIB * this._a2 * this._a2;

                    if (this._motorMass > FarseerPhysics.Settings.Epsilon) {
                        this._motorMass = 1.0 / this._motorMass;
                    }
                }

                {
                    this._perp = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), this._localYAxis1.$clone());

                    this._s1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._perp.$clone());
                    this._s2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._perp.$clone());

                    var m1 = this.InvMassA, m2 = this.InvMassB;
                    var i1 = this.InvIA, i2 = this.InvIB;

                    var k11 = m1 + m2 + i1 * this._s1 * this._s1 + i2 * this._s2 * this._s2;
                    var k12 = i1 * this._s1 + i2 * this._s2;
                    var k13 = i1 * this._s1 * this._a1 + i2 * this._s2 * this._a2;
                    var k22 = i1 + i2;
                    var k23 = i1 * this._a1 + i2 * this._a2;
                    var k33 = m1 + m2 + i1 * this._a1 * this._a1 + i2 * this._a2 * this._a2;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k11, k12, k13);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k12, k22, k23);
                    this._K.Col3 = new Microsoft.Xna.Framework.Vector3.$ctor3(k13, k23, k33);
                }

                if (this._enableLimit) {
                    var jointTranslation = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), d.$clone());
                    if (Math.abs(this._upperTranslation - this._lowerTranslation) < 0.01) {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Equal;
                    } else if (jointTranslation <= this._lowerTranslation) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                            this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtLower;
                            this._impulse.Z = 0.0;
                        }
                    } else if (jointTranslation >= this._upperTranslation) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                            this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                            this._impulse.Z = 0.0;
                        }
                    } else {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                        this._impulse.Z = 0.0;
                    }
                } else {
                    this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (this._enableMotor === false) {
                    this._motorImpulse = 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                    this._motorImpulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this._motorImpulse + this._impulse.Z), this._axis.$clone()));
                    var L1 = this._impulse.X * this._s1 + this._impulse.Y + (this._motorImpulse + this._impulse.Z) * this._a1;
                    var L2 = this._impulse.X * this._s2 + this._impulse.Y + (this._motorImpulse + this._impulse.Z) * this._a2;

                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    b1.AngularVelocityInternal -= this.InvIA * L1;

                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    b2.AngularVelocityInternal += this.InvIB * L2;
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var v1 = b1.LinearVelocityInternal.$clone();
                var w1 = b1.AngularVelocityInternal;
                var v2 = b2.LinearVelocityInternal.$clone();
                var w2 = b2.AngularVelocityInternal;

                if (this._enableMotor && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                    var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._a2 * w2 - this._a1 * w1;
                    var impulse = this._motorMass * (this._motorSpeed - Cdot);
                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorForce;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._motorImpulse - oldImpulse;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._axis.$clone());
                    var L1 = impulse * this._a1;
                    var L2 = impulse * this._a2;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    w1 -= this.InvIA * L1;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    w2 += this.InvIB * L2;
                }

                var Cdot1 = new Microsoft.Xna.Framework.Vector2.$ctor2(Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._s2 * w2 - this._s1 * w1, w2 - w1);

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var Cdot2 = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._a2 * w2 - this._a1 * w1;
                    var Cdot3 = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                    var f1 = this._impulse.$clone();
                    var df = this._K.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), df.$clone());

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        this._impulse.Z = Math.max(this._impulse.Z, 0.0);
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        this._impulse.Z = Math.min(this._impulse.Z, 0.0);
                    }

                    var b = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this._impulse.Z - f1.Z), new Microsoft.Xna.Framework.Vector2.$ctor2(this._K.Col3.X, this._K.Col3.Y)));
                    var f2r = Microsoft.Xna.Framework.Vector2.op_Addition(this._K.Solve22(b.$clone()), new Microsoft.Xna.Framework.Vector2.$ctor2(f1.X, f1.Y));
                    this._impulse.X = f2r.X;
                    this._impulse.Y = f2r.Y;

                    df = Microsoft.Xna.Framework.Vector3.op_Subtraction(this._impulse.$clone(), f1.$clone());

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.Z, this._axis.$clone()));
                    var L11 = df.X * this._s1 + df.Y + df.Z * this._a1;
                    var L21 = df.X * this._s2 + df.Y + df.Z * this._a2;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P1.$clone()));
                    w1 -= this.InvIA * L11;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P1.$clone()));
                    w2 += this.InvIB * L21;
                } else {
                    var df1 = this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                    this._impulse.X += df1.X;
                    this._impulse.Y += df1.Y;

                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(df1.X, this._perp.$clone());
                    var L12 = df1.X * this._s1 + df1.Y;
                    var L22 = df1.X * this._s2 + df1.Y;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P2.$clone()));
                    w1 -= this.InvIA * L12;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P2.$clone()));
                    w2 += this.InvIB * L22;
                }

                b1.LinearVelocityInternal = v1.$clone();
                b1.AngularVelocityInternal = w1;
                b2.LinearVelocityInternal = v2.$clone();
                b2.AngularVelocityInternal = w2;
            },
            SolvePositionConstraints: function () {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var c1 = b1.Sweep.C.$clone();
                var a1 = b1.Sweep.A;

                var c2 = b2.Sweep.C.$clone();
                var a2 = b2.Sweep.A;

                var linearError = 0.0;
                var active = false;
                var C2 = 0.0;

                var R1 = { v : new FarseerPhysics.Common.Mat22.$ctor2(a1) };
                var R2 = { v : new FarseerPhysics.Common.Mat22.$ctor2(a2) };

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(R1, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(R2, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(c2.$clone(), r2.$clone()), c1.$clone()), r1.$clone());

                if (this._enableLimit) {
                    this._axis = FarseerPhysics.Common.MathUtils.Multiply(R1, this._localXAxis1.$clone());

                    this._a1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._axis.$clone());
                    this._a2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._axis.$clone());

                    var translation = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), d.$clone());
                    if (Math.abs(this._upperTranslation - this._lowerTranslation) < 0.01) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);
                        linearError = Math.abs(translation);
                        active = true;
                    } else if (translation <= this._lowerTranslation) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation - this._lowerTranslation + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                        linearError = this._lowerTranslation - translation;
                        active = true;
                    } else if (translation >= this._upperTranslation) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation - this._upperTranslation - FarseerPhysics.Settings.LinearSlop, 0.0, FarseerPhysics.Settings.MaxLinearCorrection);
                        linearError = translation - this._upperTranslation;
                        active = true;
                    }
                }

                this._perp = FarseerPhysics.Common.MathUtils.Multiply(R1, this._localYAxis1.$clone());

                this._s1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._perp.$clone());
                this._s2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._perp.$clone());

                var impulse = new Microsoft.Xna.Framework.Vector3();
                var C1 = new Microsoft.Xna.Framework.Vector2.$ctor2(Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(), d.$clone()), a2 - a1 - this.ReferenceAngle);

                linearError = Math.max(linearError, Math.abs(C1.X));
                var angularError = Math.abs(C1.Y);

                if (active) {
                    var m1 = this.InvMassA, m2 = this.InvMassB;
                    var i1 = this.InvIA, i2 = this.InvIB;

                    var k11 = m1 + m2 + i1 * this._s1 * this._s1 + i2 * this._s2 * this._s2;
                    var k12 = i1 * this._s1 + i2 * this._s2;
                    var k13 = i1 * this._s1 * this._a1 + i2 * this._s2 * this._a2;
                    var k22 = i1 + i2;
                    var k23 = i1 * this._a1 + i2 * this._a2;
                    var k33 = m1 + m2 + i1 * this._a1 * this._a1 + i2 * this._a2 * this._a2;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k11, k12, k13);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k12, k22, k23);
                    this._K.Col3 = new Microsoft.Xna.Framework.Vector3.$ctor3(k13, k23, k33);

                    var C = new Microsoft.Xna.Framework.Vector3.$ctor3(-C1.X, -C1.Y, -C2);
                    impulse = this._K.Solve33(C.$clone());
                } else {
                    var m11 = this.InvMassA, m21 = this.InvMassB;
                    var i11 = this.InvIA, i21 = this.InvIB;

                    var k111 = m11 + m21 + i11 * this._s1 * this._s1 + i21 * this._s2 * this._s2;
                    var k121 = i11 * this._s1 + i21 * this._s2;
                    var k221 = i11 + i21;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k111, k121, 0.0);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k121, k221, 0.0);

                    var impulse1 = this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C1.$clone()));
                    impulse.X = impulse1.X;
                    impulse.Y = impulse1.Y;
                    impulse.Z = 0.0;
                }

                var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.Z, this._axis.$clone()));
                var L1 = impulse.X * this._s1 + impulse.Y + impulse.Z * this._a1;
                var L2 = impulse.X * this._s2 + impulse.Y + impulse.Z * this._a2;

                c1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(c1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                a1 -= this.InvIA * L1;
                c2 = Microsoft.Xna.Framework.Vector2.op_Addition(c2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                a2 += this.InvIB * L2;

                b1.Sweep.C = c1.$clone();
                b1.Sweep.A = a1;
                b2.Sweep.C = c2.$clone();
                b2.Sweep.A = a2;
                b1.SynchronizeTransform();
                b2.SynchronizeTransform();

                return linearError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    /**
     * The pulley joint is connected to two bodies and two fixed ground points.
     The pulley supports a ratio such that:
     length1 + ratio * length2 <!--<-->= ant
     Yes, the force transmitted is scaled by the ratio.
     The pulley also enforces a maximum length limit on both sides. This is
     useful to prevent one side of the pulley hitting the top.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.PulleyJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.PulleyJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            /**
             * Get the first ground anchor.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            GroundAnchorA: null,
            /**
             * Get the second ground anchor.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            GroundAnchorB: null,
            LocalAnchorA: null,
            LocalAnchorB: null,
            MinPulleyLength: 0,
            _ant: 0,
            _impulse: 0,
            _lengthA: 0,
            _lengthB: 0,
            _limitImpulse1: 0,
            _limitImpulse2: 0,
            _limitMass1: 0,
            _limitMass2: 0,
            _limitState1: 0,
            _limitState2: 0,
            _maxLengthA: 0,
            _maxLengthB: 0,
            _pulleyMass: 0,
            _state: 0,
            _u1: null,
            _u2: null,
            /**
             * Get the pulley ratio.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @function Ratio
             * @type number
             */
            Ratio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            /**
             * Get the current length of the segment attached to body1.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @function LengthA
             * @type number
             */
            LengthA: {
                get: function () {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone()), this.GroundAnchorA.$clone());
                    return d.Length();
                },
                set: function (value) {
                    this._lengthA = value;
                }
            },
            /**
             * Get the current length of the segment attached to body2.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @function LengthB
             * @type number
             */
            LengthB: {
                get: function () {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone()), this.GroundAnchorB.$clone());
                    return d.Length();
                },
                set: function (value) {
                    this._lengthB = value;
                }
            },
            MaxLengthA: {
                get: function () {
                    return this._maxLengthA;
                },
                set: function (value) {
                    this._maxLengthA = value;
                }
            },
            MaxLengthB: {
                get: function () {
                    return this._maxLengthB;
                },
                set: function (value) {
                    this._maxLengthB = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.GroundAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.GroundAnchorB = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._u1 = new Microsoft.Xna.Framework.Vector2();
                this._u2 = new Microsoft.Xna.Framework.Vector2();
                this.MinPulleyLength = 2.0;
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Pulley;
            },
            /**
             * Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
             This requires two ground anchors,
             two dynamic body anchor points, max lengths for each side,
             and a pulley ratio.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA            The first body.
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB            The second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    groundAnchorA    The ground anchor for the first body.
             * @param   {Microsoft.Xna.Framework.Vector2}    groundAnchorB    The ground anchor for the second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA     The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB     The second body anchor.
             * @param   {number}                             ratio            The ratio.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, groundAnchorA, groundAnchorB, localAnchorA, localAnchorB, ratio) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Pulley;

                this.GroundAnchorA = groundAnchorA.$clone();
                this.GroundAnchorB = groundAnchorB.$clone();
                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                var d1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyA.GetWorldPoint(localAnchorA.$clone()), groundAnchorA.$clone());
                this._lengthA = d1.Length();

                var d2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(localAnchorB.$clone()), groundAnchorB.$clone());
                this._lengthB = d2.Length();

                System.Diagnostics.Debug.Assert(ratio !== 0.0);
                System.Diagnostics.Debug.Assert(ratio > FarseerPhysics.Settings.Epsilon);
                this.Ratio = ratio;

                var C = this._lengthA + this.Ratio * this._lengthB;

                this.MaxLengthA = C - this.Ratio * this.MinPulleyLength;
                this.MaxLengthB = (C - this.MinPulleyLength) / this.Ratio;

                this._ant = this._lengthA + this.Ratio * this._lengthB;

                this.MaxLengthA = Math.min(this.MaxLengthA, this._ant - this.Ratio * this.MinPulleyLength);
                this.MaxLengthB = Math.min(this.MaxLengthB, (this._ant - this.MinPulleyLength) / this.Ratio);

                this._impulse = 0.0;
                this._limitImpulse1 = 0.0;
                this._limitImpulse2 = 0.0;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u2.$clone());
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, P.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                return 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                var p1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), r1.$clone());
                var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone());

                var s1 = this.GroundAnchorA.$clone();
                var s2 = this.GroundAnchorB.$clone();

                this._u1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p1.$clone(), s1.$clone());
                this._u2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), s2.$clone());

                var length1 = this._u1.Length();
                var length2 = this._u2.Length();

                if (length1 > FarseerPhysics.Settings.LinearSlop) {
                    this._u1 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u1.$clone(), 1.0 / length1);
                } else {
                    this._u1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                if (length2 > FarseerPhysics.Settings.LinearSlop) {
                    this._u2 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u2.$clone(), 1.0 / length2);
                } else {
                    this._u2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                var C = this._ant - length1 - this.Ratio * length2;
                if (C > 0.0) {
                    this._state = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                    this._impulse = 0.0;
                } else {
                    this._state = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                }

                if (length1 < this.MaxLengthA) {
                    this._limitState1 = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                    this._limitImpulse1 = 0.0;
                } else {
                    this._limitState1 = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                }

                if (length2 < this.MaxLengthB) {
                    this._limitState2 = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                    this._limitImpulse2 = 0.0;
                } else {
                    this._limitState2 = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                }

                var cr1u1 = FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), this._u1.$clone());
                var cr2u2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._u2.$clone());

                this._limitMass1 = b1.InvMass + b1.InvI * cr1u1 * cr1u1;
                this._limitMass2 = b2.InvMass + b2.InvI * cr2u2 * cr2u2;
                this._pulleyMass = this._limitMass1 + this.Ratio * this.Ratio * this._limitMass2;
                System.Diagnostics.Debug.Assert(this._limitMass1 > FarseerPhysics.Settings.Epsilon);
                System.Diagnostics.Debug.Assert(this._limitMass2 > FarseerPhysics.Settings.Epsilon);
                System.Diagnostics.Debug.Assert(this._pulleyMass > FarseerPhysics.Settings.Epsilon);
                this._limitMass1 = 1.0 / this._limitMass1;
                this._limitMass2 = 1.0 / this._limitMass2;
                this._pulleyMass = 1.0 / this._pulleyMass;

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;
                    this._limitImpulse1 *= step.v.dtRatio;
                    this._limitImpulse2 *= step.v.dtRatio;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-(this._impulse + this._limitImpulse1), this._u1.$clone());
                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2((-this.Ratio * this._impulse - this._limitImpulse2), this._u2.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P1.$clone()));
                    b1.AngularVelocityInternal += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P1.$clone());
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P2.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P2.$clone());
                } else {
                    this._impulse = 0.0;
                    this._limitImpulse1 = 0.0;
                    this._limitImpulse2 = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                if (this._state === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var v1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b1.AngularVelocityInternal, r1.$clone()));
                    var v2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b2.AngularVelocityInternal, r2.$clone()));

                    var Cdot = -Microsoft.Xna.Framework.Vector2.Dot(this._u1.$clone(), v1.$clone()) - this.Ratio * Microsoft.Xna.Framework.Vector2.Dot(this._u2.$clone(), v2.$clone());
                    var impulse = this._pulleyMass * (-Cdot);
                    var oldImpulse = this._impulse;
                    this._impulse = Math.max(0.0, this._impulse + impulse);
                    impulse = this._impulse - oldImpulse;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse, this._u1.$clone());
                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio * impulse, this._u2.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P1.$clone()));
                    b1.AngularVelocityInternal += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P1.$clone());
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P2.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P2.$clone());
                }

                if (this._limitState1 === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var v11 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b1.AngularVelocityInternal, r1.$clone()));

                    var Cdot1 = -Microsoft.Xna.Framework.Vector2.Dot(this._u1.$clone(), v11.$clone());
                    var impulse1 = -this._limitMass1 * Cdot1;
                    var oldImpulse1 = this._limitImpulse1;
                    this._limitImpulse1 = Math.max(0.0, this._limitImpulse1 + impulse1);
                    impulse1 = this._limitImpulse1 - oldImpulse1;

                    var P11 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse1, this._u1.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P11.$clone()));
                    b1.AngularVelocityInternal += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P11.$clone());
                }

                if (this._limitState2 === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var v21 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b2.AngularVelocityInternal, r2.$clone()));

                    var Cdot2 = -Microsoft.Xna.Framework.Vector2.Dot(this._u2.$clone(), v21.$clone());
                    var impulse2 = -this._limitMass2 * Cdot2;
                    var oldImpulse2 = this._limitImpulse2;
                    this._limitImpulse2 = Math.max(0.0, this._limitImpulse2 + impulse2);
                    impulse2 = this._limitImpulse2 - oldImpulse2;

                    var P21 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse2, this._u2.$clone());
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P21.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P21.$clone());
                }
            },
            SolvePositionConstraints: function () {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var s1 = this.GroundAnchorA.$clone();
                var s2 = this.GroundAnchorB.$clone();

                var linearError = 0.0;

                if (this._state === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf1);
                    b2.GetTransform(xf2);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                    var p1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), r1.$clone());
                    var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone());

                    this._u1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p1.$clone(), s1.$clone());
                    this._u2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), s2.$clone());

                    var length1 = this._u1.Length();
                    var length2 = this._u2.Length();

                    if (length1 > FarseerPhysics.Settings.LinearSlop) {
                        this._u1 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u1.$clone(), 1.0 / length1);
                    } else {
                        this._u1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    if (length2 > FarseerPhysics.Settings.LinearSlop) {
                        this._u2 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u2.$clone(), 1.0 / length2);
                    } else {
                        this._u2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    var C = this._ant - length1 - this.Ratio * length2;
                    linearError = Math.max(linearError, -C);

                    C = FarseerPhysics.Common.MathUtils.Clamp$2(C + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                    var impulse = -this._pulleyMass * C;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse, this._u1.$clone());
                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio * impulse, this._u2.$clone());

                    b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P1.$clone()));
                    b1.Sweep.A += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P1.$clone());
                    b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P2.$clone()));
                    b2.Sweep.A += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P2.$clone());

                    b1.SynchronizeTransform();
                    b2.SynchronizeTransform();
                }

                if (this._limitState1 === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var xf11 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf11);

                    var r11 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf11.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var p11 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), r11.$clone());

                    this._u1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p11.$clone(), s1.$clone());
                    var length11 = this._u1.Length();

                    if (length11 > FarseerPhysics.Settings.LinearSlop) {
                        this._u1 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u1.$clone(), 1.0 / length11);
                    } else {
                        this._u1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    var C1 = this.MaxLengthA - length11;
                    linearError = Math.max(linearError, -C1);
                    C1 = FarseerPhysics.Common.MathUtils.Clamp$2(C1 + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                    var impulse1 = -this._limitMass1 * C1;

                    var P11 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse1, this._u1.$clone());
                    b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P11.$clone()));
                    b1.Sweep.A += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r11.$clone(), P11.$clone());

                    b1.SynchronizeTransform();
                }

                if (this._limitState2 === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var xf21 = { v : new FarseerPhysics.Common.Transform() };
                    b2.GetTransform(xf21);

                    var r21 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf21.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));
                    var p21 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r21.$clone());

                    this._u2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p21.$clone(), s2.$clone());
                    var length21 = this._u2.Length();

                    if (length21 > FarseerPhysics.Settings.LinearSlop) {
                        this._u2 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u2.$clone(), 1.0 / length21);
                    } else {
                        this._u2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    var C2 = this.MaxLengthB - length21;
                    linearError = Math.max(linearError, -C2);
                    C2 = FarseerPhysics.Common.MathUtils.Clamp$2(C2 + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                    var impulse2 = -this._limitMass2 * C2;

                    var P21 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse2, this._u2.$clone());
                    b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P21.$clone()));
                    b2.Sweep.A += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r21.$clone(), P21.$clone());

                    b2.SynchronizeTransform();
                }

                return linearError < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    /**
     * A revolute joint rains to bodies to share a common point while they
     are free to rotate about the point. The relative rotation about the shared
     point is the joint angle. You can limit the relative rotation with
     a joint limit that specifies a lower and upper angle. You can use a motor
     to drive the relative rotation about the shared point. A maximum motor torque
     is provided so that infinite forces are not generated.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.RevoluteJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.RevoluteJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _enableLimit: false,
            _enableMotor: false,
            _impulse: null,
            _limitState: 0,
            _lowerAngle: 0,
            _mass: null,
            _maxMotorTorque: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _referenceAngle: 0,
            _tmpFloat1: 0,
            _tmpVector1: null,
            _tmpVector2: null,
            _upperAngle: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            ReferenceAngle: {
                get: function () {
                    return this._referenceAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._referenceAngle = value;
                }
            },
            /**
             * Get the current joint angle in radians.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function JointAngle
             * @type number
             */
            JointAngle: {
                get: function () {
                    return this.BodyB.Sweep.A - this.BodyA.Sweep.A - this.ReferenceAngle;
                }
            },
            /**
             * Get the current joint angle speed in radians per second.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function JointSpeed
             * @type number
             */
            JointSpeed: {
                get: function () {
                    return this.BodyB.AngularVelocityInternal - this.BodyA.AngularVelocityInternal;
                }
            },
            /**
             * Is the joint limit enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function LimitEnabled
             * @type boolean
             */
            LimitEnabled: {
                get: function () {
                    return this._enableLimit;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableLimit = value;
                }
            },
            /**
             * Get the lower joint limit in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function LowerLimit
             * @type number
             */
            LowerLimit: {
                get: function () {
                    return this._lowerAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._lowerAngle = value;
                }
            },
            /**
             * Get the upper joint limit in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function UpperLimit
             * @type number
             */
            UpperLimit: {
                get: function () {
                    return this._upperAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._upperAngle = value;
                }
            },
            /**
             * Is the joint motor enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function MotorEnabled
             * @type boolean
             */
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableMotor = value;
                }
            },
            /**
             * Set the motor speed in radians per second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function MotorSpeed
             * @type number
             */
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorSpeed = value;
                }
            },
            /**
             * Set the maximum motor torque, usually in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function MaxMotorTorque
             * @type number
             */
            MaxMotorTorque: {
                get: function () {
                    return this._maxMotorTorque;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._maxMotorTorque = value;
                }
            },
            /**
             * Get the current motor torque, usually in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function MotorTorque
             * @type number
             */
            MotorTorque: {
                get: function () {
                    return this._motorImpulse;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorImpulse = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._mass = new FarseerPhysics.Common.Mat33();
                this._tmpVector1 = new Microsoft.Xna.Framework.Vector2();
                this._tmpVector2 = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Revolute;
            },
            /**
             * Initialize the bodies and local anchor.
             This requires defining an
             anchor point where the bodies are joined. The definition
             uses local anchor points so that the initial configuration
             can violate the constraint slightly. You also need to
             specify the initial relative angle for joint limits. This
             helps when saving and loading a game.
             The local anchor points are measured from the body's origin
             rather than the center of mass because:
             1. you might not know where the center of mass will be.
             2. if you add/remove shapes from a body and recompute the mass,
             the joints will be broken.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body.
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second anchor.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Revolute;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                this.ReferenceAngle = this.BodyB.Rotation - this.BodyA.Rotation;

                this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();

                this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y);
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, P.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Z;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                if (this._enableMotor || this._enableLimit) {
                    System.Diagnostics.Debug.Assert(b1.InvI > 0.0 || b2.InvI > 0.0);
                }

                /* Transform xf1, xf2;
                b1.GetTransform(out xf1);
                b2.GetTransform(out xf2);*/

                var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b1.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b2.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };



                var m1 = b1.InvMass, m2 = b2.InvMass;
                var i1 = b1.InvI, i2 = b2.InvI;

                this._mass.Col1.X = m1 + m2 + r1.v.Y * r1.v.Y * i1 + r2.v.Y * r2.v.Y * i2;
                this._mass.Col2.X = -r1.v.Y * r1.v.X * i1 - r2.v.Y * r2.v.X * i2;
                this._mass.Col3.X = -r1.v.Y * i1 - r2.v.Y * i2;
                this._mass.Col1.Y = this._mass.Col2.X;
                this._mass.Col2.Y = m1 + m2 + r1.v.X * r1.v.X * i1 + r2.v.X * r2.v.X * i2;
                this._mass.Col3.Y = r1.v.X * i1 + r2.v.X * i2;
                this._mass.Col1.Z = this._mass.Col3.X;
                this._mass.Col2.Z = this._mass.Col3.Y;
                this._mass.Col3.Z = i1 + i2;

                this._motorMass = i1 + i2;
                if (this._motorMass > 0.0) {
                    this._motorMass = 1.0 / this._motorMass;
                }

                if (this._enableMotor === false) {
                    this._motorImpulse = 0.0;
                }

                if (this._enableLimit) {
                    var jointAngle = b2.Sweep.A - b1.Sweep.A - this.ReferenceAngle;
                    if (Math.abs(this._upperAngle - this._lowerAngle) < 0.06981318) {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Equal;
                    } else if (jointAngle <= this._lowerAngle) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                            this._impulse.Z = 0.0;
                        }
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtLower;
                    } else if (jointAngle >= this._upperAngle) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                            this._impulse.Z = 0.0;
                        }
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                    } else {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                        this._impulse.Z = 0.0;
                    }
                } else {
                    this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                    this._motorImpulse *= step.v.dtRatio;

                    var P = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y) };

                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                    b1.AngularVelocityInternal -= i1 * (this._tmpFloat1 + this._motorImpulse + this._impulse.Z);

                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m2, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                    b2.AngularVelocityInternal += i2 * (this._tmpFloat1 + this._motorImpulse + this._impulse.Z);
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var v1 = b1.LinearVelocityInternal.$clone();
                var w1 = b1.AngularVelocityInternal;
                var v2 = b2.LinearVelocityInternal.$clone();
                var w2 = b2.AngularVelocityInternal;

                var m1 = b1.InvMass, m2 = b2.InvMass;
                var i1 = b1.InvI, i2 = b2.InvI;

                if (this._enableMotor && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                    var Cdot = w2 - w1 - this._motorSpeed;
                    var impulse = this._motorMass * (-Cdot);
                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorTorque;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._motorImpulse - oldImpulse;

                    w1 -= i1 * impulse;
                    w2 += i2 * impulse;
                }

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    /* Transform xf1, xf2;
                    b1.GetTransform(out xf1);
                    b2.GetTransform(out xf2);*/

                    var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b1.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                    var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b2.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };

                    FarseerPhysics.Common.MathUtils.Cross$4(w2, r2, Bridge.ref(this, "_tmpVector2"));
                    FarseerPhysics.Common.MathUtils.Cross$4(w1, r1, Bridge.ref(this, "_tmpVector1"));
                    var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), this._tmpVector2.$clone()), v1.$clone()), this._tmpVector1.$clone());
                    var Cdot2 = w2 - w1;
                    var Cdot3 = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                    var impulse1 = this._mass.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                        this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), impulse1.$clone());
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        var newImpulse = this._impulse.Z + impulse1.Z;
                        if (newImpulse < 0.0) {
                            var reduced = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                            impulse1.X = reduced.X;
                            impulse1.Y = reduced.Y;
                            impulse1.Z = -this._impulse.Z;
                            this._impulse.X += reduced.X;
                            this._impulse.Y += reduced.Y;
                            this._impulse.Z = 0.0;
                        }
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        var newImpulse1 = this._impulse.Z + impulse1.Z;
                        if (newImpulse1 > 0.0) {
                            var reduced1 = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                            impulse1.X = reduced1.X;
                            impulse1.Y = reduced1.Y;
                            impulse1.Z = -this._impulse.Z;
                            this._impulse.X += reduced1.X;
                            this._impulse.Y += reduced1.Y;
                            this._impulse.Z = 0.0;
                        }
                    }

                    var P = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(impulse1.X, impulse1.Y) };

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                    w1 -= i1 * (this._tmpFloat1 + impulse1.Z);

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m2, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                    w2 += i2 * (this._tmpFloat1 + impulse1.Z);
                } else {
                    /* Transform xf1, xf2;
                    b1.GetTransform(out xf1);
                    b2.GetTransform(out xf2);*/

                    this._tmpVector1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone());
                    this._tmpVector2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone());
                    var r11 = { v : FarseerPhysics.Common.MathUtils.Multiply$1(Bridge.ref(b1.Xf, "R"), Bridge.ref(this, "_tmpVector1")) };
                    var r21 = { v : FarseerPhysics.Common.MathUtils.Multiply$1(Bridge.ref(b2.Xf, "R"), Bridge.ref(this, "_tmpVector2")) };

                    FarseerPhysics.Common.MathUtils.Cross$4(w2, r21, Bridge.ref(this, "_tmpVector2"));
                    FarseerPhysics.Common.MathUtils.Cross$4(w1, r11, Bridge.ref(this, "_tmpVector1"));
                    var Cdot4 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), this._tmpVector2.$clone()), v1.$clone()), this._tmpVector1.$clone());
                    var impulse2 = { v : this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot4.$clone())) };

                    this._impulse.X += impulse2.v.X;
                    this._impulse.Y += impulse2.v.Y;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, impulse2.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r11, impulse2, Bridge.ref(this, "_tmpFloat1"));
                    w1 -= i1 * this._tmpFloat1;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m2, impulse2.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r21, impulse2, Bridge.ref(this, "_tmpFloat1"));
                    w2 += i2 * this._tmpFloat1;
                }

                b1.LinearVelocityInternal = v1.$clone();
                b1.AngularVelocityInternal = w1;
                b2.LinearVelocityInternal = v2.$clone();
                b2.AngularVelocityInternal = w2;
            },
            SolvePositionConstraints: function () {

                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var angularError = 0.0;
                var positionError;

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var angle = b2.Sweep.A - b1.Sweep.A - this.ReferenceAngle;
                    var limitImpulse = 0.0;

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                        var C = FarseerPhysics.Common.MathUtils.Clamp$2(angle - this._lowerAngle, -0.139626354, FarseerPhysics.Settings.MaxAngularCorrection);
                        limitImpulse = -this._motorMass * C;
                        angularError = Math.abs(C);
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        var C1 = angle - this._lowerAngle;
                        angularError = -C1;

                        C1 = FarseerPhysics.Common.MathUtils.Clamp$2(C1 + FarseerPhysics.Settings.AngularSlop, -0.139626354, 0.0);
                        limitImpulse = -this._motorMass * C1;
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        var C2 = angle - this._upperAngle;
                        angularError = C2;

                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(C2 - FarseerPhysics.Settings.AngularSlop, 0.0, FarseerPhysics.Settings.MaxAngularCorrection);
                        limitImpulse = -this._motorMass * C2;
                    }

                    b1.Sweep.A -= b1.InvI * limitImpulse;
                    b2.Sweep.A += b2.InvI * limitImpulse;

                    b1.SynchronizeTransform();
                    b2.SynchronizeTransform();
                }

                {
                    /* Transform xf1, xf2;
                    b1.GetTransform(out xf1);
                    b2.GetTransform(out xf2);*/

                    var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b1.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                    var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b2.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };

                    var C3 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.v.$clone()), b1.Sweep.C.$clone()), r1.v.$clone());
                    positionError = C3.Length();

                    var invMass1 = b1.InvMass, invMass2 = b2.InvMass;
                    var invI1 = b1.InvI, invI2 = b2.InvI;

                    var k_allowedStretch = 0.049999997;
                    if (C3.LengthSquared() > 0.00249999971) {
                        var u = C3.$clone();
                        u.Normalize();
                        var k = invMass1 + invMass2;
                        System.Diagnostics.Debug.Assert(k > FarseerPhysics.Settings.Epsilon);
                        var m = 1.0 / k;
                        var impulse2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(m, (Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C3.$clone())));
                        var k_beta = 0.5;
                        b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(k_beta * invMass1, impulse2.$clone()));
                        b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(k_beta * invMass2, impulse2.$clone()));

                        C3 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.v.$clone()), b1.Sweep.C.$clone()), r1.v.$clone());
                    }

                    var K1 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invMass1 + invMass2, 0.0), new Microsoft.Xna.Framework.Vector2.$ctor2(0.0, invMass1 + invMass2)) };
                    var K2 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI1 * r1.v.Y * r1.v.Y, -invI1 * r1.v.X * r1.v.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(-invI1 * r1.v.X * r1.v.Y, invI1 * r1.v.X * r1.v.X)) };
                    var K3 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI2 * r2.v.Y * r2.v.Y, -invI2 * r2.v.X * r2.v.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(-invI2 * r2.v.X * r2.v.Y, invI2 * r2.v.X * r2.v.X)) };

                    var Ka = { v : new FarseerPhysics.Common.Mat22() };
                    FarseerPhysics.Common.Mat22.Add(K1, K2, Ka);

                    var K = { v : new FarseerPhysics.Common.Mat22() };
                    FarseerPhysics.Common.Mat22.Add(Ka, K3, K);


                    var impulse = { v : K.v.Solve(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C3.$clone())) };

                    b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, impulse.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r1, impulse, Bridge.ref(this, "_tmpFloat1"));
                    b1.Sweep.A -= b1.InvI * this._tmpFloat1;

                    b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, impulse.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r2, impulse, Bridge.ref(this, "_tmpFloat1"));
                    b2.Sweep.A += b2.InvI * this._tmpFloat1;

                    b1.SynchronizeTransform();
                    b2.SynchronizeTransform();
                }

                return positionError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    /**
     * A rope joint enforces a maximum distance between two points
     on two bodies. It has no other effect.
     Warning: if you attempt to change the maximum length during
     the simulation you will get some non-physical behavior.
     A model that would allow you to dynamically modify the length
     would have some sponginess, so I chose not to implement it
     that way. See b2DistanceJoint if you want to dynamically
     control length.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.RopeJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.RopeJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _impulse: 0,
            _length: 0,
            _mass: 0,
            _rA: null,
            _rB: null,
            _state: 0,
            _u: null,
            /**
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RopeJoint
             * @function MaxLength
             * @type number
             */
            MaxLength: 0
        },
        props: {
            State: {
                get: function () {
                    return this._state;
                }
            },
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._rA = new Microsoft.Xna.Framework.Vector2();
                this._rB = new Microsoft.Xna.Framework.Vector2();
                this._u = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Rope;
            },
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Rope;
                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.WorldAnchorB.$clone(), this.WorldAnchorA.$clone());
                this.MaxLength = d.Length();

                this._mass = 0.0;
                this._impulse = 0.0;
                this._state = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                this._length = 0.0;
            }
        },
        methods: {
            GetReactionForce: function (invDt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2((invDt * this._impulse), this._u.$clone());
            },
            GetReactionTorque: function (invDt) {
                return 0;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xf1);

                var xf2 = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xf2);

                this._rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                this._rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                this._u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), this._rB.$clone()), bA.Sweep.C.$clone()), this._rA.$clone());

                this._length = this._u.Length();

                var C = this._length - this.MaxLength;
                if (C > 0.0) {
                    this._state = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                } else {
                    this._state = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (this._length > FarseerPhysics.Settings.LinearSlop) {
                    this._u = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(), 1.0 / this._length);
                } else {
                    this._u = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    this._mass = 0.0;
                    this._impulse = 0.0;
                    return;
                }

                var crA = FarseerPhysics.Common.MathUtils.Cross$2(this._rA.$clone(), this._u.$clone());
                var crB = FarseerPhysics.Common.MathUtils.Cross$2(this._rB.$clone(), this._u.$clone());
                var invMass = bA.InvMass + bA.InvI * crA * crA + bB.InvMass + bB.InvI * crB * crB;

                this._mass = invMass !== 0.0 ? 1.0 / invMass : 0.0;

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u.$clone());
                    bA.LinearVelocity = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocity.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bA.InvMass, P.$clone()));
                    bA.AngularVelocity -= bA.InvI * FarseerPhysics.Common.MathUtils.Cross$2(this._rA.$clone(), P.$clone());
                    bB.LinearVelocity = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocity.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bB.InvMass, P.$clone()));
                    bB.AngularVelocity += bB.InvI * FarseerPhysics.Common.MathUtils.Cross$2(this._rB.$clone(), P.$clone());
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var vA = Microsoft.Xna.Framework.Vector2.op_Addition(bA.LinearVelocity.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(bA.AngularVelocity, this._rA.$clone()));
                var vB = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocity.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(bB.AngularVelocity, this._rB.$clone()));
                var C = this._length - this.MaxLength;
                var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone()));

                if (C < 0.0) {
                    Cdot += step.v.inv_dt * C;
                }

                var impulse = -this._mass * Cdot;
                var oldImpulse = this._impulse;
                this._impulse = Math.min(0.0, this._impulse + impulse);
                impulse = this._impulse - oldImpulse;

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());
                bA.LinearVelocity = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocity.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bA.InvMass, P.$clone()));
                bA.AngularVelocity -= bA.InvI * FarseerPhysics.Common.MathUtils.Cross$2(this._rA.$clone(), P.$clone());
                bB.LinearVelocity = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocity.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bB.InvMass, P.$clone()));
                bB.AngularVelocity += bB.InvI * FarseerPhysics.Common.MathUtils.Cross$2(this._rB.$clone(), P.$clone());
            },
            SolvePositionConstraints: function () {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xf1);

                var xf2 = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xf2);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                var u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), rB.$clone()), bA.Sweep.C.$clone()), rA.$clone());


                var length = u.Length();
                u.Normalize();

                var C = length - this.MaxLength;

                C = FarseerPhysics.Common.MathUtils.Clamp$2(C, 0.0, FarseerPhysics.Settings.MaxLinearCorrection);

                var impulse = -this._mass * C;
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, u.$clone());

                bA.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bA.InvMass, P.$clone()));
                bA.Sweep.A -= bA.InvI * FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone());
                bB.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bB.InvMass, P.$clone()));
                bB.Sweep.A += bB.InvI * FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone());

                bA.SynchronizeTransform();
                bB.SynchronizeTransform();

                return length - this.MaxLength < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    /**
     * A distance joint contrains two points on two bodies
     to remain at a fixed distance from each other. You can view
     this as a massless, rigid rod.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.SliderJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.SliderJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _bias: 0,
            _gamma: 0,
            _impulse: 0,
            _mass: 0,
            _u: null,
            /**
             * The maximum length between the anchor points.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @function MaxLength
             * @type number
             */
            MaxLength: 0,
            /**
             * The minimal length between the anchor points.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @function MinLength
             * @type number
             */
            MinLength: 0,
            /**
             * The mass-spring-damper frequency in Hertz.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @function Frequency
             * @type number
             */
            Frequency: 0,
            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @function DampingRatio
             * @type number
             */
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._u = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Slider;
            },
            /**
             * Initializes a new instance of the {@link } class.
             Warning: Do not use a zero or short length.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.SliderJoint
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body.
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second body anchor.
             * @param   {number}                             minLength       The minimum length between anchorpoints
             * @param   {number}                             maxlength       The maximum length between anchorpoints.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB, minLength, maxlength) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Slider;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();
                this.MaxLength = maxlength;
                this.MinLength = minLength;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var F = Microsoft.Xna.Framework.Vector2.op_Multiply$2((inv_dt * this._impulse), this._u.$clone());
                return F.$clone();
            },
            GetReactionTorque: function (inv_dt) {
                return 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));
                this._u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());

                var length = this._u.Length();

                if (length < this.MaxLength && length > this.MinLength) {
                    return;
                }

                if (length > FarseerPhysics.Settings.LinearSlop) {
                    this._u = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(), 1.0 / length);
                } else {
                    this._u = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                var cr1u = FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), this._u.$clone());
                var cr2u = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._u.$clone());
                var invMass = b1.InvMass + b1.InvI * cr1u * cr1u + b2.InvMass + b2.InvI * cr2u * cr2u;
                System.Diagnostics.Debug.Assert(invMass > FarseerPhysics.Settings.Epsilon);
                this._mass = invMass !== 0.0 ? 1.0 / invMass : 0.0;

                if (this.Frequency > 0.0) {
                    var C = length - this.MaxLength;

                    var omega = 6.28318548 * this.Frequency;

                    var d = 2.0 * this._mass * this.DampingRatio * omega;

                    var k = this._mass * omega * omega;

                    this._gamma = step.v.dt * (d + step.v.dt * k);
                    this._gamma = this._gamma !== 0.0 ? 1.0 / this._gamma : 0.0;
                    this._bias = C * step.v.dt * k * this._gamma;

                    this._mass = invMass + this._gamma;
                    this._mass = this._mass !== 0.0 ? 1.0 / this._mass : 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                    b1.AngularVelocityInternal -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P.$clone());
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());

                var length = d.Length();

                if (length < this.MaxLength && length > this.MinLength) {
                    return;
                }

                var v1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b1.AngularVelocityInternal, r1.$clone()));
                var v2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b2.AngularVelocityInternal, r2.$clone()));
                var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone()));

                var impulse = -this._mass * (Cdot + this._bias + this._gamma * this._impulse);
                this._impulse += impulse;

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());
                b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                b1.AngularVelocityInternal -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
                b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.$clone()));
                b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P.$clone());
            },
            SolvePositionConstraints: function () {
                if (this.Frequency > 0.0) {
                    return true;
                }

                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());

                var length = d.Length();

                if (length < this.MaxLength && length > this.MinLength) {
                    return true;
                }

                if (length === 0.0) {
                    return true;
                }

                d = Microsoft.Xna.Framework.Vector2.op_Division$1(d.$clone(), length);
                var C = length - this.MaxLength;
                C = FarseerPhysics.Common.MathUtils.Clamp$2(C, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);

                var impulse = -this._mass * C;
                this._u = d.$clone();
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());

                b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                b1.Sweep.A -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
                b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.$clone()));
                b2.Sweep.A += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P.$clone());

                b1.SynchronizeTransform();
                b2.SynchronizeTransform();

                return Math.abs(C) < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    /**
     * A weld joint essentially glues two bodies together. A weld joint may
     distort somewhat because the island constraint solver is approximate.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.WeldJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.WeldJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _impulse: null,
            _mass: null,
            /**
             * The body2 angle minus body1 angle in the reference state (radians).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.WeldJoint
             * @function ReferenceAngle
             * @type number
             */
            ReferenceAngle: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._mass = new FarseerPhysics.Common.Mat33();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Weld;
            },
            /**
             * You need to specify a local anchor point
             where they are attached and the relative body angle. The position
             of the anchor point is important for computing the reaction torque.
             You can change the anchor points relative to bodyA or bodyB by changing LocalAnchorA
             and/or LocalAnchorB.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.WeldJoint
             * @memberof FarseerPhysics.Dynamics.Joints.WeldJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second body anchor.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Weld;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();
                this.ReferenceAngle = this.BodyB.Rotation - this.BodyA.Rotation;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y));
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Z;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));



                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                this._mass.Col1.X = mA + mB + rA.Y * rA.Y * iA + rB.Y * rB.Y * iB;
                this._mass.Col2.X = -rA.Y * rA.X * iA - rB.Y * rB.X * iB;
                this._mass.Col3.X = -rA.Y * iA - rB.Y * iB;
                this._mass.Col1.Y = this._mass.Col2.X;
                this._mass.Col2.Y = mA + mB + rA.X * rA.X * iA + rB.X * rB.X * iB;
                this._mass.Col3.Y = rA.X * iA + rB.X * iB;
                this._mass.Col1.Z = this._mass.Col3.X;
                this._mass.Col2.Z = this._mass.Col3.Y;
                this._mass.Col3.Z = iA + iB;

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y);

                    bA.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                    bA.AngularVelocityInternal -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + this._impulse.Z);

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, P.$clone()));
                    bB.AngularVelocityInternal += iB * (FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone()) + this._impulse.Z);
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var vA = bA.LinearVelocityInternal.$clone();
                var wA = bA.AngularVelocityInternal;
                var vB = bB.LinearVelocityInternal.$clone();
                var wB = bB.AngularVelocityInternal;

                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(wB, rB.$clone())), vA.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(wA, rA.$clone()));
                var Cdot2 = wB - wA;
                var Cdot = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                var impulse = this._mass.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot.$clone()));
                this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), impulse.$clone());

                var P = new Microsoft.Xna.Framework.Vector2.$ctor2(impulse.X, impulse.Y);

                vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                wA -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + impulse.Z);

                vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, P.$clone()));
                wB += iB * (FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone()) + impulse.Z);

                bA.LinearVelocityInternal = vA.$clone();
                bA.AngularVelocityInternal = wA;
                bB.LinearVelocityInternal = vB.$clone();
                bB.AngularVelocityInternal = wB;
            },
            SolvePositionConstraints: function () {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                var xfA = { v : new FarseerPhysics.Common.Transform() };
                var xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                var C1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), rB.$clone()), bA.Sweep.C.$clone()), rA.$clone());
                var C2 = bB.Sweep.A - bA.Sweep.A - this.ReferenceAngle;

                var k_allowedStretch = 0.049999997;
                var positionError = C1.Length();
                var angularError = Math.abs(C2);
                if (positionError > k_allowedStretch) {
                    iA *= 1.0;
                    iB *= 1.0;
                }

                this._mass.Col1.X = mA + mB + rA.Y * rA.Y * iA + rB.Y * rB.Y * iB;
                this._mass.Col2.X = -rA.Y * rA.X * iA - rB.Y * rB.X * iB;
                this._mass.Col3.X = -rA.Y * iA - rB.Y * iB;
                this._mass.Col1.Y = this._mass.Col2.X;
                this._mass.Col2.Y = mA + mB + rA.X * rA.X * iA + rB.X * rB.X * iB;
                this._mass.Col3.Y = rA.X * iA + rB.X * iB;
                this._mass.Col1.Z = this._mass.Col3.X;
                this._mass.Col2.Z = this._mass.Col3.Y;
                this._mass.Col3.Z = iA + iB;

                var C = new Microsoft.Xna.Framework.Vector3.$ctor3(C1.X, C1.Y, C2);

                var impulse = this._mass.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(C.$clone()));

                var P = new Microsoft.Xna.Framework.Vector2.$ctor2(impulse.X, impulse.Y);

                bA.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                bA.Sweep.A -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + impulse.Z);

                bB.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, P.$clone()));
                bB.Sweep.A += iB * (FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone()) + impulse.Z);

                bA.SynchronizeTransform();
                bB.SynchronizeTransform();

                return positionError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    Bridge.define("FarseerPhysics.Utility.PhysicsGameScreen", {
        inherits: [FarseerPhysics.Utility.GameScreen],
        fields: {
            Camera: null,
            World: null,
            _agentForce: 0,
            _agentTorque: 0,
            _fixedMouseJoint: null,
            _userAgent: null,
            EnableCameraControl: false
        },
        ctors: {
            ctor: function (screenManager) {
                this.$initialize();
                FarseerPhysics.Utility.GameScreen.ctor.call(this);
                this.HasCursor = true;
                this.EnableCameraControl = true;
                this._userAgent = null;
                this.World = null;
                this.Camera = null;

                this.ScreenManager = screenManager;
                FarseerPhysics.Settings.EnableDiagnostics = true;

                if (this.World == null) {
                    this.World = new FarseerPhysics.Dynamics.World.$ctor1(Microsoft.Xna.Framework.Vector2.Zero.$clone());
                } else {
                    this.World.Clear();
                }

                if (this.Camera == null) {
                    this.Camera = new FarseerPhysics.Utility.Camera2D(screenManager.GraphicsDevice);
                } else {
                    this.Camera.ResetCamera();
                }

            }
        },
        methods: {
            SetUserAgent: function (agent, force, torque) {
                this._userAgent = agent;
                this._agentForce = force;
                this._agentTorque = torque;
            },
            LoadContent: function () {
                FarseerPhysics.Utility.GameScreen.prototype.LoadContent.call(this);
            },
            Update: function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {
                if (!coveredByOtherScreen && !otherScreenHasFocus) {
                    this.World.Step(Math.min(gameTime.ElapsedGameTime.getTotalSeconds(), (0.02)));
                } else {
                    this.World.Step(0.0);
                }
                this.Camera.Update(gameTime);
                FarseerPhysics.Utility.GameScreen.prototype.Update.call(this, gameTime, otherScreenHasFocus, coveredByOtherScreen);
            },
            Draw: function (gameTime) {
                var projection = this.Camera.SimProjection.$clone();
                var view = this.Camera.SimView.$clone();

                FarseerPhysics.Utility.GameScreen.prototype.Draw.call(this, gameTime);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint", {
        inherits: [Poly2Tri.Triangulation.TriangulationConstraint],
        ctors: {
            /**
             * Give two points in any order. Will always be ordered so
             that q.y &gt; p.y and q.x &gt; p.x if same y value
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p1    
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p2
             * @return  {void}
             */
            ctor: function (p1, p2) {
                this.$initialize();
                Poly2Tri.Triangulation.TriangulationConstraint.ctor.call(this);
                this.P = p1;
                this.Q = p2;
                if (p1.Y > p2.Y) {
                    this.Q = p1;
                    this.P = p2;
                } else if (p1.Y === p2.Y) {
                    if (p1.X > p2.X) {
                        this.Q = p1;
                        this.P = p2;
                    } else if (p1.X === p2.X) {
                    }
                }
                this.Q.AddEdge(this);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext", {
        inherits: [Poly2Tri.Triangulation.TriangulationContext],
        statics: {
            fields: {
                ALPHA: 0
            },
            ctors: {
                init: function () {
                    this.ALPHA = 0.3;
                }
            }
        },
        fields: {
            Basin: null,
            EdgeEvent: null,
            _comparator: null,
            aFront: null,
            Head: null,
            Tail: null
        },
        ctors: {
            init: function () {
                this.Basin = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.DTSweepBasin();
                this.EdgeEvent = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.DTSweepEdgeEvent();
                this._comparator = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepPointComparator();
            },
            ctor: function () {
                this.$initialize();
                Poly2Tri.Triangulation.TriangulationContext.ctor.call(this);
                this.Clear();
            }
        },
        methods: {
            RemoveFromList: function (triangle) {
                this.Triangles.remove(triangle);
            },
            MeshClean: function (triangle) {
                this.MeshCleanReq(triangle);
            },
            MeshCleanReq: function (triangle) {
                if (triangle != null && !triangle.IsInterior) {
                    triangle.IsInterior = true;
                    this.Triangulatable.Poly2Tri$Triangulation$Triangulatable$AddTriangle(triangle);
                    for (var i = 0; i < 3; i = (i + 1) | 0) {
                        if (!triangle.EdgeIsConstrained.getItem(i)) {
                            this.MeshCleanReq(triangle.Neighbors.getItem(i));
                        }
                    }
                }
            },
            Clear: function () {
                Poly2Tri.Triangulation.TriangulationContext.prototype.Clear.call(this);
                this.Triangles.clear();
            },
            AddNode: function (node) {
                this.aFront.AddNode(node);
            },
            RemoveNode: function (node) {
                this.aFront.RemoveNode(node);
            },
            LocateNode: function (point) {
                return this.aFront.LocateNode(point);
            },
            CreateAdvancingFront: function () {
                var head, tail, middle;
                var iTriangle = new Poly2Tri.Triangulation.Delaunay.DelaunayTriangle(this.Points.getItem(0), this.Tail, this.Head);
                this.Triangles.add(iTriangle);

                head = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(1));
                head.Triangle = iTriangle;
                middle = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(0));
                middle.Triangle = iTriangle;
                tail = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(2));

                this.aFront = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront(head, tail);
                this.aFront.AddNode(middle);

                this.aFront.Head.Next = middle;
                middle.Next = this.aFront.Tail;
                middle.Prev = this.aFront.Head;
                this.aFront.Tail.Prev = middle;
            },
            /**
             * Try to map a node to all sides of this triangle that don't have 
             a neighbor.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext
             * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t
             * @return  {void}
             */
            MapTriangleToNodes: function (t) {
                var n;
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (t.Neighbors.getItem(i) == null) {
                        n = this.aFront.LocatePoint(t.PointCW(t.Points.getItem(i)));
                        if (n != null) {
                            n.Triangle = t;
                        }
                    }
                }
            },
            PrepareTriangulation: function (t) {
                var $t;
                Poly2Tri.Triangulation.TriangulationContext.prototype.PrepareTriangulation.call(this, t);

                var xmax, xmin;
                var ymax, ymin;

                xmax = (xmin = this.Points.getItem(0).X);
                ymax = (ymin = this.Points.getItem(0).Y);

                $t = Bridge.getEnumerator(this.Points);
                try {
                    while ($t.moveNext()) {
                        var p = $t.Current;
                        if (p.X > xmax) {
                            xmax = p.X;
                        }
                        if (p.X < xmin) {
                            xmin = p.X;
                        }
                        if (p.Y > ymax) {
                            ymax = p.Y;
                        }
                        if (p.Y < ymin) {
                            ymin = p.Y;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var deltaX = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.ALPHA * (xmax - xmin);
                var deltaY = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.ALPHA * (ymax - ymin);
                var p1 = new Poly2Tri.Triangulation.TriangulationPoint(xmax + deltaX, ymin - deltaY);
                var p2 = new Poly2Tri.Triangulation.TriangulationPoint(xmin - deltaX, ymin - deltaY);

                this.Head = p1;
                this.Tail = p2;

                this.Points.Sort$1(this._comparator);
            },
            FinalizeTriangulation: function () {
                this.Triangulatable.Poly2Tri$Triangulation$Triangulatable$AddTriangles(this.Triangles);
                this.Triangles.clear();
            },
            NewConstraint: function (a, b) {
                return new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint(a, b);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepPointComparator", {
        inherits: [System.Collections.Generic.IComparer$1(Poly2Tri.Triangulation.TriangulationPoint)],
        alias: ["compare", ["System$Collections$Generic$IComparer$1$Poly2Tri$Triangulation$TriangulationPoint$compare", "System$Collections$Generic$IComparer$1$compare"]],
        methods: {
            compare: function (p1, p2) {
                if (p1.Y < p2.Y) {
                    return -1;
                } else if (p1.Y > p2.Y) {
                    return 1;
                } else {
                    if (p1.X < p2.X) {
                        return -1;
                    } else if (p1.X > p2.X) {
                        return 1;
                    } else {
                        return 0;
                    }
                }
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Polygon.Polygon", {
        inherits: [Poly2Tri.Triangulation.Triangulatable],
        fields: {
            _holes: null,
            _last: null,
            _points: null,
            _steinerPoints: null,
            _triangles: null
        },
        props: {
            Holes: {
                get: function () {
                    return this._holes;
                }
            },
            TriangulationMode: {
                get: function () {
                    return Poly2Tri.Triangulation.TriangulationMode.Polygon;
                }
            },
            Points: {
                get: function () {
                    return this._points;
                }
            },
            Triangles: {
                get: function () {
                    return this._triangles;
                }
            }
        },
        alias: [
            "TriangulationMode", "Poly2Tri$Triangulation$Triangulatable$TriangulationMode",
            "Points", "Poly2Tri$Triangulation$Triangulatable$Points",
            "Triangles", "Poly2Tri$Triangulation$Triangulatable$Triangles",
            "AddTriangle", "Poly2Tri$Triangulation$Triangulatable$AddTriangle",
            "AddTriangles", "Poly2Tri$Triangulation$Triangulatable$AddTriangles",
            "ClearTriangles", "Poly2Tri$Triangulation$Triangulatable$ClearTriangles",
            "PrepareTriangulation", "Poly2Tri$Triangulation$Triangulatable$PrepareTriangulation"
        ],
        ctors: {
            init: function () {
                this._points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
            },
            /**
             * Create a polygon from a list of at least 3 points with no duplicates.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {System.Collections.Generic.IList$1}    points    A list of unique points
             * @return  {void}
             */
            $ctor2: function (points) {
                this.$initialize();
                if (System.Array.getCount(points, Poly2Tri.Triangulation.Polygon.PolygonPoint) < 3) {
                    throw new System.ArgumentException.$ctor3("List has fewer than 3 points", "points");
                }

                if (Bridge.equals(System.Array.getItem(points, 0, Poly2Tri.Triangulation.Polygon.PolygonPoint), System.Array.getItem(points, ((System.Array.getCount(points, Poly2Tri.Triangulation.Polygon.PolygonPoint) - 1) | 0), Poly2Tri.Triangulation.Polygon.PolygonPoint))) {
                    System.Array.removeAt(points, ((System.Array.getCount(points, Poly2Tri.Triangulation.Polygon.PolygonPoint) - 1) | 0), Poly2Tri.Triangulation.Polygon.PolygonPoint);
                }

                this._points.AddRange(System.Linq.Enumerable.from(points).select(function (x) { return Bridge.cast(x, Poly2Tri.Triangulation.TriangulationPoint); }));
            },
            /**
             * Create a polygon from a list of at least 3 points with no duplicates.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {System.Collections.Generic.IEnumerable$1}    points    A list of unique points.
             * @return  {void}
             */
            $ctor1: function (points) {
                Poly2Tri.Triangulation.Polygon.Polygon.$ctor2.call(this, (Bridge.as(points, System.Collections.Generic.IList$1(Poly2Tri.Triangulation.Polygon.PolygonPoint))) || System.Linq.Enumerable.from(points).ToArray());
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            AddTriangle: function (t) {
                this._triangles.add(t);
            },
            AddTriangles: function (list) {
                this._triangles.AddRange(list);
            },
            ClearTriangles: function () {
                if (this._triangles != null) {
                    this._triangles.clear();
                }
            },
            /**
             * Creates constraints and populates the context with points
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.TriangulationContext}    tcx    The context
             * @return  {void}
             */
            PrepareTriangulation: function (tcx) {
                var $t;
                if (this._triangles == null) {
                    this._triangles = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)).$ctor2(this._points.Count);
                } else {
                    this._triangles.clear();
                }

                for (var i = 0; i < ((this._points.Count - 1) | 0); i = (i + 1) | 0) {
                    tcx.NewConstraint(this._points.getItem(i), this._points.getItem(((i + 1) | 0)));
                }
                tcx.NewConstraint(this._points.getItem(0), this._points.getItem(((this._points.Count - 1) | 0)));
                tcx.Points.AddRange(this._points);

                if (this._holes != null) {
                    $t = Bridge.getEnumerator(this._holes);
                    try {
                        while ($t.moveNext()) {
                            var p = $t.Current;
                            for (var i1 = 0; i1 < ((p._points.Count - 1) | 0); i1 = (i1 + 1) | 0) {
                                tcx.NewConstraint(p._points.getItem(i1), p._points.getItem(((i1 + 1) | 0)));
                            }
                            tcx.NewConstraint(p._points.getItem(0), p._points.getItem(((p._points.Count - 1) | 0)));
                            tcx.Points.AddRange(p._points);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}

                if (this._steinerPoints != null) {
                    tcx.Points.AddRange(this._steinerPoints);
                }
            },
            AddSteinerPoint: function (point) {
                if (this._steinerPoints == null) {
                    this._steinerPoints = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                }
                this._steinerPoints.add(point);
            },
            AddSteinerPoints: function (points) {
                if (this._steinerPoints == null) {
                    this._steinerPoints = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                }
                this._steinerPoints.AddRange(points);
            },
            ClearSteinerPoints: function () {
                if (this._steinerPoints != null) {
                    this._steinerPoints.clear();
                }
            },
            /**
             * Add a hole to the polygon.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.Polygon.Polygon}    poly    A subtraction polygon fully contained inside this polygon.
             * @return  {void}
             */
            AddHole: function (poly) {
                if (this._holes == null) {
                    this._holes = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Polygon.Polygon)).ctor();
                }
                this._holes.add(poly);
            },
            /**
             * Inserts newPoint after point.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.Polygon.PolygonPoint}    point       The point to insert after in the polygon
             * @param   {Poly2Tri.Triangulation.Polygon.PolygonPoint}    newPoint    The point to insert into the polygon
             * @return  {void}
             */
            InsertPointAfter: function (point, newPoint) {
                var index = this._points.indexOf(point);
                if (index === -1) {
                    throw new System.ArgumentException.$ctor3("Tried to insert a point into a Polygon after a point not belonging to the Polygon", "point");
                }
                newPoint.Next = point.Next;
                newPoint.Previous = point;
                point.Next.Previous = newPoint;
                point.Next = newPoint;
                this._points.insert(((index + 1) | 0), newPoint);
            },
            /**
             * Inserts list (after last point in polygon?)
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {System.Collections.Generic.IEnumerable$1}    list
             * @return  {void}
             */
            AddPoints: function (list) {
                var $t;
                var first;
                $t = Bridge.getEnumerator(list, Poly2Tri.Triangulation.Polygon.PolygonPoint);
                try {
                    while ($t.moveNext()) {
                        var p = $t.Current;
                        p.Previous = this._last;
                        if (this._last != null) {
                            p.Next = this._last.Next;
                            this._last.Next = p;
                        }
                        this._last = p;
                        this._points.add(p);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }first = Bridge.cast(this._points.getItem(0), Poly2Tri.Triangulation.Polygon.PolygonPoint);
                this._last.Next = first;
                first.Previous = this._last;
            },
            /**
             * Adds a point after the last in the polygon.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.Polygon.PolygonPoint}    p    The point to add
             * @return  {void}
             */
            AddPoint: function (p) {
                p.Previous = this._last;
                p.Next = this._last.Next;
                this._last.Next = p;
                this._points.add(p);
            },
            /**
             * Removes a point from the polygon.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.Polygon.PolygonPoint}    p
             * @return  {void}
             */
            RemovePoint: function (p) {
                var next, prev;

                next = p.Next;
                prev = p.Previous;
                prev.Next = next;
                next.Previous = prev;
                this._points.remove(p);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Polygon.PolygonPoint", {
        inherits: [Poly2Tri.Triangulation.TriangulationPoint],
        fields: {
            Next: null,
            Previous: null
        },
        ctors: {
            ctor: function (x, y) {
                this.$initialize();
                Poly2Tri.Triangulation.TriangulationPoint.ctor.call(this, x, y);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Sets.PointSet", {
        inherits: [Poly2Tri.Triangulation.Triangulatable],
        fields: {
            Points: null,
            Triangles: null
        },
        props: {
            TriangulationMode: {
                get: function () {
                    return Poly2Tri.Triangulation.TriangulationMode.Unconstrained;
                }
            }
        },
        alias: [
            "Points", "Poly2Tri$Triangulation$Triangulatable$Points",
            "Triangles", "Poly2Tri$Triangulation$Triangulatable$Triangles",
            "TriangulationMode", "Poly2Tri$Triangulation$Triangulatable$TriangulationMode",
            "AddTriangle", "Poly2Tri$Triangulation$Triangulatable$AddTriangle",
            "AddTriangles", "Poly2Tri$Triangulation$Triangulatable$AddTriangles",
            "ClearTriangles", "Poly2Tri$Triangulation$Triangulatable$ClearTriangles",
            "PrepareTriangulation", "Poly2Tri$Triangulation$Triangulatable$PrepareTriangulation"
        ],
        ctors: {
            ctor: function (points) {
                this.$initialize();
                this.Points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).$ctor1(points);
            }
        },
        methods: {
            AddTriangle: function (t) {
                System.Array.add(this.Triangles, t, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
            },
            AddTriangles: function (list) {
                var $t;
                $t = Bridge.getEnumerator(list, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                try {
                    while ($t.moveNext()) {
                        var tri = $t.Current;
                        System.Array.add(this.Triangles, tri, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            ClearTriangles: function () {
                System.Array.clear(this.Triangles, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
            },
            PrepareTriangulation: function (tcx) {
                if (this.Triangles == null) {
                    this.Triangles = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)).$ctor2(System.Array.getCount(this.Points, Poly2Tri.Triangulation.TriangulationPoint));
                } else {
                    System.Array.clear(this.Triangles, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                }
                tcx.Points.AddRange(this.Points);
            }
        }
    });

    Bridge.define("QuadTreeBroadPhase", {
        inherits: [FarseerPhysics.Collision.IBroadPhase],
        statics: {
            fields: {
                TreeUpdateThresh: 0
            },
            ctors: {
                init: function () {
                    this.TreeUpdateThresh = 10000;
                }
            }
        },
        fields: {
            _currID: 0,
            _idRegister: null,
            _moveBuffer: null,
            _pairBuffer: null,
            _quadTree: null,
            _treeMoveNum: 0
        },
        props: {
            /**
             * The number of proxies
             *
             * @instance
             * @public
             * @readonly
             * @memberof QuadTreeBroadPhase
             * @function ProxyCount
             * @type number
             */
            ProxyCount: {
                get: function () {
                    return this._idRegister.count;
                }
            }
        },
        alias: [
            "ProxyCount", "FarseerPhysics$Collision$IBroadPhase$ProxyCount",
            "GetFatAABB", "FarseerPhysics$Collision$IBroadPhase$GetFatAABB",
            "UpdatePairs", "FarseerPhysics$Collision$IBroadPhase$UpdatePairs",
            "TestOverlap", "FarseerPhysics$Collision$IBroadPhase$TestOverlap",
            "AddProxy", "FarseerPhysics$Collision$IBroadPhase$AddProxy",
            "RemoveProxy", "FarseerPhysics$Collision$IBroadPhase$RemoveProxy",
            "MoveProxy", "FarseerPhysics$Collision$IBroadPhase$MoveProxy",
            "GetProxy", "FarseerPhysics$Collision$IBroadPhase$GetProxy",
            "TouchProxy", "FarseerPhysics$Collision$IBroadPhase$TouchProxy",
            "Query", "FarseerPhysics$Collision$IBroadPhase$Query",
            "RayCast", "FarseerPhysics$Collision$IBroadPhase$RayCast"
        ],
        ctors: {
            /**
             * Creates a new quad tree broadphase with the specified span.
             *
             * @instance
             * @public
             * @this QuadTreeBroadPhase
             * @memberof QuadTreeBroadPhase
             * @param   {FarseerPhysics.Collision.AABB}    span    the maximum span of the tree (world size)
             * @return  {void}
             */
            ctor: function (span) {
                this.$initialize();
                this._quadTree = new (QuadTree$1(FarseerPhysics.Dynamics.FixtureProxy))(span.$clone(), 5, 10);
                this._idRegister = new (System.Collections.Generic.Dictionary$2(System.Int32,Element$1(FarseerPhysics.Dynamics.FixtureProxy)))();
                this._moveBuffer = new (System.Collections.Generic.List$1(Element$1(FarseerPhysics.Dynamics.FixtureProxy))).ctor();
                this._pairBuffer = new (System.Collections.Generic.List$1(FarseerPhysics.Collision.Pair)).ctor();
            }
        },
        methods: {
            GetFatAABB: function (proxyID, aabb) {
                if (this._idRegister.containsKey(proxyID)) {
                    aabb.v = this._idRegister.get(proxyID).Span.$clone();
                } else {
                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("proxyID not found in register");
                }
            },
            UpdatePairs: function (callback) {
                var $t;
                this._pairBuffer.clear();
                $t = Bridge.getEnumerator(this._moveBuffer);
                try {
                    while ($t.moveNext()) {
                        var qtnode = { v : $t.Current };
                        this.Query((function ($me, qtnode) {
                            return Bridge.fn.bind($me, function (proxyID) {
                                return this.PairBufferQueryCallback(proxyID, qtnode.v.Value.ProxyId);
                            });
                        })(this, qtnode), Bridge.ref(qtnode.v, "Span"));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }this._moveBuffer.clear();

                this._pairBuffer.Sort();

                var i = 0;
                while (i < this._pairBuffer.Count) {
                    var primaryPair = this._pairBuffer.getItem(i).$clone();
                    var userDataA = { v : this.GetProxy(primaryPair.ProxyIdA) };
                    var userDataB = { v : this.GetProxy(primaryPair.ProxyIdB) };

                    callback(userDataA, userDataB);
                    i = (i + 1) | 0;

                    while (i < this._pairBuffer.Count && this._pairBuffer.getItem(i).$clone().ProxyIdA === primaryPair.ProxyIdA && this._pairBuffer.getItem(i).$clone().ProxyIdB === primaryPair.ProxyIdB) {
                        i = (i + 1) | 0;
                    }
                }
            },
            /**
             * Test overlap of fat AABBs.
             *
             * @instance
             * @public
             * @this QuadTreeBroadPhase
             * @memberof QuadTreeBroadPhase
             * @param   {number}     proxyIdA    The proxy id A.
             * @param   {number}     proxyIdB    The proxy id B.
             * @return  {boolean}
             */
            TestOverlap: function (proxyIdA, proxyIdB) {
                var aabb1 = { v : new FarseerPhysics.Collision.AABB() };
                var aabb2 = { v : new FarseerPhysics.Collision.AABB() };
                this.GetFatAABB(proxyIdA, aabb1);
                this.GetFatAABB(proxyIdB, aabb2);
                return FarseerPhysics.Collision.AABB.TestOverlap$1(aabb1, aabb2);
            },
            AddProxy: function (proxy) {
                var proxyID = Bridge.identity(this._currID, (this._currID = (this._currID + 1) | 0));
                proxy.v.ProxyId = proxyID;
                var aabb = this.Fatten(Bridge.ref(proxy.v, "AABB"));
                var qtnode = new (Element$1(FarseerPhysics.Dynamics.FixtureProxy))(proxy.v.$clone(), aabb.$clone());

                this._idRegister.add(proxyID, qtnode);
                this._quadTree.AddNode(qtnode);

                return proxyID;
            },
            RemoveProxy: function (proxyId) {
                if (this._idRegister.containsKey(proxyId)) {
                    var qtnode = this._idRegister.get(proxyId);
                    this.UnbufferMove(qtnode);
                    this._idRegister.remove(proxyId);
                    this._quadTree.RemoveNode(qtnode);
                } else {
                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("proxyID not found in register");
                }
            },
            MoveProxy: function (proxyId, aabb, displacement) {
                var fatAABB = { v : new FarseerPhysics.Collision.AABB() };
                this.GetFatAABB(proxyId, fatAABB);

                if (fatAABB.v.Contains(aabb)) {
                    return;
                }

                var b = aabb.v.$clone();
                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.AABBExtension, FarseerPhysics.Settings.AABBExtension);
                b.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(b.LowerBound.$clone(), r.$clone());
                b.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(b.UpperBound.$clone(), r.$clone());

                var d = Microsoft.Xna.Framework.Vector2.op_Multiply$2(FarseerPhysics.Settings.AABBMultiplier, displacement.$clone());

                if (d.X < 0.0) {
                    b.LowerBound.X += d.X;
                } else {
                    b.UpperBound.X += d.X;
                }

                if (d.Y < 0.0) {
                    b.LowerBound.Y += d.Y;
                } else {
                    b.UpperBound.Y += d.Y;
                }


                var qtnode = this._idRegister.get(proxyId);
                qtnode.Value.AABB = b.$clone();
                qtnode.Span = b.$clone();

                this.ReinsertNode(qtnode);

                this.BufferMove(qtnode);
            },
            GetProxy: function (proxyId) {
                if (this._idRegister.containsKey(proxyId)) {
                    return this._idRegister.get(proxyId).Value.$clone();
                } else {
                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("proxyID not found in register");
                }
            },
            TouchProxy: function (proxyId) {
                if (this._idRegister.containsKey(proxyId)) {
                    this.BufferMove(this._idRegister.get(proxyId));
                } else {
                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("proxyID not found in register");
                }
            },
            Query: function (callback, query) {
                this._quadTree.QueryAABB(this.TransformPredicate(callback), query);
            },
            RayCast: function (callback, input) {
                this._quadTree.RayCast(this.TransformRayCallback(callback), input);
            },
            Fatten: function (aabb) {
                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.AABBExtension, FarseerPhysics.Settings.AABBExtension);
                return new FarseerPhysics.Collision.AABB.$ctor1(Microsoft.Xna.Framework.Vector2.op_Subtraction(aabb.v.LowerBound.$clone(), r.$clone()), Microsoft.Xna.Framework.Vector2.op_Addition(aabb.v.UpperBound.$clone(), r.$clone()));
            },
            TransformPredicate: function (idPredicate) {
                var qtPred = function (qtnode) {
                    return idPredicate(qtnode.Value.ProxyId);
                };
                return qtPred;
            },
            TransformRayCallback: function (callback) {
                var newCallback = function (input, qtnode) {
                    return callback(input.$clone(), qtnode.Value.ProxyId);
                };
                return newCallback;
            },
            PairBufferQueryCallback: function (proxyID, baseID) {
                if (proxyID === baseID) {
                    return true;
                }

                var p = new FarseerPhysics.Collision.Pair();
                p.ProxyIdA = Math.min(proxyID, baseID);
                p.ProxyIdB = Math.max(proxyID, baseID);
                this._pairBuffer.add(p.$clone());

                return true;
            },
            ReconstructTree: function () {
                var $t;
                this._quadTree.Clear();
                $t = Bridge.getEnumerator(this._idRegister.getValues(), Element$1(FarseerPhysics.Dynamics.FixtureProxy));
                try {
                    while ($t.moveNext()) {
                        var elem = $t.Current;
                        this._quadTree.AddNode(elem);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            ReinsertNode: function (qtnode) {
                this._quadTree.RemoveNode(qtnode);
                this._quadTree.AddNode(qtnode);

                if (((this._treeMoveNum = (this._treeMoveNum + 1) | 0)) > QuadTreeBroadPhase.TreeUpdateThresh) {
                    this.ReconstructTree();
                    this._treeMoveNum = 0;
                }
            },
            BufferMove: function (proxy) {
                this._moveBuffer.add(proxy);
            },
            UnbufferMove: function (proxy) {
                this._moveBuffer.remove(proxy);
            }
        }
    });

    
    Bridge.define("FarseerPhysics.Common.PhysicsLogic.Explosion", {
        inherits: [FarseerPhysics.Common.PhysicsLogic.PhysicsLogic],
        statics: {
            fields: {
                /**
                 * Two degrees: maximum angle from edges to first ray tested
                 *
                 * @static
                 * @private
                 * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
                 * @constant
                 * @default 0.0349065848
                 * @type number
                 */
                MaxEdgeOffset: 0
            },
            ctors: {
                init: function () {
                    this.MaxEdgeOffset = 0.0349065848;
                }
            }
        },
        fields: {
            /**
             * Ratio of arc length to angle from edges to first ray tested.
             Defaults to 1/40.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @type number
             */
            EdgeRatio: 0,
            /**
             * Ignore Explosion if it happens inside a shape.
             Default value is false.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @default false
             * @type boolean
             */
            IgnoreWhenInsideShape: false,
            /**
             * Max angle between rays (used when segment is large).
             Defaults to 15 degrees
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @type number
             */
            MaxAngle: 0,
            /**
             * Maximum number of shapes involved in the explosion.
             Defaults to 100
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @default 100
             * @type number
             */
            MaxShapes: 0,
            /**
             * How many rays per shape/body/segment.
             Defaults to 5
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @default 5
             * @type number
             */
            MinRays: 0,
            _data: null,
            _exploded: null,
            _rdc: null
        },
        ctors: {
            init: function () {
                this.EdgeRatio = 0.025;
                this.IgnoreWhenInsideShape = false;
                this.MaxAngle = 0.209439516;
                this.MaxShapes = 100;
                this.MinRays = 5;
                this._data = new (System.Collections.Generic.List$1(FarseerPhysics.Common.PhysicsLogic.ShapeData)).ctor();
            },
            ctor: function (world) {
                this.$initialize();
                FarseerPhysics.Common.PhysicsLogic.PhysicsLogic.ctor.call(this, world, FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType.Explosion);
                this._exploded = new (System.Collections.Generic.Dictionary$2(FarseerPhysics.Dynamics.Fixture,System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)))();
                this._rdc = new FarseerPhysics.Common.PhysicsLogic.RayDataComparer();
                this._data = new (System.Collections.Generic.List$1(FarseerPhysics.Common.PhysicsLogic.ShapeData)).ctor();
            }
        },
        methods: {
            /**
             * This makes the explosive explode
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.PhysicsLogic.Explosion
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @param   {Microsoft.Xna.Framework.Vector2}            pos         The position where the explosion happens
             * @param   {number}                                     radius      The explosion radius
             * @param   {number}                                     maxForce    The explosion force at the explosion point
             (then is inversely proportional to the square of the distance)
             * @return  {System.Collections.Generic.Dictionary$2}                A dictionnary containing all the "exploded" fixtures
             with a list of the applied impulses
             */
            Activate: function (pos, radius, maxForce) {
                pos = {v:pos};
                this._exploded.clear();

                var aabb = { v : new FarseerPhysics.Collision.AABB() };
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-radius, -radius));
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(radius, radius));
                var shapes = System.Array.init(this.MaxShapes, null, FarseerPhysics.Dynamics.Fixture);

                var containedShapes = System.Array.init(5, null, FarseerPhysics.Dynamics.Fixture);
                var exit = false;

                var shapeCount = 0;
                var containedShapeCount = 0;

                this.World.QueryAABB(Bridge.fn.bind(this, function (fixture) {
                    if (fixture.TestPoint(pos)) {
                        if (this.IgnoreWhenInsideShape) {
                            exit = true;
                        } else {
                            containedShapes[System.Array.index(Bridge.identity(containedShapeCount, (containedShapeCount = (containedShapeCount + 1) | 0)), containedShapes)] = fixture;
                        }
                    } else {
                        shapes[System.Array.index(Bridge.identity(shapeCount, (shapeCount = (shapeCount + 1) | 0)), shapes)] = fixture;
                    }

                    return true;
                }), aabb);

                if (exit) {
                    return this._exploded;
                }

                var vals = System.Array.init(Bridge.Int.mul(shapeCount, 2), 0, System.Single);
                var valIndex = 0;
                for (var i = 0; i < shapeCount; i = (i + 1) | 0) {
                    var ps;
                    var cs = Bridge.as(shapes[System.Array.index(i, shapes)].Shape, FarseerPhysics.Collision.Shapes.CircleShape);
                    if (cs != null) {
                        var v = new FarseerPhysics.Common.Vertices.ctor();
                        var vec = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(cs.Radius, 0));
                        v.add(vec.$clone());
                        vec = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(0, cs.Radius));
                        v.add(vec.$clone());
                        vec = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-cs.Radius, cs.Radius));
                        v.add(vec.$clone());
                        vec = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(0, -cs.Radius));
                        v.add(vec.$clone());
                        ps = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(v, 0);
                    } else {
                        ps = Bridge.as(shapes[System.Array.index(i, shapes)].Shape, FarseerPhysics.Collision.Shapes.PolygonShape);
                    }

                    if ((shapes[System.Array.index(i, shapes)].Body.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic) && ps != null) {
                        var toCentroid = Microsoft.Xna.Framework.Vector2.op_Subtraction(shapes[System.Array.index(i, shapes)].Body.GetWorldPoint(ps.MassData.Centroid.$clone()), pos.v.$clone());
                        var angleToCentroid = Math.atan2(toCentroid.Y, toCentroid.X);
                        var min = 3.40282347E+38;
                        var max = -3.40282347E+38;
                        var minAbsolute = 0.0;
                        var maxAbsolute = 0.0;

                        for (var j = 0; j < (System.Linq.Enumerable.from(ps.Vertices).count()); j = (j + 1) | 0) {
                            var toVertex = (Microsoft.Xna.Framework.Vector2.op_Subtraction(shapes[System.Array.index(i, shapes)].Body.GetWorldPoint(ps.Vertices.getItem(j).$clone()), pos.v.$clone()));
                            var newAngle = Math.atan2(toVertex.Y, toVertex.X);
                            var diff = (newAngle - angleToCentroid);

                            diff = (diff - Microsoft.Xna.Framework.MathHelper.Pi) % (6.28318548);

                            if (diff < 0.0) {
                                diff += 6.28318548;
                            }

                            diff -= Microsoft.Xna.Framework.MathHelper.Pi;

                            if (Math.abs(diff) > Microsoft.Xna.Framework.MathHelper.Pi) {
                                throw new System.ArgumentException.$ctor1("OMG!");
                            }

                            if (diff > max) {
                                max = diff;
                                maxAbsolute = newAngle;
                            }
                            if (diff < min) {
                                min = diff;
                                minAbsolute = newAngle;
                            }
                        }

                        vals[System.Array.index(valIndex, vals)] = minAbsolute;
                        valIndex = (valIndex + 1) | 0;
                        vals[System.Array.index(valIndex, vals)] = maxAbsolute;
                        valIndex = (valIndex + 1) | 0;
                    }
                }

                System.Array.sort(vals, 0, valIndex, this._rdc);
                this._data.clear();
                var rayMissed = true;

                for (var i1 = 0; i1 < valIndex; i1 = (i1 + 1) | 0) {
                    var shape = { v : null };
                    var midpt;

                    var iplus = (i1 === ((valIndex - 1) | 0) ? 0 : ((i1 + 1) | 0));
                    if (vals[System.Array.index(i1, vals)] === vals[System.Array.index(iplus, vals)]) {
                        continue;
                    }

                    if (i1 === ((valIndex - 1) | 0)) {
                        midpt = (vals[System.Array.index(0, vals)] + 6.28318548 + vals[System.Array.index(i1, vals)]);
                    } else {
                        midpt = (vals[System.Array.index(((i1 + 1) | 0), vals)] + vals[System.Array.index(i1, vals)]);
                    }

                    midpt = midpt / 2;

                    var p1 = pos.v.$clone();
                    var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(radius, new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(midpt), Math.sin(midpt))), pos.v.$clone());

                    var hitClosest = { v : false };
                    this.World.RayCast((function ($me, hitClosest, shape) {
                        return Bridge.fn.bind($me, function (f, p, n, fr) {
                            var body = f.Body;

                            if (!this.IsActiveOn(body)) {
                                return 0;
                            }

                            if (body.UserData != null) {
                                var index = System.Nullable.getValue(Bridge.cast(Bridge.unbox(body.UserData, System.Int32), System.Int32));
                                if (index === 0) {
                                    return -1.0;
                                }
                            }

                            hitClosest.v = true;
                            shape.v = f;
                            return fr;
                        });
                    })(this, hitClosest, shape), p1.$clone(), p2.$clone());

                    if ((hitClosest.v) && (shape.v.Body.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic)) {
                        if ((System.Linq.Enumerable.from(this._data).count() > 0) && (Bridge.referenceEquals(System.Linq.Enumerable.from(this._data).last().Body, shape.v.Body)) && (!rayMissed)) {
                            var laPos = (this._data.Count - 1) | 0;
                            var la = this._data.getItem(laPos).$clone();
                            la.Max = vals[System.Array.index(iplus, vals)];
                            this._data.setItem(laPos, la.$clone());
                        } else {
                            var d = new FarseerPhysics.Common.PhysicsLogic.ShapeData();
                            d.Body = shape.v.Body;
                            d.Min = vals[System.Array.index(i1, vals)];
                            d.Max = vals[System.Array.index(iplus, vals)];
                            this._data.add(d.$clone());
                        }

                        if ((System.Linq.Enumerable.from(this._data).count() > 1) && (i1 === ((valIndex - 1) | 0)) && (Bridge.referenceEquals(System.Linq.Enumerable.from(this._data).last().Body, System.Linq.Enumerable.from(this._data).first().Body)) && (System.Linq.Enumerable.from(this._data).last().Max === System.Linq.Enumerable.from(this._data).first().Min)) {
                            var fi = this._data.getItem(0).$clone();
                            fi.Min = System.Linq.Enumerable.from(this._data).last().Min;
                            this._data.removeAt(((System.Linq.Enumerable.from(this._data).count() - 1) | 0));
                            this._data.setItem(0, fi.$clone());
                            while (System.Linq.Enumerable.from(this._data).first().Min >= System.Linq.Enumerable.from(this._data).first().Max) {
                                fi.Min -= 6.28318548;
                                this._data.setItem(0, fi.$clone());
                            }
                        }

                        var lastPos = (this._data.Count - 1) | 0;
                        var last = this._data.getItem(lastPos).$clone();
                        while ((System.Linq.Enumerable.from(this._data).count() > 0) && (System.Linq.Enumerable.from(this._data).last().Min >= System.Linq.Enumerable.from(this._data).last().Max)) {
                            last.Min = System.Linq.Enumerable.from(this._data).last().Min - 6.28318548;
                            this._data.setItem(lastPos, last.$clone());
                        }
                        rayMissed = false;
                    } else {
                        rayMissed = true;
                    }
                }

                for (var i2 = 0; i2 < System.Linq.Enumerable.from(this._data).count(); i2 = (i2 + 1) | 0) {
                    if (!this.IsActiveOn(this._data.getItem(i2).$clone().Body)) {
                        continue;
                    }

                    var arclen = this._data.getItem(i2).$clone().Max - this._data.getItem(i2).$clone().Min;

                    var first = Microsoft.Xna.Framework.MathHelper.Min$1(FarseerPhysics.Common.PhysicsLogic.Explosion.MaxEdgeOffset, this.EdgeRatio * arclen);
                    var insertedRays = Bridge.Int.clip32(Math.ceil(((arclen - 2.0 * first) - (((this.MinRays - 1) | 0)) * this.MaxAngle) / this.MaxAngle));

                    if (insertedRays < 0) {
                        insertedRays = 0;
                    }

                    var offset = (arclen - first * 2.0) / (this.MinRays + insertedRays - 1);

                    for (var j1 = this._data.getItem(i2).$clone().Min + first; j1 < this._data.getItem(i2).$clone().Max || FarseerPhysics.Common.MathUtils.FloatEquals$1(j1, this._data.getItem(i2).$clone().Max, 0.0001); j1 += offset) {
                        var p11 = pos.v.$clone();
                        var p21 = Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(radius, new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1), Math.sin(j1))));
                        var hitpoint = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };
                        var minlambda = 3.40282347E+38;

                        var fl = this._data.getItem(i2).$clone().Body.FixtureList;
                        for (var x = 0; x < fl.Count; x = (x + 1) | 0) {
                            var f = fl.getItem(x);
                            var ri = { v : new FarseerPhysics.Collision.RayCastInput() };
                            ri.v.Point1 = p11.$clone();
                            ri.v.Point2 = p21.$clone();
                            ri.v.MaxFraction = 50.0;

                            var ro = { v : new FarseerPhysics.Collision.RayCastOutput() };
                            if (f.RayCast(ro, ri, 0)) {
                                if (minlambda > ro.v.Fraction) {
                                    minlambda = ro.v.Fraction;
                                    hitpoint.v = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(ro.v.Fraction, p21.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((1 - ro.v.Fraction), p11.$clone()));
                                }
                            }

                            var impulse = (arclen / (((this.MinRays + insertedRays) | 0))) * maxForce * 180.0 / Microsoft.Xna.Framework.MathHelper.Pi * (1.0 - Math.min(1.0, minlambda));

                            var vectImp = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1), Math.sin(j1))), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(ro.v.Normal.$clone())), new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1), Math.sin(j1))) };

                            this._data.getItem(i2).$clone().Body.ApplyLinearImpulse$3(vectImp, hitpoint);

                            var val = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                            var vectorList = { };
                            if (this._exploded.tryGetValue(f, vectorList)) {
                                val.X += Math.abs(vectImp.v.X);
                                val.Y += Math.abs(vectImp.v.Y);

                                vectorList.v.add(val.$clone());
                            } else {
                                vectorList.v = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();
                                val.X = Math.abs(vectImp.v.X);
                                val.Y = Math.abs(vectImp.v.Y);

                                vectorList.v.add(val.$clone());
                                this._exploded.add(f, vectorList.v);
                            }

                            if (minlambda > 1.0) {
                                hitpoint.v = p21.$clone();
                            }
                        }
                    }
                }

                for (var i3 = 0; i3 < containedShapeCount; i3 = (i3 + 1) | 0) {
                    var fix = containedShapes[System.Array.index(i3, containedShapes)];

                    if (!this.IsActiveOn(fix.Body)) {
                        continue;
                    }

                    var impulse1 = this.MinRays * maxForce * 180.0 / Microsoft.Xna.Framework.MathHelper.Pi;
                    var hitPoint = { v : new Microsoft.Xna.Framework.Vector2() };

                    var circShape = Bridge.as(fix.Shape, FarseerPhysics.Collision.Shapes.CircleShape);
                    if (circShape != null) {
                        hitPoint.v = fix.Body.GetWorldPoint(circShape.Position.$clone());
                    } else {
                        var shape1 = Bridge.as(fix.Shape, FarseerPhysics.Collision.Shapes.PolygonShape);
                        hitPoint.v = fix.Body.GetWorldPoint(shape1.MassData.Centroid.$clone());
                    }

                    var vectImp1 = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse1, (Microsoft.Xna.Framework.Vector2.op_Subtraction(hitPoint.v.$clone(), pos.v.$clone()))) };

                    var vectorList1 = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();
                    vectorList1.add(vectImp1.v.$clone());

                    fix.Body.ApplyLinearImpulse$3(vectImp1, hitPoint);

                    if (!this._exploded.containsKey(fix)) {
                        this._exploded.add(fix, vectorList1);
                    }
                }

                return this._exploded;
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.AbstractForceController", {
        inherits: [FarseerPhysics.Controllers.Controller],
        fields: {
            /**
             * Curve to be used for Decay in Curve mode
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @type Microsoft.Xna.Framework.Curve
             */
            DecayCurve: null,
            /**
             * The Forcetype of the instance
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @type number
             */
            ForceType: 0,
            /**
             * Provided for reuse to provide Variation functionality in 
             inheriting classes
             *
             * @instance
             * @protected
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @type System.Random
             */
            Randomize: null,
            /**
             * Curve used by Curve Mode as an animated multiplier for the force 
             strength.
             Only positions between 0 and 1 are considered as that range is 
             stretched to have ImpulseLength.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @type Microsoft.Xna.Framework.Curve
             */
            StrengthCurve: null,
            /**
             * Global Strength of the force to be applied
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function Strength
             * @type number
             */
            Strength: 0,
            /**
             * Position of the Force. Can be ignored (left at (0,0) for forces
             that are not position-dependent
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function Position
             * @type Microsoft.Xna.Framework.Vector2
             */
            Position: null,
            /**
             * Maximum speed of the bodies. Bodies that are travelling faster are
             supposed to be ignored
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function MaximumSpeed
             * @type number
             */
            MaximumSpeed: 0,
            /**
             * Maximum Force to be applied. As opposed to Maximum Speed this is 
             independent of the velocity of
             the affected body
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function MaximumForce
             * @type number
             */
            MaximumForce: 0,
            /**
             * Timing Mode of the force instance
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function TimingMode
             * @type number
             */
            TimingMode: 0,
            /**
             * Time of the current impulse. Incremented in update till 
             ImpulseLength is reached
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function ImpulseTime
             * @type number
             */
            ImpulseTime: 0,
            /**
             * Length of a triggered impulse. Used in both Triggered and Curve Mode
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function ImpulseLength
             * @type number
             */
            ImpulseLength: 0,
            /**
             * Indicating if we are currently during an Impulse 
             (Triggered and Curve Mode)
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function Triggered
             * @type boolean
             */
            Triggered: false,
            /**
             * Variation of the force applied to each body affected
             !! Must be used in inheriting classes properly !!
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function Variation
             * @type number
             */
            Variation: 0,
            /**
             * See DecayModes
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function DecayMode
             * @type number
             */
            DecayMode: 0,
            /**
             * Start of the distance based Decay. To set a non decaying area
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function DecayStart
             * @type number
             */
            DecayStart: 0,
            /**
             * Maximum distance a force should be applied
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function DecayEnd
             * @type number
             */
            DecayEnd: 0
        },
        ctors: {
            init: function () {
                this.Position = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * Constructor
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @return  {void}
             */
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.AbstractForceController);
                this.Enabled = true;

                this.Strength = 1.0;
                this.Position = new Microsoft.Xna.Framework.Vector2.$ctor2(0, 0);
                this.MaximumSpeed = 100.0;
                this.TimingMode = FarseerPhysics.Controllers.AbstractForceController.TimingModes.Switched;
                this.ImpulseTime = 0.0;
                this.ImpulseLength = 1.0;
                this.Triggered = false;
                this.StrengthCurve = new Microsoft.Xna.Framework.Curve();
                this.Variation = 0.0;
                this.Randomize = new System.Random.$ctor1(1234);
                this.DecayMode = FarseerPhysics.Controllers.AbstractForceController.DecayModes.None;
                this.DecayCurve = new Microsoft.Xna.Framework.Curve();
                this.DecayStart = 0.0;
                this.DecayEnd = 0.0;

                this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(0, 5));
                this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(0.1, 5));
                this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(0.2, -4));
                this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(1.0, 0));
            },
            /**
             * Overloaded Contstructor with supplying Timing Mode
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @param   {number}    mode
             * @return  {void}
             */
            $ctor1: function (mode) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.AbstractForceController);
                this.TimingMode = mode;
                switch (mode) {
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Switched: 
                        this.Enabled = true;
                        break;
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Triggered: 
                        this.Enabled = false;
                        break;
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Curve: 
                        this.Enabled = false;
                        break;
                }
            }
        },
        methods: {
            /**
             * Calculate the Decay for a given body. Meant to ease force 
             development and stick to the DRY principle and provide unified and 
             predictable decay math.
             *
             * @instance
             * @protected
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @param   {FarseerPhysics.Dynamics.Body}    body    The body to calculate decay for
             * @return  {number}                                  A multiplier to multiply the force with to add decay 
             support in inheriting classes
             */
            GetDecayMultiplier: function (body) {
                var distance = (Microsoft.Xna.Framework.Vector2.op_Subtraction(body.Position.$clone(), this.Position.$clone())).Length();
                switch (this.DecayMode) {
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.None: 
                        {
                            return 1.0;
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.Step: 
                        {
                            if (distance < this.DecayEnd) {
                                return 1.0;
                            } else {
                                return 0.0;
                            }
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.Linear: 
                        {
                            if (distance < this.DecayStart) {
                                return 1.0;
                            }
                            if (distance > this.DecayEnd) {
                                return 0.0;
                            }
                            return (this.DecayEnd - this.DecayStart / distance - this.DecayStart);
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.InverseSquare: 
                        {
                            if (distance < this.DecayStart) {
                                return 1.0;
                            } else {
                                return 1.0 / ((distance - this.DecayStart) * (distance - this.DecayStart));
                            }
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.Curve: 
                        {
                            if (distance < this.DecayStart) {
                                return 1.0;
                            } else {
                                return this.DecayCurve.Evaluate(distance - this.DecayStart);
                            }
                        }
                    default: 
                        return 1.0;
                }
            },
            /**
             * Triggers the trigger modes (Trigger and Curve)
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @return  {void}
             */
            Trigger: function () {
                this.Triggered = true;
                this.ImpulseTime = 0;
            },
            /**
             * Inherited from Controller
             Depending on the TimingMode perform timing logic and call ApplyForce()
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @param   {number}    dt
             * @return  {void}
             */
            Update: function (dt) {
                switch (this.TimingMode) {
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Switched: 
                        {
                            if (this.Enabled) {
                                this.ApplyForce(dt, this.Strength);
                            }
                            break;
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Triggered: 
                        {
                            if (this.Enabled && this.Triggered) {
                                if (this.ImpulseTime < this.ImpulseLength) {
                                    this.ApplyForce(dt, this.Strength);
                                    this.ImpulseTime += dt;
                                } else {
                                    this.Triggered = false;
                                }
                            }
                            break;
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Curve: 
                        {
                            if (this.Enabled && this.Triggered) {
                                if (this.ImpulseTime < this.ImpulseLength) {
                                    this.ApplyForce(dt, this.Strength * this.StrengthCurve.Evaluate(this.ImpulseTime));
                                    this.ImpulseTime += dt;
                                } else {
                                    this.Triggered = false;
                                }
                            }
                            break;
                        }
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.BuoyancyController", {
        inherits: [FarseerPhysics.Controllers.Controller],
        fields: {
            /**
             * Controls the rotational drag that the fluid exerts on the bodies within it. Use higher values will simulate thick fluid, like honey, lower values to
             simulate water-like fluids.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @type number
             */
            AngularDragCoefficient: 0,
            /**
             * Density of the fluid. Higher values will make things more buoyant, lower values will cause things to sink.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @type number
             */
            Density: 0,
            /**
             * Controls the linear drag that the fluid exerts on the bodies within it.  Use higher values will simulate thick fluid, like honey, lower values to
             simulate water-like fluids.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @type number
             */
            LinearDragCoefficient: 0,
            /**
             * Acts like waterflow. Defaults to 0,0.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @type Microsoft.Xna.Framework.Vector2
             */
            Velocity: null,
            _container: null,
            _gravity: null,
            _normal: null,
            _offset: 0,
            _uniqueBodies: null
        },
        props: {
            Container: {
                get: function () {
                    return this._container.$clone();
                },
                set: function (value) {
                    this._container = value.$clone();
                    this._offset = this._container.UpperBound.Y;
                }
            }
        },
        ctors: {
            init: function () {
                this.Velocity = new Microsoft.Xna.Framework.Vector2();
                this._container = new FarseerPhysics.Collision.AABB();
                this._gravity = new Microsoft.Xna.Framework.Vector2();
                this._normal = new Microsoft.Xna.Framework.Vector2();
                this._uniqueBodies = new (System.Collections.Generic.Dictionary$2(System.Int32,FarseerPhysics.Dynamics.Body))();
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.BuoyancyController
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @param   {FarseerPhysics.Collision.AABB}      container                    Only bodies inside this AABB will be influenced by the controller
             * @param   {number}                             density                      Density of the fluid
             * @param   {number}                             linearDragCoefficient        Linear drag coefficient of the fluid
             * @param   {number}                             rotationalDragCoefficient    Rotational drag coefficient of the fluid
             * @param   {Microsoft.Xna.Framework.Vector2}    gravity                      The direction gravity acts. Buoyancy force will act in opposite direction of gravity.
             * @return  {void}
             */
            ctor: function (container, density, linearDragCoefficient, rotationalDragCoefficient, gravity) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.BuoyancyController);
                this.Container = container.$clone();
                this._normal = new Microsoft.Xna.Framework.Vector2.$ctor2(0, 1);
                this.Density = density;
                this.LinearDragCoefficient = linearDragCoefficient;
                this.AngularDragCoefficient = rotationalDragCoefficient;
                this._gravity = gravity.$clone();
            }
        },
        methods: {
            Update: function (dt) {
                var $t;
                this._uniqueBodies.clear();
                this.World.QueryAABB(Bridge.fn.bind(this, function (fixture) {
                    if (fixture.Body.IsStatic || !fixture.Body.Awake) {
                        return true;
                    }

                    if (!this._uniqueBodies.containsKey(fixture.Body.BodyId)) {
                        this._uniqueBodies.add(fixture.Body.BodyId, fixture.Body);
                    }

                    return true;
                }), Bridge.ref(this, "_container"));

                $t = Bridge.getEnumerator(this._uniqueBodies);
                try {
                    while ($t.moveNext()) {
                        var kv = $t.Current;
                        var body = kv.value;

                        var areac = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        var massc = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        var area = 0;
                        var mass = 0;

                        for (var j = 0; j < body.FixtureList.Count; j = (j + 1) | 0) {
                            var fixture = body.FixtureList.getItem(j);

                            if (fixture.Shape.ShapeType !== FarseerPhysics.Collision.Shapes.ShapeType.Polygon && fixture.Shape.ShapeType !== FarseerPhysics.Collision.Shapes.ShapeType.Circle) {
                                continue;
                            }

                            var shape = fixture.Shape;

                            var sc = { v : new Microsoft.Xna.Framework.Vector2() };
                            var sarea = shape.ComputeSubmergedArea(this._normal.$clone(), this._offset, body.Xf.$clone(), sc);
                            area += sarea;
                            areac.X += sarea * sc.v.X;
                            areac.Y += sarea * sc.v.Y;

                            mass += sarea * shape.Density;
                            massc.X += sarea * sc.v.X * shape.Density;
                            massc.Y += sarea * sc.v.Y * shape.Density;
                        }

                        areac.X /= area;
                        areac.Y /= area;
                        massc.X /= mass;
                        massc.Y /= mass;

                        if (area < FarseerPhysics.Settings.Epsilon) {
                            continue;
                        }

                        var buoyancyForce = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Density * area, this._gravity.$clone());
                        body.ApplyForce$1(buoyancyForce.$clone(), massc.$clone());

                        var dragForce = Microsoft.Xna.Framework.Vector2.op_Subtraction(body.GetLinearVelocityFromWorldPoint(areac.$clone()), this.Velocity.$clone());
                        dragForce = Microsoft.Xna.Framework.Vector2.op_Multiply$1(dragForce.$clone(), -this.LinearDragCoefficient * area);
                        body.ApplyForce$1(dragForce.$clone(), areac.$clone());

                        body.ApplyTorque(-body.Inertia / body.Mass * area * body.AngularVelocity * this.AngularDragCoefficient);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        }
    });

    Bridge.define("FarseerPhysics.Controllers.GravityController", {
        inherits: [FarseerPhysics.Controllers.Controller],
        fields: {
            Bodies: null,
            Points: null,
            MinRadius: 0,
            MaxRadius: 0,
            Strength: 0,
            GravityType: 0
        },
        ctors: {
            init: function () {
                this.Bodies = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body)).ctor();
                this.Points = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();
            },
            ctor: function (strength) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.GravityController);
                this.Strength = strength;
                this.MaxRadius = 3.40282347E+38;
            },
            $ctor1: function (strength, maxRadius, minRadius) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.GravityController);
                this.MinRadius = minRadius;
                this.MaxRadius = maxRadius;
                this.Strength = strength;
            }
        },
        methods: {
            Update: function (dt) {
                var $t, $t1, $t2;
                var f = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };

                $t = Bridge.getEnumerator(this.World.BodyList);
                try {
                    while ($t.moveNext()) {
                        var body1 = $t.Current;
                        if (!this.IsActiveOn(body1)) {
                            continue;
                        }

                        $t1 = Bridge.getEnumerator(this.Bodies);
                        try {
                            while ($t1.moveNext()) {
                                var body2 = $t1.Current;
                                if (Bridge.referenceEquals(body1, body2) || (body1.IsStatic && body2.IsStatic) || !body2.Enabled) {
                                    continue;
                                }

                                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(body2.WorldCenter.$clone(), body1.WorldCenter.$clone());
                                var r2 = d.LengthSquared();

                                if (r2 < FarseerPhysics.Settings.Epsilon) {
                                    continue;
                                }

                                var r = d.Length();

                                if (r >= this.MaxRadius || r <= this.MinRadius) {
                                    continue;
                                }

                                switch (this.GravityType) {
                                    case FarseerPhysics.Controllers.GravityType.DistanceSquared: 
                                        f.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength / r2 / Math.sqrt(r2) * body1.Mass * body2.Mass, d.$clone());
                                        break;
                                    case FarseerPhysics.Controllers.GravityType.Linear: 
                                        f.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength / r2 * body1.Mass * body2.Mass, d.$clone());
                                        break;
                                }

                                body1.ApplyForce$2(f);
                                Microsoft.Xna.Framework.Vector2.Negate$1(f, f);
                                body2.ApplyForce$2(f);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                        $t2 = Bridge.getEnumerator(this.Points);
                        try {
                            while ($t2.moveNext()) {
                                var point = $t2.Current.$clone();
                                var d1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(point.$clone(), body1.Position.$clone());
                                var r21 = d1.LengthSquared();

                                if (r21 < FarseerPhysics.Settings.Epsilon) {
                                    continue;
                                }

                                var r1 = d1.Length();

                                if (r1 >= this.MaxRadius || r1 <= this.MinRadius) {
                                    continue;
                                }

                                switch (this.GravityType) {
                                    case FarseerPhysics.Controllers.GravityType.DistanceSquared: 
                                        f.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength / r21 / Math.sqrt(r21) * body1.Mass, d1.$clone());
                                        break;
                                    case FarseerPhysics.Controllers.GravityType.Linear: 
                                        f.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength / r21 * body1.Mass, d1.$clone());
                                        break;
                                }

                                body1.ApplyForce$2(f);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            AddBody: function (body) {
                this.Bodies.add(body);
            },
            AddPoint: function (point) {
                this.Points.add(point.$clone());
            }
        }
    });

    /**
     * Put a limit on the linear (translation - the movespeed) and angular (rotation) velocity
     of bodies added to this controller.
     *
     * @public
     * @class FarseerPhysics.Controllers.VelocityLimitController
     * @augments FarseerPhysics.Controllers.Controller
     */
    Bridge.define("FarseerPhysics.Controllers.VelocityLimitController", {
        inherits: [FarseerPhysics.Controllers.Controller],
        fields: {
            LimitAngularVelocity: false,
            LimitLinearVelocity: false,
            _bodies: null,
            _maxAngularSqared: 0,
            _maxAngularVelocity: 0,
            _maxLinearSqared: 0,
            _maxLinearVelocity: 0
        },
        props: {
            /**
             * Gets or sets the max angular velocity.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.VelocityLimitController
             * @function MaxAngularVelocity
             * @type number
             */
            MaxAngularVelocity: {
                get: function () {
                    return this._maxAngularVelocity;
                },
                set: function (value) {
                    this._maxAngularVelocity = value;
                    this._maxAngularSqared = this._maxAngularVelocity * this._maxAngularVelocity;
                }
            },
            /**
             * Gets or sets the max linear velocity.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.VelocityLimitController
             * @function MaxLinearVelocity
             * @type number
             */
            MaxLinearVelocity: {
                get: function () {
                    return this._maxLinearVelocity;
                },
                set: function (value) {
                    this._maxLinearVelocity = value;
                    this._maxLinearSqared = this._maxLinearVelocity * this._maxLinearVelocity;
                }
            }
        },
        ctors: {
            init: function () {
                this.LimitAngularVelocity = true;
                this.LimitLinearVelocity = true;
                this._bodies = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body)).ctor();
            },
            /**
             * Initializes a new instance of the {@link } class.
             Sets the max linear velocity to Settings.MaxTranslation
             Sets the max angular velocity to Settings.MaxRotation
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.VelocityLimitController
             * @memberof FarseerPhysics.Controllers.VelocityLimitController
             * @return  {void}
             */
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.VelocityLimitController);
                this.MaxLinearVelocity = FarseerPhysics.Settings.MaxTranslation;
                this.MaxAngularVelocity = FarseerPhysics.Settings.MaxRotation;
            },
            /**
             * Initializes a new instance of the {@link } class.
             Pass in 0 or float.MaxValue to disable the limit.
             maxAngularVelocity = 0 will disable the angular velocity limit.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.VelocityLimitController
             * @memberof FarseerPhysics.Controllers.VelocityLimitController
             * @param   {number}    maxLinearVelocity     The max linear velocity.
             * @param   {number}    maxAngularVelocity    The max angular velocity.
             * @return  {void}
             */
            $ctor1: function (maxLinearVelocity, maxAngularVelocity) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.VelocityLimitController);
                if (maxLinearVelocity === 0 || maxLinearVelocity === 3.40282347E+38) {
                    this.LimitLinearVelocity = false;
                }

                if (maxAngularVelocity === 0 || maxAngularVelocity === 3.40282347E+38) {
                    this.LimitAngularVelocity = false;
                }

                this.MaxLinearVelocity = maxLinearVelocity;
                this.MaxAngularVelocity = maxAngularVelocity;
            }
        },
        methods: {
            Update: function (dt) {
                var $t;
                $t = Bridge.getEnumerator(this._bodies);
                try {
                    while ($t.moveNext()) {
                        var body = $t.Current;
                        if (!this.IsActiveOn(body)) {
                            continue;
                        }

                        if (this.LimitLinearVelocity) {
                            var translationX = dt * body.LinearVelocityInternal.X;
                            var translationY = dt * body.LinearVelocityInternal.Y;
                            var result = translationX * translationX + translationY * translationY;

                            if (result > dt * this._maxLinearSqared) {
                                var sq = Math.sqrt(result);

                                var ratio = this._maxLinearVelocity / sq;
                                body.LinearVelocityInternal.X *= ratio;
                                body.LinearVelocityInternal.Y *= ratio;
                            }
                        }

                        if (this.LimitAngularVelocity) {
                            var rotation = dt * body.AngularVelocityInternal;
                            if (rotation * rotation > this._maxAngularSqared) {
                                var ratio1 = this._maxAngularVelocity / Math.abs(rotation);
                                body.AngularVelocityInternal *= ratio1;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            AddBody: function (body) {
                this._bodies.add(body);
            },
            RemoveBody: function (body) {
                this._bodies.remove(body);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Sets.ConstrainedPointSet", {
        inherits: [Poly2Tri.Triangulation.Sets.PointSet],
        fields: {
            _constrainedPointList: null,
            EdgeIndex: null
        },
        props: {
            TriangulationMode: {
                get: function () {
                    return Poly2Tri.Triangulation.TriangulationMode.Constrained;
                }
            }
        },
        alias: [
            "TriangulationMode", "Poly2Tri$Triangulation$Triangulatable$TriangulationMode",
            "PrepareTriangulation", "Poly2Tri$Triangulation$Triangulatable$PrepareTriangulation"
        ],
        ctors: {
            $ctor1: function (points, index) {
                this.$initialize();
                Poly2Tri.Triangulation.Sets.PointSet.ctor.call(this, points);
                this.EdgeIndex = index;
            },
            ctor: function (points, constraints) {
                this.$initialize();
                Poly2Tri.Triangulation.Sets.PointSet.ctor.call(this, points);
                this._constrainedPointList = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                this._constrainedPointList.AddRange(constraints);
            }
        },
        methods: {
            PrepareTriangulation: function (tcx) {
                var $t, $t1;
                Poly2Tri.Triangulation.Sets.PointSet.prototype.PrepareTriangulation.call(this, tcx);
                if (this._constrainedPointList != null) {
                    var p1, p2;
                    var iterator = this._constrainedPointList.GetEnumerator();
                    while (iterator.moveNext()) {
                        p1 = iterator.Current;
                        iterator.moveNext();
                        p2 = iterator.Current;
                        tcx.NewConstraint(p1, p2);
                    }
                } else {
                    for (var i = 0; i < this.EdgeIndex.length; i = (i + 2) | 0) {
                        tcx.NewConstraint(System.Array.getItem(this.Points, ($t = this.EdgeIndex)[System.Array.index(i, $t)], Poly2Tri.Triangulation.TriangulationPoint), System.Array.getItem(this.Points, ($t1 = this.EdgeIndex)[System.Array.index(((i + 1) | 0), $t1)], Poly2Tri.Triangulation.TriangulationPoint));
                    }
                }
            },
            isValid: function () {
                return true;
            }
        }
    });

    /**
     * Reference implementation for forces based on AbstractForceController
     It supports all features provided by the base class and illustrates proper
     usage as an easy to understand example.
     As a side-effect it is a nice and easy to use wind force for your projects
     *
     * @public
     * @class FarseerPhysics.Controllers.SimpleWindForce
     * @augments FarseerPhysics.Controllers.AbstractForceController
     */
    Bridge.define("FarseerPhysics.Controllers.SimpleWindForce", {
        inherits: [FarseerPhysics.Controllers.AbstractForceController],
        fields: {
            /**
             * Direction of the windforce
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.SimpleWindForce
             * @function Direction
             * @type Microsoft.Xna.Framework.Vector2
             */
            Direction: null,
            /**
             * The amount of Direction randomization. Allowed range is 0-1.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.SimpleWindForce
             * @function Divergence
             * @type number
             */
            Divergence: 0,
            /**
             * Ignore the position and apply the force. If off only in the "front" (relative to position and direction)
             will be affected
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.SimpleWindForce
             * @function IgnorePosition
             * @type boolean
             */
            IgnorePosition: false
        },
        ctors: {
            init: function () {
                this.Direction = new Microsoft.Xna.Framework.Vector2();
            }
        },
        methods: {
            ApplyForce: function (dt, strength) {
                var $t;
                $t = Bridge.getEnumerator(this.World.BodyList);
                try {
                    while ($t.moveNext()) {
                        var body = $t.Current;
                        var decayMultiplier = this.GetDecayMultiplier(body);

                        if (decayMultiplier !== 0) {
                            var forceVector = new Microsoft.Xna.Framework.Vector2();

                            if (this.ForceType === FarseerPhysics.Controllers.AbstractForceController.ForceTypes.Point) {
                                forceVector = Microsoft.Xna.Framework.Vector2.op_Subtraction(body.Position.$clone(), this.Position.$clone());
                            } else {
                                this.Direction.Normalize();

                                forceVector = this.Direction.$clone();

                                if (forceVector.Length() === 0) {
                                    forceVector = new Microsoft.Xna.Framework.Vector2.$ctor2(0, 1);
                                }
                            }


                            if (this.Variation !== 0) {
                                var strengthVariation = this.Randomize.NextDouble() * Microsoft.Xna.Framework.MathHelper.Clamp$1(this.Variation, 0, 1);
                                forceVector.Normalize();
                                body.ApplyForce(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(), strength), decayMultiplier), strengthVariation));
                            } else {
                                forceVector.Normalize();
                                body.ApplyForce(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(), strength), decayMultiplier));
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        }
    });
});

//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAiZmlsZSI6ICJGYXJzZWVyUGh5c2ljcy5qcyIsCiAgInNvdXJjZVJvb3QiOiAiIiwKICAic291cmNlcyI6IFsiQ29sbGlzaW9uL1F1YWRUcmVlLmNzIiwiQ29sbGlzaW9uL0NvbGxpc2lvbi5jcyIsIkNvbGxpc2lvbi9EaXN0YW5jZS5jcyIsIkNvbGxpc2lvbi9EeW5hbWljVHJlZS5jcyIsIkNvbGxpc2lvbi9EeW5hbWljVHJlZUJyb2FkUGhhc2UuY3MiLCJDb2xsaXNpb24vVGltZU9mSW1wYWN0LmNzIiwiQ29sbGlzaW9uL1NoYXBlcy9TaGFwZS5jcyIsIkNvbW1vbi9Db252ZXhIdWxsL0NoYWluSHVsbC5jcyIsIkNvbW1vbi9Db252ZXhIdWxsL0dpZnRXcmFwLmNzIiwiQ29tbW9uL0NvbnZleEh1bGwvTWVsa21hbi5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0JheWF6aXREZWNvbXBvc2VyLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RURGVjb21wb3Nlci5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0VhcmNsaXBEZWNvbXBvc2VyLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vU2VpZGVsRGVjb21wb3Nlci5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0ZsaXBjb2RlRGVjb21wb3Nlci5jcyIsIkNvbW1vbi9WZXJ0aWNlcy5jcyIsIkNvbW1vbi9GaXhlZEFycmF5LmNzIiwiQ29tbW9uL0xpbmVUb29scy5jcyIsIkNvbW1vbi9UZXh0dXJlVG9vbHMvTWFyY2hpbmdTcXVhcmVzLmNzIiwiQ29tbW9uL01hdGguY3MiLCJDb21tb24vVGV4dHVyZVRvb2xzL01TVGVycmFpbi5jcyIsIkR5bmFtaWNzL1dvcmxkLmNzIiwiQ29tbW9uL1BoeXNpY3NMb2dpYy9QaHlzaWNzTG9naWMuY3MiLCJDb21tb24vUGh5c2ljc0xvZ2ljL0V4cGxvc2lvbi5jcyIsIkNvbW1vbi9Qb2x5Z29uTWFuaXB1bGF0aW9uL0N1dHRpbmdUb29scy5jcyIsIkNvbW1vbi9Qb2x5Z29uTWFuaXB1bGF0aW9uL1NpbXBsaWZ5VG9vbHMuY3MiLCJDb21tb24vUG9seWdvbk1hbmlwdWxhdGlvbi9ZdVBlbmdDbGlwcGVyLmNzIiwiQ29tbW9uL1BvbHlnb25Ub29scy5jcyIsIkNvbW1vbi9UZXh0dXJlVG9vbHMvVGV4dHVyZUNvbnZlcnRlci5jcyIsIkNvbnRyb2xsZXJzL0NvbnRyb2xsZXIuY3MiLCJEZWJ1Z1ZpZXcuY3MiLCJEeW5hbWljcy9Cb2R5LmNzIiwiRHluYW1pY3MvQnJlYWthYmxlQm9keS5jcyIsIkR5bmFtaWNzL0ZpeHR1cmUuY3MiLCJEeW5hbWljcy9Db250YWN0TWFuYWdlci5jcyIsIkR5bmFtaWNzL0NvbnRhY3RzL0NvbnRhY3QuY3MiLCJEeW5hbWljcy9Db250YWN0cy9Db250YWN0U29sdmVyLmNzIiwiRHluYW1pY3MvSXNsYW5kLmNzIiwiRHluYW1pY3MvSm9pbnRzL0pvaW50LmNzIiwiRmFjdG9yaWVzL0JvZHlGYWN0b3J5LmNzIiwiRmFjdG9yaWVzL0ZpeHR1cmVGYWN0b3J5LmNzIiwiRmFjdG9yaWVzL0pvaW50RmFjdG9yeS5jcyIsIlNldHRpbmdzLmNzIiwiU2NyZWVuU3lzdGVtL0NhbWVyYTJELmNzIiwiQ29tbW9uLmNzIiwiU2NyZWVuU3lzdGVtL0NvbnZlcnRVbml0cy5jcyIsIlNjcmVlblN5c3RlbS9HYW1lU2NyZWVuLmNzIiwiU2NyZWVuU3lzdGVtL1NjcmVlbk1hbmFnZXJDb21wb25lbnQuY3MiLCJEcmF3aW5nU3lzdGVtL1Nwcml0ZS5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9EZWxhdW5heS9EZWxhdW5heVRyaWFuZ2xlLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL0RlbGF1bmF5L1N3ZWVwL0FkdmFuY2luZ0Zyb250LmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL0RlbGF1bmF5L1N3ZWVwL0FkdmFuY2luZ0Zyb250Tm9kZS5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9EZWxhdW5heS9Td2VlcC9EVFN3ZWVwLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL1RyaWFuZ3VsYXRpb25Db250ZXh0LmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL1RyaWFuZ3VsYXRpb25Qb2ludC5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9EZWxhdW5heS9Td2VlcC9Qb2ludE9uRWRnZUV4Y2VwdGlvbi5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9Qb2x5Z29uL1BvbHlnb25TZXQuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvVHJpYW5ndWxhdGlvblV0aWwuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvVXRpbC9GaXhlZEFycmF5My5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9VdGlsL0ZpeGVkQml0QXJyYXkzLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL1V0aWwvUG9pbnRHZW5lcmF0b3IuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvVXRpbC9Qb2x5Z29uR2VuZXJhdG9yLmNzIiwiQ29sbGlzaW9uL1NoYXBlcy9DaXJjbGVTaGFwZS5jcyIsIkNvbGxpc2lvbi9TaGFwZXMvRWRnZVNoYXBlLmNzIiwiQ29sbGlzaW9uL1NoYXBlcy9Mb29wU2hhcGUuY3MiLCJDb2xsaXNpb24vU2hhcGVzL1BvbHlnb25TaGFwZS5jcyIsIkR5bmFtaWNzL0pvaW50cy9BbmdsZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0Rpc3RhbmNlSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvRml4ZWRBbmdsZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0ZpeGVkRGlzdGFuY2VKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9GaXhlZEZyaWN0aW9uSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvRml4ZWRMaW5lSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvRml4ZWRNb3VzZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0ZpeGVkUHJpc21hdGljSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvRml4ZWRSZXZvbHV0ZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0ZyaWN0aW9uSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvR2VhckpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0xpbmVKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9QcmlzbWF0aWNKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9QdWxsZXlKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9SZXZvbHV0ZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL1JvcGVKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9TbGlkZXJKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9XZWxkSm9pbnQuY3MiLCJTY3JlZW5TeXN0ZW0vUGh5c2ljc0dhbWVTY3JlZW4uY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvRGVsYXVuYXkvU3dlZXAvRFRTd2VlcENvbnN0cmFpbnQuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvRGVsYXVuYXkvU3dlZXAvRFRTd2VlcENvbnRleHQuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvRGVsYXVuYXkvU3dlZXAvRFRTd2VlcFBvaW50Q29tcGFyYXRvci5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9Qb2x5Z29uL1BvbHlnb24uY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvUG9seWdvbi9Qb2x5Z29uUG9pbnQuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvU2V0cy9Qb2ludFNldC5jcyIsIkNvbGxpc2lvbi9RdWFkVHJlZUJyb2FkUGhhc2UuY3MiLCJDb250cm9sbGVycy9BYnN0cmFjdEZvcmNlQ29udHJvbGxlci5jcyIsIkNvbnRyb2xsZXJzL0J1b3lhbmN5Q29udHJvbGxlci5jcyIsIkNvbnRyb2xsZXJzL0dyYXZpdHlDb250cm9sbGVyLmNzIiwiQ29udHJvbGxlcnMvVmVsb2NpdHlMaW1pdENvbnRyb2xsZXIuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvU2V0cy9Db25zdHJhaW5lZFBvaW50U2V0LmNzIiwiQ29udHJvbGxlcnMvU2ltcGxlV2luZEZvcmNlLmNzIl0sCiAgIm5hbWVzIjogWyIiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBV21CQSxPQUFTQTs7Z0JBRXBCQSxZQUFPQTtnQkFDUEEsYUFBUUE7Z0JBQ1JBLGNBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NDOE02QkEsSUFBSUE7Ozs7dUNBd0xYQSxHQUFRQTs7O29CQUVuQ0EsT0FBT0EsNENBQWdCQSxHQUFPQTs7eUNBR0hBLEdBQVlBO29CQUV2Q0EsU0FBYUEsd0VBQWVBO29CQUM1QkEsU0FBYUEsd0VBQWVBOztvQkFFNUJBLElBQUlBLGNBQWVBO3dCQUNmQTs7O29CQUVKQSxJQUFJQSxjQUFlQTt3QkFDZkE7OztvQkFFSkE7O3lDQUcyQkEsUUFBY0EsUUFDZEEsUUFBY0EsUUFDZEEsS0FBbUJBO29CQUU5Q0EsZ0RBQWtCQSxRQUFRQTtvQkFDMUJBLGdEQUFrQkEsUUFBUUE7b0JBQzFCQSxrREFBb0JBO29CQUNwQkEsa0RBQW9CQTtvQkFDcEJBOztvQkFFQUE7b0JBQ0FBO29CQUNBQSxrREFBNkJBLFFBQVlBLE9BQU9BOztvQkFFaERBLE9BQU9BLG9CQUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXRMbkJBLE9BQU9BLG1EQUFPQSxDQUFDQSxzRUFBYUE7Ozs7Ozs7Ozs7Ozs7OztvQkFTNUJBLE9BQU9BLG1EQUFPQSxDQUFDQSx5RUFBYUE7Ozs7Ozs7Ozs7Ozs7OztvQkFXOUJBLFNBQVdBLG9CQUFlQTtvQkFDMUJBLFNBQVdBLG9CQUFlQTtvQkFDMUJBLE9BQU9BLE1BQU9BLENBQUNBLEtBQUtBOzs7Ozs7Ozs7Ozs7Ozs7b0JBWXBCQSxlQUFvQkEsSUFBSUE7b0JBQ3hCQSxhQUFhQTtvQkFDYkEsYUFBYUEsSUFBSUEsdUNBQVFBLG1CQUFjQTtvQkFDdkNBLGFBQWFBO29CQUNiQSxhQUFhQSxJQUFJQSx1Q0FBUUEs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STNEQTtnQ0FDQUEsZ0JBQWdCQSxrSEFBY0EsV0FBV0EiLAogICJzb3VyY2VzQ29udGVudCI6IFsidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbnB1YmxpYyBjbGFzcyBFbGVtZW50PFQ+XHJcbntcclxuICAgIHB1YmxpYyBRdWFkVHJlZTxUPiBQYXJlbnQ7XHJcbiAgICBwdWJsaWMgQUFCQiBTcGFuO1xyXG4gICAgcHVibGljIFQgVmFsdWU7XHJcblxyXG4gICAgcHVibGljIEVsZW1lbnQoVCB2YWx1ZSwgQUFCQiBzcGFuKVxyXG4gICAge1xyXG4gICAgICAgIFNwYW4gPSBzcGFuO1xyXG4gICAgICAgIFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgUGFyZW50ID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxucHVibGljIGNsYXNzIFF1YWRUcmVlPFQ+XHJcbntcclxuICAgIHB1YmxpYyBpbnQgTWF4QnVja2V0O1xyXG4gICAgcHVibGljIGludCBNYXhEZXB0aDtcclxuICAgIHB1YmxpYyBMaXN0PEVsZW1lbnQ8VD4+IE5vZGVzO1xyXG4gICAgcHVibGljIEFBQkIgU3BhbjtcclxuICAgIHB1YmxpYyBRdWFkVHJlZTxUPltdIFN1YlRyZWVzO1xyXG5cclxuICAgIHB1YmxpYyBRdWFkVHJlZShBQUJCIHNwYW4sIGludCBtYXhidWNrZXQsIGludCBtYXhkZXB0aClcclxuICAgIHtcclxuICAgICAgICBTcGFuID0gc3BhbjtcclxuICAgICAgICBOb2RlcyA9IG5ldyBMaXN0PEVsZW1lbnQ8VD4+KCk7XHJcblxyXG4gICAgICAgIE1heEJ1Y2tldCA9IG1heGJ1Y2tldDtcclxuICAgICAgICBNYXhEZXB0aCA9IG1heGRlcHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBib29sIElzUGFydGl0aW9uZWRcclxuICAgIHtcclxuICAgICAgICBnZXQgeyByZXR1cm4gU3ViVHJlZXMgIT0gbnVsbDsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyByZXR1cm5zIHRoZSBxdWFkcmFudCBvZiBzcGFuIHRoYXQgZW50aXJlbHkgY29udGFpbnMgdGVzdC4gaWYgbm9uZSwgcmV0dXJuIDAuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwic3BhblwiPjwvcGFyYW0+XHJcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0ZXN0XCI+PC9wYXJhbT5cclxuICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICBwcml2YXRlIGludCBQYXJ0aXRpb24oQUFCQiBzcGFuLCBBQUJCIHRlc3QpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKHNwYW4uUTEuQ29udGFpbnMocmVmIHRlc3QpKSByZXR1cm4gMTtcclxuICAgICAgICBpZiAoc3Bhbi5RMi5Db250YWlucyhyZWYgdGVzdCkpIHJldHVybiAyO1xyXG4gICAgICAgIGlmIChzcGFuLlEzLkNvbnRhaW5zKHJlZiB0ZXN0KSkgcmV0dXJuIDM7XHJcbiAgICAgICAgaWYgKHNwYW4uUTQuQ29udGFpbnMocmVmIHRlc3QpKSByZXR1cm4gNDtcclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgQWRkTm9kZShFbGVtZW50PFQ+IG5vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCFJc1BhcnRpdGlvbmVkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKE5vZGVzLkNvdW50ID49IE1heEJ1Y2tldCAmJiBNYXhEZXB0aCA+IDApIC8vYmluIGlzIGZ1bGwgYW5kIGNhbiBzdGlsbCBzdWJkaXZpZGVcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vcGFydGl0aW9uIGludG8gcXVhZHJhbnRzIGFuZCBzb3J0IGV4aXN0aW5nIG5vZGVzIGFtb25zdCBxdWFkcy5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBOb2Rlcy5BZGQobm9kZSk7IC8vdHJlYXQgbmV3IG5vZGUganVzdCBsaWtlIG90aGVyIG5vZGVzIGZvciBwYXJ0aXRpb25pbmdcclxuXHJcbiAgICAgICAgICAgICAgICBTdWJUcmVlcyA9IG5ldyBRdWFkVHJlZTxUPls0XTtcclxuICAgICAgICAgICAgICAgIFN1YlRyZWVzWzBdID0gbmV3IFF1YWRUcmVlPFQ+KFNwYW4uUTEsIE1heEJ1Y2tldCwgTWF4RGVwdGggLSAxKTtcclxuICAgICAgICAgICAgICAgIFN1YlRyZWVzWzFdID0gbmV3IFF1YWRUcmVlPFQ+KFNwYW4uUTIsIE1heEJ1Y2tldCwgTWF4RGVwdGggLSAxKTtcclxuICAgICAgICAgICAgICAgIFN1YlRyZWVzWzJdID0gbmV3IFF1YWRUcmVlPFQ+KFNwYW4uUTMsIE1heEJ1Y2tldCwgTWF4RGVwdGggLSAxKTtcclxuICAgICAgICAgICAgICAgIFN1YlRyZWVzWzNdID0gbmV3IFF1YWRUcmVlPFQ+KFNwYW4uUTQsIE1heEJ1Y2tldCwgTWF4RGVwdGggLSAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBMaXN0PEVsZW1lbnQ8VD4+IHJlbU5vZGVzID0gbmV3IExpc3Q8RWxlbWVudDxUPj4oKTtcclxuICAgICAgICAgICAgICAgIC8vbm9kZXMgdGhhdCBhcmUgbm90IGZ1bGx5IGNvbnRhaW5lZCBieSBhbnkgcXVhZHJhbnRcclxuXHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChFbGVtZW50PFQ+IG4gaW4gTm9kZXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChQYXJ0aXRpb24oU3Bhbiwgbi5TcGFuKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogLy9xdWFkcmFudCAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJUcmVlc1swXS5BZGROb2RlKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1YlRyZWVzWzFdLkFkZE5vZGUobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3ViVHJlZXNbMl0uQWRkTm9kZShuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJUcmVlc1szXS5BZGROb2RlKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLlBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1Ob2Rlcy5BZGQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgTm9kZXMgPSByZW1Ob2RlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuUGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIE5vZGVzLkFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgIC8vaWYgYmluIGlzIG5vdCB5ZXQgZnVsbCBvciBtYXggZGVwdGggaGFzIGJlZW4gcmVhY2hlZCwganVzdCBhZGQgdGhlIG5vZGUgd2l0aG91dCBzdWJkaXZpZGluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgLy93ZSBhbHJlYWR5IGhhdmUgY2hpbGRyZW4gbm9kZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vYWRkIG5vZGUgdG8gc3BlY2lmaWMgc3ViLXRyZWVcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgc3dpdGNoIChQYXJ0aXRpb24oU3Bhbiwgbm9kZS5TcGFuKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvL3F1YWRyYW50IDFcclxuICAgICAgICAgICAgICAgICAgICBTdWJUcmVlc1swXS5BZGROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIFN1YlRyZWVzWzFdLkFkZE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgU3ViVHJlZXNbMl0uQWRkTm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBTdWJUcmVlc1szXS5BZGROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBub2RlLlBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgTm9kZXMuQWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyB0ZXN0cyBpZiByYXkgaW50ZXJzZWN0cyBBQUJCXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPjwvcGFyYW0+XHJcbiAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgcHVibGljIHN0YXRpYyBib29sIFJheUNhc3RBQUJCKEFBQkIgYWFiYiwgVmVjdG9yMiBwMSwgVmVjdG9yMiBwMilcclxuICAgIHtcclxuICAgICAgICBBQUJCIHNlZ21lbnRBQUJCID0gbmV3IEFBQkIoKTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIuTWluKHJlZiBwMSwgcmVmIHAyLCBvdXQgc2VnbWVudEFBQkIuTG93ZXJCb3VuZCk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIuTWF4KHJlZiBwMSwgcmVmIHAyLCBvdXQgc2VnbWVudEFBQkIuVXBwZXJCb3VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghQUFCQi5UZXN0T3ZlcmxhcChhYWJiLCBzZWdtZW50QUFCQikpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgVmVjdG9yMiByYXlEaXIgPSBwMiAtIHAxO1xyXG4gICAgICAgIFZlY3RvcjIgcmF5UG9zID0gcDE7XHJcblxyXG4gICAgICAgIFZlY3RvcjIgbm9ybSA9IG5ldyBWZWN0b3IyKC1yYXlEaXIuWSwgcmF5RGlyLlgpOyAvL25vcm1hbCB0byByYXlcclxuICAgICAgICBpZiAobm9ybS5MZW5ndGgoKSA9PSAwLjApXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvL2lmIHJheSBpcyBqdXN0IGEgcG9pbnQsIHJldHVybiB0cnVlIChpZmYgcG9pbnQgaXMgd2l0aGluIGFhYmIsIGFzIHRlc3RlZCBlYXJsaWVyKVxyXG4gICAgICAgIG5vcm0uTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIGZsb2F0IGRQb3MgPSBWZWN0b3IyLkRvdChyYXlQb3MsIG5vcm0pO1xyXG5cclxuICAgICAgICBWZWN0b3IyW10gdmVydHMgPSBhYWJiLkdldFZlcnRpY2VzKCk7XHJcbiAgICAgICAgZmxvYXQgZDAgPSBWZWN0b3IyLkRvdCh2ZXJ0c1swXSwgbm9ybSkgLSBkUG9zO1xyXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgNDsgaSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgZCA9IFZlY3RvcjIuRG90KHZlcnRzW2ldLCBub3JtKSAtIGRQb3M7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLlNpZ24oZCkgIT0gTWF0aC5TaWduKGQwKSlcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRydWUgaWYgdGhlIHJheSBzcGxpdHMgdGhlIHZlcnRpY2VzIChpZTogc2lnbiBvZiBkb3QgcHJvZHVjdHMgd2l0aCBub3JtYWwgYXJlIG5vdCBhbGwgc2FtZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIFF1ZXJ5QUFCQihGdW5jPEVsZW1lbnQ8VD4sIGJvb2w+IGNhbGxiYWNrLCByZWYgQUFCQiBzZWFyY2hSKVxyXG4gICAge1xyXG4gICAgICAgIFN0YWNrPFF1YWRUcmVlPFQ+PiBzdGFjayA9IG5ldyBTdGFjazxRdWFkVHJlZTxUPj4oKTtcclxuICAgICAgICBzdGFjay5QdXNoKHRoaXMpO1xyXG5cclxuICAgICAgICB3aGlsZSAoc3RhY2suQ291bnQgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUXVhZFRyZWU8VD4gcXQgPSBzdGFjay5Qb3AoKTtcclxuICAgICAgICAgICAgaWYgKCFBQUJCLlRlc3RPdmVybGFwKHJlZiBzZWFyY2hSLCByZWYgcXQuU3BhbikpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEVsZW1lbnQ8VD4gbiBpbiBxdC5Ob2RlcylcclxuICAgICAgICAgICAgICAgIGlmIChBQUJCLlRlc3RPdmVybGFwKHJlZiBzZWFyY2hSLCByZWYgbi5TcGFuKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKG4pKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocXQuSXNQYXJ0aXRpb25lZClcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKFF1YWRUcmVlPFQ+IHN0IGluIHF0LlN1YlRyZWVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLlB1c2goc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdm9pZCBSYXlDYXN0KEZ1bmM8UmF5Q2FzdElucHV0LCBFbGVtZW50PFQ+LCBmbG9hdD4gY2FsbGJhY2ssIHJlZiBSYXlDYXN0SW5wdXQgaW5wdXQpXHJcbiAgICB7XHJcbiAgICAgICAgU3RhY2s8UXVhZFRyZWU8VD4+IHN0YWNrID0gbmV3IFN0YWNrPFF1YWRUcmVlPFQ+PigpO1xyXG4gICAgICAgIHN0YWNrLlB1c2godGhpcyk7XHJcblxyXG4gICAgICAgIGZsb2F0IG1heEZyYWN0aW9uID0gaW5wdXQuTWF4RnJhY3Rpb247XHJcbiAgICAgICAgVmVjdG9yMiBwMSA9IGlucHV0LlBvaW50MTtcclxuICAgICAgICBWZWN0b3IyIHAyID0gcDEgKyAoaW5wdXQuUG9pbnQyIC0gaW5wdXQuUG9pbnQxKSAqIG1heEZyYWN0aW9uO1xyXG5cclxuICAgICAgICB3aGlsZSAoc3RhY2suQ291bnQgPiAwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUXVhZFRyZWU8VD4gcXQgPSBzdGFjay5Qb3AoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghUmF5Q2FzdEFBQkIocXQuU3BhbiwgcDEsIHAyKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoRWxlbWVudDxUPiBuIGluIHF0Lk5vZGVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVJheUNhc3RBQUJCKG4uU3BhbiwgcDEsIHAyKSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBSYXlDYXN0SW5wdXQgc3ViSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBzdWJJbnB1dC5Qb2ludDEgPSBpbnB1dC5Qb2ludDE7XHJcbiAgICAgICAgICAgICAgICBzdWJJbnB1dC5Qb2ludDIgPSBpbnB1dC5Qb2ludDI7XHJcbiAgICAgICAgICAgICAgICBzdWJJbnB1dC5NYXhGcmFjdGlvbiA9IG1heEZyYWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gY2FsbGJhY2soc3ViSW5wdXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB0aGUgY2xpZW50IGhhcyB0ZXJtaW5hdGVkIHRoZSByYXljYXN0LlxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIG1heEZyYWN0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBwMiA9IHAxICsgKGlucHV0LlBvaW50MiAtIGlucHV0LlBvaW50MSkgKiBtYXhGcmFjdGlvbjsgLy91cGRhdGUgc2VnbWVudCBlbmRwb2ludFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChJc1BhcnRpdGlvbmVkKVxyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoUXVhZFRyZWU8VD4gc3QgaW4gcXQuU3ViVHJlZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suUHVzaChzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIEdldEFsbE5vZGVzUihyZWYgTGlzdDxFbGVtZW50PFQ+PiBub2RlcylcclxuICAgIHtcclxuICAgICAgICBub2Rlcy5BZGRSYW5nZShOb2Rlcyk7XHJcblxyXG4gICAgICAgIGlmIChJc1BhcnRpdGlvbmVkKVxyXG4gICAgICAgICAgICBmb3JlYWNoIChRdWFkVHJlZTxUPiBzdCBpbiBTdWJUcmVlcykgc3QuR2V0QWxsTm9kZXNSKHJlZiBub2Rlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgUmVtb3ZlTm9kZShFbGVtZW50PFQ+IG5vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgbm9kZS5QYXJlbnQuTm9kZXMuUmVtb3ZlKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIFJlY29uc3RydWN0KClcclxuICAgIHtcclxuICAgICAgICBMaXN0PEVsZW1lbnQ8VD4+IGFsbE5vZGVzID0gbmV3IExpc3Q8RWxlbWVudDxUPj4oKTtcclxuICAgICAgICBHZXRBbGxOb2Rlc1IocmVmIGFsbE5vZGVzKTtcclxuXHJcbiAgICAgICAgQ2xlYXIoKTtcclxuXHJcbiNpZiBORVRGWF9DT1JFXHJcbiAgICAgICAgZm9yZWFjaCAodmFyIG5vZGUgaW4gYWxsTm9kZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBZGROb2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuI2Vsc2VcclxuICAgICAgICBhbGxOb2Rlcy5Gb3JFYWNoKChnbG9iYWw6OlN5c3RlbS5BY3Rpb248Z2xvYmFsOjpFbGVtZW50PFQ+PilBZGROb2RlKTtcclxuI2VuZGlmXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgQ2xlYXIoKVxyXG4gICAge1xyXG4gICAgICAgIE5vZGVzLkNsZWFyKCk7XHJcbiAgICAgICAgU3ViVHJlZXMgPSBudWxsO1xyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvblxyXG57XHJcbiAgICBpbnRlcm5hbCBlbnVtIENvbnRhY3RGZWF0dXJlVHlwZSA6IGJ5dGVcclxuICAgIHtcclxuICAgICAgICBWZXJ0ZXggPSAwLFxyXG4gICAgICAgIEZhY2UgPSAxLFxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGUgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgdG8gZm9ybSB0aGUgY29udGFjdCBwb2ludFxyXG4gICAgLy8vIFRoaXMgbXVzdCBiZSA0IGJ5dGVzIG9yIGxlc3MuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBDb250YWN0RmVhdHVyZVxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmVhdHVyZSBpbmRleCBvbiBTaGFwZUFcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBieXRlIEluZGV4QTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGZWF0dXJlIGluZGV4IG9uIFNoYXBlQlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJ5dGUgSW5kZXhCO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBmZWF0dXJlIHR5cGUgb24gU2hhcGVBXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYnl0ZSBUeXBlQTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZmVhdHVyZSB0eXBlIG9uIFNoYXBlQlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJ5dGUgVHlwZUI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIENvbnRhY3QgaWRzIHRvIGZhY2lsaXRhdGUgd2FybSBzdGFydGluZy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBbU3RydWN0TGF5b3V0KExheW91dEtpbmQuRXhwbGljaXQpXVxyXG4gICAgcHVibGljIHN0cnVjdCBDb250YWN0SURcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCB0byBmb3JtIHRoZSBjb250YWN0IHBvaW50XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBbRmllbGRPZmZzZXQoMCldXHJcbiAgICAgICAgcHVibGljIENvbnRhY3RGZWF0dXJlIEZlYXR1cmVzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFVzZWQgdG8gcXVpY2tseSBjb21wYXJlIGNvbnRhY3QgaWRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgW0ZpZWxkT2Zmc2V0KDApXVxyXG4gICAgICAgIHB1YmxpYyB1aW50IEtleTtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBtYW5pZm9sZCBwb2ludCBpcyBhIGNvbnRhY3QgcG9pbnQgYmVsb25naW5nIHRvIGEgY29udGFjdFxyXG4gICAgLy8vIG1hbmlmb2xkLiBJdCBob2xkcyBkZXRhaWxzIHJlbGF0ZWQgdG8gdGhlIGdlb21ldHJ5IGFuZCBkeW5hbWljc1xyXG4gICAgLy8vIG9mIHRoZSBjb250YWN0IHBvaW50cy5cclxuICAgIC8vLyBUaGUgbG9jYWwgcG9pbnQgdXNhZ2UgZGVwZW5kcyBvbiB0aGUgbWFuaWZvbGQgdHlwZTpcclxuICAgIC8vLyAtU2hhcGVUeXBlLkNpcmNsZXM6IHRoZSBsb2NhbCBjZW50ZXIgb2YgY2lyY2xlQlxyXG4gICAgLy8vIC1TZXBhcmF0aW9uRnVuY3Rpb24uRmFjZUE6IHRoZSBsb2NhbCBjZW50ZXIgb2YgY2lybGNlQiBvciB0aGUgY2xpcCBwb2ludCBvZiBwb2x5Z29uQlxyXG4gICAgLy8vIC1TZXBhcmF0aW9uRnVuY3Rpb24uRmFjZUI6IHRoZSBjbGlwIHBvaW50IG9mIHBvbHlnb25BXHJcbiAgICAvLy8gVGhpcyBzdHJ1Y3R1cmUgaXMgc3RvcmVkIGFjcm9zcyB0aW1lIHN0ZXBzLCBzbyB3ZSBrZWVwIGl0IHNtYWxsLlxyXG4gICAgLy8vIE5vdGU6IHRoZSBpbXB1bHNlcyBhcmUgdXNlZCBmb3IgaW50ZXJuYWwgY2FjaGluZyBhbmQgbWF5IG5vdFxyXG4gICAgLy8vIHByb3ZpZGUgcmVsaWFibGUgY29udGFjdCBmb3JjZXMsIGVzcGVjaWFsbHkgZm9yIGhpZ2ggc3BlZWQgY29sbGlzaW9ucy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IE1hbmlmb2xkUG9pbnRcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFVuaXF1ZWx5IGlkZW50aWZpZXMgYSBjb250YWN0IHBvaW50IGJldHdlZW4gdHdvIFNoYXBlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIENvbnRhY3RJRCBJZDtcclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxQb2ludDtcclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE5vcm1hbEltcHVsc2U7XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBUYW5nZW50SW1wdWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZW51bSBNYW5pZm9sZFR5cGVcclxuICAgIHtcclxuICAgICAgICBDaXJjbGVzLFxyXG4gICAgICAgIEZhY2VBLFxyXG4gICAgICAgIEZhY2VCXHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgbWFuaWZvbGQgZm9yIHR3byB0b3VjaGluZyBjb252ZXggU2hhcGVzLlxyXG4gICAgLy8vIEJveDJEIHN1cHBvcnRzIG11bHRpcGxlIHR5cGVzIG9mIGNvbnRhY3Q6XHJcbiAgICAvLy8gLSBjbGlwIHBvaW50IHZlcnN1cyBwbGFuZSB3aXRoIHJhZGl1c1xyXG4gICAgLy8vIC0gcG9pbnQgdmVyc3VzIHBvaW50IHdpdGggcmFkaXVzIChjaXJjbGVzKVxyXG4gICAgLy8vIFRoZSBsb2NhbCBwb2ludCB1c2FnZSBkZXBlbmRzIG9uIHRoZSBtYW5pZm9sZCB0eXBlOlxyXG4gICAgLy8vIC1TaGFwZVR5cGUuQ2lyY2xlczogdGhlIGxvY2FsIGNlbnRlciBvZiBjaXJjbGVBXHJcbiAgICAvLy8gLVNlcGFyYXRpb25GdW5jdGlvbi5GYWNlQTogdGhlIGNlbnRlciBvZiBmYWNlQVxyXG4gICAgLy8vIC1TZXBhcmF0aW9uRnVuY3Rpb24uRmFjZUI6IHRoZSBjZW50ZXIgb2YgZmFjZUJcclxuICAgIC8vLyBTaW1pbGFybHkgdGhlIGxvY2FsIG5vcm1hbCB1c2FnZTpcclxuICAgIC8vLyAtU2hhcGVUeXBlLkNpcmNsZXM6IG5vdCB1c2VkXHJcbiAgICAvLy8gLVNlcGFyYXRpb25GdW5jdGlvbi5GYWNlQTogdGhlIG5vcm1hbCBvbiBwb2x5Z29uQVxyXG4gICAgLy8vIC1TZXBhcmF0aW9uRnVuY3Rpb24uRmFjZUI6IHRoZSBub3JtYWwgb24gcG9seWdvbkJcclxuICAgIC8vLyBXZSBzdG9yZSBjb250YWN0cyBpbiB0aGlzIHdheSBzbyB0aGF0IHBvc2l0aW9uIGNvcnJlY3Rpb24gY2FuXHJcbiAgICAvLy8gYWNjb3VudCBmb3IgbW92ZW1lbnQsIHdoaWNoIGlzIGNyaXRpY2FsIGZvciBjb250aW51b3VzIHBoeXNpY3MuXHJcbiAgICAvLy8gQWxsIGNvbnRhY3Qgc2NlbmFyaW9zIG11c3QgYmUgZXhwcmVzc2VkIGluIG9uZSBvZiB0aGVzZSB0eXBlcy5cclxuICAgIC8vLyBUaGlzIHN0cnVjdHVyZSBpcyBzdG9yZWQgYWNyb3NzIHRpbWUgc3RlcHMsIHNvIHdlIGtlZXAgaXQgc21hbGwuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBNYW5pZm9sZFxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTm90IHVzZSBmb3IgVHlwZS5TZXBhcmF0aW9uRnVuY3Rpb24uUG9pbnRzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbE5vcm1hbDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBVc2FnZSBkZXBlbmRzIG9uIG1hbmlmb2xkIHR5cGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsUG9pbnQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG51bWJlciBvZiBtYW5pZm9sZCBwb2ludHNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBpbnQgUG9pbnRDb3VudDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgcG9pbnRzIG9mIGNvbnRhY3RcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBGaXhlZEFycmF5MjxNYW5pZm9sZFBvaW50PiBQb2ludHM7XHJcblxyXG4gICAgICAgIHB1YmxpYyBNYW5pZm9sZFR5cGUgVHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhpcyBpcyB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgc3RhdGUgb2YgY29udGFjdCBwb2ludHMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGVudW0gUG9pbnRTdGF0ZVxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnQgZG9lcyBub3QgZXhpc3RcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIE51bGwsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnQgd2FzIGFkZGVkIGluIHRoZSB1cGRhdGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIEFkZCxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludCBwZXJzaXN0ZWQgYWNyb3NzIHRoZSB1cGRhdGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFBlcnNpc3QsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnQgd2FzIHJlbW92ZWQgaW4gdGhlIHVwZGF0ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgUmVtb3ZlLFxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBVc2VkIGZvciBjb21wdXRpbmcgY29udGFjdCBtYW5pZm9sZHMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBDbGlwVmVydGV4XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIENvbnRhY3RJRCBJRDtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBWO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBSYXktY2FzdCBpbnB1dCBkYXRhLiBUaGUgcmF5IGV4dGVuZHMgZnJvbSBwMSB0byBwMSArIG1heEZyYWN0aW9uICogKHAyIC0gcDEpLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgUmF5Q2FzdElucHV0XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heEZyYWN0aW9uO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFBvaW50MSwgUG9pbnQyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBSYXktY2FzdCBvdXRwdXQgZGF0YS4gIFRoZSByYXkgaGl0cyBhdCBwMSArIGZyYWN0aW9uICogKHAyIC0gcDEpLCB3aGVyZSBwMSBhbmQgcDJcclxuICAgIC8vLyBjb21lIGZyb20gUmF5Q2FzdElucHV0LiBcclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IFJheUNhc3RPdXRwdXRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgRnJhY3Rpb247XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTm9ybWFsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBbiBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94LlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgQUFCQlxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIERpc3RhbmNlSW5wdXQgX2lucHV0ID0gbmV3IERpc3RhbmNlSW5wdXQoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbG93ZXIgdmVydGV4XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb3dlckJvdW5kO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSB1cHBlciB2ZXJ0ZXhcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFVwcGVyQm91bmQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBBQUJCKFZlY3RvcjIgbWluLCBWZWN0b3IyIG1heClcclxuICAgICAgICAgICAgOiB0aGlzKHJlZiBtaW4sIHJlZiBtYXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEFBQkIocmVmIFZlY3RvcjIgbWluLCByZWYgVmVjdG9yMiBtYXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMb3dlckJvdW5kID0gbWluO1xyXG4gICAgICAgICAgICBVcHBlckJvdW5kID0gbWF4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEFBQkIoVmVjdG9yMiBjZW50ZXIsIGZsb2F0IHdpZHRoLCBmbG9hdCBoZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMb3dlckJvdW5kID0gY2VudGVyIC0gbmV3IFZlY3RvcjIod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgVXBwZXJCb3VuZCA9IGNlbnRlciArIG5ldyBWZWN0b3IyKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY2VudGVyIG9mIHRoZSBBQUJCLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIENlbnRlclxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIDAuNWYgKiAoTG93ZXJCb3VuZCArIFVwcGVyQm91bmQpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgZXh0ZW50cyBvZiB0aGUgQUFCQiAoaGFsZi13aWR0aHMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEV4dGVudHNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAwLjVmICogKFVwcGVyQm91bmQgLSBMb3dlckJvdW5kKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHBlcmltZXRlciBsZW5ndGhcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUGVyaW1ldGVyXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgd3ggPSBVcHBlckJvdW5kLlggLSBMb3dlckJvdW5kLlg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB3eSA9IFVwcGVyQm91bmQuWSAtIExvd2VyQm91bmQuWTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyLjBmICogKHd4ICsgd3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIHZlcnRpY2VzIG9mIHRoZSBBQUJCLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgY29ybmVycyBvZiB0aGUgQUFCQjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIFZlcnRpY2VzIFZlcnRpY2VzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChMb3dlckJvdW5kKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMihMb3dlckJvdW5kLlgsIFVwcGVyQm91bmQuWSkpO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKFVwcGVyQm91bmQpO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKFVwcGVyQm91bmQuWCwgTG93ZXJCb3VuZC5ZKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gZmlyc3QgcXVhZHJhbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBBQUJCIFExXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gbmV3IEFBQkIoQ2VudGVyLCBVcHBlckJvdW5kKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEFBQkIgUTJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFBQkIobmV3IFZlY3RvcjIoTG93ZXJCb3VuZC5YLCBDZW50ZXIuWSksIG5ldyBWZWN0b3IyKENlbnRlci5YLCBVcHBlckJvdW5kLlkpKTtcclxuICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEFBQkIgUTNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBuZXcgQUFCQihMb3dlckJvdW5kLCBDZW50ZXIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgQUFCQiBRNFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIG5ldyBBQUJCKG5ldyBWZWN0b3IyKENlbnRlci5YLCBMb3dlckJvdW5kLlkpLCBuZXcgVmVjdG9yMihVcHBlckJvdW5kLlgsIENlbnRlci5ZKSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyW10gR2V0VmVydGljZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBwMSA9IFVwcGVyQm91bmQ7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDIgPSBuZXcgVmVjdG9yMihVcHBlckJvdW5kLlgsIExvd2VyQm91bmQuWSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDMgPSBMb3dlckJvdW5kO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHA0ID0gbmV3IFZlY3RvcjIoTG93ZXJCb3VuZC5YLCBVcHBlckJvdW5kLlkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3W10geyBwMSwgcDIsIHAzLCBwNCB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBWZXJpZnkgdGhhdCB0aGUgYm91bmRzIGFyZSBzb3J0ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgdGhpcyBpbnN0YW5jZSBpcyB2YWxpZDsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc1ZhbGlkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IFVwcGVyQm91bmQgLSBMb3dlckJvdW5kO1xyXG4gICAgICAgICAgICBib29sIHZhbGlkID0gZC5YID49IDAuMGYgJiYgZC5ZID49IDAuMGY7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgTG93ZXJCb3VuZC5Jc1ZhbGlkKCkgJiYgVXBwZXJCb3VuZC5Jc1ZhbGlkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWxpZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tYmluZSBhbiBBQUJCIGludG8gdGhpcyBvbmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDb21iaW5lKHJlZiBBQUJCIGFhYmIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMb3dlckJvdW5kID0gVmVjdG9yMi5NaW4oTG93ZXJCb3VuZCwgYWFiYi5Mb3dlckJvdW5kKTtcclxuICAgICAgICAgICAgVXBwZXJCb3VuZCA9IFZlY3RvcjIuTWF4KFVwcGVyQm91bmQsIGFhYmIuVXBwZXJCb3VuZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbWJpbmUgdHdvIEFBQkJzIGludG8gdGhpcyBvbmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiMVwiPlRoZSBhYWJiMS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmIyXCI+VGhlIGFhYmIyLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29tYmluZShyZWYgQUFCQiBhYWJiMSwgcmVmIEFBQkIgYWFiYjIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMb3dlckJvdW5kID0gVmVjdG9yMi5NaW4oYWFiYjEuTG93ZXJCb3VuZCwgYWFiYjIuTG93ZXJCb3VuZCk7XHJcbiAgICAgICAgICAgIFVwcGVyQm91bmQgPSBWZWN0b3IyLk1heChhYWJiMS5VcHBlckJvdW5kLCBhYWJiMi5VcHBlckJvdW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRG9lcyB0aGlzIGFhYmIgY29udGFpbiB0aGUgcHJvdmlkZWQgQUFCQi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgYWFiYi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gXHQ8Yz50cnVlPC9jPiBpZiBpdCBjb250YWlucyB0aGUgc3BlY2lmaWVkIGFhYmI7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29udGFpbnMocmVmIEFBQkIgYWFiYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvb2wgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIExvd2VyQm91bmQuWCA8PSBhYWJiLkxvd2VyQm91bmQuWDtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIExvd2VyQm91bmQuWSA8PSBhYWJiLkxvd2VyQm91bmQuWTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIGFhYmIuVXBwZXJCb3VuZC5YIDw9IFVwcGVyQm91bmQuWDtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICYmIGFhYmIuVXBwZXJCb3VuZC5ZIDw9IFVwcGVyQm91bmQuWTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBBQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRcIj5UaGUgcG9pbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgaXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludDsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBDb250YWlucyhyZWYgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vdXNpbmcgZXBzaWxvbiB0byB0cnkgYW5kIGdhdXJkIGFnYWluc3QgZmxvYXQgcm91bmRpbmcgZXJyb3JzLlxyXG4gICAgICAgICAgICBpZiAoKHBvaW50LlggPiAoTG93ZXJCb3VuZC5YICsgU2V0dGluZ3MuRXBzaWxvbikgJiYgcG9pbnQuWCA8IChVcHBlckJvdW5kLlggLSBTZXR0aW5ncy5FcHNpbG9uKSAmJlxyXG4gICAgICAgICAgICAgICAgIChwb2ludC5ZID4gKExvd2VyQm91bmQuWSArIFNldHRpbmdzLkVwc2lsb24pICYmIHBvaW50LlkgPCAoVXBwZXJCb3VuZC5ZIC0gU2V0dGluZ3MuRXBzaWxvbikpKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIFRlc3RPdmVybGFwKEFBQkIgYSwgQUFCQiBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRlc3RPdmVybGFwKHJlZiBhLCByZWYgYik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgVGVzdE92ZXJsYXAocmVmIEFBQkIgYSwgcmVmIEFBQkIgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZDEgPSBiLkxvd2VyQm91bmQgLSBhLlVwcGVyQm91bmQ7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZDIgPSBhLkxvd2VyQm91bmQgLSBiLlVwcGVyQm91bmQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoZDEuWCA+IDAuMGYgfHwgZDEuWSA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoZDIuWCA+IDAuMGYgfHwgZDIuWSA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBUZXN0T3ZlcmxhcChTaGFwZSBzaGFwZUEsIGludCBpbmRleEEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNoYXBlIHNoYXBlQiwgaW50IGluZGV4QixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmIFRyYW5zZm9ybSB4ZkEsIHJlZiBUcmFuc2Zvcm0geGZCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2lucHV0LlByb3h5QS5TZXQoc2hhcGVBLCBpbmRleEEpO1xyXG4gICAgICAgICAgICBfaW5wdXQuUHJveHlCLlNldChzaGFwZUIsIGluZGV4Qik7XHJcbiAgICAgICAgICAgIF9pbnB1dC5UcmFuc2Zvcm1BID0geGZBO1xyXG4gICAgICAgICAgICBfaW5wdXQuVHJhbnNmb3JtQiA9IHhmQjtcclxuICAgICAgICAgICAgX2lucHV0LlVzZVJhZGlpID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIFNpbXBsZXhDYWNoZSBjYWNoZTtcclxuICAgICAgICAgICAgRGlzdGFuY2VPdXRwdXQgb3V0cHV0O1xyXG4gICAgICAgICAgICBEaXN0YW5jZS5Db21wdXRlRGlzdGFuY2Uob3V0IG91dHB1dCwgb3V0IGNhY2hlLCBfaW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5EaXN0YW5jZSA8IDEwLjBmICogU2V0dGluZ3MuRXBzaWxvbjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBGcm9tIFJlYWwtdGltZSBDb2xsaXNpb24gRGV0ZWN0aW9uLCBwMTc5LlxyXG4gICAgICAgIHB1YmxpYyBib29sIFJheUNhc3Qob3V0IFJheUNhc3RPdXRwdXQgb3V0cHV0LCByZWYgUmF5Q2FzdElucHV0IGlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gbmV3IFJheUNhc3RPdXRwdXQoKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHRtaW4gPSAtU2V0dGluZ3MuTWF4RmxvYXQ7XHJcbiAgICAgICAgICAgIGZsb2F0IHRtYXggPSBTZXR0aW5ncy5NYXhGbG9hdDtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcCA9IGlucHV0LlBvaW50MTtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gaW5wdXQuUG9pbnQyIC0gaW5wdXQuUG9pbnQxO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGFic0QgPSBNYXRoVXRpbHMuQWJzKGQpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBub3JtYWwgPSBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDI7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgYWJzRF9pID0gaSA9PSAwID8gYWJzRC5YIDogYWJzRC5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbG93ZXJCb3VuZF9pID0gaSA9PSAwID8gTG93ZXJCb3VuZC5YIDogTG93ZXJCb3VuZC5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgdXBwZXJCb3VuZF9pID0gaSA9PSAwID8gVXBwZXJCb3VuZC5YIDogVXBwZXJCb3VuZC5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgcF9pID0gaSA9PSAwID8gcC5YIDogcC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhYnNEX2kgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcmFsbGVsLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwX2kgPCBsb3dlckJvdW5kX2kgfHwgdXBwZXJCb3VuZF9pIDwgcF9pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBkX2kgPSBpID09IDAgPyBkLlggOiBkLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGludl9kID0gMS4wZiAvIGRfaTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB0MSA9IChsb3dlckJvdW5kX2kgLSBwX2kpICogaW52X2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdDIgPSAodXBwZXJCb3VuZF9pIC0gcF9pKSAqIGludl9kO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTaWduIG9mIHRoZSBub3JtYWwgdmVjdG9yLlxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHMgPSAtMS4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQxID4gdDIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoVXRpbHMuU3dhcDxmbG9hdD4ocmVmIHQxLCByZWYgdDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gMS4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggdGhlIG1pbiB1cFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0MSA+IHRtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWCA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWSA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtaW4gPSB0MTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIG1heCBkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgdG1heCA9IE1hdGguTWluKHRtYXgsIHQyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtaW4gPiB0bWF4KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRG9lcyB0aGUgcmF5IHN0YXJ0IGluc2lkZSB0aGUgYm94P1xyXG4gICAgICAgICAgICAvLyBEb2VzIHRoZSByYXkgaW50ZXJzZWN0IGJleW9uZCB0aGUgbWF4IGZyYWN0aW9uP1xyXG4gICAgICAgICAgICBpZiAodG1pbiA8IDAuMGYgfHwgaW5wdXQuTWF4RnJhY3Rpb24gPCB0bWluKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEludGVyc2VjdGlvbi5cclxuICAgICAgICAgICAgb3V0cHV0LkZyYWN0aW9uID0gdG1pbjtcclxuICAgICAgICAgICAgb3V0cHV0Lk5vcm1hbCA9IG5vcm1hbDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBFZGdlIHNoYXBlIHBsdXMgbW9yZSBzdHVmZi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IEZhdEVkZ2VcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgYm9vbCBIYXNWZXJ0ZXgwLCBIYXNWZXJ0ZXgzO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIE5vcm1hbDtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBWMCwgVjEsIFYyLCBWMztcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhpcyBsZXRzIHVzIHRyZWF0ZSBhbmQgZWRnZSBzaGFwZSBhbmQgYSBwb2x5Z29uIGluIHRoZSBzYW1lXHJcbiAgICAvLy8gd2F5IGluIHRoZSBTQVQgY29sbGlkZXIuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIEVQUHJveHlcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBDZW50cm9pZDtcclxuICAgICAgICBwdWJsaWMgaW50IENvdW50O1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyW10gTm9ybWFscyA9IG5ldyBWZWN0b3IyW1NldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlc107XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjJbXSBWZXJ0aWNlcyA9IG5ldyBWZWN0b3IyW1NldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlc107XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0cnVjdCBFUEF4aXNcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgaW50IEluZGV4O1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBTZXBhcmF0aW9uO1xyXG4gICAgICAgIHB1YmxpYyBFUEF4aXNUeXBlIFR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGVudW0gRVBBeGlzVHlwZVxyXG4gICAge1xyXG4gICAgICAgIFVua25vd24sXHJcbiAgICAgICAgRWRnZUEsXHJcbiAgICAgICAgRWRnZUIsXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBDb2xsaXNpb25cclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBGYXRFZGdlIF9lZGdlQTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgRVBQcm94eSBfcHJveHlBID0gbmV3IEVQUHJveHkoKTtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBFUFByb3h5IF9wcm94eUIgPSBuZXcgRVBQcm94eSgpO1xyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBUcmFuc2Zvcm0gX3hmO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlY3RvcjIgX2xpbWl0MTEsIF9saW1pdDEyO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlY3RvcjIgX2xpbWl0MjEsIF9saW1pdDIyO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IF9yYWRpdXM7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgVmVjdG9yMltdIF90bXBOb3JtYWxzID0gbmV3IFZlY3RvcjJbMl07XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRXZhbHVhdGUgdGhlIG1hbmlmb2xkIHdpdGggc3VwcGxpZWQgdHJhbnNmb3Jtcy4gVGhpcyBhc3N1bWVzXHJcbiAgICAgICAgLy8vIG1vZGVzdCBtb3Rpb24gZnJvbSB0aGUgb3JpZ2luYWwgc3RhdGUuIFRoaXMgZG9lcyBub3QgY2hhbmdlIHRoZVxyXG4gICAgICAgIC8vLyBwb2ludCBjb3VudCwgaW1wdWxzZXMsIGV0Yy4gVGhlIHJhZGlpIG11c3QgY29tZSBmcm9tIHRoZSBTaGFwZXNcclxuICAgICAgICAvLy8gdGhhdCBnZW5lcmF0ZWQgdGhlIG1hbmlmb2xkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWFuaWZvbGRcIj5UaGUgbWFuaWZvbGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1BXCI+VGhlIHRyYW5zZm9ybSBmb3IgQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJhZGl1c0FcIj5UaGUgcmFkaXVzIGZvciBBLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtQlwiPlRoZSB0cmFuc2Zvcm0gZm9yIEIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyYWRpdXNCXCI+VGhlIHJhZGl1cyBmb3IgQi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5vcm1hbFwiPldvcmxkIHZlY3RvciBwb2ludGluZyBmcm9tIEEgdG8gQjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRzXCI+VG9ybGQgY29udGFjdCBwb2ludCAocG9pbnQgb2YgaW50ZXJzZWN0aW9uKS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBHZXRXb3JsZE1hbmlmb2xkKHJlZiBNYW5pZm9sZCBtYW5pZm9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybUEsIGZsb2F0IHJhZGl1c0EsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1CLCBmbG9hdCByYWRpdXNCLCBvdXQgVmVjdG9yMiBub3JtYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IEZpeGVkQXJyYXkyPFZlY3RvcjI+IHBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IG5ldyBGaXhlZEFycmF5MjxWZWN0b3IyPigpO1xyXG4gICAgICAgICAgICBub3JtYWwgPSBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICBpZiAobWFuaWZvbGQuUG9pbnRDb3VudCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBub3JtYWwgPSBWZWN0b3IyLlVuaXRZO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKG1hbmlmb2xkLlR5cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTWFuaWZvbGRUeXBlLkNpcmNsZXM6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRtcCA9IG1hbmlmb2xkLlBvaW50c1swXS5Mb2NhbFBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwb2ludEF4ID0gdHJhbnNmb3JtQS5Qb3NpdGlvbi5YICsgdHJhbnNmb3JtQS5SLkNvbDEuWCAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1BLlIuQ29sMi5YICogbWFuaWZvbGQuTG9jYWxQb2ludC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcG9pbnRBeSA9IHRyYW5zZm9ybUEuUG9zaXRpb24uWSArIHRyYW5zZm9ybUEuUi5Db2wxLlkgKiBtYW5pZm9sZC5Mb2NhbFBvaW50LlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQS5SLkNvbDIuWSAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBvaW50QnggPSB0cmFuc2Zvcm1CLlBvc2l0aW9uLlggKyB0cmFuc2Zvcm1CLlIuQ29sMS5YICogdG1wLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQi5SLkNvbDIuWCAqIHRtcC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcG9pbnRCeSA9IHRyYW5zZm9ybUIuUG9zaXRpb24uWSArIHRyYW5zZm9ybUIuUi5Db2wxLlkgKiB0bXAuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1CLlIuQ29sMi5ZICogdG1wLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ZID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHJlc3VsdCA9IChwb2ludEF4IC0gcG9pbnRCeCkgKiAocG9pbnRBeCAtIHBvaW50QngpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvaW50QXkgLSBwb2ludEJ5KSAqIChwb2ludEF5IC0gcG9pbnRCeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPiBTZXR0aW5ncy5FcHNpbG9uICogU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdG1wTm9ybWFseCA9IHBvaW50QnggLSBwb2ludEF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdG1wTm9ybWFseSA9IHBvaW50QnkgLSBwb2ludEF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZmFjdG9yID0gMWYgLyAoZmxvYXQpTWF0aC5TcXJ0KHRtcE5vcm1hbHggKiB0bXBOb3JtYWx4ICsgdG1wTm9ybWFseSAqIHRtcE5vcm1hbHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlggPSB0bXBOb3JtYWx4ICogZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlkgPSB0bXBOb3JtYWx5ICogZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGMgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuWCA9IChwb2ludEF4ICsgcmFkaXVzQSAqIG5vcm1hbC5YKSArIChwb2ludEJ4IC0gcmFkaXVzQiAqIG5vcm1hbC5YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5ZID0gKHBvaW50QXkgKyByYWRpdXNBICogbm9ybWFsLlkpICsgKHBvaW50QnkgLSByYWRpdXNCICogbm9ybWFsLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gMC41ZiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgTWFuaWZvbGRUeXBlLkZhY2VBOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlggPSB0cmFuc2Zvcm1BLlIuQ29sMS5YICogbWFuaWZvbGQuTG9jYWxOb3JtYWwuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQS5SLkNvbDIuWCAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ZID0gdHJhbnNmb3JtQS5SLkNvbDEuWSAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUEuUi5Db2wyLlkgKiBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcGxhbmVQb2ludHggPSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlggKyB0cmFuc2Zvcm1BLlIuQ29sMS5YICogbWFuaWZvbGQuTG9jYWxQb2ludC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1BLlIuQ29sMi5YICogbWFuaWZvbGQuTG9jYWxQb2ludC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcGxhbmVQb2ludHkgPSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlkgKyB0cmFuc2Zvcm1BLlIuQ29sMS5ZICogbWFuaWZvbGQuTG9jYWxQb2ludC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1BLlIuQ29sMi5ZICogbWFuaWZvbGQuTG9jYWxQb2ludC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtYW5pZm9sZC5Qb2ludENvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdG1wID0gbWFuaWZvbGQuUG9pbnRzW2ldLkxvY2FsUG9pbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY2xpcFBvaW50eCA9IHRyYW5zZm9ybUIuUG9zaXRpb24uWCArIHRyYW5zZm9ybUIuUi5Db2wxLlggKiB0bXAuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQi5SLkNvbDIuWCAqIHRtcC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGNsaXBQb2ludHkgPSB0cmFuc2Zvcm1CLlBvc2l0aW9uLlkgKyB0cmFuc2Zvcm1CLlIuQ29sMS5ZICogdG1wLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUi5Db2wyLlkgKiB0bXAuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IChjbGlwUG9pbnR4IC0gcGxhbmVQb2ludHgpICogbm9ybWFsLlggKyAoY2xpcFBvaW50eSAtIHBsYW5lUG9pbnR5KSAqIG5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYyA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuWCA9IChjbGlwUG9pbnR4ICsgKHJhZGl1c0EgLSB2YWx1ZSkgKiBub3JtYWwuWCkgKyAoY2xpcFBvaW50eCAtIHJhZGl1c0IgKiBub3JtYWwuWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLlkgPSAoY2xpcFBvaW50eSArIChyYWRpdXNBIC0gdmFsdWUpICogbm9ybWFsLlkpICsgKGNsaXBQb2ludHkgLSByYWRpdXNCICogbm9ybWFsLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IDAuNWYgKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgTWFuaWZvbGRUeXBlLkZhY2VCOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlggPSB0cmFuc2Zvcm1CLlIuQ29sMS5YICogbWFuaWZvbGQuTG9jYWxOb3JtYWwuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQi5SLkNvbDIuWCAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ZID0gdHJhbnNmb3JtQi5SLkNvbDEuWSAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUi5Db2wyLlkgKiBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcGxhbmVQb2ludHggPSB0cmFuc2Zvcm1CLlBvc2l0aW9uLlggKyB0cmFuc2Zvcm1CLlIuQ29sMS5YICogbWFuaWZvbGQuTG9jYWxQb2ludC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1CLlIuQ29sMi5YICogbWFuaWZvbGQuTG9jYWxQb2ludC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcGxhbmVQb2ludHkgPSB0cmFuc2Zvcm1CLlBvc2l0aW9uLlkgKyB0cmFuc2Zvcm1CLlIuQ29sMS5ZICogbWFuaWZvbGQuTG9jYWxQb2ludC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1CLlIuQ29sMi5ZICogbWFuaWZvbGQuTG9jYWxQb2ludC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtYW5pZm9sZC5Qb2ludENvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdG1wID0gbWFuaWZvbGQuUG9pbnRzW2ldLkxvY2FsUG9pbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY2xpcFBvaW50eCA9IHRyYW5zZm9ybUEuUG9zaXRpb24uWCArIHRyYW5zZm9ybUEuUi5Db2wxLlggKiB0bXAuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQS5SLkNvbDIuWCAqIHRtcC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGNsaXBQb2ludHkgPSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlkgKyB0cmFuc2Zvcm1BLlIuQ29sMS5ZICogdG1wLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUEuUi5Db2wyLlkgKiB0bXAuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IChjbGlwUG9pbnR4IC0gcGxhbmVQb2ludHgpICogbm9ybWFsLlggKyAoY2xpcFBvaW50eSAtIHBsYW5lUG9pbnR5KSAqIG5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYyA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuWCA9IChjbGlwUG9pbnR4IC0gcmFkaXVzQSAqIG5vcm1hbC5YKSArIChjbGlwUG9pbnR4ICsgKHJhZGl1c0IgLSB2YWx1ZSkgKiBub3JtYWwuWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLlkgPSAoY2xpcFBvaW50eSAtIHJhZGl1c0EgKiBub3JtYWwuWSkgKyAoY2xpcFBvaW50eSArIChyYWRpdXNCIC0gdmFsdWUpICogbm9ybWFsLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IDAuNWYgKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBub3JtYWwgcG9pbnRzIGZyb20gQSB0byBCLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgKj0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBWZWN0b3IyLlVuaXRZO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgR2V0UG9pbnRTdGF0ZXMob3V0IEZpeGVkQXJyYXkyPFBvaW50U3RhdGU+IHN0YXRlMSwgb3V0IEZpeGVkQXJyYXkyPFBvaW50U3RhdGU+IHN0YXRlMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmIE1hbmlmb2xkIG1hbmlmb2xkMSwgcmVmIE1hbmlmb2xkIG1hbmlmb2xkMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXRlMSA9IG5ldyBGaXhlZEFycmF5MjxQb2ludFN0YXRlPigpO1xyXG4gICAgICAgICAgICBzdGF0ZTIgPSBuZXcgRml4ZWRBcnJheTI8UG9pbnRTdGF0ZT4oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVjdCBwZXJzaXN0cyBhbmQgcmVtb3Zlcy5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtYW5pZm9sZDEuUG9pbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0SUQgaWQgPSBtYW5pZm9sZDEuUG9pbnRzW2ldLklkO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlMVtpXSA9IFBvaW50U3RhdGUuUmVtb3ZlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbWFuaWZvbGQyLlBvaW50Q291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFuaWZvbGQyLlBvaW50c1tqXS5JZC5LZXkgPT0gaWQuS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUxW2ldID0gUG9pbnRTdGF0ZS5QZXJzaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERldGVjdCBwZXJzaXN0cyBhbmQgYWRkcy5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtYW5pZm9sZDIuUG9pbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0SUQgaWQgPSBtYW5pZm9sZDIuUG9pbnRzW2ldLklkO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlMltpXSA9IFBvaW50U3RhdGUuQWRkO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgbWFuaWZvbGQxLlBvaW50Q291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFuaWZvbGQxLlBvaW50c1tqXS5JZC5LZXkgPT0gaWQuS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUyW2ldID0gUG9pbnRTdGF0ZS5QZXJzaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLy8gQ29tcHV0ZSB0aGUgY29sbGlzaW9uIG1hbmlmb2xkIGJldHdlZW4gdHdvIGNpcmNsZXMuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIENvbGxpZGVDaXJjbGVzKHJlZiBNYW5pZm9sZCBtYW5pZm9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2lyY2xlU2hhcGUgY2lyY2xlQSwgcmVmIFRyYW5zZm9ybSB4ZkEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENpcmNsZVNoYXBlIGNpcmNsZUIsIHJlZiBUcmFuc2Zvcm0geGZCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBwQXggPSB4ZkEuUG9zaXRpb24uWCArIHhmQS5SLkNvbDEuWCAqIGNpcmNsZUEuUG9zaXRpb24uWCArIHhmQS5SLkNvbDIuWCAqIGNpcmNsZUEuUG9zaXRpb24uWTtcclxuICAgICAgICAgICAgZmxvYXQgcEF5ID0geGZBLlBvc2l0aW9uLlkgKyB4ZkEuUi5Db2wxLlkgKiBjaXJjbGVBLlBvc2l0aW9uLlggKyB4ZkEuUi5Db2wyLlkgKiBjaXJjbGVBLlBvc2l0aW9uLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IHBCeCA9IHhmQi5Qb3NpdGlvbi5YICsgeGZCLlIuQ29sMS5YICogY2lyY2xlQi5Qb3NpdGlvbi5YICsgeGZCLlIuQ29sMi5YICogY2lyY2xlQi5Qb3NpdGlvbi5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBwQnkgPSB4ZkIuUG9zaXRpb24uWSArIHhmQi5SLkNvbDEuWSAqIGNpcmNsZUIuUG9zaXRpb24uWCArIHhmQi5SLkNvbDIuWSAqIGNpcmNsZUIuUG9zaXRpb24uWTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGRpc3RTcXIgPSAocEJ4IC0gcEF4KSAqIChwQnggLSBwQXgpICsgKHBCeSAtIHBBeSkgKiAocEJ5IC0gcEF5KTtcclxuICAgICAgICAgICAgZmxvYXQgcmFkaXVzID0gY2lyY2xlQS5SYWRpdXMgKyBjaXJjbGVCLlJhZGl1cztcclxuICAgICAgICAgICAgaWYgKGRpc3RTcXIgPiByYWRpdXMgKiByYWRpdXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5DaXJjbGVzO1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbFBvaW50ID0gY2lyY2xlQS5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSAxO1xyXG5cclxuICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBwMCA9IG1hbmlmb2xkLlBvaW50c1swXTtcclxuXHJcbiAgICAgICAgICAgIHAwLkxvY2FsUG9pbnQgPSBjaXJjbGVCLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICBwMC5JZC5LZXkgPSAwO1xyXG5cclxuICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRzWzBdID0gcDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIGNvbGxpc2lvbiBtYW5pZm9sZCBiZXR3ZWVuIGEgcG9seWdvbiBhbmQgYSBjaXJjbGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYW5pZm9sZFwiPlRoZSBtYW5pZm9sZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHlnb25BXCI+VGhlIHBvbHlnb24gQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybUFcIj5UaGUgdHJhbnNmb3JtIG9mIEEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaXJjbGVCXCI+VGhlIGNpcmNsZSBCLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtQlwiPlRoZSB0cmFuc2Zvcm0gb2YgQi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBDb2xsaWRlUG9seWdvbkFuZENpcmNsZShyZWYgTWFuaWZvbGQgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5Z29uQSwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1BLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaXJjbGVTaGFwZSBjaXJjbGVCLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgY2lyY2xlIHBvc2l0aW9uIGluIHRoZSBmcmFtZSBvZiB0aGUgcG9seWdvbi5cclxuICAgICAgICAgICAgVmVjdG9yMiBjID1cclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUG9zaXRpb24uWCArIHRyYW5zZm9ybUIuUi5Db2wxLlggKiBjaXJjbGVCLlBvc2l0aW9uLlggK1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUi5Db2wyLlggKiBjaXJjbGVCLlBvc2l0aW9uLlksXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQi5Qb3NpdGlvbi5ZICsgdHJhbnNmb3JtQi5SLkNvbDEuWSAqIGNpcmNsZUIuUG9zaXRpb24uWCArXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQi5SLkNvbDIuWSAqIGNpcmNsZUIuUG9zaXRpb24uWSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgY0xvY2FsID1cclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgICAgICAgICAgIChjLlggLSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlgpICogdHJhbnNmb3JtQS5SLkNvbDEuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgKGMuWSAtIHRyYW5zZm9ybUEuUG9zaXRpb24uWSkgKiB0cmFuc2Zvcm1BLlIuQ29sMS5ZLFxyXG4gICAgICAgICAgICAgICAgICAgIChjLlggLSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlgpICogdHJhbnNmb3JtQS5SLkNvbDIuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgKGMuWSAtIHRyYW5zZm9ybUEuUG9zaXRpb24uWSkgKiB0cmFuc2Zvcm1BLlIuQ29sMi5ZKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1pbiBzZXBhcmF0aW5nIGVkZ2UuXHJcbiAgICAgICAgICAgIGludCBub3JtYWxJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZsb2F0IHNlcGFyYXRpb24gPSAtU2V0dGluZ3MuTWF4RmxvYXQ7XHJcbiAgICAgICAgICAgIGZsb2F0IHJhZGl1cyA9IHBvbHlnb25BLlJhZGl1cyArIGNpcmNsZUIuUmFkaXVzO1xyXG4gICAgICAgICAgICBpbnQgdmVydGV4Q291bnQgPSBwb2x5Z29uQS5WZXJ0aWNlcy5Db3VudDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2YWx1ZTEgPSBwb2x5Z29uQS5Ob3JtYWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2YWx1ZTIgPSBjTG9jYWwgLSBwb2x5Z29uQS5WZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHMgPSB2YWx1ZTEuWCAqIHZhbHVlMi5YICsgdmFsdWUxLlkgKiB2YWx1ZTIuWTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocyA+IHJhZGl1cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFYXJseSBvdXQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzID4gc2VwYXJhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uID0gcztcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFZlcnRpY2VzIHRoYXQgc3VidGVuZCB0aGUgaW5jaWRlbnQgZmFjZS5cclxuICAgICAgICAgICAgaW50IHZlcnRJbmRleDEgPSBub3JtYWxJbmRleDtcclxuICAgICAgICAgICAgaW50IHZlcnRJbmRleDIgPSB2ZXJ0SW5kZXgxICsgMSA8IHZlcnRleENvdW50ID8gdmVydEluZGV4MSArIDEgOiAwO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gcG9seWdvbkEuVmVydGljZXNbdmVydEluZGV4MV07XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBwb2x5Z29uQS5WZXJ0aWNlc1t2ZXJ0SW5kZXgyXTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBjZW50ZXIgaXMgaW5zaWRlIHRoZSBwb2x5Z29uIC4uLlxyXG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5GYWNlQTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsID0gcG9seWdvbkEuTm9ybWFsc1tub3JtYWxJbmRleF07XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbFBvaW50ID0gMC41ZiAqICh2MSArIHYyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IHAwID0gbWFuaWZvbGQuUG9pbnRzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHAwLkxvY2FsUG9pbnQgPSBjaXJjbGVCLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgcDAuSWQuS2V5ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludHNbMF0gPSBwMDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgZmxvYXQgdTEgPSAoY0xvY2FsLlggLSB2MS5YKSAqICh2Mi5YIC0gdjEuWCkgKyAoY0xvY2FsLlkgLSB2MS5ZKSAqICh2Mi5ZIC0gdjEuWSk7XHJcbiAgICAgICAgICAgIGZsb2F0IHUyID0gKGNMb2NhbC5YIC0gdjIuWCkgKiAodjEuWCAtIHYyLlgpICsgKGNMb2NhbC5ZIC0gdjIuWSkgKiAodjEuWSAtIHYyLlkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHUxIDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHIgPSAoY0xvY2FsLlggLSB2MS5YKSAqIChjTG9jYWwuWCAtIHYxLlgpICsgKGNMb2NhbC5ZIC0gdjEuWSkgKiAoY0xvY2FsLlkgLSB2MS5ZKTtcclxuICAgICAgICAgICAgICAgIGlmIChyID4gcmFkaXVzICogcmFkaXVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlR5cGUgPSBNYW5pZm9sZFR5cGUuRmFjZUE7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbCA9IGNMb2NhbCAtIHYxO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZmFjdG9yID0gMWYgL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsb2F0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5TcXJ0KG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggKiBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZICogbWFuaWZvbGQuTG9jYWxOb3JtYWwuWSk7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5YID0gbWFuaWZvbGQuTG9jYWxOb3JtYWwuWCAqIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlkgPSBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZICogZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxQb2ludCA9IHYxO1xyXG5cclxuICAgICAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgcDBiID0gbWFuaWZvbGQuUG9pbnRzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHAwYi5Mb2NhbFBvaW50ID0gY2lyY2xlQi5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHAwYi5JZC5LZXkgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50c1swXSA9IHAwYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1MiA8PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByID0gKGNMb2NhbC5YIC0gdjIuWCkgKiAoY0xvY2FsLlggLSB2Mi5YKSArIChjTG9jYWwuWSAtIHYyLlkpICogKGNMb2NhbC5ZIC0gdjIuWSk7XHJcbiAgICAgICAgICAgICAgICBpZiAociA+IHJhZGl1cyAqIHJhZGl1cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5UeXBlID0gTWFuaWZvbGRUeXBlLkZhY2VBO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwgPSBjTG9jYWwgLSB2MjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGZhY3RvciA9IDFmIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbG9hdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguU3FydChtYW5pZm9sZC5Mb2NhbE5vcm1hbC5YICogbWFuaWZvbGQuTG9jYWxOb3JtYWwuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwuWSAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlkpO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwuWCA9IG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggKiBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZID0gbWFuaWZvbGQuTG9jYWxOb3JtYWwuWSAqIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsUG9pbnQgPSB2MjtcclxuXHJcbiAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IHAwYyA9IG1hbmlmb2xkLlBvaW50c1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICBwMGMuTG9jYWxQb2ludCA9IGNpcmNsZUIuUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBwMGMuSWQuS2V5ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludHNbMF0gPSBwMGM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGZhY2VDZW50ZXIgPSAwLjVmICogKHYxICsgdjIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2YWx1ZTEgPSBjTG9jYWwgLSBmYWNlQ2VudGVyO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2YWx1ZTIgPSBwb2x5Z29uQS5Ob3JtYWxzW3ZlcnRJbmRleDFdO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbjIgPSB2YWx1ZTEuWCAqIHZhbHVlMi5YICsgdmFsdWUxLlkgKiB2YWx1ZTIuWTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0aW9uMiA+IHJhZGl1cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5UeXBlID0gTWFuaWZvbGRUeXBlLkZhY2VBO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwgPSBwb2x5Z29uQS5Ob3JtYWxzW3ZlcnRJbmRleDFdO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxQb2ludCA9IGZhY2VDZW50ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBwMGQgPSBtYW5pZm9sZC5Qb2ludHNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgcDBkLkxvY2FsUG9pbnQgPSBjaXJjbGVCLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgcDBkLklkLktleSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRzWzBdID0gcDBkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIGNvbGxpc2lvbiBtYW5pZm9sZCBiZXR3ZWVuIHR3byBwb2x5Z29ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1hbmlmb2xkXCI+VGhlIG1hbmlmb2xkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9seUFcIj5UaGUgcG9seSBBLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtQVwiPlRoZSB0cmFuc2Zvcm0gQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHlCXCI+VGhlIHBvbHkgQi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybUJcIj5UaGUgdHJhbnNmb3JtIEIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgQ29sbGlkZVBvbHlnb25zKHJlZiBNYW5pZm9sZCBtYW5pZm9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5QSwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1BLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHlCLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gMDtcclxuICAgICAgICAgICAgZmxvYXQgdG90YWxSYWRpdXMgPSBwb2x5QS5SYWRpdXMgKyBwb2x5Qi5SYWRpdXM7XHJcblxyXG4gICAgICAgICAgICBpbnQgZWRnZUEgPSAwO1xyXG4gICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uQSA9IEZpbmRNYXhTZXBhcmF0aW9uKG91dCBlZGdlQSwgcG9seUEsIHJlZiB0cmFuc2Zvcm1BLCBwb2x5QiwgcmVmIHRyYW5zZm9ybUIpO1xyXG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbkEgPiB0b3RhbFJhZGl1cylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGludCBlZGdlQiA9IDA7XHJcbiAgICAgICAgICAgIGZsb2F0IHNlcGFyYXRpb25CID0gRmluZE1heFNlcGFyYXRpb24ob3V0IGVkZ2VCLCBwb2x5QiwgcmVmIHRyYW5zZm9ybUIsIHBvbHlBLCByZWYgdHJhbnNmb3JtQSk7XHJcbiAgICAgICAgICAgIGlmIChzZXBhcmF0aW9uQiA+IHRvdGFsUmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHkxOyAvLyByZWZlcmVuY2UgcG9seWdvblxyXG4gICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seTI7IC8vIGluY2lkZW50IHBvbHlnb25cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICBpbnQgZWRnZTE7IC8vIHJlZmVyZW5jZSBlZGdlXHJcbiAgICAgICAgICAgIGJvb2wgZmxpcDtcclxuICAgICAgICAgICAgY29uc3QgZmxvYXQga19yZWxhdGl2ZVRvbCA9IDAuOThmO1xyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCBrX2Fic29sdXRlVG9sID0gMC4wMDFmO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb25CID4ga19yZWxhdGl2ZVRvbCAqIHNlcGFyYXRpb25BICsga19hYnNvbHV0ZVRvbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcG9seTEgPSBwb2x5QjtcclxuICAgICAgICAgICAgICAgIHBvbHkyID0gcG9seUE7XHJcbiAgICAgICAgICAgICAgICB4ZjEgPSB0cmFuc2Zvcm1CO1xyXG4gICAgICAgICAgICAgICAgeGYyID0gdHJhbnNmb3JtQTtcclxuICAgICAgICAgICAgICAgIGVkZ2UxID0gZWRnZUI7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5UeXBlID0gTWFuaWZvbGRUeXBlLkZhY2VCO1xyXG4gICAgICAgICAgICAgICAgZmxpcCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwb2x5MSA9IHBvbHlBO1xyXG4gICAgICAgICAgICAgICAgcG9seTIgPSBwb2x5QjtcclxuICAgICAgICAgICAgICAgIHhmMSA9IHRyYW5zZm9ybUE7XHJcbiAgICAgICAgICAgICAgICB4ZjIgPSB0cmFuc2Zvcm1CO1xyXG4gICAgICAgICAgICAgICAgZWRnZTEgPSBlZGdlQTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlR5cGUgPSBNYW5pZm9sZFR5cGUuRmFjZUE7XHJcbiAgICAgICAgICAgICAgICBmbGlwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEZpeGVkQXJyYXkyPENsaXBWZXJ0ZXg+IGluY2lkZW50RWRnZTtcclxuICAgICAgICAgICAgRmluZEluY2lkZW50RWRnZShvdXQgaW5jaWRlbnRFZGdlLCBwb2x5MSwgcmVmIHhmMSwgZWRnZTEsIHBvbHkyLCByZWYgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIGludCBjb3VudDEgPSBwb2x5MS5WZXJ0aWNlcy5Db3VudDtcclxuXHJcbiAgICAgICAgICAgIGludCBpdjEgPSBlZGdlMTtcclxuICAgICAgICAgICAgaW50IGl2MiA9IGVkZ2UxICsgMSA8IGNvdW50MSA/IGVkZ2UxICsgMSA6IDA7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHYxMSA9IHBvbHkxLlZlcnRpY2VzW2l2MV07XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEyID0gcG9seTEuVmVydGljZXNbaXYyXTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGxvY2FsVGFuZ2VudFggPSB2MTIuWCAtIHYxMS5YO1xyXG4gICAgICAgICAgICBmbG9hdCBsb2NhbFRhbmdlbnRZID0gdjEyLlkgLSB2MTEuWTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGZhY3RvciA9IDFmIC8gKGZsb2F0KU1hdGguU3FydChsb2NhbFRhbmdlbnRYICogbG9jYWxUYW5nZW50WCArIGxvY2FsVGFuZ2VudFkgKiBsb2NhbFRhbmdlbnRZKTtcclxuICAgICAgICAgICAgbG9jYWxUYW5nZW50WCA9IGxvY2FsVGFuZ2VudFggKiBmYWN0b3I7XHJcbiAgICAgICAgICAgIGxvY2FsVGFuZ2VudFkgPSBsb2NhbFRhbmdlbnRZICogZmFjdG9yO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBsb2NhbE5vcm1hbCA9IG5ldyBWZWN0b3IyKGxvY2FsVGFuZ2VudFksIC1sb2NhbFRhbmdlbnRYKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBwbGFuZVBvaW50ID0gMC41ZiAqICh2MTEgKyB2MTIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB0YW5nZW50ID0gbmV3IFZlY3RvcjIoeGYxLlIuQ29sMS5YICogbG9jYWxUYW5nZW50WCArIHhmMS5SLkNvbDIuWCAqIGxvY2FsVGFuZ2VudFksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhmMS5SLkNvbDEuWSAqIGxvY2FsVGFuZ2VudFggKyB4ZjEuUi5Db2wyLlkgKiBsb2NhbFRhbmdlbnRZKTtcclxuICAgICAgICAgICAgZmxvYXQgbm9ybWFseCA9IHRhbmdlbnQuWTtcclxuICAgICAgICAgICAgZmxvYXQgbm9ybWFseSA9IC10YW5nZW50Llg7XHJcblxyXG4gICAgICAgICAgICB2MTEgPSBuZXcgVmVjdG9yMih4ZjEuUG9zaXRpb24uWCArIHhmMS5SLkNvbDEuWCAqIHYxMS5YICsgeGYxLlIuQ29sMi5YICogdjExLlksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhmMS5Qb3NpdGlvbi5ZICsgeGYxLlIuQ29sMS5ZICogdjExLlggKyB4ZjEuUi5Db2wyLlkgKiB2MTEuWSk7XHJcbiAgICAgICAgICAgIHYxMiA9IG5ldyBWZWN0b3IyKHhmMS5Qb3NpdGlvbi5YICsgeGYxLlIuQ29sMS5YICogdjEyLlggKyB4ZjEuUi5Db2wyLlggKiB2MTIuWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGYxLlBvc2l0aW9uLlkgKyB4ZjEuUi5Db2wxLlkgKiB2MTIuWCArIHhmMS5SLkNvbDIuWSAqIHYxMi5ZKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZhY2Ugb2Zmc2V0LlxyXG4gICAgICAgICAgICBmbG9hdCBmcm9udE9mZnNldCA9IG5vcm1hbHggKiB2MTEuWCArIG5vcm1hbHkgKiB2MTEuWTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpZGUgb2Zmc2V0cywgZXh0ZW5kZWQgYnkgcG9seXRvcGUgc2tpbiB0aGlja25lc3MuXHJcbiAgICAgICAgICAgIGZsb2F0IHNpZGVPZmZzZXQxID0gLSh0YW5nZW50LlggKiB2MTEuWCArIHRhbmdlbnQuWSAqIHYxMS5ZKSArIHRvdGFsUmFkaXVzO1xyXG4gICAgICAgICAgICBmbG9hdCBzaWRlT2Zmc2V0MiA9IHRhbmdlbnQuWCAqIHYxMi5YICsgdGFuZ2VudC5ZICogdjEyLlkgKyB0b3RhbFJhZGl1cztcclxuXHJcbiAgICAgICAgICAgIC8vIENsaXAgaW5jaWRlbnQgZWRnZSBhZ2FpbnN0IGV4dHJ1ZGVkIGVkZ2UxIHNpZGUgZWRnZXMuXHJcbiAgICAgICAgICAgIEZpeGVkQXJyYXkyPENsaXBWZXJ0ZXg+IGNsaXBQb2ludHMxO1xyXG4gICAgICAgICAgICBGaXhlZEFycmF5MjxDbGlwVmVydGV4PiBjbGlwUG9pbnRzMjtcclxuXHJcbiAgICAgICAgICAgIC8vIENsaXAgdG8gYm94IHNpZGUgMVxyXG4gICAgICAgICAgICBpbnQgbnAgPSBDbGlwU2VnbWVudFRvTGluZShvdXQgY2xpcFBvaW50czEsIHJlZiBpbmNpZGVudEVkZ2UsIC10YW5nZW50LCBzaWRlT2Zmc2V0MSwgaXYxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChucCA8IDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBDbGlwIHRvIG5lZ2F0aXZlIGJveCBzaWRlIDFcclxuICAgICAgICAgICAgbnAgPSBDbGlwU2VnbWVudFRvTGluZShvdXQgY2xpcFBvaW50czIsIHJlZiBjbGlwUG9pbnRzMSwgdGFuZ2VudCwgc2lkZU9mZnNldDIsIGl2Mik7XHJcblxyXG4gICAgICAgICAgICBpZiAobnAgPCAyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdyBjbGlwUG9pbnRzMiBjb250YWlucyB0aGUgY2xpcHBlZCBwb2ludHMuXHJcbiAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsID0gbG9jYWxOb3JtYWw7XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsUG9pbnQgPSBwbGFuZVBvaW50O1xyXG5cclxuICAgICAgICAgICAgaW50IHBvaW50Q291bnQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFNldHRpbmdzLk1heE1hbmlmb2xkUG9pbnRzOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdmFsdWUgPSBjbGlwUG9pbnRzMltpXS5WO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IG5vcm1hbHggKiB2YWx1ZS5YICsgbm9ybWFseSAqIHZhbHVlLlkgLSBmcm9udE9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSB0b3RhbFJhZGl1cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IGNwID0gbWFuaWZvbGQuUG9pbnRzW3BvaW50Q291bnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdG1wID0gY2xpcFBvaW50czJbaV0uVjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB0bXAxWCA9IHRtcC5YIC0geGYyLlBvc2l0aW9uLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdG1wMVkgPSB0bXAuWSAtIHhmMi5Qb3NpdGlvbi5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIGNwLkxvY2FsUG9pbnQuWCA9IHRtcDFYICogeGYyLlIuQ29sMS5YICsgdG1wMVkgKiB4ZjIuUi5Db2wxLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3AuTG9jYWxQb2ludC5ZID0gdG1wMVggKiB4ZjIuUi5Db2wyLlggKyB0bXAxWSAqIHhmMi5SLkNvbDIuWTtcclxuICAgICAgICAgICAgICAgICAgICBjcC5JZCA9IGNsaXBQb2ludHMyW2ldLklEO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmxpcClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3YXAgZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdEZlYXR1cmUgY2YgPSBjcC5JZC5GZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3AuSWQuRmVhdHVyZXMuSW5kZXhBID0gY2YuSW5kZXhCO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcC5JZC5GZWF0dXJlcy5JbmRleEIgPSBjZi5JbmRleEE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwLklkLkZlYXR1cmVzLlR5cGVBID0gY2YuVHlwZUI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwLklkLkZlYXR1cmVzLlR5cGVCID0gY2YuVHlwZUE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludHNbcG9pbnRDb3VudF0gPSBjcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKytwb2ludENvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gcG9pbnRDb3VudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZSBjb250YWN0IHBvaW50cyBmb3IgZWRnZSB2ZXJzdXMgY2lyY2xlLlxyXG4gICAgICAgIC8vLyBUaGlzIGFjY291bnRzIGZvciBlZGdlIGNvbm5lY3Rpdml0eS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1hbmlmb2xkXCI+VGhlIG1hbmlmb2xkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZWRnZUFcIj5UaGUgZWRnZSBBLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtQVwiPlRoZSB0cmFuc2Zvcm0gQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNpcmNsZUJcIj5UaGUgY2lyY2xlIEIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1CXCI+VGhlIHRyYW5zZm9ybSBCLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIENvbGxpZGVFZGdlQW5kQ2lyY2xlKHJlZiBNYW5pZm9sZCBtYW5pZm9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRWRnZVNoYXBlIGVkZ2VBLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybUEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENpcmNsZVNoYXBlIGNpcmNsZUIsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBjaXJjbGUgaW4gZnJhbWUgb2YgZWRnZVxyXG4gICAgICAgICAgICBWZWN0b3IyIFEgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB0cmFuc2Zvcm1BLCBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybUIsIHJlZiBjaXJjbGVCLl9wb3NpdGlvbikpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBBID0gZWRnZUEuVmVydGV4MSwgQiA9IGVkZ2VBLlZlcnRleDI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZSA9IEIgLSBBO1xyXG5cclxuICAgICAgICAgICAgLy8gQmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgZmxvYXQgdSA9IFZlY3RvcjIuRG90KGUsIEIgLSBRKTtcclxuICAgICAgICAgICAgZmxvYXQgdiA9IFZlY3RvcjIuRG90KGUsIFEgLSBBKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHJhZGl1cyA9IGVkZ2VBLlJhZGl1cyArIGNpcmNsZUIuUmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgQ29udGFjdEZlYXR1cmUgY2Y7XHJcbiAgICAgICAgICAgIGNmLkluZGV4QiA9IDA7XHJcbiAgICAgICAgICAgIGNmLlR5cGVCID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLlZlcnRleDtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCwgZDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZ2lvbiBBXHJcbiAgICAgICAgICAgIGlmICh2IDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFAgPSBBO1xyXG4gICAgICAgICAgICAgICAgZCA9IFEgLSBQO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZGQ7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyLkRvdChyZWYgZCwgcmVmIGQsIG91dCBkZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGQgPiByYWRpdXMgKiByYWRpdXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElzIHRoZXJlIGFuIGVkZ2UgY29ubmVjdGVkIHRvIEE/XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRnZUEuSGFzVmVydGV4MClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIEExID0gZWRnZUEuVmVydGV4MDtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIEIxID0gQTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGUxID0gQjEgLSBBMTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB1MSA9IFZlY3RvcjIuRG90KGUxLCBCMSAtIFEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGUgY2lyY2xlIGluIFJlZ2lvbiBBQiBvZiB0aGUgcHJldmlvdXMgZWRnZT9cclxuICAgICAgICAgICAgICAgICAgICBpZiAodTEgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjZi5JbmRleEEgPSAwO1xyXG4gICAgICAgICAgICAgICAgY2YuVHlwZUEgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuVmVydGV4O1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5UeXBlID0gTWFuaWZvbGRUeXBlLkNpcmNsZXM7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsUG9pbnQgPSBQO1xyXG4gICAgICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBtcCA9IG5ldyBNYW5pZm9sZFBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICBtcC5JZC5LZXkgPSAwO1xyXG4gICAgICAgICAgICAgICAgbXAuSWQuRmVhdHVyZXMgPSBjZjtcclxuICAgICAgICAgICAgICAgIG1wLkxvY2FsUG9pbnQgPSBjaXJjbGVCLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRzWzBdID0gbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlZ2lvbiBCXHJcbiAgICAgICAgICAgIGlmICh1IDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFAgPSBCO1xyXG4gICAgICAgICAgICAgICAgZCA9IFEgLSBQO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZGQ7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyLkRvdChyZWYgZCwgcmVmIGQsIG91dCBkZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGQgPiByYWRpdXMgKiByYWRpdXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElzIHRoZXJlIGFuIGVkZ2UgY29ubmVjdGVkIHRvIEI/XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRnZUEuSGFzVmVydGV4MylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIEIyID0gZWRnZUEuVmVydGV4MztcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIEEyID0gQjtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGUyID0gQjIgLSBBMjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB2MiA9IFZlY3RvcjIuRG90KGUyLCBRIC0gQTIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGUgY2lyY2xlIGluIFJlZ2lvbiBBQiBvZiB0aGUgbmV4dCBlZGdlP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2MiA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNmLkluZGV4QSA9IDE7XHJcbiAgICAgICAgICAgICAgICBjZi5UeXBlQSA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5WZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlR5cGUgPSBNYW5pZm9sZFR5cGUuQ2lyY2xlcztcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxQb2ludCA9IFA7XHJcbiAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IG1wID0gbmV3IE1hbmlmb2xkUG9pbnQoKTtcclxuICAgICAgICAgICAgICAgIG1wLklkLktleSA9IDA7XHJcbiAgICAgICAgICAgICAgICBtcC5JZC5GZWF0dXJlcyA9IGNmO1xyXG4gICAgICAgICAgICAgICAgbXAuTG9jYWxQb2ludCA9IGNpcmNsZUIuUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludHNbMF0gPSBtcDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVnaW9uIEFCXHJcbiAgICAgICAgICAgIGZsb2F0IGRlbjtcclxuICAgICAgICAgICAgVmVjdG9yMi5Eb3QocmVmIGUsIHJlZiBlLCBvdXQgZGVuKTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGRlbiA+IDAuMGYpO1xyXG4gICAgICAgICAgICBQID0gKDEuMGYgLyBkZW4pICogKHUgKiBBICsgdiAqIEIpO1xyXG4gICAgICAgICAgICBkID0gUSAtIFA7XHJcbiAgICAgICAgICAgIGZsb2F0IGRkMjtcclxuICAgICAgICAgICAgVmVjdG9yMi5Eb3QocmVmIGQsIHJlZiBkLCBvdXQgZGQyKTtcclxuICAgICAgICAgICAgaWYgKGRkMiA+IHJhZGl1cyAqIHJhZGl1cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIG4gPSBuZXcgVmVjdG9yMigtZS5ZLCBlLlgpO1xyXG4gICAgICAgICAgICBpZiAoVmVjdG9yMi5Eb3QobiwgUSAtIEEpIDwgMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBWZWN0b3IyKC1uLlgsIC1uLlkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4uTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBjZi5JbmRleEEgPSAwO1xyXG4gICAgICAgICAgICBjZi5UeXBlQSA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5GYWNlO1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gMTtcclxuICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5GYWNlQTtcclxuICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwgPSBuO1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbFBvaW50ID0gQTtcclxuICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBtcDIgPSBuZXcgTWFuaWZvbGRQb2ludCgpO1xyXG4gICAgICAgICAgICBtcDIuSWQuS2V5ID0gMDtcclxuICAgICAgICAgICAgbXAyLklkLkZlYXR1cmVzID0gY2Y7XHJcbiAgICAgICAgICAgIG1wMi5Mb2NhbFBvaW50ID0gY2lyY2xlQi5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRzWzBdID0gbXAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb2xsaWRlcyBhbmQgZWRnZSBhbmQgYSBwb2x5Z29uLCB0YWtpbmcgaW50byBhY2NvdW50IGVkZ2UgYWRqYWNlbmN5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWFuaWZvbGRcIj5UaGUgbWFuaWZvbGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlZGdlQVwiPlRoZSBlZGdlIEEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4ZkFcIj5UaGUgeGYgQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHlnb25CXCI+VGhlIHBvbHlnb24gQi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhmQlwiPlRoZSB4ZiBCLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIENvbGxpZGVFZGdlQW5kUG9seWdvbihyZWYgTWFuaWZvbGQgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFZGdlU2hhcGUgZWRnZUEsIHJlZiBUcmFuc2Zvcm0geGZBLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHlnb25CLCByZWYgVHJhbnNmb3JtIHhmQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHhmQSwgcmVmIHhmQiwgb3V0IF94Zik7XHJcblxyXG4gICAgICAgICAgICAvLyBFZGdlIGdlb21ldHJ5XHJcbiAgICAgICAgICAgIF9lZGdlQS5WMCA9IGVkZ2VBLlZlcnRleDA7XHJcbiAgICAgICAgICAgIF9lZGdlQS5WMSA9IGVkZ2VBLlZlcnRleDE7XHJcbiAgICAgICAgICAgIF9lZGdlQS5WMiA9IGVkZ2VBLlZlcnRleDI7XHJcbiAgICAgICAgICAgIF9lZGdlQS5WMyA9IGVkZ2VBLlZlcnRleDM7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZSA9IF9lZGdlQS5WMiAtIF9lZGdlQS5WMTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vcm1hbCBwb2ludHMgb3V0d2FyZHMgaW4gQ0NXIG9yZGVyLlxyXG4gICAgICAgICAgICBfZWRnZUEuTm9ybWFsID0gbmV3IFZlY3RvcjIoZS5ZLCAtZS5YKTtcclxuICAgICAgICAgICAgX2VkZ2VBLk5vcm1hbC5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgX2VkZ2VBLkhhc1ZlcnRleDAgPSBlZGdlQS5IYXNWZXJ0ZXgwO1xyXG4gICAgICAgICAgICBfZWRnZUEuSGFzVmVydGV4MyA9IGVkZ2VBLkhhc1ZlcnRleDM7XHJcblxyXG4gICAgICAgICAgICAvLyBQcm94eSBmb3IgZWRnZVxyXG4gICAgICAgICAgICBfcHJveHlBLlZlcnRpY2VzWzBdID0gX2VkZ2VBLlYxO1xyXG4gICAgICAgICAgICBfcHJveHlBLlZlcnRpY2VzWzFdID0gX2VkZ2VBLlYyO1xyXG4gICAgICAgICAgICBfcHJveHlBLk5vcm1hbHNbMF0gPSBfZWRnZUEuTm9ybWFsO1xyXG4gICAgICAgICAgICBfcHJveHlBLk5vcm1hbHNbMV0gPSAtX2VkZ2VBLk5vcm1hbDtcclxuICAgICAgICAgICAgX3Byb3h5QS5DZW50cm9pZCA9IDAuNWYgKiAoX2VkZ2VBLlYxICsgX2VkZ2VBLlYyKTtcclxuICAgICAgICAgICAgX3Byb3h5QS5Db3VudCA9IDI7XHJcblxyXG4gICAgICAgICAgICAvLyBQcm94eSBmb3IgcG9seWdvblxyXG4gICAgICAgICAgICBfcHJveHlCLkNvdW50ID0gcG9seWdvbkIuVmVydGljZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIF9wcm94eUIuQ2VudHJvaWQgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIF94ZiwgcmVmIHBvbHlnb25CLk1hc3NEYXRhLkNlbnRyb2lkKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwb2x5Z29uQi5WZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfcHJveHlCLlZlcnRpY2VzW2ldID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBfeGYsIHBvbHlnb25CLlZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgICAgIF9wcm94eUIuTm9ybWFsc1tpXSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgX3hmLlIsIHBvbHlnb25CLk5vcm1hbHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfcmFkaXVzID0gMi4wZiAqIFNldHRpbmdzLlBvbHlnb25SYWRpdXM7XHJcblxyXG4gICAgICAgICAgICBfbGltaXQxMSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgX2xpbWl0MTIgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIF9saW1pdDIxID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBfbGltaXQyMiA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgIC8vQ29sbGlkZShyZWYgbWFuaWZvbGQpOyBpbmxpbmUgc3RhcnRcclxuICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICAvL0NvbXB1dGVBZGphY2VuY3koKTsgaW5saW5lIHN0YXJ0XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjAgPSBfZWRnZUEuVjA7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBfZWRnZUEuVjE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBfZWRnZUEuVjI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjMgPSBfZWRnZUEuVjM7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgYWxsb3dhYmxlIHRoZSBub3JtYWwgcmVnaW9ucyBiYXNlZCBvbiBhZGphY2VuY3kuXHJcbiAgICAgICAgICAgIC8vIE5vdGU6IGl0IG1heSBiZSBwb3NzaWJsZSB0aGF0IG5vIG5vcm1hbCBpcyBhZG1pc3NhYmxlLlxyXG4gICAgICAgICAgICBWZWN0b3IyIGNlbnRlckIgPSBfcHJveHlCLkNlbnRyb2lkO1xyXG4gICAgICAgICAgICBpZiAoX2VkZ2VBLkhhc1ZlcnRleDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZTAgPSB2MSAtIHYwO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlMSA9IHYyIC0gdjE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG4wID0gbmV3IFZlY3RvcjIoZTAuWSwgLWUwLlgpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuMSA9IG5ldyBWZWN0b3IyKGUxLlksIC1lMS5YKTtcclxuICAgICAgICAgICAgICAgIG4wLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgbjEuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm9vbCBjb252ZXggPSBNYXRoVXRpbHMuQ3Jvc3MobjAsIG4xKSA+PSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgYm9vbCBmcm9udDAgPSBWZWN0b3IyLkRvdChuMCwgY2VudGVyQiAtIHYwKSA+PSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgYm9vbCBmcm9udDEgPSBWZWN0b3IyLkRvdChuMSwgY2VudGVyQiAtIHYxKSA+PSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb252ZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb250MCB8fCBmcm9udDEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQxMSA9IG4xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQxMiA9IG4wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQxMSA9IC1uMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MTIgPSAtbjA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9udDAgJiYgZnJvbnQxKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MTEgPSBuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MTIgPSBuMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MTEgPSAtbjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDEyID0gLW4xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW1pdDExID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0MTIgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfZWRnZUEuSGFzVmVydGV4MylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlMSA9IHYyIC0gdjE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGUyID0gdjMgLSB2MjtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbjEgPSBuZXcgVmVjdG9yMihlMS5ZLCAtZTEuWCk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG4yID0gbmV3IFZlY3RvcjIoZTIuWSwgLWUyLlgpO1xyXG4gICAgICAgICAgICAgICAgbjEuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICBuMi5Ob3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib29sIGNvbnZleCA9IE1hdGhVdGlscy5Dcm9zcyhuMSwgbjIpID49IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBib29sIGZyb250MSA9IFZlY3RvcjIuRG90KG4xLCBjZW50ZXJCIC0gdjEpID49IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBib29sIGZyb250MiA9IFZlY3RvcjIuRG90KG4yLCBjZW50ZXJCIC0gdjIpID49IDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnZleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbnQxIHx8IGZyb250MilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDIxID0gbjI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDIyID0gbjE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDIxID0gLW4yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQyMiA9IC1uMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb250MSAmJiBmcm9udDIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQyMSA9IG4xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQyMiA9IG4yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQyMSA9IC1uMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MjIgPSAtbjI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0MjEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBfbGltaXQyMiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9Db21wdXRlQWRqYWNlbmN5KCk7IGlubGluZSBlbmRcclxuXHJcbiAgICAgICAgICAgIC8vRVBBeGlzIGVkZ2VBeGlzID0gQ29tcHV0ZUVkZ2VTZXBhcmF0aW9uKCk7IGlubGluZSBzdGFydFxyXG4gICAgICAgICAgICBFUEF4aXMgZWRnZUF4aXMgPSBDb21wdXRlRWRnZVNlcGFyYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vIHZhbGlkIG5vcm1hbCBjYW4gYmUgZm91bmQgdGhhbiB0aGlzIGVkZ2Ugc2hvdWxkIG5vdCBjb2xsaWRlLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gb24gdGhlIG1pZGRsZSBlZGdlIG9mIGEgMy1lZGdlIHppZy16YWcgY2hhaW4uXHJcbiAgICAgICAgICAgIGlmIChlZGdlQXhpcy5UeXBlID09IEVQQXhpc1R5cGUuVW5rbm93bilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZWRnZUF4aXMuU2VwYXJhdGlvbiA+IF9yYWRpdXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRVBBeGlzIHBvbHlnb25BeGlzID0gQ29tcHV0ZVBvbHlnb25TZXBhcmF0aW9uKCk7XHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uQXhpcy5UeXBlICE9IEVQQXhpc1R5cGUuVW5rbm93biAmJiBwb2x5Z29uQXhpcy5TZXBhcmF0aW9uID4gX3JhZGl1cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgaHlzdGVyZXNpcyBmb3Igaml0dGVyIHJlZHVjdGlvbi5cclxuICAgICAgICAgICAgY29uc3QgZmxvYXQga19yZWxhdGl2ZVRvbCA9IDAuOThmO1xyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCBrX2Fic29sdXRlVG9sID0gMC4wMDFmO1xyXG5cclxuICAgICAgICAgICAgRVBBeGlzIHByaW1hcnlBeGlzO1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbkF4aXMuVHlwZSA9PSBFUEF4aXNUeXBlLlVua25vd24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByaW1hcnlBeGlzID0gZWRnZUF4aXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocG9seWdvbkF4aXMuU2VwYXJhdGlvbiA+IGtfcmVsYXRpdmVUb2wgKiBlZGdlQXhpcy5TZXBhcmF0aW9uICsga19hYnNvbHV0ZVRvbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcHJpbWFyeUF4aXMgPSBwb2x5Z29uQXhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByaW1hcnlBeGlzID0gZWRnZUF4aXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEVQUHJveHkgcHJveHkxO1xyXG4gICAgICAgICAgICBFUFByb3h5IHByb3h5MjtcclxuICAgICAgICAgICAgRml4ZWRBcnJheTI8Q2xpcFZlcnRleD4gaW5jaWRlbnRFZGdlID0gbmV3IEZpeGVkQXJyYXkyPENsaXBWZXJ0ZXg+KCk7XHJcbiAgICAgICAgICAgIGlmIChwcmltYXJ5QXhpcy5UeXBlID09IEVQQXhpc1R5cGUuRWRnZUEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByb3h5MSA9IF9wcm94eUE7XHJcbiAgICAgICAgICAgICAgICBwcm94eTIgPSBfcHJveHlCO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5GYWNlQTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByb3h5MSA9IF9wcm94eUI7XHJcbiAgICAgICAgICAgICAgICBwcm94eTIgPSBfcHJveHlBO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5GYWNlQjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50IGVkZ2UxID0gcHJpbWFyeUF4aXMuSW5kZXg7XHJcblxyXG4gICAgICAgICAgICBGaW5kSW5jaWRlbnRFZGdlKHJlZiBpbmNpZGVudEVkZ2UsIHByb3h5MSwgcHJpbWFyeUF4aXMuSW5kZXgsIHByb3h5Mik7XHJcbiAgICAgICAgICAgIGludCBjb3VudDEgPSBwcm94eTEuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBpbnQgaXYxID0gZWRnZTE7XHJcbiAgICAgICAgICAgIGludCBpdjIgPSBlZGdlMSArIDEgPCBjb3VudDEgPyBlZGdlMSArIDEgOiAwO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2MTEgPSBwcm94eTEuVmVydGljZXNbaXYxXTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MTIgPSBwcm94eTEuVmVydGljZXNbaXYyXTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdGFuZ2VudCA9IHYxMiAtIHYxMTtcclxuICAgICAgICAgICAgdGFuZ2VudC5Ob3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gTWF0aFV0aWxzLkNyb3NzKHRhbmdlbnQsIDEuMGYpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHBsYW5lUG9pbnQgPSAwLjVmICogKHYxMSArIHYxMik7XHJcblxyXG4gICAgICAgICAgICAvLyBGYWNlIG9mZnNldC5cclxuICAgICAgICAgICAgZmxvYXQgZnJvbnRPZmZzZXQgPSBWZWN0b3IyLkRvdChub3JtYWwsIHYxMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaWRlIG9mZnNldHMsIGV4dGVuZGVkIGJ5IHBvbHl0b3BlIHNraW4gdGhpY2tuZXNzLlxyXG4gICAgICAgICAgICBmbG9hdCBzaWRlT2Zmc2V0MSA9IC1WZWN0b3IyLkRvdCh0YW5nZW50LCB2MTEpICsgX3JhZGl1cztcclxuICAgICAgICAgICAgZmxvYXQgc2lkZU9mZnNldDIgPSBWZWN0b3IyLkRvdCh0YW5nZW50LCB2MTIpICsgX3JhZGl1cztcclxuXHJcbiAgICAgICAgICAgIC8vIENsaXAgaW5jaWRlbnQgZWRnZSBhZ2FpbnN0IGV4dHJ1ZGVkIGVkZ2UxIHNpZGUgZWRnZXMuXHJcbiAgICAgICAgICAgIEZpeGVkQXJyYXkyPENsaXBWZXJ0ZXg+IGNsaXBQb2ludHMxO1xyXG4gICAgICAgICAgICBGaXhlZEFycmF5MjxDbGlwVmVydGV4PiBjbGlwUG9pbnRzMjtcclxuICAgICAgICAgICAgaW50IG5wO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xpcCB0byBib3ggc2lkZSAxXHJcbiAgICAgICAgICAgIG5wID0gQ2xpcFNlZ21lbnRUb0xpbmUob3V0IGNsaXBQb2ludHMxLCByZWYgaW5jaWRlbnRFZGdlLCAtdGFuZ2VudCwgc2lkZU9mZnNldDEsIGl2MSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobnAgPCBTZXR0aW5ncy5NYXhNYW5pZm9sZFBvaW50cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDbGlwIHRvIG5lZ2F0aXZlIGJveCBzaWRlIDFcclxuICAgICAgICAgICAgbnAgPSBDbGlwU2VnbWVudFRvTGluZShvdXQgY2xpcFBvaW50czIsIHJlZiBjbGlwUG9pbnRzMSwgdGFuZ2VudCwgc2lkZU9mZnNldDIsIGl2Mik7XHJcblxyXG4gICAgICAgICAgICBpZiAobnAgPCBTZXR0aW5ncy5NYXhNYW5pZm9sZFBvaW50cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOb3cgY2xpcFBvaW50czIgY29udGFpbnMgdGhlIGNsaXBwZWQgcG9pbnRzLlxyXG4gICAgICAgICAgICBpZiAocHJpbWFyeUF4aXMuVHlwZSA9PSBFUEF4aXNUeXBlLkVkZ2VBKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbCA9IG5vcm1hbDtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsUG9pbnQgPSBwbGFuZVBvaW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiBfeGYuUiwgcmVmIG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbFBvaW50ID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgX3hmLCByZWYgcGxhbmVQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCBwb2ludENvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaTEgPSAwOyBpMSA8IFNldHRpbmdzLk1heE1hbmlmb2xkUG9pbnRzOyArK2kxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uID0gVmVjdG9yMi5Eb3Qobm9ybWFsLCBjbGlwUG9pbnRzMltpMV0uVikgLSBmcm9udE9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdGlvbiA8PSBfcmFkaXVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgY3AgPSBtYW5pZm9sZC5Qb2ludHNbcG9pbnRDb3VudF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmltYXJ5QXhpcy5UeXBlID09IEVQQXhpc1R5cGUuRWRnZUEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcC5Mb2NhbFBvaW50ID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgX3hmLCBjbGlwUG9pbnRzMltpMV0uVik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwLklkID0gY2xpcFBvaW50czJbaTFdLklEO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcC5Mb2NhbFBvaW50ID0gY2xpcFBvaW50czJbaTFdLlY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwLklkLkZlYXR1cmVzLlR5cGVBID0gY2xpcFBvaW50czJbaTFdLklELkZlYXR1cmVzLlR5cGVCO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcC5JZC5GZWF0dXJlcy5UeXBlQiA9IGNsaXBQb2ludHMyW2kxXS5JRC5GZWF0dXJlcy5UeXBlQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3AuSWQuRmVhdHVyZXMuSW5kZXhBID0gY2xpcFBvaW50czJbaTFdLklELkZlYXR1cmVzLkluZGV4QjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3AuSWQuRmVhdHVyZXMuSW5kZXhCID0gY2xpcFBvaW50czJbaTFdLklELkZlYXR1cmVzLkluZGV4QTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50c1twb2ludENvdW50XSA9IGNwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICArK3BvaW50Q291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSBwb2ludENvdW50O1xyXG5cclxuICAgICAgICAgICAgLy9Db2xsaWRlKHJlZiBtYW5pZm9sZCk7IGlubGluZSBlbmRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIEVQQXhpcyBDb21wdXRlRWRnZVNlcGFyYXRpb24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRWRnZUEgc2VwYXJhdGlvblxyXG4gICAgICAgICAgICBFUEF4aXMgYmVzdEF4aXM7XHJcbiAgICAgICAgICAgIGJlc3RBeGlzLlR5cGUgPSBFUEF4aXNUeXBlLlVua25vd247XHJcbiAgICAgICAgICAgIGJlc3RBeGlzLkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGJlc3RBeGlzLlNlcGFyYXRpb24gPSAtU2V0dGluZ3MuTWF4RmxvYXQ7XHJcbiAgICAgICAgICAgIF90bXBOb3JtYWxzWzBdID0gX2VkZ2VBLk5vcm1hbDtcclxuICAgICAgICAgICAgX3RtcE5vcm1hbHNbMV0gPSAtX2VkZ2VBLk5vcm1hbDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMjsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG4gPSBfdG1wTm9ybWFsc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGphY2VuY3lcclxuICAgICAgICAgICAgICAgIGJvb2wgdmFsaWQxID0gTWF0aFV0aWxzLkNyb3NzKG4sIF9saW1pdDExKSA+PSAtU2V0dGluZ3MuQW5ndWxhclNsb3AgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKF9saW1pdDEyLCBuKSA+PSAtU2V0dGluZ3MuQW5ndWxhclNsb3A7XHJcbiAgICAgICAgICAgICAgICBib29sIHZhbGlkMiA9IE1hdGhVdGlscy5Dcm9zcyhuLCBfbGltaXQyMSkgPj0gLVNldHRpbmdzLkFuZ3VsYXJTbG9wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhfbGltaXQyMiwgbikgPj0gLVNldHRpbmdzLkFuZ3VsYXJTbG9wO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWxpZDEgPT0gZmFsc2UgfHwgdmFsaWQyID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIEVQQXhpcyBheGlzO1xyXG4gICAgICAgICAgICAgICAgYXhpcy5UeXBlID0gRVBBeGlzVHlwZS5FZGdlQTtcclxuICAgICAgICAgICAgICAgIGF4aXMuSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgYXhpcy5TZXBhcmF0aW9uID0gU2V0dGluZ3MuTWF4RmxvYXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBfcHJveHlCLkNvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcyA9IFZlY3RvcjIuRG90KG4sIF9wcm94eUIuVmVydGljZXNbal0gLSBfZWRnZUEuVjEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgYXhpcy5TZXBhcmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5TZXBhcmF0aW9uID0gcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuU2VwYXJhdGlvbiA+IF9yYWRpdXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4aXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuU2VwYXJhdGlvbiA+IGJlc3RBeGlzLlNlcGFyYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdEF4aXMgPSBheGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmVzdEF4aXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBFUEF4aXMgQ29tcHV0ZVBvbHlnb25TZXBhcmF0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVQQXhpcyBheGlzO1xyXG4gICAgICAgICAgICBheGlzLlR5cGUgPSBFUEF4aXNUeXBlLlVua25vd247XHJcbiAgICAgICAgICAgIGF4aXMuSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgYXhpcy5TZXBhcmF0aW9uID0gLVNldHRpbmdzLk1heEZsb2F0O1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9wcm94eUIuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuID0gLV9wcm94eUIuTm9ybWFsc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGphY2VuY3lcclxuICAgICAgICAgICAgICAgIGJvb2wgdmFsaWQxID0gTWF0aFV0aWxzLkNyb3NzKG4sIF9saW1pdDExKSA+PSAtU2V0dGluZ3MuQW5ndWxhclNsb3AgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKF9saW1pdDEyLCBuKSA+PSAtU2V0dGluZ3MuQW5ndWxhclNsb3A7XHJcbiAgICAgICAgICAgICAgICBib29sIHZhbGlkMiA9IE1hdGhVdGlscy5Dcm9zcyhuLCBfbGltaXQyMSkgPj0gLVNldHRpbmdzLkFuZ3VsYXJTbG9wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhfbGltaXQyMiwgbikgPj0gLVNldHRpbmdzLkFuZ3VsYXJTbG9wO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWxpZDEgPT0gZmFsc2UgJiYgdmFsaWQyID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHMxID0gVmVjdG9yMi5Eb3QobiwgX3Byb3h5Qi5WZXJ0aWNlc1tpXSAtIF9lZGdlQS5WMSk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzMiA9IFZlY3RvcjIuRG90KG4sIF9wcm94eUIuVmVydGljZXNbaV0gLSBfZWRnZUEuVjIpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgcyA9IE1hdGguTWluKHMxLCBzMik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHMgPiBfcmFkaXVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuVHlwZSA9IEVQQXhpc1R5cGUuRWRnZUI7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5JbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5TZXBhcmF0aW9uID0gcztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocyA+IGF4aXMuU2VwYXJhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzLlR5cGUgPSBFUEF4aXNUeXBlLkVkZ2VCO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuU2VwYXJhdGlvbiA9IHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBheGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaW5kSW5jaWRlbnRFZGdlKHJlZiBGaXhlZEFycmF5MjxDbGlwVmVydGV4PiBjLCBFUFByb3h5IHByb3h5MSwgaW50IGVkZ2UxLCBFUFByb3h5IHByb3h5MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBjb3VudDIgPSBwcm94eTIuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBlZGdlMSAmJiBlZGdlMSA8IHByb3h5MS5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbCBvZiB0aGUgcmVmZXJlbmNlIGVkZ2UgaW4gcHJveHkyJ3MgZnJhbWUuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsMSA9IHByb3h5MS5Ob3JtYWxzW2VkZ2UxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluY2lkZW50IGVkZ2Ugb24gcHJveHkyLlxyXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmbG9hdCBtaW5Eb3QgPSBmbG9hdC5NYXhWYWx1ZTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb3VudDI7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZG90ID0gVmVjdG9yMi5Eb3Qobm9ybWFsMSwgcHJveHkyLk5vcm1hbHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvdCA8IG1pbkRvdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Eb3QgPSBkb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgY2xpcCB2ZXJ0aWNlcyBmb3IgdGhlIGluY2lkZW50IGVkZ2UuXHJcbiAgICAgICAgICAgIGludCBpMSA9IGluZGV4O1xyXG4gICAgICAgICAgICBpbnQgaTIgPSBpMSArIDEgPCBjb3VudDIgPyBpMSArIDEgOiAwO1xyXG5cclxuICAgICAgICAgICAgQ2xpcFZlcnRleCBjVGVtcCA9IG5ldyBDbGlwVmVydGV4KCk7XHJcbiAgICAgICAgICAgIGNUZW1wLlYgPSBwcm94eTIuVmVydGljZXNbaTFdO1xyXG4gICAgICAgICAgICBjVGVtcC5JRC5GZWF0dXJlcy5JbmRleEEgPSAoYnl0ZSllZGdlMTtcclxuICAgICAgICAgICAgY1RlbXAuSUQuRmVhdHVyZXMuSW5kZXhCID0gKGJ5dGUpaTE7XHJcbiAgICAgICAgICAgIGNUZW1wLklELkZlYXR1cmVzLlR5cGVBID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLkZhY2U7XHJcbiAgICAgICAgICAgIGNUZW1wLklELkZlYXR1cmVzLlR5cGVCID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLlZlcnRleDtcclxuICAgICAgICAgICAgY1swXSA9IGNUZW1wO1xyXG5cclxuICAgICAgICAgICAgY1RlbXAuViA9IHByb3h5Mi5WZXJ0aWNlc1tpMl07XHJcbiAgICAgICAgICAgIGNUZW1wLklELkZlYXR1cmVzLkluZGV4QSA9IChieXRlKWVkZ2UxO1xyXG4gICAgICAgICAgICBjVGVtcC5JRC5GZWF0dXJlcy5JbmRleEIgPSAoYnl0ZSlpMjtcclxuICAgICAgICAgICAgY1RlbXAuSUQuRmVhdHVyZXMuVHlwZUEgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuRmFjZTtcclxuICAgICAgICAgICAgY1RlbXAuSUQuRmVhdHVyZXMuVHlwZUIgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuVmVydGV4O1xyXG4gICAgICAgICAgICBjWzFdID0gY1RlbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENsaXBwaW5nIGZvciBjb250YWN0IG1hbmlmb2xkcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZPdXRcIj5UaGUgdiBvdXQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2SW5cIj5UaGUgdiBpbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5vcm1hbFwiPlRoZSBub3JtYWwuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvZmZzZXRcIj5UaGUgb2Zmc2V0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGV4SW5kZXhBXCI+VGhlIHZlcnRleCBpbmRleCBBLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBpbnQgQ2xpcFNlZ21lbnRUb0xpbmUob3V0IEZpeGVkQXJyYXkyPENsaXBWZXJ0ZXg+IHZPdXQsIHJlZiBGaXhlZEFycmF5MjxDbGlwVmVydGV4PiB2SW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsLCBmbG9hdCBvZmZzZXQsIGludCB2ZXJ0ZXhJbmRleEEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2T3V0ID0gbmV3IEZpeGVkQXJyYXkyPENsaXBWZXJ0ZXg+KCk7XHJcblxyXG4gICAgICAgICAgICBDbGlwVmVydGV4IHYwID0gdkluWzBdO1xyXG4gICAgICAgICAgICBDbGlwVmVydGV4IHYxID0gdkluWzFdO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBubyBvdXRwdXQgcG9pbnRzXHJcbiAgICAgICAgICAgIGludCBudW1PdXQgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBvZiBlbmQgcG9pbnRzIHRvIHRoZSBsaW5lXHJcbiAgICAgICAgICAgIGZsb2F0IGRpc3RhbmNlMCA9IG5vcm1hbC5YICogdjAuVi5YICsgbm9ybWFsLlkgKiB2MC5WLlkgLSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGZsb2F0IGRpc3RhbmNlMSA9IG5vcm1hbC5YICogdjEuVi5YICsgbm9ybWFsLlkgKiB2MS5WLlkgLSBvZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgcG9pbnRzIGFyZSBiZWhpbmQgdGhlIHBsYW5lXHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZTAgPD0gMC4wZikgdk91dFtudW1PdXQrK10gPSB2MDtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlMSA8PSAwLjBmKSB2T3V0W251bU91dCsrXSA9IHYxO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHBvaW50cyBhcmUgb24gZGlmZmVyZW50IHNpZGVzIG9mIHRoZSBwbGFuZVxyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UwICogZGlzdGFuY2UxIDwgMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgZWRnZSBhbmQgcGxhbmVcclxuICAgICAgICAgICAgICAgIGZsb2F0IGludGVycCA9IGRpc3RhbmNlMCAvIChkaXN0YW5jZTAgLSBkaXN0YW5jZTEpO1xyXG5cclxuICAgICAgICAgICAgICAgIENsaXBWZXJ0ZXggY3YgPSB2T3V0W251bU91dF07XHJcblxyXG4gICAgICAgICAgICAgICAgY3YuVi5YID0gdjAuVi5YICsgaW50ZXJwICogKHYxLlYuWCAtIHYwLlYuWCk7XHJcbiAgICAgICAgICAgICAgICBjdi5WLlkgPSB2MC5WLlkgKyBpbnRlcnAgKiAodjEuVi5ZIC0gdjAuVi5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBWZXJ0ZXhBIGlzIGhpdHRpbmcgZWRnZUIuXHJcbiAgICAgICAgICAgICAgICBjdi5JRC5GZWF0dXJlcy5JbmRleEEgPSAoYnl0ZSl2ZXJ0ZXhJbmRleEE7XHJcbiAgICAgICAgICAgICAgICBjdi5JRC5GZWF0dXJlcy5JbmRleEIgPSB2MC5JRC5GZWF0dXJlcy5JbmRleEI7XHJcbiAgICAgICAgICAgICAgICBjdi5JRC5GZWF0dXJlcy5UeXBlQSA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5WZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICBjdi5JRC5GZWF0dXJlcy5UeXBlQiA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5GYWNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZPdXRbbnVtT3V0XSA9IGN2O1xyXG5cclxuICAgICAgICAgICAgICAgICsrbnVtT3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVtT3V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gcG9seTEgYW5kIHBvbHkyIGZvciBhIGdpdmUgZWRnZSBub3JtYWwgb24gcG9seTEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2x5MVwiPlRoZSBwb2x5MS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhmMVwiPlRoZSBYRjEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlZGdlMVwiPlRoZSBlZGdlMS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHkyXCI+VGhlIHBvbHkyLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieGYyXCI+VGhlIFhGMi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgRWRnZVNlcGFyYXRpb24oUG9seWdvblNoYXBlIHBvbHkxLCByZWYgVHJhbnNmb3JtIHhmMSwgaW50IGVkZ2UxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5MiwgcmVmIFRyYW5zZm9ybSB4ZjIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgY291bnQyID0gcG9seTIuVmVydGljZXMuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBlZGdlMSAmJiBlZGdlMSA8IHBvbHkxLlZlcnRpY2VzLkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgbm9ybWFsIGZyb20gcG9seTEncyBmcmFtZSBpbnRvIHBvbHkyJ3MgZnJhbWUuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDFuID0gcG9seTEuTm9ybWFsc1tlZGdlMV07XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBub3JtYWxXb3JsZHggPSB4ZjEuUi5Db2wxLlggKiBwMW4uWCArIHhmMS5SLkNvbDIuWCAqIHAxbi5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBub3JtYWxXb3JsZHkgPSB4ZjEuUi5Db2wxLlkgKiBwMW4uWCArIHhmMS5SLkNvbDIuWSAqIHAxbi5ZO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBub3JtYWwgPSBuZXcgVmVjdG9yMihub3JtYWxXb3JsZHggKiB4ZjIuUi5Db2wxLlggKyBub3JtYWxXb3JsZHkgKiB4ZjIuUi5Db2wxLlksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsV29ybGR4ICogeGYyLlIuQ29sMi5YICsgbm9ybWFsV29ybGR5ICogeGYyLlIuQ29sMi5ZKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgc3VwcG9ydCB2ZXJ0ZXggb24gcG9seTIgZm9yIC1ub3JtYWwuXHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZsb2F0IG1pbkRvdCA9IFNldHRpbmdzLk1heEZsb2F0O1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb3VudDI7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZG90ID0gVmVjdG9yMi5Eb3QocG9seTIuVmVydGljZXNbaV0sIG5vcm1hbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRvdCA8IG1pbkRvdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Eb3QgPSBkb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHAxdmUgPSBwb2x5MS5WZXJ0aWNlc1tlZGdlMV07XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDJ2aSA9IHBvbHkyLlZlcnRpY2VzW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKHhmMi5Qb3NpdGlvbi5YICsgeGYyLlIuQ29sMS5YICogcDJ2aS5YICsgeGYyLlIuQ29sMi5YICogcDJ2aS5ZKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKHhmMS5Qb3NpdGlvbi5YICsgeGYxLlIuQ29sMS5YICogcDF2ZS5YICsgeGYxLlIuQ29sMi5YICogcDF2ZS5ZKSkgKiBub3JtYWxXb3JsZHggK1xyXG4gICAgICAgICAgICAgICAgICAgKCh4ZjIuUG9zaXRpb24uWSArIHhmMi5SLkNvbDEuWSAqIHAydmkuWCArIHhmMi5SLkNvbDIuWSAqIHAydmkuWSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICh4ZjEuUG9zaXRpb24uWSArIHhmMS5SLkNvbDEuWSAqIHAxdmUuWCArIHhmMS5SLkNvbDIuWSAqIHAxdmUuWSkpICogbm9ybWFsV29ybGR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kIHRoZSBtYXggc2VwYXJhdGlvbiBiZXR3ZWVuIHBvbHkxIGFuZCBwb2x5MiB1c2luZyBlZGdlIG5vcm1hbHMgZnJvbSBwb2x5MS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVkZ2VJbmRleFwiPkluZGV4IG9mIHRoZSBlZGdlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9seTFcIj5UaGUgcG9seTEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4ZjFcIj5UaGUgWEYxLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9seTJcIj5UaGUgcG9seTIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4ZjJcIj5UaGUgWEYyLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBGaW5kTWF4U2VwYXJhdGlvbihvdXQgaW50IGVkZ2VJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seTEsIHJlZiBUcmFuc2Zvcm0geGYxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5MiwgcmVmIFRyYW5zZm9ybSB4ZjIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgY291bnQxID0gcG9seTEuVmVydGljZXMuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBWZWN0b3IgcG9pbnRpbmcgZnJvbSB0aGUgY2VudHJvaWQgb2YgcG9seTEgdG8gdGhlIGNlbnRyb2lkIG9mIHBvbHkyLlxyXG4gICAgICAgICAgICBmbG9hdCBkeCA9ICh4ZjIuUG9zaXRpb24uWCArIHhmMi5SLkNvbDEuWCAqIHBvbHkyLk1hc3NEYXRhLkNlbnRyb2lkLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ZjIuUi5Db2wyLlggKiBwb2x5Mi5NYXNzRGF0YS5DZW50cm9pZC5ZKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgKHhmMS5Qb3NpdGlvbi5YICsgeGYxLlIuQ29sMS5YICogcG9seTEuTWFzc0RhdGEuQ2VudHJvaWQuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhmMS5SLkNvbDIuWCAqIHBvbHkxLk1hc3NEYXRhLkNlbnRyb2lkLlkpO1xyXG4gICAgICAgICAgICBmbG9hdCBkeSA9ICh4ZjIuUG9zaXRpb24uWSArIHhmMi5SLkNvbDEuWSAqIHBvbHkyLk1hc3NEYXRhLkNlbnRyb2lkLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ZjIuUi5Db2wyLlkgKiBwb2x5Mi5NYXNzRGF0YS5DZW50cm9pZC5ZKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgKHhmMS5Qb3NpdGlvbi5ZICsgeGYxLlIuQ29sMS5ZICogcG9seTEuTWFzc0RhdGEuQ2VudHJvaWQuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhmMS5SLkNvbDIuWSAqIHBvbHkxLk1hc3NEYXRhLkNlbnRyb2lkLlkpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGRMb2NhbDEgPSBuZXcgVmVjdG9yMihkeCAqIHhmMS5SLkNvbDEuWCArIGR5ICogeGYxLlIuQ29sMS5ZLCBkeCAqIHhmMS5SLkNvbDIuWCArIGR5ICogeGYxLlIuQ29sMi5ZKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgZWRnZSBub3JtYWwgb24gcG9seTEgdGhhdCBoYXMgdGhlIGxhcmdlc3QgcHJvamVjdGlvbiBvbnRvIGQuXHJcbiAgICAgICAgICAgIGludCBlZGdlID0gMDtcclxuICAgICAgICAgICAgZmxvYXQgbWF4RG90ID0gLVNldHRpbmdzLk1heEZsb2F0O1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGNvdW50MTsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkb3QgPSBWZWN0b3IyLkRvdChwb2x5MS5Ob3JtYWxzW2ldLCBkTG9jYWwxKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb3QgPiBtYXhEb3QpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RG90ID0gZG90O1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHNlcGFyYXRpb24gZm9yIHRoZSBlZGdlIG5vcm1hbC5cclxuICAgICAgICAgICAgZmxvYXQgcyA9IEVkZ2VTZXBhcmF0aW9uKHBvbHkxLCByZWYgeGYxLCBlZGdlLCBwb2x5MiwgcmVmIHhmMik7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgc2VwYXJhdGlvbiBmb3IgdGhlIHByZXZpb3VzIGVkZ2Ugbm9ybWFsLlxyXG4gICAgICAgICAgICBpbnQgcHJldkVkZ2UgPSBlZGdlIC0gMSA+PSAwID8gZWRnZSAtIDEgOiBjb3VudDEgLSAxO1xyXG4gICAgICAgICAgICBmbG9hdCBzUHJldiA9IEVkZ2VTZXBhcmF0aW9uKHBvbHkxLCByZWYgeGYxLCBwcmV2RWRnZSwgcG9seTIsIHJlZiB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNlcGFyYXRpb24gZm9yIHRoZSBuZXh0IGVkZ2Ugbm9ybWFsLlxyXG4gICAgICAgICAgICBpbnQgbmV4dEVkZ2UgPSBlZGdlICsgMSA8IGNvdW50MSA/IGVkZ2UgKyAxIDogMDtcclxuICAgICAgICAgICAgZmxvYXQgc05leHQgPSBFZGdlU2VwYXJhdGlvbihwb2x5MSwgcmVmIHhmMSwgbmV4dEVkZ2UsIHBvbHkyLCByZWYgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGJlc3QgZWRnZSBhbmQgdGhlIHNlYXJjaCBkaXJlY3Rpb24uXHJcbiAgICAgICAgICAgIGludCBiZXN0RWRnZTtcclxuICAgICAgICAgICAgZmxvYXQgYmVzdFNlcGFyYXRpb247XHJcbiAgICAgICAgICAgIGludCBpbmNyZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChzUHJldiA+IHMgJiYgc1ByZXYgPiBzTmV4dClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBiZXN0RWRnZSA9IHByZXZFZGdlO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNlcGFyYXRpb24gPSBzUHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzTmV4dCA+IHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBiZXN0RWRnZSA9IG5leHRFZGdlO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNlcGFyYXRpb24gPSBzTmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVkZ2VJbmRleCA9IGVkZ2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGxvY2FsIHNlYXJjaCBmb3IgdGhlIGJlc3QgZWRnZSBub3JtYWwuXHJcbiAgICAgICAgICAgIGZvciAoOyA7IClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluY3JlbWVudCA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICBlZGdlID0gYmVzdEVkZ2UgLSAxID49IDAgPyBiZXN0RWRnZSAtIDEgOiBjb3VudDEgLSAxO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UgPSBiZXN0RWRnZSArIDEgPCBjb3VudDEgPyBiZXN0RWRnZSArIDEgOiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHMgPSBFZGdlU2VwYXJhdGlvbihwb2x5MSwgcmVmIHhmMSwgZWRnZSwgcG9seTIsIHJlZiB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzID4gYmVzdFNlcGFyYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdEVkZ2UgPSBlZGdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RTZXBhcmF0aW9uID0gcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWRnZUluZGV4ID0gYmVzdEVkZ2U7XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0U2VwYXJhdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmluZEluY2lkZW50RWRnZShvdXQgRml4ZWRBcnJheTI8Q2xpcFZlcnRleD4gYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHkxLCByZWYgVHJhbnNmb3JtIHhmMSwgaW50IGVkZ2UxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seTIsIHJlZiBUcmFuc2Zvcm0geGYyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYyA9IG5ldyBGaXhlZEFycmF5MjxDbGlwVmVydGV4PigpO1xyXG5cclxuICAgICAgICAgICAgaW50IGNvdW50MiA9IHBvbHkyLlZlcnRpY2VzLkNvdW50O1xyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gZWRnZTEgJiYgZWRnZTEgPCBwb2x5MS5WZXJ0aWNlcy5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbCBvZiB0aGUgcmVmZXJlbmNlIGVkZ2UgaW4gcG9seTIncyBmcmFtZS5cclxuICAgICAgICAgICAgVmVjdG9yMiB2ID0gcG9seTEuTm9ybWFsc1tlZGdlMV07XHJcbiAgICAgICAgICAgIGZsb2F0IHRtcHggPSB4ZjEuUi5Db2wxLlggKiB2LlggKyB4ZjEuUi5Db2wyLlggKiB2Llk7XHJcbiAgICAgICAgICAgIGZsb2F0IHRtcHkgPSB4ZjEuUi5Db2wxLlkgKiB2LlggKyB4ZjEuUi5Db2wyLlkgKiB2Llk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsMSA9IG5ldyBWZWN0b3IyKHRtcHggKiB4ZjIuUi5Db2wxLlggKyB0bXB5ICogeGYyLlIuQ29sMS5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXB4ICogeGYyLlIuQ29sMi5YICsgdG1weSAqIHhmMi5SLkNvbDIuWSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmNpZGVudCBlZGdlIG9uIHBvbHkyLlxyXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmbG9hdCBtaW5Eb3QgPSBTZXR0aW5ncy5NYXhGbG9hdDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb3VudDI7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZG90ID0gVmVjdG9yMi5Eb3Qobm9ybWFsMSwgcG9seTIuTm9ybWFsc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG90IDwgbWluRG90KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRvdCA9IGRvdDtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBjbGlwIHZlcnRpY2VzIGZvciB0aGUgaW5jaWRlbnQgZWRnZS5cclxuICAgICAgICAgICAgaW50IGkxID0gaW5kZXg7XHJcbiAgICAgICAgICAgIGludCBpMiA9IGkxICsgMSA8IGNvdW50MiA/IGkxICsgMSA6IDA7XHJcblxyXG4gICAgICAgICAgICBDbGlwVmVydGV4IGN2MCA9IGNbMF07XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gcG9seTIuVmVydGljZXNbaTFdO1xyXG4gICAgICAgICAgICBjdjAuVi5YID0geGYyLlBvc2l0aW9uLlggKyB4ZjIuUi5Db2wxLlggKiB2MS5YICsgeGYyLlIuQ29sMi5YICogdjEuWTtcclxuICAgICAgICAgICAgY3YwLlYuWSA9IHhmMi5Qb3NpdGlvbi5ZICsgeGYyLlIuQ29sMS5ZICogdjEuWCArIHhmMi5SLkNvbDIuWSAqIHYxLlk7XHJcbiAgICAgICAgICAgIGN2MC5JRC5GZWF0dXJlcy5JbmRleEEgPSAoYnl0ZSllZGdlMTtcclxuICAgICAgICAgICAgY3YwLklELkZlYXR1cmVzLkluZGV4QiA9IChieXRlKWkxO1xyXG4gICAgICAgICAgICBjdjAuSUQuRmVhdHVyZXMuVHlwZUEgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuRmFjZTtcclxuICAgICAgICAgICAgY3YwLklELkZlYXR1cmVzLlR5cGVCID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLlZlcnRleDtcclxuXHJcbiAgICAgICAgICAgIGNbMF0gPSBjdjA7XHJcblxyXG4gICAgICAgICAgICBDbGlwVmVydGV4IGN2MSA9IGNbMV07XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBwb2x5Mi5WZXJ0aWNlc1tpMl07XHJcbiAgICAgICAgICAgIGN2MS5WLlggPSB4ZjIuUG9zaXRpb24uWCArIHhmMi5SLkNvbDEuWCAqIHYyLlggKyB4ZjIuUi5Db2wyLlggKiB2Mi5ZO1xyXG4gICAgICAgICAgICBjdjEuVi5ZID0geGYyLlBvc2l0aW9uLlkgKyB4ZjIuUi5Db2wxLlkgKiB2Mi5YICsgeGYyLlIuQ29sMi5ZICogdjIuWTtcclxuICAgICAgICAgICAgY3YxLklELkZlYXR1cmVzLkluZGV4QSA9IChieXRlKWVkZ2UxO1xyXG4gICAgICAgICAgICBjdjEuSUQuRmVhdHVyZXMuSW5kZXhCID0gKGJ5dGUpaTI7XHJcbiAgICAgICAgICAgIGN2MS5JRC5GZWF0dXJlcy5UeXBlQSA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5GYWNlO1xyXG4gICAgICAgICAgICBjdjEuSUQuRmVhdHVyZXMuVHlwZUIgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuVmVydGV4O1xyXG5cclxuICAgICAgICAgICAgY1sxXSA9IGN2MTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvblxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBkaXN0YW5jZSBwcm94eSBpcyB1c2VkIGJ5IHRoZSBHSksgYWxnb3JpdGhtLlxyXG4gICAgLy8vIEl0IGVuY2Fwc3VsYXRlcyBhbnkgc2hhcGUuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIERpc3RhbmNlUHJveHlcclxuICAgIHtcclxuICAgICAgICBpbnRlcm5hbCBmbG9hdCBSYWRpdXM7XHJcbiAgICAgICAgaW50ZXJuYWwgVmVydGljZXMgVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplIHRoZSBwcm94eSB1c2luZyB0aGUgZ2l2ZW4gc2hhcGUuIFRoZSBzaGFwZVxyXG4gICAgICAgIC8vLyBtdXN0IHJlbWFpbiBpbiBzY29wZSB3aGlsZSB0aGUgcHJveHkgaXMgaW4gdXNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2hhcGVcIj5UaGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldChTaGFwZSBzaGFwZSwgaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzaGFwZS5TaGFwZVR5cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgU2hhcGVUeXBlLkNpcmNsZTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENpcmNsZVNoYXBlIGNpcmNsZSA9IChDaXJjbGVTaGFwZSlzaGFwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljZXMuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljZXMuQWRkKGNpcmNsZS5Qb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJhZGl1cyA9IGNpcmNsZS5SYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgU2hhcGVUeXBlLlBvbHlnb246XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seWdvbiA9IChQb2x5Z29uU2hhcGUpc2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcG9seWdvbi5WZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5BZGQocG9seWdvbi5WZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgUmFkaXVzID0gcG9seWdvbi5SYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgU2hhcGVUeXBlLkxvb3A6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb29wU2hhcGUgbG9vcCA9IChMb29wU2hhcGUpc2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDw9IGluZGV4ICYmIGluZGV4IDwgbG9vcC5WZXJ0aWNlcy5Db3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkFkZChsb29wLlZlcnRpY2VzW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkFkZChpbmRleCArIDEgPCBsb29wLlZlcnRpY2VzLkNvdW50ID8gbG9vcC5WZXJ0aWNlc1tpbmRleCArIDFdIDogbG9vcC5WZXJ0aWNlc1swXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSYWRpdXMgPSBsb29wLlJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBTaGFwZVR5cGUuRWRnZTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEVkZ2VTaGFwZSBlZGdlID0gKEVkZ2VTaGFwZSlzaGFwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljZXMuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljZXMuQWRkKGVkZ2UuVmVydGV4MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkFkZChlZGdlLlZlcnRleDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSYWRpdXMgPSBlZGdlLlJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgc3VwcG9ydGluZyB2ZXJ0ZXggaW5kZXggaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpcmVjdGlvblwiPlRoZSBkaXJlY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgR2V0U3VwcG9ydChWZWN0b3IyIGRpcmVjdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBiZXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmbG9hdCBiZXN0VmFsdWUgPSBWZWN0b3IyLkRvdChWZXJ0aWNlc1swXSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBWZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IFZlY3RvcjIuRG90KFZlcnRpY2VzW2ldLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gYmVzdFZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0SW5kZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgc3VwcG9ydGluZyB2ZXJ0ZXggaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpcmVjdGlvblwiPlRoZSBkaXJlY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdldFN1cHBvcnRWZXJ0ZXgoVmVjdG9yMiBkaXJlY3Rpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgYmVzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgZmxvYXQgYmVzdFZhbHVlID0gVmVjdG9yMi5Eb3QoVmVydGljZXNbMF0sIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgVmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBWZWN0b3IyLkRvdChWZXJ0aWNlc1tpXSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gVmVydGljZXNbYmVzdEluZGV4XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFVzZWQgdG8gd2FybSBzdGFydCBDb21wdXRlRGlzdGFuY2UuXHJcbiAgICAvLy8gU2V0IGNvdW50IHRvIHplcm8gb24gZmlyc3QgY2FsbC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IFNpbXBsZXhDYWNoZVxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTGVuZ3RoIG9yIGFyZWFcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB1c2hvcnQgQ291bnQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVmVydGljZXMgb24gc2hhcGUgQVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEZpeGVkQXJyYXkzPGJ5dGU+IEluZGV4QTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBWZXJ0aWNlcyBvbiBzaGFwZSBCXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgRml4ZWRBcnJheTM8Ynl0ZT4gSW5kZXhCO1xyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWV0cmljO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBJbnB1dCBmb3IgQ29tcHV0ZURpc3RhbmNlLlxyXG4gICAgLy8vIFlvdSBoYXZlIHRvIG9wdGlvbiB0byB1c2UgdGhlIHNoYXBlIHJhZGlpXHJcbiAgICAvLy8gaW4gdGhlIGNvbXB1dGF0aW9uLiBcclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRGlzdGFuY2VJbnB1dFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBEaXN0YW5jZVByb3h5IFByb3h5QSA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XHJcbiAgICAgICAgcHVibGljIERpc3RhbmNlUHJveHkgUHJveHlCID0gbmV3IERpc3RhbmNlUHJveHkoKTtcclxuICAgICAgICBwdWJsaWMgVHJhbnNmb3JtIFRyYW5zZm9ybUE7XHJcbiAgICAgICAgcHVibGljIFRyYW5zZm9ybSBUcmFuc2Zvcm1CO1xyXG4gICAgICAgIHB1YmxpYyBib29sIFVzZVJhZGlpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBPdXRwdXQgZm9yIENvbXB1dGVEaXN0YW5jZS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IERpc3RhbmNlT3V0cHV0XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IERpc3RhbmNlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE51bWJlciBvZiBHSksgaXRlcmF0aW9ucyB1c2VkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IEl0ZXJhdGlvbnM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2xvc2VzdCBwb2ludCBvbiBzaGFwZUFcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFBvaW50QTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDbG9zZXN0IHBvaW50IG9uIHNoYXBlQlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgUG9pbnRCO1xyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIHN0cnVjdCBTaW1wbGV4VmVydGV4XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBCYXJ5Y2VudHJpYyBjb29yZGluYXRlIGZvciBjbG9zZXN0IHBvaW50IFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gd0EgaW5kZXhcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBpbnQgSW5kZXhBO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIHdCIGluZGV4XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IEluZGV4QjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyB3QiAtIHdBXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBXO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFN1cHBvcnQgcG9pbnQgaW4gcHJveHlBXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBXQTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdXBwb3J0IHBvaW50IGluIHByb3h5QlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgV0I7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJuYWwgc3RydWN0IFNpbXBsZXhcclxuICAgIHtcclxuICAgICAgICBpbnRlcm5hbCBpbnQgQ291bnQ7XHJcbiAgICAgICAgaW50ZXJuYWwgRml4ZWRBcnJheTM8U2ltcGxleFZlcnRleD4gVjtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBSZWFkQ2FjaGUocmVmIFNpbXBsZXhDYWNoZSBjYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXN0YW5jZVByb3h5IHByb3h5QSwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1BLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERpc3RhbmNlUHJveHkgcHJveHlCLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoY2FjaGUuQ291bnQgPD0gMyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb3B5IGRhdGEgZnJvbSBjYWNoZS5cclxuICAgICAgICAgICAgQ291bnQgPSBjYWNoZS5Db3VudDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYgPSBWW2ldO1xyXG4gICAgICAgICAgICAgICAgdi5JbmRleEEgPSBjYWNoZS5JbmRleEFbaV07XHJcbiAgICAgICAgICAgICAgICB2LkluZGV4QiA9IGNhY2hlLkluZGV4QltpXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgd0FMb2NhbCA9IHByb3h5QS5WZXJ0aWNlc1t2LkluZGV4QV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHdCTG9jYWwgPSBwcm94eUIuVmVydGljZXNbdi5JbmRleEJdO1xyXG4gICAgICAgICAgICAgICAgdi5XQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtQSwgd0FMb2NhbCk7XHJcbiAgICAgICAgICAgICAgICB2LldCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB0cmFuc2Zvcm1CLCB3QkxvY2FsKTtcclxuICAgICAgICAgICAgICAgIHYuVyA9IHYuV0IgLSB2LldBO1xyXG4gICAgICAgICAgICAgICAgdi5BID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIFZbaV0gPSB2O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBuZXcgc2ltcGxleCBtZXRyaWMsIGlmIGl0IGlzIHN1YnN0YW50aWFsbHkgZGlmZmVyZW50IHRoYW5cclxuICAgICAgICAgICAgLy8gb2xkIG1ldHJpYyB0aGVuIGZsdXNoIHRoZSBzaW1wbGV4LlxyXG4gICAgICAgICAgICBpZiAoQ291bnQgPiAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtZXRyaWMxID0gY2FjaGUuTWV0cmljO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWV0cmljMiA9IEdldE1ldHJpYygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldHJpYzIgPCAwLjVmICogbWV0cmljMSB8fCAyLjBmICogbWV0cmljMSA8IG1ldHJpYzIgfHwgbWV0cmljMiA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHNpbXBsZXguXHJcbiAgICAgICAgICAgICAgICAgICAgQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgY2FjaGUgaXMgZW1wdHkgb3IgaW52YWxpZCAuLi5cclxuICAgICAgICAgICAgaWYgKENvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdiA9IFZbMF07XHJcbiAgICAgICAgICAgICAgICB2LkluZGV4QSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2LkluZGV4QiA9IDA7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHdBTG9jYWwgPSBwcm94eUEuVmVydGljZXNbMF07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHdCTG9jYWwgPSBwcm94eUIuVmVydGljZXNbMF07XHJcbiAgICAgICAgICAgICAgICB2LldBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB0cmFuc2Zvcm1BLCB3QUxvY2FsKTtcclxuICAgICAgICAgICAgICAgIHYuV0IgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybUIsIHdCTG9jYWwpO1xyXG4gICAgICAgICAgICAgICAgdi5XID0gdi5XQiAtIHYuV0E7XHJcbiAgICAgICAgICAgICAgICBWWzBdID0gdjtcclxuICAgICAgICAgICAgICAgIENvdW50ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBXcml0ZUNhY2hlKHJlZiBTaW1wbGV4Q2FjaGUgY2FjaGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYWNoZS5NZXRyaWMgPSBHZXRNZXRyaWMoKTtcclxuICAgICAgICAgICAgY2FjaGUuQ291bnQgPSAoVUludDE2KUNvdW50O1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlLkluZGV4QVtpXSA9IChieXRlKShWW2ldLkluZGV4QSk7XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5JbmRleEJbaV0gPSAoYnl0ZSkoVltpXS5JbmRleEIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBWZWN0b3IyIEdldFNlYXJjaERpcmVjdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKENvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1WWzBdLlc7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBlMTIgPSBWWzFdLlcgLSBWWzBdLlc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHNnbiA9IE1hdGhVdGlscy5Dcm9zcyhlMTIsIC1WWzBdLlcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2duID4gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luIGlzIGxlZnQgb2YgZTEyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKC1lMTIuWSwgZTEyLlgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luIGlzIHJpZ2h0IG9mIGUxMi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihlMTIuWSwgLWUxMi5YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgVmVjdG9yMiBHZXRDbG9zZXN0UG9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dpdGNoIChDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZbMF0uVztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZbMF0uQSAqIFZbMF0uVyArIFZbMV0uQSAqIFZbMV0uVztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBHZXRXaXRuZXNzUG9pbnRzKG91dCBWZWN0b3IyIHBBLCBvdXQgVmVjdG9yMiBwQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBwQSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgICAgICBwQiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBwQSA9IFZbMF0uV0E7XHJcbiAgICAgICAgICAgICAgICAgICAgcEIgPSBWWzBdLldCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBwQSA9IFZbMF0uQSAqIFZbMF0uV0EgKyBWWzFdLkEgKiBWWzFdLldBO1xyXG4gICAgICAgICAgICAgICAgICAgIHBCID0gVlswXS5BICogVlswXS5XQiArIFZbMV0uQSAqIFZbMV0uV0I7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHBBID0gVlswXS5BICogVlswXS5XQSArIFZbMV0uQSAqIFZbMV0uV0EgKyBWWzJdLkEgKiBWWzJdLldBO1xyXG4gICAgICAgICAgICAgICAgICAgIHBCID0gcEE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIGZsb2F0IEdldE1ldHJpYygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKENvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoVlswXS5XIC0gVlsxXS5XKS5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5Dcm9zcyhWWzFdLlcgLSBWWzBdLlcsIFZbMl0uVyAtIFZbMF0uVyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTb2x2ZSBhIGxpbmUgc2VnbWVudCB1c2luZyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIHAgPSBhMSAqIHcxICsgYTIgKiB3MlxyXG4gICAgICAgIC8vIGExICsgYTIgPSAxXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGUgdmVjdG9yIGZyb20gdGhlIG9yaWdpbiB0byB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgbGluZSBpc1xyXG4gICAgICAgIC8vIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGxpbmUuXHJcbiAgICAgICAgLy8gZTEyID0gdzIgLSB3MVxyXG4gICAgICAgIC8vIGRvdChwLCBlKSA9IDBcclxuICAgICAgICAvLyBhMSAqIGRvdCh3MSwgZSkgKyBhMiAqIGRvdCh3MiwgZSkgPSAwXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAyLWJ5LTIgbGluZWFyIHN5c3RlbVxyXG4gICAgICAgIC8vIFsxICAgICAgMSAgICAgXVthMV0gPSBbMV1cclxuICAgICAgICAvLyBbdzEuZTEyIHcyLmUxMl1bYTJdID0gWzBdXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBEZWZpbmVcclxuICAgICAgICAvLyBkMTJfMSA9ICBkb3QodzIsIGUxMilcclxuICAgICAgICAvLyBkMTJfMiA9IC1kb3QodzEsIGUxMilcclxuICAgICAgICAvLyBkMTIgPSBkMTJfMSArIGQxMl8yXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBTb2x1dGlvblxyXG4gICAgICAgIC8vIGExID0gZDEyXzEgLyBkMTJcclxuICAgICAgICAvLyBhMiA9IGQxMl8yIC8gZDEyXHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgU29sdmUyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdzEgPSBWWzBdLlc7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdzIgPSBWWzFdLlc7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZTEyID0gdzIgLSB3MTtcclxuXHJcbiAgICAgICAgICAgIC8vIHcxIHJlZ2lvblxyXG4gICAgICAgICAgICBmbG9hdCBkMTJfMiA9IC1WZWN0b3IyLkRvdCh3MSwgZTEyKTtcclxuICAgICAgICAgICAgaWYgKGQxMl8yIDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGEyIDw9IDAsIHNvIHdlIGNsYW1wIGl0IHRvIDBcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjAgPSBWWzBdO1xyXG4gICAgICAgICAgICAgICAgdjAuQSA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICBWWzBdID0gdjA7XHJcbiAgICAgICAgICAgICAgICBDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHcyIHJlZ2lvblxyXG4gICAgICAgICAgICBmbG9hdCBkMTJfMSA9IFZlY3RvcjIuRG90KHcyLCBlMTIpO1xyXG4gICAgICAgICAgICBpZiAoZDEyXzEgPD0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gYTEgPD0gMCwgc28gd2UgY2xhbXAgaXQgdG8gMFxyXG4gICAgICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2MSA9IFZbMV07XHJcbiAgICAgICAgICAgICAgICB2MS5BID0gMS4wZjtcclxuICAgICAgICAgICAgICAgIFZbMV0gPSB2MTtcclxuICAgICAgICAgICAgICAgIENvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgIFZbMF0gPSBWWzFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNdXN0IGJlIGluIGUxMiByZWdpb24uXHJcbiAgICAgICAgICAgIGZsb2F0IGludl9kMTIgPSAxLjBmIC8gKGQxMl8xICsgZDEyXzIpO1xyXG4gICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYwXzIgPSBWWzBdO1xyXG4gICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYxXzIgPSBWWzFdO1xyXG4gICAgICAgICAgICB2MF8yLkEgPSBkMTJfMSAqIGludl9kMTI7XHJcbiAgICAgICAgICAgIHYxXzIuQSA9IGQxMl8yICogaW52X2QxMjtcclxuICAgICAgICAgICAgVlswXSA9IHYwXzI7XHJcbiAgICAgICAgICAgIFZbMV0gPSB2MV8yO1xyXG4gICAgICAgICAgICBDb3VudCA9IDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQb3NzaWJsZSByZWdpb25zOlxyXG4gICAgICAgIC8vIC0gcG9pbnRzWzJdXHJcbiAgICAgICAgLy8gLSBlZGdlIHBvaW50c1swXS1wb2ludHNbMl1cclxuICAgICAgICAvLyAtIGVkZ2UgcG9pbnRzWzFdLXBvaW50c1syXVxyXG4gICAgICAgIC8vIC0gaW5zaWRlIHRoZSB0cmlhbmdsZVxyXG4gICAgICAgIGludGVybmFsIHZvaWQgU29sdmUzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdzEgPSBWWzBdLlc7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdzIgPSBWWzFdLlc7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdzMgPSBWWzJdLlc7XHJcblxyXG4gICAgICAgICAgICAvLyBFZGdlMTJcclxuICAgICAgICAgICAgLy8gWzEgICAgICAxICAgICBdW2ExXSA9IFsxXVxyXG4gICAgICAgICAgICAvLyBbdzEuZTEyIHcyLmUxMl1bYTJdID0gWzBdXHJcbiAgICAgICAgICAgIC8vIGEzID0gMFxyXG4gICAgICAgICAgICBWZWN0b3IyIGUxMiA9IHcyIC0gdzE7XHJcbiAgICAgICAgICAgIGZsb2F0IHcxZTEyID0gVmVjdG9yMi5Eb3QodzEsIGUxMik7XHJcbiAgICAgICAgICAgIGZsb2F0IHcyZTEyID0gVmVjdG9yMi5Eb3QodzIsIGUxMik7XHJcbiAgICAgICAgICAgIGZsb2F0IGQxMl8xID0gdzJlMTI7XHJcbiAgICAgICAgICAgIGZsb2F0IGQxMl8yID0gLXcxZTEyO1xyXG5cclxuICAgICAgICAgICAgLy8gRWRnZTEzXHJcbiAgICAgICAgICAgIC8vIFsxICAgICAgMSAgICAgXVthMV0gPSBbMV1cclxuICAgICAgICAgICAgLy8gW3cxLmUxMyB3My5lMTNdW2EzXSA9IFswXVxyXG4gICAgICAgICAgICAvLyBhMiA9IDBcclxuICAgICAgICAgICAgVmVjdG9yMiBlMTMgPSB3MyAtIHcxO1xyXG4gICAgICAgICAgICBmbG9hdCB3MWUxMyA9IFZlY3RvcjIuRG90KHcxLCBlMTMpO1xyXG4gICAgICAgICAgICBmbG9hdCB3M2UxMyA9IFZlY3RvcjIuRG90KHczLCBlMTMpO1xyXG4gICAgICAgICAgICBmbG9hdCBkMTNfMSA9IHczZTEzO1xyXG4gICAgICAgICAgICBmbG9hdCBkMTNfMiA9IC13MWUxMztcclxuXHJcbiAgICAgICAgICAgIC8vIEVkZ2UyM1xyXG4gICAgICAgICAgICAvLyBbMSAgICAgIDEgICAgIF1bYTJdID0gWzFdXHJcbiAgICAgICAgICAgIC8vIFt3Mi5lMjMgdzMuZTIzXVthM10gPSBbMF1cclxuICAgICAgICAgICAgLy8gYTEgPSAwXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZTIzID0gdzMgLSB3MjtcclxuICAgICAgICAgICAgZmxvYXQgdzJlMjMgPSBWZWN0b3IyLkRvdCh3MiwgZTIzKTtcclxuICAgICAgICAgICAgZmxvYXQgdzNlMjMgPSBWZWN0b3IyLkRvdCh3MywgZTIzKTtcclxuICAgICAgICAgICAgZmxvYXQgZDIzXzEgPSB3M2UyMztcclxuICAgICAgICAgICAgZmxvYXQgZDIzXzIgPSAtdzJlMjM7XHJcblxyXG4gICAgICAgICAgICAvLyBUcmlhbmdsZTEyM1xyXG4gICAgICAgICAgICBmbG9hdCBuMTIzID0gTWF0aFV0aWxzLkNyb3NzKGUxMiwgZTEzKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGQxMjNfMSA9IG4xMjMgKiBNYXRoVXRpbHMuQ3Jvc3ModzIsIHczKTtcclxuICAgICAgICAgICAgZmxvYXQgZDEyM18yID0gbjEyMyAqIE1hdGhVdGlscy5Dcm9zcyh3MywgdzEpO1xyXG4gICAgICAgICAgICBmbG9hdCBkMTIzXzMgPSBuMTIzICogTWF0aFV0aWxzLkNyb3NzKHcxLCB3Mik7XHJcblxyXG4gICAgICAgICAgICAvLyB3MSByZWdpb25cclxuICAgICAgICAgICAgaWYgKGQxMl8yIDw9IDAuMGYgJiYgZDEzXzIgPD0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2MF8xID0gVlswXTtcclxuICAgICAgICAgICAgICAgIHYwXzEuQSA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICBWWzBdID0gdjBfMTtcclxuICAgICAgICAgICAgICAgIENvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZTEyXHJcbiAgICAgICAgICAgIGlmIChkMTJfMSA+IDAuMGYgJiYgZDEyXzIgPiAwLjBmICYmIGQxMjNfMyA8PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZfZDEyID0gMS4wZiAvIChkMTJfMSArIGQxMl8yKTtcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjBfMiA9IFZbMF07XHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYxXzIgPSBWWzFdO1xyXG4gICAgICAgICAgICAgICAgdjBfMi5BID0gZDEyXzEgKiBpbnZfZDEyO1xyXG4gICAgICAgICAgICAgICAgdjFfMi5BID0gZDEyXzIgKiBpbnZfZDEyO1xyXG4gICAgICAgICAgICAgICAgVlswXSA9IHYwXzI7XHJcbiAgICAgICAgICAgICAgICBWWzFdID0gdjFfMjtcclxuICAgICAgICAgICAgICAgIENvdW50ID0gMjtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZTEzXHJcbiAgICAgICAgICAgIGlmIChkMTNfMSA+IDAuMGYgJiYgZDEzXzIgPiAwLjBmICYmIGQxMjNfMiA8PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZfZDEzID0gMS4wZiAvIChkMTNfMSArIGQxM18yKTtcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjBfMyA9IFZbMF07XHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYyXzMgPSBWWzJdO1xyXG4gICAgICAgICAgICAgICAgdjBfMy5BID0gZDEzXzEgKiBpbnZfZDEzO1xyXG4gICAgICAgICAgICAgICAgdjJfMy5BID0gZDEzXzIgKiBpbnZfZDEzO1xyXG4gICAgICAgICAgICAgICAgVlswXSA9IHYwXzM7XHJcbiAgICAgICAgICAgICAgICBWWzJdID0gdjJfMztcclxuICAgICAgICAgICAgICAgIENvdW50ID0gMjtcclxuICAgICAgICAgICAgICAgIFZbMV0gPSBWWzJdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB3MiByZWdpb25cclxuICAgICAgICAgICAgaWYgKGQxMl8xIDw9IDAuMGYgJiYgZDIzXzIgPD0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2MV80ID0gVlsxXTtcclxuICAgICAgICAgICAgICAgIHYxXzQuQSA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICBWWzFdID0gdjFfNDtcclxuICAgICAgICAgICAgICAgIENvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgIFZbMF0gPSBWWzFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB3MyByZWdpb25cclxuICAgICAgICAgICAgaWYgKGQxM18xIDw9IDAuMGYgJiYgZDIzXzEgPD0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2Ml81ID0gVlsyXTtcclxuICAgICAgICAgICAgICAgIHYyXzUuQSA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICBWWzJdID0gdjJfNTtcclxuICAgICAgICAgICAgICAgIENvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgIFZbMF0gPSBWWzJdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBlMjNcclxuICAgICAgICAgICAgaWYgKGQyM18xID4gMC4wZiAmJiBkMjNfMiA+IDAuMGYgJiYgZDEyM18xIDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGludl9kMjMgPSAxLjBmIC8gKGQyM18xICsgZDIzXzIpO1xyXG4gICAgICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2MV82ID0gVlsxXTtcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjJfNiA9IFZbMl07XHJcbiAgICAgICAgICAgICAgICB2MV82LkEgPSBkMjNfMSAqIGludl9kMjM7XHJcbiAgICAgICAgICAgICAgICB2Ml82LkEgPSBkMjNfMiAqIGludl9kMjM7XHJcbiAgICAgICAgICAgICAgICBWWzFdID0gdjFfNjtcclxuICAgICAgICAgICAgICAgIFZbMl0gPSB2Ml82O1xyXG4gICAgICAgICAgICAgICAgQ291bnQgPSAyO1xyXG4gICAgICAgICAgICAgICAgVlswXSA9IFZbMl07XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE11c3QgYmUgaW4gdHJpYW5nbGUxMjNcclxuICAgICAgICAgICAgZmxvYXQgaW52X2QxMjMgPSAxLjBmIC8gKGQxMjNfMSArIGQxMjNfMiArIGQxMjNfMyk7XHJcbiAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjBfNyA9IFZbMF07XHJcbiAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjFfNyA9IFZbMV07XHJcbiAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjJfNyA9IFZbMl07XHJcbiAgICAgICAgICAgIHYwXzcuQSA9IGQxMjNfMSAqIGludl9kMTIzO1xyXG4gICAgICAgICAgICB2MV83LkEgPSBkMTIzXzIgKiBpbnZfZDEyMztcclxuICAgICAgICAgICAgdjJfNy5BID0gZDEyM18zICogaW52X2QxMjM7XHJcbiAgICAgICAgICAgIFZbMF0gPSB2MF83O1xyXG4gICAgICAgICAgICBWWzFdID0gdjFfNztcclxuICAgICAgICAgICAgVlsyXSA9IHYyXzc7XHJcbiAgICAgICAgICAgIENvdW50ID0gMztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBEaXN0YW5jZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW50IEdKS0NhbGxzLCBHSktJdGVycywgR0pLTWF4SXRlcnM7XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBDb21wdXRlRGlzdGFuY2Uob3V0IERpc3RhbmNlT3V0cHV0IG91dHB1dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBTaW1wbGV4Q2FjaGUgY2FjaGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXN0YW5jZUlucHV0IGlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FjaGUgPSBuZXcgU2ltcGxleENhY2hlKCk7XHJcbiAgICAgICAgICAgICsrR0pLQ2FsbHM7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBzaW1wbGV4LlxyXG4gICAgICAgICAgICBTaW1wbGV4IHNpbXBsZXggPSBuZXcgU2ltcGxleCgpO1xyXG4gICAgICAgICAgICBzaW1wbGV4LlJlYWRDYWNoZShyZWYgY2FjaGUsIGlucHV0LlByb3h5QSwgcmVmIGlucHV0LlRyYW5zZm9ybUEsIGlucHV0LlByb3h5QiwgcmVmIGlucHV0LlRyYW5zZm9ybUIpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHNpbXBsZXggdmVydGljZXMgYXMgYW4gYXJyYXkuXHJcbiAgICAgICAgICAgIGNvbnN0IGludCBrX21heEl0ZXJzID0gMjA7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGVzZSBzdG9yZSB0aGUgdmVydGljZXMgb2YgdGhlIGxhc3Qgc2ltcGxleCBzbyB0aGF0IHdlXHJcbiAgICAgICAgICAgIC8vIGNhbiBjaGVjayBmb3IgZHVwbGljYXRlcyBhbmQgcHJldmVudCBjeWNsaW5nLlxyXG4gICAgICAgICAgICBGaXhlZEFycmF5MzxpbnQ+IHNhdmVBID0gbmV3IEZpeGVkQXJyYXkzPGludD4oKTtcclxuICAgICAgICAgICAgRml4ZWRBcnJheTM8aW50PiBzYXZlQiA9IG5ldyBGaXhlZEFycmF5MzxpbnQ+KCk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGNsb3Nlc3RQb2ludCA9IHNpbXBsZXguR2V0Q2xvc2VzdFBvaW50KCk7XHJcbiAgICAgICAgICAgIGZsb2F0IGRpc3RhbmNlU3FyMSA9IGNsb3Nlc3RQb2ludC5MZW5ndGhTcXVhcmVkKCk7XHJcbiAgICAgICAgICAgIGZsb2F0IGRpc3RhbmNlU3FyMiA9IGRpc3RhbmNlU3FyMTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1haW4gaXRlcmF0aW9uIGxvb3AuXHJcbiAgICAgICAgICAgIGludCBpdGVyID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGl0ZXIgPCBrX21heEl0ZXJzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHNpbXBsZXggc28gd2UgY2FuIGlkZW50aWZ5IGR1cGxpY2F0ZXMuXHJcbiAgICAgICAgICAgICAgICBpbnQgc2F2ZUNvdW50ID0gc2ltcGxleC5Db3VudDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgc2F2ZUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUFbaV0gPSBzaW1wbGV4LlZbaV0uSW5kZXhBO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVCW2ldID0gc2ltcGxleC5WW2ldLkluZGV4QjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNpbXBsZXguQ291bnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGV4LlNvbHZlMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGV4LlNvbHZlMygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSAzIHBvaW50cywgdGhlbiB0aGUgb3JpZ2luIGlzIGluIHRoZSBjb3JyZXNwb25kaW5nIHRyaWFuZ2xlLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZXguQ291bnQgPT0gMylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGNsb3Nlc3QgcG9pbnQuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAgPSBzaW1wbGV4LkdldENsb3Nlc3RQb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VTcXIyID0gcC5MZW5ndGhTcXVhcmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHByb2dyZXNzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VTcXIyID49IGRpc3RhbmNlU3FyMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2JyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VTcXIxID0gZGlzdGFuY2VTcXIyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBzZWFyY2ggZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gc2ltcGxleC5HZXRTZWFyY2hEaXJlY3Rpb24oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHNlYXJjaCBkaXJlY3Rpb24gaXMgbnVtZXJpY2FsbHkgZml0LlxyXG4gICAgICAgICAgICAgICAgaWYgKGQuTGVuZ3RoU3F1YXJlZCgpIDwgU2V0dGluZ3MuRXBzaWxvbiAqIFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbiBpcyBwcm9iYWJseSBjb250YWluZWQgYnkgYSBsaW5lIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBvciB0cmlhbmdsZS4gVGh1cyB0aGUgc2hhcGVzIGFyZSBvdmVybGFwcGVkLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCByZXR1cm4gemVybyBoZXJlIGV2ZW4gdGhvdWdoIHRoZXJlIG1heSBiZSBvdmVybGFwLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIHNpbXBsZXggaXMgYSBwb2ludCwgc2VnbWVudCwgb3IgdHJpYW5nbGUgaXQgaXMgZGlmZmljdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIGlmIHRoZSBvcmlnaW4gaXMgY29udGFpbmVkIGluIHRoZSBDU08gb3IgdmVyeSBjbG9zZSB0byBpdC5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGEgdGVudGF0aXZlIG5ldyBzaW1wbGV4IHZlcnRleCB1c2luZyBzdXBwb3J0IHBvaW50cy5cclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdmVydGV4ID0gc2ltcGxleC5WW3NpbXBsZXguQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4LkluZGV4QSA9IGlucHV0LlByb3h5QS5HZXRTdXBwb3J0KE1hdGhVdGlscy5NdWx0aXBseVQocmVmIGlucHV0LlRyYW5zZm9ybUEuUiwgLWQpKTtcclxuICAgICAgICAgICAgICAgIHZlcnRleC5XQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgaW5wdXQuVHJhbnNmb3JtQSwgaW5wdXQuUHJveHlBLlZlcnRpY2VzW3ZlcnRleC5JbmRleEFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXguSW5kZXhCID0gaW5wdXQuUHJveHlCLkdldFN1cHBvcnQoTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgaW5wdXQuVHJhbnNmb3JtQi5SLCBkKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXguV0IgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIGlucHV0LlRyYW5zZm9ybUIsIGlucHV0LlByb3h5Qi5WZXJ0aWNlc1t2ZXJ0ZXguSW5kZXhCXSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXguVyA9IHZlcnRleC5XQiAtIHZlcnRleC5XQTtcclxuICAgICAgICAgICAgICAgIHNpbXBsZXguVltzaW1wbGV4LkNvdW50XSA9IHZlcnRleDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb24gY291bnQgaXMgZXF1YXRlZCB0byB0aGUgbnVtYmVyIG9mIHN1cHBvcnQgcG9pbnQgY2FsbHMuXHJcbiAgICAgICAgICAgICAgICArK2l0ZXI7XHJcbiAgICAgICAgICAgICAgICArK0dKS0l0ZXJzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgc3VwcG9ydCBwb2ludHMuIFRoaXMgaXMgdGhlIG1haW4gdGVybWluYXRpb24gY3JpdGVyaWEuXHJcbiAgICAgICAgICAgICAgICBib29sIGR1cGxpY2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzYXZlQ291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4LkluZGV4QSA9PSBzYXZlQVtpXSAmJiB2ZXJ0ZXguSW5kZXhCID09IHNhdmVCW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZHVwbGljYXRlIHN1cHBvcnQgcG9pbnQgd2UgbXVzdCBleGl0IHRvIGF2b2lkIGN5Y2xpbmcuXHJcbiAgICAgICAgICAgICAgICBpZiAoZHVwbGljYXRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5ldyB2ZXJ0ZXggaXMgb2sgYW5kIG5lZWRlZC5cclxuICAgICAgICAgICAgICAgICsrc2ltcGxleC5Db3VudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgR0pLTWF4SXRlcnMgPSBNYXRoLk1heChHSktNYXhJdGVycywgaXRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVwYXJlIG91dHB1dC5cclxuICAgICAgICAgICAgc2ltcGxleC5HZXRXaXRuZXNzUG9pbnRzKG91dCBvdXRwdXQuUG9pbnRBLCBvdXQgb3V0cHV0LlBvaW50Qik7XHJcbiAgICAgICAgICAgIG91dHB1dC5EaXN0YW5jZSA9IChvdXRwdXQuUG9pbnRBIC0gb3V0cHV0LlBvaW50QikuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5JdGVyYXRpb25zID0gaXRlcjtcclxuXHJcbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSBzaW1wbGV4LlxyXG4gICAgICAgICAgICBzaW1wbGV4LldyaXRlQ2FjaGUocmVmIGNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHJhZGlpIGlmIHJlcXVlc3RlZC5cclxuICAgICAgICAgICAgaWYgKGlucHV0LlVzZVJhZGlpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByQSA9IGlucHV0LlByb3h5QS5SYWRpdXM7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByQiA9IGlucHV0LlByb3h5Qi5SYWRpdXM7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5EaXN0YW5jZSA+IHJBICsgckIgJiYgb3V0cHV0LkRpc3RhbmNlID4gU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaGFwZXMgYXJlIHN0aWxsIG5vIG92ZXJsYXBwZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgd2l0bmVzcyBwb2ludHMgdG8gdGhlIG91dGVyIHN1cmZhY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LkRpc3RhbmNlIC09IHJBICsgckI7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBub3JtYWwgPSBvdXRwdXQuUG9pbnRCIC0gb3V0cHV0LlBvaW50QTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWwuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlBvaW50QSArPSByQSAqIG5vcm1hbDtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuUG9pbnRCIC09IHJCICogbm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNoYXBlcyBhcmUgb3ZlcmxhcHBlZCB3aGVuIHJhZGlpIGFyZSBjb25zaWRlcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHdpdG5lc3MgcG9pbnRzIHRvIHRoZSBtaWRkbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwID0gMC41ZiAqIChvdXRwdXQuUG9pbnRBICsgb3V0cHV0LlBvaW50Qik7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlBvaW50QSA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlBvaW50QiA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LkRpc3RhbmNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvblxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBub2RlIGluIHRoZSBkeW5hbWljIHRyZWUuIFRoZSBjbGllbnQgZG9lcyBub3QgaW50ZXJhY3Qgd2l0aCB0aGlzIGRpcmVjdGx5LlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIGludGVybmFsIHN0cnVjdCBEeW5hbWljVHJlZU5vZGU8VD5cclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgaXMgdGhlIGZhdHRlbmVkIEFBQkIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBpbnRlcm5hbCBBQUJCIEFBQkI7XHJcblxyXG4gICAgICAgIGludGVybmFsIGludCBDaGlsZDE7XHJcbiAgICAgICAgaW50ZXJuYWwgaW50IENoaWxkMjtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgaW50IExlYWZDb3VudDtcclxuICAgICAgICBpbnRlcm5hbCBpbnQgUGFyZW50T3JOZXh0O1xyXG4gICAgICAgIGludGVybmFsIFQgVXNlckRhdGE7XHJcblxyXG4gICAgICAgIGludGVybmFsIGJvb2wgSXNMZWFmKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDaGlsZDEgPT0gRHluYW1pY1RyZWU8VD4uTnVsbE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIGR5bmFtaWMgdHJlZSBhcnJhbmdlcyBkYXRhIGluIGEgYmluYXJ5IHRyZWUgdG8gYWNjZWxlcmF0ZVxyXG4gICAgLy8vIHF1ZXJpZXMgc3VjaCBhcyB2b2x1bWUgcXVlcmllcyBhbmQgcmF5IGNhc3RzLiBMZWFmcyBhcmUgcHJveGllc1xyXG4gICAgLy8vIHdpdGggYW4gQUFCQi4gSW4gdGhlIHRyZWUgd2UgZXhwYW5kIHRoZSBwcm94eSBBQUJCIGJ5IFNldHRpbmdzLmIyX2ZhdEFBQkJGYWN0b3JcclxuICAgIC8vLyBzbyB0aGF0IHRoZSBwcm94eSBBQUJCIGlzIGJpZ2dlciB0aGFuIHRoZSBjbGllbnQgb2JqZWN0LiBUaGlzIGFsbG93cyB0aGUgY2xpZW50XHJcbiAgICAvLy8gb2JqZWN0IHRvIG1vdmUgYnkgc21hbGwgYW1vdW50cyB3aXRob3V0IHRyaWdnZXJpbmcgYSB0cmVlIHVwZGF0ZS5cclxuICAgIC8vL1xyXG4gICAgLy8vIE5vZGVzIGFyZSBwb29sZWQgYW5kIHJlbG9jYXRhYmxlLCBzbyB3ZSB1c2Ugbm9kZSBpbmRpY2VzIHJhdGhlciB0aGFuIHBvaW50ZXJzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBEeW5hbWljVHJlZTxUPlxyXG4gICAge1xyXG4gICAgICAgIGludGVybmFsIGNvbnN0IGludCBOdWxsTm9kZSA9IC0xO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFN0YWNrPGludD4gX3N0YWNrID0gbmV3IFN0YWNrPGludD4oMjU2KTtcclxuICAgICAgICBwcml2YXRlIGludCBfZnJlZUxpc3Q7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX2luc2VydGlvbkNvdW50O1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9ub2RlQ2FwYWNpdHk7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX25vZGVDb3VudDtcclxuICAgICAgICBwcml2YXRlIER5bmFtaWNUcmVlTm9kZTxUPltdIF9ub2RlcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGlzIHVzZWQgaW5jcmVtZW50YWxseSB0cmF2ZXJzZSB0aGUgdHJlZSBmb3IgcmUtYmFsYW5jaW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX3BhdGg7XHJcblxyXG4gICAgICAgIHByaXZhdGUgaW50IF9yb290O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnN0cnVjdGluZyB0aGUgdHJlZSBpbml0aWFsaXplcyB0aGUgbm9kZSBwb29sLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIER5bmFtaWNUcmVlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9yb290ID0gTnVsbE5vZGU7XHJcblxyXG4gICAgICAgICAgICBfbm9kZUNhcGFjaXR5ID0gMTY7XHJcbiAgICAgICAgICAgIF9ub2RlcyA9IG5ldyBEeW5hbWljVHJlZU5vZGU8VD5bX25vZGVDYXBhY2l0eV07XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCBhIGxpbmtlZCBsaXN0IGZvciB0aGUgZnJlZSBsaXN0LlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9ub2RlQ2FwYWNpdHkgLSAxOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tpXS5QYXJlbnRPck5leHQgPSBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfbm9kZXNbX25vZGVDYXBhY2l0eSAtIDFdLlBhcmVudE9yTmV4dCA9IE51bGxOb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBwcm94eSBpbiB0aGUgdHJlZSBhcyBhIGxlYWYgbm9kZS4gV2UgcmV0dXJuIHRoZSBpbmRleFxyXG4gICAgICAgIC8vLyBvZiB0aGUgbm9kZSBpbnN0ZWFkIG9mIGEgcG9pbnRlciBzbyB0aGF0IHdlIGNhbiBncm93XHJcbiAgICAgICAgLy8vIHRoZSBub2RlIHBvb2wuICAgICAgICBcclxuICAgICAgICAvLy8gLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ1c2VyRGF0YVwiPlRoZSB1c2VyIGRhdGEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+SW5kZXggb2YgdGhlIGNyZWF0ZWQgcHJveHk8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGludCBBZGRQcm94eShyZWYgQUFCQiBhYWJiLCBUIHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IHByb3h5SWQgPSBBbGxvY2F0ZU5vZGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZhdHRlbiB0aGUgYWFiYi5cclxuICAgICAgICAgICAgVmVjdG9yMiByID0gbmV3IFZlY3RvcjIoU2V0dGluZ3MuQUFCQkV4dGVuc2lvbiwgU2V0dGluZ3MuQUFCQkV4dGVuc2lvbik7XHJcbiAgICAgICAgICAgIF9ub2Rlc1twcm94eUlkXS5BQUJCLkxvd2VyQm91bmQgPSBhYWJiLkxvd2VyQm91bmQgLSByO1xyXG4gICAgICAgICAgICBfbm9kZXNbcHJveHlJZF0uQUFCQi5VcHBlckJvdW5kID0gYWFiYi5VcHBlckJvdW5kICsgcjtcclxuICAgICAgICAgICAgX25vZGVzW3Byb3h5SWRdLlVzZXJEYXRhID0gdXNlckRhdGE7XHJcbiAgICAgICAgICAgIF9ub2Rlc1twcm94eUlkXS5MZWFmQ291bnQgPSAxO1xyXG5cclxuICAgICAgICAgICAgSW5zZXJ0TGVhZihwcm94eUlkKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwcm94eUlkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXN0cm95IGEgcHJveHkuIFRoaXMgYXNzZXJ0cyBpZiB0aGUgaWQgaXMgaW52YWxpZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3h5SWRcIj5UaGUgcHJveHkgaWQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVQcm94eShpbnQgcHJveHlJZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDw9IHByb3h5SWQgJiYgcHJveHlJZCA8IF9ub2RlQ2FwYWNpdHkpO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoX25vZGVzW3Byb3h5SWRdLklzTGVhZigpKTtcclxuXHJcbiAgICAgICAgICAgIFJlbW92ZUxlYWYocHJveHlJZCk7XHJcbiAgICAgICAgICAgIEZyZWVOb2RlKHByb3h5SWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNb3ZlIGEgcHJveHkgd2l0aCBhIHN3ZXB0ZWQgQUFCQi4gSWYgdGhlIHByb3h5IGhhcyBtb3ZlZCBvdXRzaWRlIG9mIGl0cyBmYXR0ZW5lZCBBQUJCLFxyXG4gICAgICAgIC8vLyB0aGVuIHRoZSBwcm94eSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUgYW5kIHJlLWluc2VydGVkLiBPdGhlcndpc2VcclxuICAgICAgICAvLy8gdGhlIGZ1bmN0aW9uIHJldHVybnMgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkXCI+VGhlIHByb3h5IGlkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGlzcGxhY2VtZW50XCI+VGhlIGRpc3BsYWNlbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz50cnVlIGlmIHRoZSBwcm94eSB3YXMgcmUtaW5zZXJ0ZWQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIE1vdmVQcm94eShpbnQgcHJveHlJZCwgcmVmIEFBQkIgYWFiYiwgVmVjdG9yMiBkaXNwbGFjZW1lbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBwcm94eUlkICYmIHByb3h5SWQgPCBfbm9kZUNhcGFjaXR5KTtcclxuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChfbm9kZXNbcHJveHlJZF0uSXNMZWFmKCkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9ub2Rlc1twcm94eUlkXS5BQUJCLkNvbnRhaW5zKHJlZiBhYWJiKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBSZW1vdmVMZWFmKHByb3h5SWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kIEFBQkIuXHJcbiAgICAgICAgICAgIEFBQkIgYiA9IGFhYmI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgciA9IG5ldyBWZWN0b3IyKFNldHRpbmdzLkFBQkJFeHRlbnNpb24sIFNldHRpbmdzLkFBQkJFeHRlbnNpb24pO1xyXG4gICAgICAgICAgICBiLkxvd2VyQm91bmQgPSBiLkxvd2VyQm91bmQgLSByO1xyXG4gICAgICAgICAgICBiLlVwcGVyQm91bmQgPSBiLlVwcGVyQm91bmQgKyByO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlZGljdCBBQUJCIGRpc3BsYWNlbWVudC5cclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gU2V0dGluZ3MuQUFCQk11bHRpcGxpZXIgKiBkaXNwbGFjZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoZC5YIDwgMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYi5Mb3dlckJvdW5kLlggKz0gZC5YO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYi5VcHBlckJvdW5kLlggKz0gZC5YO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZC5ZIDwgMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYi5Mb3dlckJvdW5kLlkgKz0gZC5ZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYi5VcHBlckJvdW5kLlkgKz0gZC5ZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfbm9kZXNbcHJveHlJZF0uQUFCQiA9IGI7XHJcblxyXG4gICAgICAgICAgICBJbnNlcnRMZWFmKHByb3h5SWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUGVyZm9ybSBzb21lIGl0ZXJhdGlvbnMgdG8gcmUtYmFsYW5jZSB0aGUgdHJlZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIml0ZXJhdGlvbnNcIj5UaGUgaXRlcmF0aW9ucy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlYmFsYW5jZShpbnQgaXRlcmF0aW9ucylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfcm9vdCA9PSBOdWxsTm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZWJhbGFuY2UgdGhlIHRyZWUgYnkgcmVtb3ZpbmcgYW5kIHJlLWluc2VydGluZyBsZWF2ZXMuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgbm9kZSA9IF9yb290O1xyXG5cclxuICAgICAgICAgICAgICAgIGludCBiaXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKF9ub2Rlc1tub2RlXS5Jc0xlYWYoKSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGlsZCBzZWxlY3RvciBiYXNlZCBvbiBhIGJpdCBpbiB0aGUgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIGludCBzZWxlY3RvciA9IChfcGF0aCA+PiBiaXQpICYgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBjaGlsZCBub2RcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gKHNlbGVjdG9yID09IDApID8gX25vZGVzW25vZGVdLkNoaWxkMSA6IF9ub2Rlc1tub2RlXS5DaGlsZDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgYml0IGJldHdlZW4gMCBhbmQgMzEgYmVjYXVzZSBfcGF0aCBoYXMgMzIgYml0c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdCA9IChiaXQgKyAxKSAlIDMxXHJcbiAgICAgICAgICAgICAgICAgICAgYml0ID0gKGJpdCArIDEpICYgMHgxRjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICsrX3BhdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgUmVtb3ZlTGVhZihub2RlKTtcclxuICAgICAgICAgICAgICAgIEluc2VydExlYWYobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHByb3h5IHVzZXIgZGF0YS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dHlwZXBhcmFtIG5hbWU9XCJUXCI+PC90eXBlcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicHJveHlJZFwiPlRoZSBwcm94eSBpZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz50aGUgcHJveHkgdXNlciBkYXRhIG9yIDAgaWYgdGhlIGlkIGlzIGludmFsaWQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBUIEdldFVzZXJEYXRhKGludCBwcm94eUlkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gcHJveHlJZCAmJiBwcm94eUlkIDwgX25vZGVDYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfbm9kZXNbcHJveHlJZF0uVXNlckRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgZmF0IEFBQkIgZm9yIGEgcHJveHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkXCI+VGhlIHByb3h5IGlkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZmF0QUFCQlwiPlRoZSBmYXQgQUFCQi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEdldEZhdEFBQkIoaW50IHByb3h5SWQsIG91dCBBQUJCIGZhdEFBQkIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBwcm94eUlkICYmIHByb3h5SWQgPCBfbm9kZUNhcGFjaXR5KTtcclxuICAgICAgICAgICAgZmF0QUFCQiA9IF9ub2Rlc1twcm94eUlkXS5BQUJCO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlIHRoZSBoZWlnaHQgb2YgdGhlIGJpbmFyeSB0cmVlIGluIE8oTikgdGltZS4gU2hvdWxkIG5vdCBiZVxyXG4gICAgICAgIC8vLyBjYWxsZWQgb2Z0ZW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgQ29tcHV0ZUhlaWdodCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29tcHV0ZUhlaWdodChfcm9vdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFF1ZXJ5IGFuIEFBQkIgZm9yIG92ZXJsYXBwaW5nIHByb3hpZXMuIFRoZSBjYWxsYmFjayBjbGFzc1xyXG4gICAgICAgIC8vLyBpcyBjYWxsZWQgZm9yIGVhY2ggcHJveHkgdGhhdCBvdmVybGFwcyB0aGUgc3VwcGxpZWQgQUFCQi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhbGxiYWNrXCI+VGhlIGNhbGxiYWNrLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUXVlcnkoRnVuYzxpbnQsIGJvb2w+IGNhbGxiYWNrLCByZWYgQUFCQiBhYWJiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3N0YWNrLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIF9zdGFjay5QdXNoKF9yb290KTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChfc3RhY2suQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgbm9kZUlkID0gX3N0YWNrLlBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVJZCA9PSBOdWxsTm9kZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBEeW5hbWljVHJlZU5vZGU8VD4gbm9kZSA9IF9ub2Rlc1tub2RlSWRdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChBQUJCLlRlc3RPdmVybGFwKHJlZiBub2RlLkFBQkIsIHJlZiBhYWJiKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5Jc0xlYWYoKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgcHJvY2VlZCA9IGNhbGxiYWNrKG5vZGVJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZWVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YWNrLlB1c2gobm9kZS5DaGlsZDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhY2suUHVzaChub2RlLkNoaWxkMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJheS1jYXN0IGFnYWluc3QgdGhlIHByb3hpZXMgaW4gdGhlIHRyZWUuIFRoaXMgcmVsaWVzIG9uIHRoZSBjYWxsYmFja1xyXG4gICAgICAgIC8vLyB0byBwZXJmb3JtIGEgZXhhY3QgcmF5LWNhc3QgaW4gdGhlIGNhc2Ugd2VyZSB0aGUgcHJveHkgY29udGFpbnMgYSBTaGFwZS5cclxuICAgICAgICAvLy8gVGhlIGNhbGxiYWNrIGFsc28gcGVyZm9ybXMgdGhlIGFueSBjb2xsaXNpb24gZmlsdGVyaW5nLiBUaGlzIGhhcyBwZXJmb3JtYW5jZVxyXG4gICAgICAgIC8vLyByb3VnaGx5IGVxdWFsIHRvIGsgKiBsb2cobiksIHdoZXJlIGsgaXMgdGhlIG51bWJlciBvZiBjb2xsaXNpb25zIGFuZCBuIGlzIHRoZVxyXG4gICAgICAgIC8vLyBudW1iZXIgb2YgcHJveGllcyBpbiB0aGUgdHJlZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhbGxiYWNrXCI+QSBjYWxsYmFjayBjbGFzcyB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCBwcm94eSB0aGF0IGlzIGhpdCBieSB0aGUgcmF5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmF5LWNhc3QgaW5wdXQgZGF0YS4gVGhlIHJheSBleHRlbmRzIGZyb20gcDEgdG8gcDEgKyBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJheUNhc3QoRnVuYzxSYXlDYXN0SW5wdXQsIGludCwgZmxvYXQ+IGNhbGxiYWNrLCByZWYgUmF5Q2FzdElucHV0IGlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBwMSA9IGlucHV0LlBvaW50MTtcclxuICAgICAgICAgICAgVmVjdG9yMiBwMiA9IGlucHV0LlBvaW50MjtcclxuICAgICAgICAgICAgVmVjdG9yMiByID0gcDIgLSBwMTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHIuTGVuZ3RoU3F1YXJlZCgpID4gMC4wZik7XHJcbiAgICAgICAgICAgIHIuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAvLyB2IGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgYWJzViA9IE1hdGhVdGlscy5BYnMobmV3IFZlY3RvcjIoLXIuWSwgci5YKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXBhcmF0aW5nIGF4aXMgZm9yIHNlZ21lbnQgKEdpbm8sIHA4MCkuXHJcbiAgICAgICAgICAgIC8vIHxkb3QodiwgcDEgLSBjKXwgPiBkb3QofHZ8LCBoKVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgbWF4RnJhY3Rpb24gPSBpbnB1dC5NYXhGcmFjdGlvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgYm91bmRpbmcgYm94IGZvciB0aGUgc2VnbWVudC5cclxuICAgICAgICAgICAgQUFCQiBzZWdtZW50QUFCQiA9IG5ldyBBQUJCKCk7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdCA9IHAxICsgbWF4RnJhY3Rpb24gKiAocDIgLSBwMSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyLk1pbihyZWYgcDEsIHJlZiB0LCBvdXQgc2VnbWVudEFBQkIuTG93ZXJCb3VuZCk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyLk1heChyZWYgcDEsIHJlZiB0LCBvdXQgc2VnbWVudEFBQkIuVXBwZXJCb3VuZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9zdGFjay5DbGVhcigpO1xyXG4gICAgICAgICAgICBfc3RhY2suUHVzaChfcm9vdCk7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoX3N0YWNrLkNvdW50ID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IG5vZGVJZCA9IF9zdGFjay5Qb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlSWQgPT0gTnVsbE5vZGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgRHluYW1pY1RyZWVOb2RlPFQ+IG5vZGUgPSBfbm9kZXNbbm9kZUlkXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQUFCQi5UZXN0T3ZlcmxhcChyZWYgbm9kZS5BQUJCLCByZWYgc2VnbWVudEFBQkIpID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlcGFyYXRpbmcgYXhpcyBmb3Igc2VnbWVudCAoR2lubywgcDgwKS5cclxuICAgICAgICAgICAgICAgIC8vIHxkb3QodiwgcDEgLSBjKXwgPiBkb3QofHZ8LCBoKVxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBjID0gbm9kZS5BQUJCLkNlbnRlcjtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaCA9IG5vZGUuQUFCQi5FeHRlbnRzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IChmbG9hdClNYXRoLkFicyhWZWN0b3IyLkRvdChuZXcgVmVjdG9yMigtci5ZLCByLlgpLCBwMSAtIGMpKSAtIFZlY3RvcjIuRG90KGFic1YsIGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChub2RlLklzTGVhZigpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFJheUNhc3RJbnB1dCBzdWJJbnB1dDtcclxuICAgICAgICAgICAgICAgICAgICBzdWJJbnB1dC5Qb2ludDEgPSBpbnB1dC5Qb2ludDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViSW5wdXQuUG9pbnQyID0gaW5wdXQuUG9pbnQyO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YklucHV0Lk1heEZyYWN0aW9uID0gbWF4RnJhY3Rpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gY2FsbGJhY2soc3ViSW5wdXQsIG5vZGVJZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNsaWVudCBoYXMgdGVybWluYXRlZCB0aGUgcmF5Y2FzdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzZWdtZW50IGJvdW5kaW5nIGJveC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RnJhY3Rpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB0ID0gcDEgKyBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudEFBQkIuTG93ZXJCb3VuZCA9IFZlY3RvcjIuTWluKHAxLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudEFBQkIuVXBwZXJCb3VuZCA9IFZlY3RvcjIuTWF4KHAxLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N0YWNrLlB1c2gobm9kZS5DaGlsZDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdGFjay5QdXNoKG5vZGUuQ2hpbGQyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgQ291bnRMZWF2ZXMoaW50IG5vZGVJZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChub2RlSWQgPT0gTnVsbE5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBub2RlSWQgJiYgbm9kZUlkIDwgX25vZGVDYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIER5bmFtaWNUcmVlTm9kZTxUPiBub2RlID0gX25vZGVzW25vZGVJZF07XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZS5Jc0xlYWYoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG5vZGUuTGVhZkNvdW50ID09IDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCBjb3VudDEgPSBDb3VudExlYXZlcyhub2RlLkNoaWxkMSk7XHJcbiAgICAgICAgICAgIGludCBjb3VudDIgPSBDb3VudExlYXZlcyhub2RlLkNoaWxkMik7XHJcbiAgICAgICAgICAgIGludCBjb3VudCA9IGNvdW50MSArIGNvdW50MjtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGNvdW50ID09IG5vZGUuTGVhZkNvdW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFZhbGlkYXRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvdW50TGVhdmVzKF9yb290KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgaW50IEFsbG9jYXRlTm9kZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBFeHBhbmQgdGhlIG5vZGUgcG9vbCBhcyBuZWVkZWQuXHJcbiAgICAgICAgICAgIGlmIChfZnJlZUxpc3QgPT0gTnVsbE5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChfbm9kZUNvdW50ID09IF9ub2RlQ2FwYWNpdHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBmcmVlIGxpc3QgaXMgZW1wdHkuIFJlYnVpbGQgYSBiaWdnZXIgcG9vbC5cclxuICAgICAgICAgICAgICAgIER5bmFtaWNUcmVlTm9kZTxUPltdIG9sZE5vZGVzID0gX25vZGVzO1xyXG4gICAgICAgICAgICAgICAgX25vZGVDYXBhY2l0eSAqPSAyO1xyXG4gICAgICAgICAgICAgICAgX25vZGVzID0gbmV3IER5bmFtaWNUcmVlTm9kZTxUPltfbm9kZUNhcGFjaXR5XTtcclxuICAgICAgICAgICAgICAgIEFycmF5LkNvcHkob2xkTm9kZXMsIF9ub2RlcywgX25vZGVDb3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBsaW5rZWQgbGlzdCBmb3IgdGhlIGZyZWUgbGlzdC4gVGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgLy8gcG9pbnRlciBiZWNvbWVzIHRoZSBcIm5leHRcIiBwb2ludGVyLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IF9ub2RlQ291bnQ7IGkgPCBfbm9kZUNhcGFjaXR5IC0gMTsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9ub2Rlc1tpXS5QYXJlbnRPck5leHQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tfbm9kZUNhcGFjaXR5IC0gMV0uUGFyZW50T3JOZXh0ID0gTnVsbE5vZGU7XHJcbiAgICAgICAgICAgICAgICBfZnJlZUxpc3QgPSBfbm9kZUNvdW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQZWVsIGEgbm9kZSBvZmYgdGhlIGZyZWUgbGlzdC5cclxuICAgICAgICAgICAgaW50IG5vZGVJZCA9IF9mcmVlTGlzdDtcclxuICAgICAgICAgICAgX2ZyZWVMaXN0ID0gX25vZGVzW25vZGVJZF0uUGFyZW50T3JOZXh0O1xyXG4gICAgICAgICAgICBfbm9kZXNbbm9kZUlkXS5QYXJlbnRPck5leHQgPSBOdWxsTm9kZTtcclxuICAgICAgICAgICAgX25vZGVzW25vZGVJZF0uQ2hpbGQxID0gTnVsbE5vZGU7XHJcbiAgICAgICAgICAgIF9ub2Rlc1tub2RlSWRdLkNoaWxkMiA9IE51bGxOb2RlO1xyXG4gICAgICAgICAgICBfbm9kZXNbbm9kZUlkXS5MZWFmQ291bnQgPSAwO1xyXG4gICAgICAgICAgICArK19ub2RlQ291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlSWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgRnJlZU5vZGUoaW50IG5vZGVJZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDw9IG5vZGVJZCAmJiBub2RlSWQgPCBfbm9kZUNhcGFjaXR5KTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPCBfbm9kZUNvdW50KTtcclxuICAgICAgICAgICAgX25vZGVzW25vZGVJZF0uUGFyZW50T3JOZXh0ID0gX2ZyZWVMaXN0O1xyXG4gICAgICAgICAgICBfZnJlZUxpc3QgPSBub2RlSWQ7XHJcbiAgICAgICAgICAgIC0tX25vZGVDb3VudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBJbnNlcnRMZWFmKGludCBsZWFmKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgKytfaW5zZXJ0aW9uQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3Jvb3QgPT0gTnVsbE5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9yb290ID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tfcm9vdF0uUGFyZW50T3JOZXh0ID0gTnVsbE5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGJlc3Qgc2libGluZyBmb3IgdGhpcyBub2RlXHJcbiAgICAgICAgICAgIEFBQkIgbGVhZkFBQkIgPSBfbm9kZXNbbGVhZl0uQUFCQjtcclxuICAgICAgICAgICAgaW50IHNpYmxpbmcgPSBfcm9vdDtcclxuICAgICAgICAgICAgd2hpbGUgKF9ub2Rlc1tzaWJsaW5nXS5Jc0xlYWYoKSA9PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGNoaWxkMSA9IF9ub2Rlc1tzaWJsaW5nXS5DaGlsZDE7XHJcbiAgICAgICAgICAgICAgICBpbnQgY2hpbGQyID0gX25vZGVzW3NpYmxpbmddLkNoaWxkMjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgdGhlIG5vZGUncyBBQUJCLlxyXG4gICAgICAgICAgICAgICAgX25vZGVzW3NpYmxpbmddLkFBQkIuQ29tYmluZShyZWYgbGVhZkFBQkIpO1xyXG4gICAgICAgICAgICAgICAgX25vZGVzW3NpYmxpbmddLkxlYWZDb3VudCArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHNpYmxpbmdBcmVhID0gX25vZGVzW3NpYmxpbmddLkFBQkIuUGVyaW1ldGVyO1xyXG4gICAgICAgICAgICAgICAgQUFCQiBwYXJlbnRBQUJCID0gbmV3IEFBQkIoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudEFBQkIuQ29tYmluZShyZWYgX25vZGVzW3NpYmxpbmddLkFBQkIsIHJlZiBsZWFmQUFCQik7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBwYXJlbnRBcmVhID0gcGFyZW50QUFCQi5QZXJpbWV0ZXI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBjb3N0MSA9IDIuMGYgKiBwYXJlbnRBcmVhO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGluaGVyaXRhbmNlQ29zdCA9IDIuMGYgKiAocGFyZW50QXJlYSAtIHNpYmxpbmdBcmVhKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBjb3N0MjtcclxuICAgICAgICAgICAgICAgIGlmIChfbm9kZXNbY2hpbGQxXS5Jc0xlYWYoKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBBQUJCIGFhYmIgPSBuZXcgQUFCQigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFhYmIuQ29tYmluZShyZWYgbGVhZkFBQkIsIHJlZiBfbm9kZXNbY2hpbGQxXS5BQUJCKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3N0MiA9IGFhYmIuUGVyaW1ldGVyICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEFBQkIgYWFiYiA9IG5ldyBBQUJCKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWFiYi5Db21iaW5lKHJlZiBsZWFmQUFCQiwgcmVmIF9ub2Rlc1tjaGlsZDFdLkFBQkIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG9sZEFyZWEgPSBfbm9kZXNbY2hpbGQxXS5BQUJCLlBlcmltZXRlcjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXdBcmVhID0gYWFiYi5QZXJpbWV0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29zdDIgPSAobmV3QXJlYSAtIG9sZEFyZWEpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGNvc3QzO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9ub2Rlc1tjaGlsZDJdLklzTGVhZigpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEFBQkIgYWFiYiA9IG5ldyBBQUJCKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWFiYi5Db21iaW5lKHJlZiBsZWFmQUFCQiwgcmVmIF9ub2Rlc1tjaGlsZDJdLkFBQkIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvc3QzID0gYWFiYi5QZXJpbWV0ZXIgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQUFCQiBhYWJiID0gbmV3IEFBQkIoKTtcclxuICAgICAgICAgICAgICAgICAgICBhYWJiLkNvbWJpbmUocmVmIGxlYWZBQUJCLCByZWYgX25vZGVzW2NoaWxkMl0uQUFCQik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgb2xkQXJlYSA9IF9ub2Rlc1tjaGlsZDJdLkFBQkIuUGVyaW1ldGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ld0FyZWEgPSBhYWJiLlBlcmltZXRlcjtcclxuICAgICAgICAgICAgICAgICAgICBjb3N0MyA9IG5ld0FyZWEgLSBvbGRBcmVhICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgYWNjb3JkaW5nIHRvIHRoZSBtaW5pbXVtIGNvc3QuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29zdDEgPCBjb3N0MiAmJiBjb3N0MSA8IGNvc3QzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgbm9kZSdzIEFBQkIgdG8gYWNjb3VudCBmb3IgdGhlIG5ldyBsZWFmLlxyXG4gICAgICAgICAgICAgICAgX25vZGVzW3NpYmxpbmddLkFBQkIuQ29tYmluZShyZWYgbGVhZkFBQkIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlc2NlbmRcclxuICAgICAgICAgICAgICAgIGlmIChjb3N0MiA8IGNvc3QzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBjaGlsZDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2libGluZyA9IGNoaWxkMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhcmVudCBmb3IgdGhlIHNpYmxpbmdzLlxyXG4gICAgICAgICAgICBpbnQgb2xkUGFyZW50ID0gX25vZGVzW3NpYmxpbmddLlBhcmVudE9yTmV4dDtcclxuICAgICAgICAgICAgaW50IG5ld1BhcmVudCA9IEFsbG9jYXRlTm9kZSgpO1xyXG4gICAgICAgICAgICBfbm9kZXNbbmV3UGFyZW50XS5QYXJlbnRPck5leHQgPSBvbGRQYXJlbnQ7XHJcbiAgICAgICAgICAgIF9ub2Rlc1tuZXdQYXJlbnRdLlVzZXJEYXRhID0gZGVmYXVsdChUKTtcclxuICAgICAgICAgICAgX25vZGVzW25ld1BhcmVudF0uQUFCQi5Db21iaW5lKHJlZiBsZWFmQUFCQiwgcmVmIF9ub2Rlc1tzaWJsaW5nXS5BQUJCKTtcclxuICAgICAgICAgICAgX25vZGVzW25ld1BhcmVudF0uTGVhZkNvdW50ID0gX25vZGVzW3NpYmxpbmddLkxlYWZDb3VudCArIDE7XHJcblxyXG4gICAgICAgICAgICBpZiAob2xkUGFyZW50ICE9IE51bGxOb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyB3YXMgbm90IHRoZSByb290LlxyXG4gICAgICAgICAgICAgICAgaWYgKF9ub2Rlc1tvbGRQYXJlbnRdLkNoaWxkMSA9PSBzaWJsaW5nKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9ub2Rlc1tvbGRQYXJlbnRdLkNoaWxkMSA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbm9kZXNbb2xkUGFyZW50XS5DaGlsZDIgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgX25vZGVzW25ld1BhcmVudF0uQ2hpbGQxID0gc2libGluZztcclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tuZXdQYXJlbnRdLkNoaWxkMiA9IGxlYWY7XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbc2libGluZ10uUGFyZW50T3JOZXh0ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgX25vZGVzW2xlYWZdLlBhcmVudE9yTmV4dCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIHdhcyB0aGUgcm9vdC5cclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tuZXdQYXJlbnRdLkNoaWxkMSA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbbmV3UGFyZW50XS5DaGlsZDIgPSBsZWFmO1xyXG4gICAgICAgICAgICAgICAgX25vZGVzW3NpYmxpbmddLlBhcmVudE9yTmV4dCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tsZWFmXS5QYXJlbnRPck5leHQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBfcm9vdCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFJlbW92ZUxlYWYoaW50IGxlYWYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobGVhZiA9PSBfcm9vdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3Jvb3QgPSBOdWxsTm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50IHBhcmVudCA9IF9ub2Rlc1tsZWFmXS5QYXJlbnRPck5leHQ7XHJcbiAgICAgICAgICAgIGludCBncmFuZFBhcmVudCA9IF9ub2Rlc1twYXJlbnRdLlBhcmVudE9yTmV4dDtcclxuICAgICAgICAgICAgaW50IHNpYmxpbmc7XHJcbiAgICAgICAgICAgIGlmIChfbm9kZXNbcGFyZW50XS5DaGlsZDEgPT0gbGVhZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2libGluZyA9IF9ub2Rlc1twYXJlbnRdLkNoaWxkMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBfbm9kZXNbcGFyZW50XS5DaGlsZDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChncmFuZFBhcmVudCAhPSBOdWxsTm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRGVzdHJveSBwYXJlbnQgYW5kIGNvbm5lY3Qgc2libGluZyB0byBncmFuZFBhcmVudC5cclxuICAgICAgICAgICAgICAgIGlmIChfbm9kZXNbZ3JhbmRQYXJlbnRdLkNoaWxkMSA9PSBwYXJlbnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX25vZGVzW2dyYW5kUGFyZW50XS5DaGlsZDEgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9ub2Rlc1tncmFuZFBhcmVudF0uQ2hpbGQyID0gc2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tzaWJsaW5nXS5QYXJlbnRPck5leHQgPSBncmFuZFBhcmVudDtcclxuICAgICAgICAgICAgICAgIEZyZWVOb2RlKHBhcmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IGFuY2VzdG9yIGJvdW5kcy5cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGdyYW5kUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCAhPSBOdWxsTm9kZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbm9kZXNbcGFyZW50XS5BQUJCLkNvbWJpbmUocmVmIF9ub2Rlc1tfbm9kZXNbcGFyZW50XS5DaGlsZDFdLkFBQkIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBfbm9kZXNbX25vZGVzW3BhcmVudF0uQ2hpbGQyXS5BQUJCKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KF9ub2Rlc1twYXJlbnRdLkxlYWZDb3VudCA+IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIF9ub2Rlc1twYXJlbnRdLkxlYWZDb3VudCAtPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBfbm9kZXNbcGFyZW50XS5QYXJlbnRPck5leHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfcm9vdCA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbc2libGluZ10uUGFyZW50T3JOZXh0ID0gTnVsbE5vZGU7XHJcbiAgICAgICAgICAgICAgICBGcmVlTm9kZShwYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGludCBDb21wdXRlSGVpZ2h0KGludCBub2RlSWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobm9kZUlkID09IE51bGxOb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gbm9kZUlkICYmIG5vZGVJZCA8IF9ub2RlQ2FwYWNpdHkpO1xyXG4gICAgICAgICAgICBEeW5hbWljVHJlZU5vZGU8VD4gbm9kZSA9IF9ub2Rlc1tub2RlSWRdO1xyXG4gICAgICAgICAgICBpbnQgaGVpZ2h0MSA9IENvbXB1dGVIZWlnaHQobm9kZS5DaGlsZDEpO1xyXG4gICAgICAgICAgICBpbnQgaGVpZ2h0MiA9IENvbXB1dGVIZWlnaHQobm9kZS5DaGlsZDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gMSArIE1hdGguTWF4KGhlaWdodDEsIGhlaWdodDIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uXHJcbntcclxuICAgIGludGVybmFsIHN0cnVjdCBQYWlyIDogSUNvbXBhcmFibGU8UGFpcj5cclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgaW50IFByb3h5SWRBO1xyXG4gICAgICAgIHB1YmxpYyBpbnQgUHJveHlJZEI7XHJcblxyXG4gICAgICAgICNyZWdpb24gSUNvbXBhcmFibGU8UGFpcj4gTWVtYmVyc1xyXG5cclxuICAgICAgICBwdWJsaWMgaW50IENvbXBhcmVUbyhQYWlyIG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFByb3h5SWRBIDwgb3RoZXIuUHJveHlJZEEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoUHJveHlJZEEgPT0gb3RoZXIuUHJveHlJZEEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChQcm94eUlkQiA8IG90aGVyLlByb3h5SWRCKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChQcm94eUlkQiA9PSBvdGhlci5Qcm94eUlkQilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoZSBicm9hZC1waGFzZSBpcyB1c2VkIGZvciBjb21wdXRpbmcgcGFpcnMgYW5kIHBlcmZvcm1pbmcgdm9sdW1lIHF1ZXJpZXMgYW5kIHJheSBjYXN0cy5cclxuICAgIC8vLyBUaGlzIGJyb2FkLXBoYXNlIGRvZXMgbm90IHBlcnNpc3QgcGFpcnMuIEluc3RlYWQsIHRoaXMgcmVwb3J0cyBwb3RlbnRpYWxseSBuZXcgcGFpcnMuXHJcbiAgICAvLy8gSXQgaXMgdXAgdG8gdGhlIGNsaWVudCB0byBjb25zdW1lIHRoZSBuZXcgcGFpcnMgYW5kIHRvIHRyYWNrIHN1YnNlcXVlbnQgb3ZlcmxhcC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRHluYW1pY1RyZWVCcm9hZFBoYXNlIDogSUJyb2FkUGhhc2VcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIGludFtdIF9tb3ZlQnVmZmVyO1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9tb3ZlQ2FwYWNpdHk7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX21vdmVDb3VudDtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBQYWlyW10gX3BhaXJCdWZmZXI7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX3BhaXJDYXBhY2l0eTtcclxuICAgICAgICBwcml2YXRlIGludCBfcGFpckNvdW50O1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9wcm94eUNvdW50O1xyXG4gICAgICAgIHByaXZhdGUgRnVuYzxpbnQsIGJvb2w+IF9xdWVyeUNhbGxiYWNrO1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9xdWVyeVByb3h5SWQ7XHJcbiAgICAgICAgcHJpdmF0ZSBEeW5hbWljVHJlZTxGaXh0dXJlUHJveHk+IF90cmVlID0gbmV3IER5bmFtaWNUcmVlPEZpeHR1cmVQcm94eT4oKTtcclxuXHJcbiAgICAgICAgcHVibGljIER5bmFtaWNUcmVlQnJvYWRQaGFzZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfcXVlcnlDYWxsYmFjayA9IG5ldyBGdW5jPGludCwgYm9vbD4oUXVlcnlDYWxsYmFjayk7XHJcblxyXG4gICAgICAgICAgICBfcGFpckNhcGFjaXR5ID0gMTY7XHJcbiAgICAgICAgICAgIF9wYWlyQnVmZmVyID0gbmV3IFBhaXJbX3BhaXJDYXBhY2l0eV07XHJcblxyXG4gICAgICAgICAgICBfbW92ZUNhcGFjaXR5ID0gMTY7XHJcbiAgICAgICAgICAgIF9tb3ZlQnVmZmVyID0gbmV3IGludFtfbW92ZUNhcGFjaXR5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gSUJyb2FkUGhhc2UgTWVtYmVyc1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgbnVtYmVyIG9mIHByb3hpZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBwcm94eSBjb3VudC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgUHJveHlDb3VudFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9wcm94eUNvdW50OyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIHByb3h5IHdpdGggYW4gaW5pdGlhbCBBQUJCLiBQYWlycyBhcmUgbm90IHJlcG9ydGVkIHVudGlsXHJcbiAgICAgICAgLy8vIFVwZGF0ZVBhaXJzIGlzIGNhbGxlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgYWFiYi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3h5XCI+VGhlIHVzZXIgZGF0YS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGludCBBZGRQcm94eShyZWYgRml4dHVyZVByb3h5IHByb3h5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IHByb3h5SWQgPSBfdHJlZS5BZGRQcm94eShyZWYgcHJveHkuQUFCQiwgcHJveHkpO1xyXG4gICAgICAgICAgICArK19wcm94eUNvdW50O1xyXG4gICAgICAgICAgICBCdWZmZXJNb3ZlKHByb3h5SWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJveHlJZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVzdHJveSBhIHByb3h5LiBJdCBpcyB1cCB0byB0aGUgY2xpZW50IHRvIHJlbW92ZSBhbnkgcGFpcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkXCI+VGhlIHByb3h5IGlkLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlUHJveHkoaW50IHByb3h5SWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBVbkJ1ZmZlck1vdmUocHJveHlJZCk7XHJcbiAgICAgICAgICAgIC0tX3Byb3h5Q291bnQ7XHJcbiAgICAgICAgICAgIF90cmVlLlJlbW92ZVByb3h5KHByb3h5SWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTW92ZVByb3h5KGludCBwcm94eUlkLCByZWYgQUFCQiBhYWJiLCBWZWN0b3IyIGRpc3BsYWNlbWVudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvb2wgYnVmZmVyID0gX3RyZWUuTW92ZVByb3h5KHByb3h5SWQsIHJlZiBhYWJiLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCdWZmZXJNb3ZlKHByb3h5SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgQUFCQiBmb3IgYSBwcm94eS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3h5SWRcIj5UaGUgcHJveHkgaWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBHZXRGYXRBQUJCKGludCBwcm94eUlkLCBvdXQgQUFCQiBhYWJiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3RyZWUuR2V0RmF0QUFCQihwcm94eUlkLCBvdXQgYWFiYik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB1c2VyIGRhdGEgZnJvbSBhIHByb3h5LiBSZXR1cm5zIG51bGwgaWYgdGhlIGlkIGlzIGludmFsaWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkXCI+VGhlIHByb3h5IGlkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgRml4dHVyZVByb3h5IEdldFByb3h5KGludCBwcm94eUlkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90cmVlLkdldFVzZXJEYXRhKHByb3h5SWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUZXN0IG92ZXJsYXAgb2YgZmF0IEFBQkJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicHJveHlJZEFcIj5UaGUgcHJveHkgaWQgQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3h5SWRCXCI+VGhlIHByb3h5IGlkIEIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIFRlc3RPdmVybGFwKGludCBwcm94eUlkQSwgaW50IHByb3h5SWRCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQUFCQiBhYWJiQSwgYWFiYkI7XHJcbiAgICAgICAgICAgIF90cmVlLkdldEZhdEFBQkIocHJveHlJZEEsIG91dCBhYWJiQSk7XHJcbiAgICAgICAgICAgIF90cmVlLkdldEZhdEFBQkIocHJveHlJZEIsIG91dCBhYWJiQik7XHJcbiAgICAgICAgICAgIHJldHVybiBBQUJCLlRlc3RPdmVybGFwKHJlZiBhYWJiQSwgcmVmIGFhYmJCKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVXBkYXRlIHRoZSBwYWlycy4gVGhpcyByZXN1bHRzIGluIHBhaXIgY2FsbGJhY2tzLiBUaGlzIGNhbiBvbmx5IGFkZCBwYWlycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhbGxiYWNrXCI+VGhlIGNhbGxiYWNrLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgVXBkYXRlUGFpcnMoQnJvYWRwaGFzZURlbGVnYXRlIGNhbGxiYWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgcGFpciBidWZmZXJcclxuICAgICAgICAgICAgX3BhaXJDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIHRyZWUgcXVlcmllcyBmb3IgYWxsIG1vdmluZyBwcm94aWVzLlxyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IF9tb3ZlQ291bnQ7ICsrailcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3F1ZXJ5UHJveHlJZCA9IF9tb3ZlQnVmZmVyW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9xdWVyeVByb3h5SWQgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBxdWVyeSB0aGUgdHJlZSB3aXRoIHRoZSBmYXQgQUFCQiBzbyB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBmYWlsIHRvIGNyZWF0ZSBhIHBhaXIgdGhhdCBtYXkgdG91Y2ggbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICBBQUJCIGZhdEFBQkI7XHJcbiAgICAgICAgICAgICAgICBfdHJlZS5HZXRGYXRBQUJCKF9xdWVyeVByb3h5SWQsIG91dCBmYXRBQUJCKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBRdWVyeSB0cmVlLCBjcmVhdGUgcGFpcnMgYW5kIGFkZCB0aGVtIHBhaXIgYnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgX3RyZWUuUXVlcnkoKGdsb2JhbDo6U3lzdGVtLkZ1bmM8aW50LCBib29sPilfcXVlcnlDYWxsYmFjaywgcmVmIGZhdEFBQkIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCBtb3ZlIGJ1ZmZlclxyXG4gICAgICAgICAgICBfbW92ZUNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvcnQgdGhlIHBhaXIgYnVmZmVyIHRvIGV4cG9zZSBkdXBsaWNhdGVzLlxyXG4gICAgICAgICAgICBBcnJheS5Tb3J0PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlBhaXI+KF9wYWlyQnVmZmVyLCAwLCBfcGFpckNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIHBhaXJzIGJhY2sgdG8gdGhlIGNsaWVudC5cclxuICAgICAgICAgICAgaW50IGkgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IF9wYWlyQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhaXIgcHJpbWFyeVBhaXIgPSBfcGFpckJ1ZmZlcltpXTtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmVQcm94eSB1c2VyRGF0YUEgPSBfdHJlZS5HZXRVc2VyRGF0YShwcmltYXJ5UGFpci5Qcm94eUlkQSk7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlUHJveHkgdXNlckRhdGFCID0gX3RyZWUuR2V0VXNlckRhdGEocHJpbWFyeVBhaXIuUHJveHlJZEIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlZiB1c2VyRGF0YUEsIHJlZiB1c2VyRGF0YUIpO1xyXG4gICAgICAgICAgICAgICAgKytpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNraXAgYW55IGR1cGxpY2F0ZSBwYWlycy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgX3BhaXJDb3VudClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBQYWlyIHBhaXIgPSBfcGFpckJ1ZmZlcltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5Qcm94eUlkQSAhPSBwcmltYXJ5UGFpci5Qcm94eUlkQSB8fCBwYWlyLlByb3h5SWRCICE9IHByaW1hcnlQYWlyLlByb3h5SWRCKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVHJ5IHRvIGtlZXAgdGhlIHRyZWUgYmFsYW5jZWQuXHJcbiAgICAgICAgICAgIF90cmVlLlJlYmFsYW5jZSg0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUXVlcnkgYW4gQUFCQiBmb3Igb3ZlcmxhcHBpbmcgcHJveGllcy4gVGhlIGNhbGxiYWNrIGNsYXNzXHJcbiAgICAgICAgLy8vIGlzIGNhbGxlZCBmb3IgZWFjaCBwcm94eSB0aGF0IG92ZXJsYXBzIHRoZSBzdXBwbGllZCBBQUJCLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2FsbGJhY2tcIj5UaGUgY2FsbGJhY2suPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBRdWVyeShGdW5jPGludCwgYm9vbD4gY2FsbGJhY2ssIHJlZiBBQUJCIGFhYmIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfdHJlZS5RdWVyeSgoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxpbnQsIGJvb2w+KWNhbGxiYWNrLCByZWYgYWFiYik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJheS1jYXN0IGFnYWluc3QgdGhlIHByb3hpZXMgaW4gdGhlIHRyZWUuIFRoaXMgcmVsaWVzIG9uIHRoZSBjYWxsYmFja1xyXG4gICAgICAgIC8vLyB0byBwZXJmb3JtIGEgZXhhY3QgcmF5LWNhc3QgaW4gdGhlIGNhc2Ugd2VyZSB0aGUgcHJveHkgY29udGFpbnMgYSBzaGFwZS5cclxuICAgICAgICAvLy8gVGhlIGNhbGxiYWNrIGFsc28gcGVyZm9ybXMgdGhlIGFueSBjb2xsaXNpb24gZmlsdGVyaW5nLiBUaGlzIGhhcyBwZXJmb3JtYW5jZVxyXG4gICAgICAgIC8vLyByb3VnaGx5IGVxdWFsIHRvIGsgKiBsb2cobiksIHdoZXJlIGsgaXMgdGhlIG51bWJlciBvZiBjb2xsaXNpb25zIGFuZCBuIGlzIHRoZVxyXG4gICAgICAgIC8vLyBudW1iZXIgb2YgcHJveGllcyBpbiB0aGUgdHJlZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhbGxiYWNrXCI+QSBjYWxsYmFjayBjbGFzcyB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCBwcm94eSB0aGF0IGlzIGhpdCBieSB0aGUgcmF5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmF5LWNhc3QgaW5wdXQgZGF0YS4gVGhlIHJheSBleHRlbmRzIGZyb20gcDEgdG8gcDEgKyBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJheUNhc3QoRnVuYzxSYXlDYXN0SW5wdXQsIGludCwgZmxvYXQ+IGNhbGxiYWNrLCByZWYgUmF5Q2FzdElucHV0IGlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3RyZWUuUmF5Q2FzdCgoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5SYXlDYXN0SW5wdXQsIGludCwgZmxvYXQ+KWNhbGxiYWNrLCByZWYgaW5wdXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgVG91Y2hQcm94eShpbnQgcHJveHlJZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJ1ZmZlck1vdmUocHJveHlJZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBlbWJlZGRlZCB0cmVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgaW50IENvbXB1dGVIZWlnaHQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90cmVlLkNvbXB1dGVIZWlnaHQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBCdWZmZXJNb3ZlKGludCBwcm94eUlkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9tb3ZlQ291bnQgPT0gX21vdmVDYXBhY2l0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50W10gb2xkQnVmZmVyID0gX21vdmVCdWZmZXI7XHJcbiAgICAgICAgICAgICAgICBfbW92ZUNhcGFjaXR5ICo9IDI7XHJcbiAgICAgICAgICAgICAgICBfbW92ZUJ1ZmZlciA9IG5ldyBpbnRbX21vdmVDYXBhY2l0eV07XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KG9sZEJ1ZmZlciwgX21vdmVCdWZmZXIsIF9tb3ZlQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfbW92ZUJ1ZmZlcltfbW92ZUNvdW50XSA9IHByb3h5SWQ7XHJcbiAgICAgICAgICAgICsrX21vdmVDb3VudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBVbkJ1ZmZlck1vdmUoaW50IHByb3h5SWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9tb3ZlQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9tb3ZlQnVmZmVyW2ldID09IHByb3h5SWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX21vdmVCdWZmZXJbaV0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBRdWVyeUNhbGxiYWNrKGludCBwcm94eUlkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gQSBwcm94eSBjYW5ub3QgZm9ybSBhIHBhaXIgd2l0aCBpdHNlbGYuXHJcbiAgICAgICAgICAgIGlmIChwcm94eUlkID09IF9xdWVyeVByb3h5SWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHcm93IHRoZSBwYWlyIGJ1ZmZlciBhcyBuZWVkZWQuXHJcbiAgICAgICAgICAgIGlmIChfcGFpckNvdW50ID09IF9wYWlyQ2FwYWNpdHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBhaXJbXSBvbGRCdWZmZXIgPSBfcGFpckJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIF9wYWlyQ2FwYWNpdHkgKj0gMjtcclxuICAgICAgICAgICAgICAgIF9wYWlyQnVmZmVyID0gbmV3IFBhaXJbX3BhaXJDYXBhY2l0eV07XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KG9sZEJ1ZmZlciwgX3BhaXJCdWZmZXIsIF9wYWlyQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfcGFpckJ1ZmZlcltfcGFpckNvdW50XS5Qcm94eUlkQSA9IE1hdGguTWluKHByb3h5SWQsIF9xdWVyeVByb3h5SWQpO1xyXG4gICAgICAgICAgICBfcGFpckJ1ZmZlcltfcGFpckNvdW50XS5Qcm94eUlkQiA9IE1hdGguTWF4KHByb3h5SWQsIF9xdWVyeVByb3h5SWQpO1xyXG4gICAgICAgICAgICArK19wYWlyQ291bnQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvblxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gSW5wdXQgcGFyYW1ldGVycyBmb3IgQ2FsY3VsYXRlVGltZU9mSW1wYWN0XHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFRPSUlucHV0XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIERpc3RhbmNlUHJveHkgUHJveHlBID0gbmV3IERpc3RhbmNlUHJveHkoKTtcclxuICAgICAgICBwdWJsaWMgRGlzdGFuY2VQcm94eSBQcm94eUIgPSBuZXcgRGlzdGFuY2VQcm94eSgpO1xyXG4gICAgICAgIHB1YmxpYyBTd2VlcCBTd2VlcEE7XHJcbiAgICAgICAgcHVibGljIFN3ZWVwIFN3ZWVwQjtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgVE1heDsgLy8gZGVmaW5lcyBzd2VlcCBpbnRlcnZhbCBbMCwgdE1heF1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZW51bSBUT0lPdXRwdXRTdGF0ZVxyXG4gICAge1xyXG4gICAgICAgIFVua25vd24sXHJcbiAgICAgICAgRmFpbGVkLFxyXG4gICAgICAgIE92ZXJsYXBwZWQsXHJcbiAgICAgICAgVG91Y2hpbmcsXHJcbiAgICAgICAgU2VwZXJhdGVkLFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgVE9JT3V0cHV0XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFRPSU91dHB1dFN0YXRlIFN0YXRlO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBUO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBlbnVtIFNlcGFyYXRpb25GdW5jdGlvblR5cGVcclxuICAgIHtcclxuICAgICAgICBQb2ludHMsXHJcbiAgICAgICAgRmFjZUEsXHJcbiAgICAgICAgRmFjZUJcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIFNlcGFyYXRpb25GdW5jdGlvblxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlY3RvcjIgX2F4aXM7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgVmVjdG9yMiBfbG9jYWxQb2ludDtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBEaXN0YW5jZVByb3h5IF9wcm94eUEgPSBuZXcgRGlzdGFuY2VQcm94eSgpO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIERpc3RhbmNlUHJveHkgX3Byb3h5QiA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgU3dlZXAgX3N3ZWVwQSwgX3N3ZWVwQjtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlIF90eXBlO1xyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgU2V0KHJlZiBTaW1wbGV4Q2FjaGUgY2FjaGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXN0YW5jZVByb3h5IHByb3h5QSwgcmVmIFN3ZWVwIHN3ZWVwQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERpc3RhbmNlUHJveHkgcHJveHlCLCByZWYgU3dlZXAgc3dlZXBCLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdDEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfbG9jYWxQb2ludCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgX3Byb3h5QSA9IHByb3h5QTtcclxuICAgICAgICAgICAgX3Byb3h5QiA9IHByb3h5QjtcclxuICAgICAgICAgICAgaW50IGNvdW50ID0gY2FjaGUuQ291bnQ7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDwgY291bnQgJiYgY291bnQgPCAzKTtcclxuXHJcbiAgICAgICAgICAgIF9zd2VlcEEgPSBzd2VlcEE7XHJcbiAgICAgICAgICAgIF9zd2VlcEIgPSBzd2VlcEI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZBLCB4ZkI7XHJcbiAgICAgICAgICAgIF9zd2VlcEEuR2V0VHJhbnNmb3JtKG91dCB4ZkEsIHQxKTtcclxuICAgICAgICAgICAgX3N3ZWVwQi5HZXRUcmFuc2Zvcm0ob3V0IHhmQiwgdDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvdW50ID09IDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90eXBlID0gU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5Qb2ludHM7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRBID0gX3Byb3h5QS5WZXJ0aWNlc1tjYWNoZS5JbmRleEFbMF1dO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QiA9IF9wcm94eUIuVmVydGljZXNbY2FjaGUuSW5kZXhCWzBdXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEsIGxvY2FsUG9pbnRBKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIsIGxvY2FsUG9pbnRCKTtcclxuICAgICAgICAgICAgICAgIF9heGlzID0gcG9pbnRCIC0gcG9pbnRBO1xyXG4gICAgICAgICAgICAgICAgX2F4aXMuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2FjaGUuSW5kZXhBWzBdID09IGNhY2hlLkluZGV4QVsxXSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVHdvIHBvaW50cyBvbiBCIGFuZCBvbmUgb24gQS5cclxuICAgICAgICAgICAgICAgIF90eXBlID0gU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5GYWNlQjtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxQb2ludEIxID0gcHJveHlCLlZlcnRpY2VzW2NhY2hlLkluZGV4QlswXV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRCMiA9IHByb3h5Qi5WZXJ0aWNlc1tjYWNoZS5JbmRleEJbMV1dO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYSA9IGxvY2FsUG9pbnRCMiAtIGxvY2FsUG9pbnRCMTtcclxuICAgICAgICAgICAgICAgIF9heGlzID0gbmV3IFZlY3RvcjIoYS5ZLCAtYS5YKTtcclxuICAgICAgICAgICAgICAgIF9heGlzLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBub3JtYWwgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBfYXhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2xvY2FsUG9pbnQgPSAwLjVmICogKGxvY2FsUG9pbnRCMSArIGxvY2FsUG9pbnRCMik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLCBfbG9jYWxQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QSA9IHByb3h5QS5WZXJ0aWNlc1tjYWNoZS5JbmRleEFbMF1dO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQSwgbG9jYWxQb2ludEEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBWZWN0b3IyLkRvdChwb2ludEEgLSBwb2ludEIsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocyA8IDAuMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2F4aXMgPSAtX2F4aXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IC1zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVHdvIHBvaW50cyBvbiBBIGFuZCBvbmUgb3IgdHdvIHBvaW50cyBvbiBCLlxyXG4gICAgICAgICAgICAgICAgX3R5cGUgPSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLkZhY2VBO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QTEgPSBfcHJveHlBLlZlcnRpY2VzW2NhY2hlLkluZGV4QVswXV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRBMiA9IF9wcm94eUEuVmVydGljZXNbY2FjaGUuSW5kZXhBWzFdXTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGEgPSBsb2NhbFBvaW50QTIgLSBsb2NhbFBvaW50QTE7XHJcbiAgICAgICAgICAgICAgICBfYXhpcyA9IG5ldyBWZWN0b3IyKGEuWSwgLWEuWCk7XHJcbiAgICAgICAgICAgICAgICBfYXhpcy5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgX2F4aXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9sb2NhbFBvaW50ID0gMC41ZiAqIChsb2NhbFBvaW50QTEgKyBsb2NhbFBvaW50QTIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQSwgX2xvY2FsUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxQb2ludEIgPSBfcHJveHlCLlZlcnRpY2VzW2NhY2hlLkluZGV4QlswXV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLCBsb2NhbFBvaW50Qik7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgcyA9IFZlY3RvcjIuRG90KHBvaW50QiAtIHBvaW50QSwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIGlmIChzIDwgMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfYXhpcyA9IC1fYXhpcztcclxuICAgICAgICAgICAgICAgICAgICBzID0gLXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgRmluZE1pblNlcGFyYXRpb24ob3V0IGludCBpbmRleEEsIG91dCBpbnQgaW5kZXhCLCBmbG9hdCB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQSwgeGZCO1xyXG4gICAgICAgICAgICBfc3dlZXBBLkdldFRyYW5zZm9ybShvdXQgeGZBLCB0KTtcclxuICAgICAgICAgICAgX3N3ZWVwQi5HZXRUcmFuc2Zvcm0ob3V0IHhmQiwgdCk7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKF90eXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFNlcGFyYXRpb25GdW5jdGlvblR5cGUuUG9pbnRzOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzQSA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHhmQS5SLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpc0IgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB4ZkIuUiwgLV9heGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QSA9IF9wcm94eUEuR2V0U3VwcG9ydChheGlzQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QiA9IF9wcm94eUIuR2V0U3VwcG9ydChheGlzQik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRBID0gX3Byb3h5QS5WZXJ0aWNlc1tpbmRleEFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRCID0gX3Byb3h5Qi5WZXJ0aWNlc1tpbmRleEJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQSwgbG9jYWxQb2ludEEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLCBsb2NhbFBvaW50Qik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uID0gVmVjdG9yMi5Eb3QocG9pbnRCIC0gcG9pbnRBLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXBhcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFNlcGFyYXRpb25GdW5jdGlvblR5cGUuRmFjZUE6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIG5vcm1hbCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLlIsIF9heGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQSwgX2xvY2FsUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzQiA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHhmQi5SLCAtbm9ybWFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleEIgPSBfcHJveHlCLkdldFN1cHBvcnQoYXhpc0IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QiA9IF9wcm94eUIuVmVydGljZXNbaW5kZXhCXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQiwgbG9jYWxQb2ludEIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IFZlY3RvcjIuRG90KHBvaW50QiAtIHBvaW50QSwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcGFyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5GYWNlQjpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIuUiwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLCBfbG9jYWxQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXNBID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgeGZBLlIsIC1ub3JtYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QSA9IF9wcm94eUEuR2V0U3VwcG9ydChheGlzQSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRBID0gX3Byb3h5QS5WZXJ0aWNlc1tpbmRleEFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLCBsb2NhbFBvaW50QSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uID0gVmVjdG9yMi5Eb3QocG9pbnRBIC0gcG9pbnRCLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VwYXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4QSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4QiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IEV2YWx1YXRlKGludCBpbmRleEEsIGludCBpbmRleEIsIGZsb2F0IHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZBLCB4ZkI7XHJcbiAgICAgICAgICAgIF9zd2VlcEEuR2V0VHJhbnNmb3JtKG91dCB4ZkEsIHQpO1xyXG4gICAgICAgICAgICBfc3dlZXBCLkdldFRyYW5zZm9ybShvdXQgeGZCLCB0KTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoX3R5cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5Qb2ludHM6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXNBID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgeGZBLlIsIF9heGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzQiA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHhmQi5SLCAtX2F4aXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QSA9IF9wcm94eUEuVmVydGljZXNbaW5kZXhBXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QiA9IF9wcm94eUIuVmVydGljZXNbaW5kZXhCXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEsIGxvY2FsUG9pbnRBKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQiwgbG9jYWxQb2ludEIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uID0gVmVjdG9yMi5Eb3QocG9pbnRCIC0gcG9pbnRBLCBfYXhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VwYXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLkZhY2VBOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBub3JtYWwgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEsIF9sb2NhbFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpc0IgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB4ZkIuUiwgLW5vcm1hbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRCID0gX3Byb3h5Qi5WZXJ0aWNlc1tpbmRleEJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLCBsb2NhbFBvaW50Qik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uID0gVmVjdG9yMi5Eb3QocG9pbnRCIC0gcG9pbnRBLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VwYXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLkZhY2VCOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBub3JtYWwgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIsIF9sb2NhbFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpc0EgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB4ZkEuUiwgLW5vcm1hbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRBID0gX3Byb3h5QS5WZXJ0aWNlc1tpbmRleEFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLCBsb2NhbFBvaW50QSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uID0gVmVjdG9yMi5Eb3QocG9pbnRBIC0gcG9pbnRCLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VwYXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgVGltZU9mSW1wYWN0XHJcbiAgICB7XHJcbiAgICAgICAgLy8gQ0NEIHZpYSB0aGUgbG9jYWwgc2VwYXJhdGluZyBheGlzIG1ldGhvZC4gVGhpcyBzZWVrcyBwcm9ncmVzc2lvblxyXG4gICAgICAgIC8vIGJ5IGNvbXB1dGluZyB0aGUgbGFyZ2VzdCB0aW1lIGF0IHdoaWNoIHNlcGFyYXRpb24gaXMgbWFpbnRhaW5lZC5cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgVE9JQ2FsbHMsIFRPSUl0ZXJzLCBUT0lNYXhJdGVycztcclxuICAgICAgICBwdWJsaWMgc3RhdGljIGludCBUT0lSb290SXRlcnMsIFRPSU1heFJvb3RJdGVycztcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBEaXN0YW5jZUlucHV0IF9kaXN0YW5jZUlucHV0ID0gbmV3IERpc3RhbmNlSW5wdXQoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlIHRoZSB1cHBlciBib3VuZCBvbiB0aW1lIGJlZm9yZSB0d28gc2hhcGVzIHBlbmV0cmF0ZS4gVGltZSBpcyByZXByZXNlbnRlZCBhc1xyXG4gICAgICAgIC8vLyBhIGZyYWN0aW9uIGJldHdlZW4gWzAsdE1heF0uIFRoaXMgdXNlcyBhIHN3ZXB0IHNlcGFyYXRpbmcgYXhpcyBhbmQgbWF5IG1pc3Mgc29tZSBpbnRlcm1lZGlhdGUsXHJcbiAgICAgICAgLy8vIG5vbi10dW5uZWxpbmcgY29sbGlzaW9uLiBJZiB5b3UgY2hhbmdlIHRoZSB0aW1lIGludGVydmFsLCB5b3Ugc2hvdWxkIGNhbGwgdGhpcyBmdW5jdGlvblxyXG4gICAgICAgIC8vLyBhZ2Fpbi5cclxuICAgICAgICAvLy8gTm90ZTogdXNlIERpc3RhbmNlKCkgdG8gY29tcHV0ZSB0aGUgY29udGFjdCBwb2ludCBhbmQgbm9ybWFsIGF0IHRoZSB0aW1lIG9mIGltcGFjdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm91dHB1dFwiPlRoZSBvdXRwdXQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSBpbnB1dC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBDYWxjdWxhdGVUaW1lT2ZJbXBhY3Qob3V0IFRPSU91dHB1dCBvdXRwdXQsIFRPSUlucHV0IGlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgKytUT0lDYWxscztcclxuXHJcbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBUT0lPdXRwdXQoKTtcclxuICAgICAgICAgICAgb3V0cHV0LlN0YXRlID0gVE9JT3V0cHV0U3RhdGUuVW5rbm93bjtcclxuICAgICAgICAgICAgb3V0cHV0LlQgPSBpbnB1dC5UTWF4O1xyXG5cclxuICAgICAgICAgICAgU3dlZXAgc3dlZXBBID0gaW5wdXQuU3dlZXBBO1xyXG4gICAgICAgICAgICBTd2VlcCBzd2VlcEIgPSBpbnB1dC5Td2VlcEI7XHJcblxyXG4gICAgICAgICAgICAvLyBMYXJnZSByb3RhdGlvbnMgY2FuIG1ha2UgdGhlIHJvb3QgZmluZGVyIGZhaWwsIHNvIHdlIG5vcm1hbGl6ZSB0aGVcclxuICAgICAgICAgICAgLy8gc3dlZXAgYW5nbGVzLlxyXG4gICAgICAgICAgICBzd2VlcEEuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIHN3ZWVwQi5Ob3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHRNYXggPSBpbnB1dC5UTWF4O1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgdG90YWxSYWRpdXMgPSBpbnB1dC5Qcm94eUEuUmFkaXVzICsgaW5wdXQuUHJveHlCLlJhZGl1cztcclxuICAgICAgICAgICAgZmxvYXQgdGFyZ2V0ID0gTWF0aC5NYXgoU2V0dGluZ3MuTGluZWFyU2xvcCwgdG90YWxSYWRpdXMgLSAzLjBmICogU2V0dGluZ3MuTGluZWFyU2xvcCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IHRvbGVyYW5jZSA9IDAuMjVmICogU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHRhcmdldCA+IHRvbGVyYW5jZSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCB0MSA9IDAuMGY7XHJcbiAgICAgICAgICAgIGNvbnN0IGludCBrX21heEl0ZXJhdGlvbnMgPSAyMDtcclxuICAgICAgICAgICAgaW50IGl0ZXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlcGFyZSBpbnB1dCBmb3IgZGlzdGFuY2UgcXVlcnkuXHJcbiAgICAgICAgICAgIFNpbXBsZXhDYWNoZSBjYWNoZTtcclxuICAgICAgICAgICAgX2Rpc3RhbmNlSW5wdXQuUHJveHlBID0gaW5wdXQuUHJveHlBO1xyXG4gICAgICAgICAgICBfZGlzdGFuY2VJbnB1dC5Qcm94eUIgPSBpbnB1dC5Qcm94eUI7XHJcbiAgICAgICAgICAgIF9kaXN0YW5jZUlucHV0LlVzZVJhZGlpID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgb3V0ZXIgbG9vcCBwcm9ncmVzc2l2ZWx5IGF0dGVtcHRzIHRvIGNvbXB1dGUgbmV3IHNlcGFyYXRpbmcgYXhlcy5cclxuICAgICAgICAgICAgLy8gVGhpcyBsb29wIHRlcm1pbmF0ZXMgd2hlbiBhbiBheGlzIGlzIHJlcGVhdGVkIChubyBwcm9ncmVzcyBpcyBtYWRlKS5cclxuICAgICAgICAgICAgZm9yICg7IDsgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0geGZBLCB4ZkI7XHJcbiAgICAgICAgICAgICAgICBzd2VlcEEuR2V0VHJhbnNmb3JtKG91dCB4ZkEsIHQxKTtcclxuICAgICAgICAgICAgICAgIHN3ZWVwQi5HZXRUcmFuc2Zvcm0ob3V0IHhmQiwgdDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzaGFwZXMuIFdlIGNhbiBhbHNvIHVzZSB0aGUgcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gZ2V0IGEgc2VwYXJhdGluZyBheGlzLlxyXG4gICAgICAgICAgICAgICAgX2Rpc3RhbmNlSW5wdXQuVHJhbnNmb3JtQSA9IHhmQTtcclxuICAgICAgICAgICAgICAgIF9kaXN0YW5jZUlucHV0LlRyYW5zZm9ybUIgPSB4ZkI7XHJcbiAgICAgICAgICAgICAgICBEaXN0YW5jZU91dHB1dCBkaXN0YW5jZU91dHB1dDtcclxuICAgICAgICAgICAgICAgIERpc3RhbmNlLkNvbXB1dGVEaXN0YW5jZShvdXQgZGlzdGFuY2VPdXRwdXQsIG91dCBjYWNoZSwgX2Rpc3RhbmNlSW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzaGFwZXMgYXJlIG92ZXJsYXBwZWQsIHdlIGdpdmUgdXAgb24gY29udGludW91cyBjb2xsaXNpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VPdXRwdXQuRGlzdGFuY2UgPD0gMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGYWlsdXJlIVxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5TdGF0ZSA9IFRPSU91dHB1dFN0YXRlLk92ZXJsYXBwZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlQgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZU91dHB1dC5EaXN0YW5jZSA8IHRhcmdldCArIHRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBWaWN0b3J5IVxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5TdGF0ZSA9IFRPSU91dHB1dFN0YXRlLlRvdWNoaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5UID0gdDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgU2VwYXJhdGlvbkZ1bmN0aW9uLlNldChyZWYgY2FjaGUsIGlucHV0LlByb3h5QSwgcmVmIHN3ZWVwQSwgaW5wdXQuUHJveHlCLCByZWYgc3dlZXBCLCB0MSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgVE9JIG9uIHRoZSBzZXBhcmF0aW5nIGF4aXMuIFdlIGRvIHRoaXMgYnkgc3VjY2Vzc2l2ZWx5XHJcbiAgICAgICAgICAgICAgICAvLyByZXNvbHZpbmcgdGhlIGRlZXBlc3QgcG9pbnQuIFRoaXMgbG9vcCBpcyBib3VuZGVkIGJ5IHRoZSBudW1iZXIgb2YgdmVydGljZXMuXHJcbiAgICAgICAgICAgICAgICBib29sIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHQyID0gdE1heDtcclxuICAgICAgICAgICAgICAgIGludCBwdXNoQmFja0l0ZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IDsgKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGRlZXBlc3QgcG9pbnQgYXQgdDIuIFN0b3JlIHRoZSB3aXRuZXNzIHBvaW50IGluZGljZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGluZGV4QSwgaW5kZXhCO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHMyID0gU2VwYXJhdGlvbkZ1bmN0aW9uLkZpbmRNaW5TZXBhcmF0aW9uKG91dCBpbmRleEEsIG91dCBpbmRleEIsIHQyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhlIGZpbmFsIGNvbmZpZ3VyYXRpb24gc2VwYXJhdGVkP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzMiA+IHRhcmdldCArIHRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZpY3RvcnkhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5TdGF0ZSA9IFRPSU91dHB1dFN0YXRlLlNlcGVyYXRlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlQgPSB0TWF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIYXMgdGhlIHNlcGFyYXRpb24gcmVhY2hlZCB0b2xlcmFuY2U/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMyID4gdGFyZ2V0IC0gdG9sZXJhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgc3dlZXBzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW5pdGlhbCBzZXBhcmF0aW9uIG9mIHRoZSB3aXRuZXNzIHBvaW50cy5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzMSA9IFNlcGFyYXRpb25GdW5jdGlvbi5FdmFsdWF0ZShpbmRleEEsIGluZGV4QiwgdDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgaW5pdGlhbCBvdmVybGFwLiBUaGlzIG1pZ2h0IGhhcHBlbiBpZiB0aGUgcm9vdCBmaW5kZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBydW5zIG91dCBvZiBpdGVyYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzMSA8IHRhcmdldCAtIHRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5TdGF0ZSA9IFRPSU91dHB1dFN0YXRlLkZhaWxlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlQgPSB0MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRvdWNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMxIDw9IHRhcmdldCArIHRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZpY3RvcnkhIHQxIHNob3VsZCBob2xkIHRoZSBUT0kgKGNvdWxkIGJlIDAuMCkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5TdGF0ZSA9IFRPSU91dHB1dFN0YXRlLlRvdWNoaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuVCA9IHQxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIDFEIHJvb3Qgb2Y6IGYoeCkgLSB0YXJnZXQgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IHJvb3RJdGVyQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGExID0gdDEsIGEyID0gdDI7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgbWl4IG9mIHRoZSBzZWNhbnQgcnVsZSBhbmQgYmlzZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvb3RJdGVyQ291bnQgJiAxKSAhPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWNhbnQgcnVsZSB0byBpbXByb3ZlIGNvbnZlcmdlbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGExICsgKHRhcmdldCAtIHMxKSAqIChhMiAtIGExKSAvIChzMiAtIHMxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpc2VjdGlvbiB0byBndWFyYW50ZWUgcHJvZ3Jlc3MuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gMC41ZiAqIChhMSArIGEyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcyA9IFNlcGFyYXRpb25GdW5jdGlvbi5FdmFsdWF0ZShpbmRleEEsIGluZGV4QiwgdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMocyAtIHRhcmdldCkgPCB0b2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHQyIGhvbGRzIGEgdGVudGF0aXZlIHZhbHVlIGZvciB0MVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBjb250aW51ZSB0byBicmFja2V0IHRoZSByb290LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA+IHRhcmdldClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTEgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczIgPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICArK3Jvb3RJdGVyQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrVE9JUm9vdEl0ZXJzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RJdGVyQ291bnQgPT0gNTApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBUT0lNYXhSb290SXRlcnMgPSBNYXRoLk1heChUT0lNYXhSb290SXRlcnMsIHJvb3RJdGVyQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICArK3B1c2hCYWNrSXRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1c2hCYWNrSXRlciA9PSBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgKytpdGVyO1xyXG4gICAgICAgICAgICAgICAgKytUT0lJdGVycztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlciA9PSBrX21heEl0ZXJhdGlvbnMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm9vdCBmaW5kZXIgZ290IHN0dWNrLiBTZW1pLXZpY3RvcnkuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlN0YXRlID0gVE9JT3V0cHV0U3RhdGUuRmFpbGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5UID0gdDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFRPSU1heEl0ZXJzID0gTWF0aC5NYXgoVE9JTWF4SXRlcnMsIGl0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgaG9sZHMgdGhlIG1hc3MgZGF0YSBjb21wdXRlZCBmb3IgYSBzaGFwZS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IE1hc3NEYXRhIDogSUVxdWF0YWJsZTxNYXNzRGF0YT5cclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBhcmVhIG9mIHRoZSBzaGFwZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEFyZWE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBzaGFwZSdzIGNlbnRyb2lkIHJlbGF0aXZlIHRvIHRoZSBzaGFwZSdzIG9yaWdpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIENlbnRyb2lkO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSByb3RhdGlvbmFsIGluZXJ0aWEgb2YgdGhlIHNoYXBlIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSW5lcnRpYTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWFzcyBvZiB0aGUgc2hhcGUsIHVzdWFsbHkgaW4ga2lsb2dyYW1zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1hc3M7XHJcblxyXG4gICAgICAgICNyZWdpb24gSUVxdWF0YWJsZTxNYXNzRGF0YT4gTWVtYmVyc1xyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBFcXVhbHMoTWFzc0RhdGEgb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIG9wZXJhdG9yID09KE1hc3NEYXRhIGxlZnQsIE1hc3NEYXRhIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChsZWZ0LkFyZWEgPT0gcmlnaHQuQXJlYSAmJiBsZWZ0Lk1hc3MgPT0gcmlnaHQuTWFzcyAmJiBsZWZ0LkNlbnRyb2lkID09IHJpZ2h0LkNlbnRyb2lkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5JbmVydGlhID09IHJpZ2h0LkluZXJ0aWEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIG9wZXJhdG9yICE9KE1hc3NEYXRhIGxlZnQsIE1hc3NEYXRhIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICEobGVmdCA9PSByaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBFcXVhbHMob2JqZWN0IG9iailcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSZWZlcmVuY2VFcXVhbHMobnVsbCwgb2JqKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAob2JqLkdldFR5cGUoKSAhPSB0eXBlb2YoTWFzc0RhdGEpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBFcXVhbHMoKE1hc3NEYXRhKW9iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEdldEhhc2hDb2RlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHVuY2hlY2tlZFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgcmVzdWx0ID0gQXJlYS5HZXRIYXNoQ29kZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDM5NykgXiBDZW50cm9pZC5HZXRIYXNoQ29kZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDM5NykgXiBJbmVydGlhLkdldEhhc2hDb2RlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0ICogMzk3KSBeIE1hc3MuR2V0SGFzaENvZGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGVudW0gU2hhcGVUeXBlXHJcbiAgICB7XHJcbiAgICAgICAgVW5rbm93biA9IC0xLFxyXG4gICAgICAgIENpcmNsZSA9IDAsXHJcbiAgICAgICAgRWRnZSA9IDEsXHJcbiAgICAgICAgUG9seWdvbiA9IDIsXHJcbiAgICAgICAgTG9vcCA9IDMsXHJcbiAgICAgICAgVHlwZUNvdW50ID0gNCxcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBzaGFwZSBpcyB1c2VkIGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLiBZb3UgY2FuIGNyZWF0ZSBhIHNoYXBlIGhvd2V2ZXIgeW91IGxpa2UuXHJcbiAgICAvLy8gU2hhcGVzIHVzZWQgZm9yIHNpbXVsYXRpb24gaW4gV29ybGQgYXJlIGNyZWF0ZWQgYXV0b21hdGljYWxseSB3aGVuIGEgRml4dHVyZVxyXG4gICAgLy8vIGlzIGNyZWF0ZWQuIFNoYXBlcyBtYXkgZW5jYXBzdWxhdGUgYSBvbmUgb3IgbW9yZSBjaGlsZCBzaGFwZXMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIFNoYXBlXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgaW50IF9zaGFwZUlkQ291bnRlcjtcclxuICAgICAgICBwdWJsaWMgTWFzc0RhdGEgTWFzc0RhdGE7XHJcbiAgICAgICAgcHVibGljIGludCBTaGFwZUlkO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBmbG9hdCBfZGVuc2l0eTtcclxuICAgICAgICBpbnRlcm5hbCBmbG9hdCBfcmFkaXVzO1xyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgU2hhcGUoZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9kZW5zaXR5ID0gZGVuc2l0eTtcclxuICAgICAgICAgICAgU2hhcGVUeXBlID0gU2hhcGVUeXBlLlVua25vd247XHJcbiAgICAgICAgICAgIFNoYXBlSWQgPSBfc2hhcGVJZENvdW50ZXIrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB0eXBlIG9mIHRoaXMgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSB0eXBlIG9mIHRoZSBzaGFwZS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBTaGFwZVR5cGUgU2hhcGVUeXBlIHsgZ2V0OyBpbnRlcm5hbCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIG51bWJlciBvZiBjaGlsZCBwcmltaXRpdmVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBpbnQgQ2hpbGRDb3VudCB7IGdldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgZGVuc2l0eS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGRlbnNpdHkuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGVuc2l0eVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9kZW5zaXR5OyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfZGVuc2l0eSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgQ29tcHV0ZVByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSYWRpdXMgb2YgdGhlIFNoYXBlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmFkaXVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3JhZGl1czsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3JhZGl1cyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgQ29tcHV0ZVByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDbG9uZSB0aGUgY29uY3JldGUgc2hhcGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIGNsb25lIG9mIHRoZSBzaGFwZTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgU2hhcGUgQ2xvbmUoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUZXN0IGEgcG9pbnQgZm9yIGNvbnRhaW5tZW50IGluIHRoaXMgc2hhcGUuIFRoaXMgb25seSB3b3JrcyBmb3IgY29udmV4IHNoYXBlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSBzaGFwZSB3b3JsZCB0cmFuc2Zvcm0uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPmEgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBzaGFwZTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgYm9vbCBUZXN0UG9pbnQocmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0sIHJlZiBWZWN0b3IyIHBvaW50KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYXN0IGEgcmF5IGFnYWluc3QgYSBjaGlsZCBzaGFwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm91dHB1dFwiPlRoZSByYXktY2FzdCByZXN1bHRzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmF5LWNhc3QgaW5wdXQgcGFyYW1ldGVycy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaGlsZEluZGV4XCI+VGhlIGNoaWxkIHNoYXBlIGluZGV4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIHJheS1jYXN0IGhpdHMgdGhlIHNoYXBlPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBib29sIFJheUNhc3Qob3V0IFJheUNhc3RPdXRwdXQgb3V0cHV0LCByZWYgUmF5Q2FzdElucHV0IGlucHV0LCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBjaGlsZEluZGV4KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHaXZlbiBhIHRyYW5zZm9ybSwgY29tcHV0ZSB0aGUgYXNzb2NpYXRlZCBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhIGNoaWxkIHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiIHJlc3VsdHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNoaWxkSW5kZXhcIj5UaGUgY2hpbGQgc2hhcGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBDb21wdXRlQUFCQihvdXQgQUFCQiBhYWJiLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgaW50IGNoaWxkSW5kZXgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGlzIHNoYXBlIHVzaW5nIGl0cyBkaW1lbnNpb25zIGFuZCBkZW5zaXR5LlxyXG4gICAgICAgIC8vLyBUaGUgaW5lcnRpYSB0ZW5zb3IgaXMgY29tcHV0ZWQgYWJvdXQgdGhlIGxvY2FsIG9yaWdpbiwgbm90IHRoZSBjZW50cm9pZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIENvbXB1dGVQcm9wZXJ0aWVzKCk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIENvbXBhcmVUbyhTaGFwZSBzaGFwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZSBpcyBQb2x5Z29uU2hhcGUgJiYgdGhpcyBpcyBQb2x5Z29uU2hhcGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKChQb2x5Z29uU2hhcGUpdGhpcykuQ29tcGFyZVRvKChQb2x5Z29uU2hhcGUpc2hhcGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNoYXBlIGlzIENpcmNsZVNoYXBlICYmIHRoaXMgaXMgQ2lyY2xlU2hhcGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKChDaXJjbGVTaGFwZSl0aGlzKS5Db21wYXJlVG8oKENpcmNsZVNoYXBlKXNoYXBlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZSBpcyBFZGdlU2hhcGUgJiYgdGhpcyBpcyBFZGdlU2hhcGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKChFZGdlU2hhcGUpdGhpcykuQ29tcGFyZVRvKChFZGdlU2hhcGUpc2hhcGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGZsb2F0IENvbXB1dGVTdWJtZXJnZWRBcmVhKFZlY3RvcjIgbm9ybWFsLCBmbG9hdCBvZmZzZXQsIFRyYW5zZm9ybSB4Ziwgb3V0IFZlY3RvcjIgc2MpO1xyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5Db252ZXhIdWxsXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgQ2hhaW5IdWxsXHJcbiAgICB7XHJcbiAgICAgICAgLy9BbmRyZXcncyBtb25vdG9uZSBjaGFpbiAyRCBjb252ZXggaHVsbCBhbGdvcml0aG0uXHJcbiAgICAgICAgLy9Db3B5cmlnaHQgMjAwMSwgc29mdFN1cmZlciAod3d3LnNvZnRzdXJmZXIuY29tKVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGNvbnZleCBodWxsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlxyXG4gICAgICAgIC8vLyBodHRwOi8vd3d3LnNvZnRzdXJmZXIuY29tL0FyY2hpdmUvYWxnb3JpdGhtXzAxMDkvYWxnb3JpdGhtXzAxMDkuaHRtXHJcbiAgICAgICAgLy8vIDwvcmVtYXJrcz5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgR2V0Q29udmV4SHVsbChWZXJ0aWNlcyBQKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUC5Tb3J0KG5ldyBQb2ludENvbXBhcmVyKCkpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMltdIEggPSBuZXcgVmVjdG9yMltQLkNvdW50XTtcclxuICAgICAgICAgICAgVmVydGljZXMgcmVzID0gbmV3IFZlcnRpY2VzKCk7XHJcblxyXG4gICAgICAgICAgICBpbnQgbiA9IFAuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBpbnQgYm90LCB0b3AgPSAtMTsgLy8gaW5kaWNlcyBmb3IgYm90dG9tIGFuZCB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIGludCBpOyAvLyBhcnJheSBzY2FuIGluZGV4XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGluZGljZXMgb2YgcG9pbnRzIHdpdGggbWluIHgtY29vcmQgYW5kIG1pbnxtYXggeS1jb29yZFxyXG4gICAgICAgICAgICBpbnQgbWlubWluID0gMCwgbWlubWF4O1xyXG4gICAgICAgICAgICBmbG9hdCB4bWluID0gUFswXS5YO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKFBbaV0uWCAhPSB4bWluKSBicmVhaztcclxuICAgICAgICAgICAgbWlubWF4ID0gaSAtIDE7XHJcbiAgICAgICAgICAgIGlmIChtaW5tYXggPT0gbiAtIDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlZ2VuZXJhdGUgY2FzZTogYWxsIHgtY29vcmRzID09IHhtaW5cclxuICAgICAgICAgICAgICAgIEhbKyt0b3BdID0gUFttaW5taW5dO1xyXG4gICAgICAgICAgICAgICAgaWYgKFBbbWlubWF4XS5ZICE9IFBbbWlubWluXS5ZKSAvLyBhIG5vbnRyaXZpYWwgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIEhbKyt0b3BdID0gUFttaW5tYXhdO1xyXG4gICAgICAgICAgICAgICAgSFsrK3RvcF0gPSBQW21pbm1pbl07IC8vIGFkZCBwb2x5Z29uIGVuZHBvaW50XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCB0b3AgKyAxOyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLkFkZChIW2pdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0b3AgPSByZXMuQ291bnQgLSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRpY2VzIG9mIHBvaW50cyB3aXRoIG1heCB4LWNvb3JkIGFuZCBtaW58bWF4IHktY29vcmRcclxuICAgICAgICAgICAgaW50IG1heG1pbiwgbWF4bWF4ID0gbiAtIDE7XHJcbiAgICAgICAgICAgIGZsb2F0IHhtYXggPSBQW24gLSAxXS5YO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgICAgICBpZiAoUFtpXS5YICE9IHhtYXgpIGJyZWFrO1xyXG4gICAgICAgICAgICBtYXhtaW4gPSBpICsgMTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGxvd2VyIGh1bGwgb24gdGhlIHN0YWNrIEhcclxuICAgICAgICAgICAgSFsrK3RvcF0gPSBQW21pbm1pbl07IC8vIHB1c2ggbWlubWluIHBvaW50IG9udG8gc3RhY2tcclxuICAgICAgICAgICAgaSA9IG1pbm1heDtcclxuICAgICAgICAgICAgd2hpbGUgKCsraSA8PSBtYXhtaW4pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBsb3dlciBsaW5lIGpvaW5zIFBbbWlubWluXSB3aXRoIFBbbWF4bWluXVxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGhVdGlscy5BcmVhKFBbbWlubWluXSwgUFttYXhtaW5dLCBQW2ldKSA+PSAwICYmIGkgPCBtYXhtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGlnbm9yZSBQW2ldIGFib3ZlIG9yIG9uIHRoZSBsb3dlciBsaW5lXHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRvcCA+IDApIC8vIHRoZXJlIGFyZSBhdCBsZWFzdCAyIHBvaW50cyBvbiB0aGUgc3RhY2tcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIFBbaV0gaXMgbGVmdCBvZiB0aGUgbGluZSBhdCB0aGUgc3RhY2sgdG9wXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGhVdGlscy5BcmVhKEhbdG9wIC0gMV0sIEhbdG9wXSwgUFtpXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gUFtpXSBpcyBhIG5ldyBodWxsIHZlcnRleFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLS07IC8vIHBvcCB0b3AgcG9pbnQgb2ZmIHN0YWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBIWysrdG9wXSA9IFBbaV07IC8vIHB1c2ggUFtpXSBvbnRvIHN0YWNrXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5leHQsIGNvbXB1dGUgdGhlIHVwcGVyIGh1bGwgb24gdGhlIHN0YWNrIEggYWJvdmUgdGhlIGJvdHRvbSBodWxsXHJcbiAgICAgICAgICAgIGlmIChtYXhtYXggIT0gbWF4bWluKSAvLyBpZiBkaXN0aW5jdCB4bWF4IHBvaW50c1xyXG4gICAgICAgICAgICAgICAgSFsrK3RvcF0gPSBQW21heG1heF07IC8vIHB1c2ggbWF4bWF4IHBvaW50IG9udG8gc3RhY2tcclxuICAgICAgICAgICAgYm90ID0gdG9wOyAvLyB0aGUgYm90dG9tIHBvaW50IG9mIHRoZSB1cHBlciBodWxsIHN0YWNrXHJcbiAgICAgICAgICAgIGkgPSBtYXhtaW47XHJcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gbWlubWF4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXBwZXIgbGluZSBqb2lucyBQW21heG1heF0gd2l0aCBQW21pbm1heF1cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoVXRpbHMuQXJlYShQW21heG1heF0sIFBbbWlubWF4XSwgUFtpXSkgPj0gMCAmJiBpID4gbWlubWF4KVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBpZ25vcmUgUFtpXSBiZWxvdyBvciBvbiB0aGUgdXBwZXIgbGluZVxyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlICh0b3AgPiBib3QpIC8vIGF0IGxlYXN0IDIgcG9pbnRzIG9uIHRoZSB1cHBlciBzdGFja1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgUFtpXSBpcyBsZWZ0IG9mIHRoZSBsaW5lIGF0IHRoZSBzdGFjayB0b3BcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aFV0aWxzLkFyZWEoSFt0b3AgLSAxXSwgSFt0b3BdLCBQW2ldKSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBQW2ldIGlzIGEgbmV3IGh1bGwgdmVydGV4XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AtLTsgLy8gcG9wIHRvcCBwb2ludCBvZmYgc3RhY2tcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEhbKyt0b3BdID0gUFtpXTsgLy8gcHVzaCBQW2ldIG9udG8gc3RhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWlubWF4ICE9IG1pbm1pbilcclxuICAgICAgICAgICAgICAgIEhbKyt0b3BdID0gUFttaW5taW5dOyAvLyBwdXNoIGpvaW5pbmcgZW5kcG9pbnQgb250byBzdGFja1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCB0b3AgKyAxOyBqKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlcy5BZGQoSFtqXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIE5lc3RlZCB0eXBlOiBQb2ludENvbXBhcmVyXHJcblxyXG4gICAgICAgIHB1YmxpYyBjbGFzcyBQb2ludENvbXBhcmVyIDogQ29tcGFyZXI8VmVjdG9yMj5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgQ29tcGFyZShWZWN0b3IyIGEsIFZlY3RvcjIgYilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGYgPSBhLlguQ29tcGFyZVRvKGIuWCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZiAhPSAwID8gZiA6IGEuWS5Db21wYXJlVG8oYi5ZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5Db252ZXhIdWxsXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgR2lmdFdyYXBcclxuICAgIHtcclxuICAgICAgICAvLyBGcm9tIEVyaWMgSm9yZGFuJ3MgY29udmV4IGRlY29tcG9zaXRpb24gbGlicmFyeSAoYm94MkQgcmV2IDMyKVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbmQgdGhlIGNvbnZleCBodWxsIG9mIGEgcG9pbnQgY2xvdWQgdXNpbmcgXCJHaWZ0LXdyYXBcIiBhbGdvcml0aG0gLSBzdGFydFxyXG4gICAgICAgIC8vLyB3aXRoIGFuIGV4dHJlbWFsIHBvaW50LCBhbmQgd2FsayBhcm91bmQgdGhlIG91dHNpZGUgZWRnZSBieSB0ZXN0aW5nXHJcbiAgICAgICAgLy8vIGFuZ2xlcy5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIFJ1bnMgaW4gTyhOKlMpIHRpbWUgd2hlcmUgUyBpcyBudW1iZXIgb2Ygc2lkZXMgb2YgcmVzdWx0aW5nIHBvbHlnb24uXHJcbiAgICAgICAgLy8vIFdvcnN0IGNhc2U6IHBvaW50IGNsb3VkIGlzIGFsbCB2ZXJ0aWNlcyBvZiBjb252ZXggcG9seWdvbjogTyhOXjIpLlxyXG4gICAgICAgIC8vLyBUaGVyZSBtYXkgYmUgZmFzdGVyIGFsZ29yaXRobXMgdG8gZG8gdGhpcywgc2hvdWxkIHlvdSBuZWVkIG9uZSAtXHJcbiAgICAgICAgLy8vIHRoaXMgaXMganVzdCB0aGUgc2ltcGxlc3QuIFlvdSBjYW4gZ2V0IE8oTiBsb2cgTikgZXhwZWN0ZWQgdGltZSBpZiB5b3VcclxuICAgICAgICAvLy8gdHJ5LCBJIHRoaW5rLCBhbmQgTyhOKSBpZiB5b3UgcmVzdHJpY3QgaW5wdXRzIHRvIHNpbXBsZSBwb2x5Z29ucy5cclxuICAgICAgICAvLy8gUmV0dXJucyBudWxsIGlmIG51bWJlciBvZiB2ZXJ0aWNlcyBwYXNzZWQgaXMgbGVzcyB0aGFuIDMuXHJcbiAgICAgICAgLy8vIFJlc3VsdHMgc2hvdWxkIGJlIHBhc3NlZCB0aHJvdWdoIGNvbnZleCBkZWNvbXBvc2l0aW9uIGFmdGVyd2FyZHNcclxuICAgICAgICAvLy8gdG8gZW5zdXJlIHRoYXQgZWFjaCBzaGFwZSBoYXMgZmV3IGVub3VnaCBwb2ludHMgdG8gYmUgdXNlZCBpbiBCb3gyZC5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIFdhcm5pbmc6IE1heSBiZSBidWdneSB3aXRoIGNvbGluZWFyIHBvaW50cyBvbiBodWxsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgdmVydGljZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgR2V0Q29udmV4SHVsbChWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICBpbnRbXSBlZGdlTGlzdCA9IG5ldyBpbnRbdmVydGljZXMuQ291bnRdO1xyXG4gICAgICAgICAgICBpbnQgbnVtRWRnZXMgPSAwO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbWluWSA9IGZsb2F0Lk1heFZhbHVlO1xyXG4gICAgICAgICAgICBpbnQgbWluWUluZGV4ID0gdmVydGljZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzW2ldLlkgPCBtaW5ZKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB2ZXJ0aWNlc1tpXS5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbllJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCBzdGFydEluZGV4ID0gbWluWUluZGV4O1xyXG4gICAgICAgICAgICBpbnQgd2luSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgZmxvYXQgZHggPSAtMS4wZjtcclxuICAgICAgICAgICAgZmxvYXQgZHkgPSAwLjBmO1xyXG4gICAgICAgICAgICB3aGlsZSAod2luSW5kZXggIT0gbWluWUluZGV4KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXhEb3QgPSAtMi4wZjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG5ybTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gc3RhcnRJbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3ZHggPSB2ZXJ0aWNlc1tpXS5YIC0gdmVydGljZXNbc3RhcnRJbmRleF0uWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXdkeSA9IHZlcnRpY2VzW2ldLlkgLSB2ZXJ0aWNlc1tzdGFydEluZGV4XS5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ybSA9IChmbG9hdClNYXRoLlNxcnQobmV3ZHggKiBuZXdkeCArIG5ld2R5ICogbmV3ZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ybSA9IChucm0gPT0gMC4wZikgPyAxLjBmIDogbnJtO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld2R4IC89IG5ybTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdkeSAvPSBucm07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vRG90IHByb2R1Y3RzIGFjdCBhcyBwcm94eSBmb3IgYW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAvL3dpdGhvdXQgcmVxdWlyaW5nIGludmVyc2UgdHJpZy5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXdEb3QgPSBuZXdkeCAqIGR4ICsgbmV3ZHkgKiBkeTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3RG90ID4gbWF4RG90KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RG90ID0gbmV3RG90O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5JbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWRnZUxpc3RbbnVtRWRnZXMrK10gPSB3aW5JbmRleDtcclxuICAgICAgICAgICAgICAgIGR4ID0gdmVydGljZXNbd2luSW5kZXhdLlggLSB2ZXJ0aWNlc1tzdGFydEluZGV4XS5YO1xyXG4gICAgICAgICAgICAgICAgZHkgPSB2ZXJ0aWNlc1t3aW5JbmRleF0uWSAtIHZlcnRpY2VzW3N0YXJ0SW5kZXhdLlk7XHJcbiAgICAgICAgICAgICAgICBucm0gPSAoZmxvYXQpTWF0aC5TcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgICAgICAgICAgICAgIG5ybSA9IChucm0gPT0gMC4wZikgPyAxLjBmIDogbnJtO1xyXG4gICAgICAgICAgICAgICAgZHggLz0gbnJtO1xyXG4gICAgICAgICAgICAgICAgZHkgLz0gbnJtO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHdpbkluZGV4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyByZXR1cm5WYWwgPSBuZXcgVmVydGljZXMobnVtRWRnZXMpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwuQWRkKHZlcnRpY2VzW2VkZ2VMaXN0W2ldXSk7XHJcbiAgICAgICAgICAgICAgICAvL0RlYnVnLldyaXRlTGluZShzdHJpbmcuRm9ybWF0KFwiezB9LCB7MX1cIiwgdmVydGljZXNbZWRnZUxpc3RbaV1dLlgsIHZlcnRpY2VzW2VkZ2VMaXN0W2ldXS5ZKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vTm90IHN1cmUgaWYgd2UgbmVlZCB0aGlzXHJcbiAgICAgICAgICAgIC8vcmV0dXJuVmFsLk1lcmdlUGFyYWxsZWxFZGdlcyhTZXR0aW5ncy5iMl9hbmd1bGFyU2xvcCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5Db252ZXhIdWxsXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgTWVsa21hblxyXG4gICAge1xyXG4gICAgICAgIC8vTWVsa21hbiBiYXNlZCBjb252ZXggaHVsbCBhbGdvcml0aG0gY29udHJpYnV0ZWQgYnkgQ293ZG96ZXJcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgY29udmV4IGh1bGwuXHJcbiAgICAgICAgLy8vIE5vdGU6XHJcbiAgICAgICAgLy8vIDEuIFZlcnRpY2VzIG11c3QgYmUgb2YgYSBzaW1wbGUgcG9seWdvbiwgaS5lLiBlZGdlcyBkbyBub3Qgb3ZlcmxhcC5cclxuICAgICAgICAvLy8gMi4gTWVsa21hbiBkb2VzIG5vdCB3b3JrIG9uIHBvaW50IGNsb3Vkc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlxyXG4gICAgICAgIC8vLyBJbXBsZW1lbnRlZCB1c2luZyBNZWxrbWFuJ3MgQ29udmV4IEh1bGwgQWxnb3JpdGhtIC0gTyhuKSB0aW1lIGNvbXBsZXhpdHkuXHJcbiAgICAgICAgLy8vIFJlZmVyZW5jZTogaHR0cDovL3d3dy5hbXMuc3VueXNiLmVkdS9+anNibS9jb3Vyc2VzLzM0NS9tZWxrbWFuLnBkZlxyXG4gICAgICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgY29udmV4IGh1bGwgaW4gY291bnRlcmNsb2Nrd2lzZSB3aW5kaW5nIG9yZGVyLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIEdldENvbnZleEh1bGwoVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1dpdGggbGVzcyB0aGFuIDMgdmVydGljZXMsIHRoaXMgaXMgYWJvdXQgdGhlIGJlc3Qgd2UgY2FuIGRvIGZvciBhIGNvbnZleCBodWxsXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICAvL1dlJ2xsIG5ldmVyIG5lZWQgYSBxdWV1ZSBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBudW1iZXIgb2YgVmVydGljZXMgKzFcclxuICAgICAgICAgICAgLy9DcmVhdGUgZG91YmxlLWVuZGVkIHF1ZXVlXHJcbiAgICAgICAgICAgIFZlY3RvcjJbXSBkZXF1ZSA9IG5ldyBWZWN0b3IyW3ZlcnRpY2VzLkNvdW50ICsgMV07XHJcbiAgICAgICAgICAgIGludCBxZiA9IDMsIHFiID0gMDsgLy9RdWV1ZSBmcm9udCBpbmRleCwgcXVldWUgYmFjayBpbmRleFxyXG4gICAgICAgICAgICBpbnQgcWZtMSwgcWJtMTsgLy9xZm0xID0gc2Vjb25kIGVsZW1lbnQsIHFibTEgPSBzZWNvbmQgbGFzdCBlbGVtZW50XHJcblxyXG4gICAgICAgICAgICAvL1N0YXJ0IGJ5IHBsYWNpbmcgZmlyc3QgMyB2ZXJ0aWNlcyBpbiBjb252ZXggQ0NXIG9yZGVyXHJcbiAgICAgICAgICAgIGludCBzdGFydEluZGV4ID0gMztcclxuICAgICAgICAgICAgZmxvYXQgayA9IE1hdGhVdGlscy5BcmVhKHZlcnRpY2VzWzBdLCB2ZXJ0aWNlc1sxXSwgdmVydGljZXNbMl0pO1xyXG4gICAgICAgICAgICBpZiAoayA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL1ZlcnRpY2VzIGFyZSBjb2xsaW5lYXIuXHJcbiAgICAgICAgICAgICAgICBkZXF1ZVswXSA9IHZlcnRpY2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgZGVxdWVbMV0gPSB2ZXJ0aWNlc1syXTsgLy9XZSBjYW4gc2tpcCB2ZXJ0ZXggMSBiZWNhdXNlIGl0IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDJcclxuICAgICAgICAgICAgICAgIGRlcXVlWzJdID0gdmVydGljZXNbMF07XHJcbiAgICAgICAgICAgICAgICBxZiA9IDI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9HbyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBjb2xsaW5lYXIgc2VxdWVuY2Ugb2YgdmVydGljZXNcclxuICAgICAgICAgICAgICAgIGZvciAoc3RhcnRJbmRleCA9IDM7IHN0YXJ0SW5kZXggPCB2ZXJ0aWNlcy5Db3VudDsgc3RhcnRJbmRleCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdG1wID0gdmVydGljZXNbc3RhcnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGhVdGlscy5BcmVhKHJlZiBkZXF1ZVswXSwgcmVmIGRlcXVlWzFdLCByZWYgdG1wKSA9PSAwKSAvL1RoaXMgcG9pbnQgaXMgYWxzbyBjb2xsaW5lYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVxdWVbMV0gPSB2ZXJ0aWNlc1tzdGFydEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGVxdWVbMF0gPSBkZXF1ZVszXSA9IHZlcnRpY2VzWzJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vSXMgTGVmdC4gIFNldCBkZXF1ZSA9IHsyLCAwLCAxLCAyfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlcXVlWzFdID0gdmVydGljZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZGVxdWVbMl0gPSB2ZXJ0aWNlc1sxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0lzIFJpZ2h0LiBTZXQgZGVxdWUgPSB7MiwgMSwgMCwgMn1cclxuICAgICAgICAgICAgICAgICAgICBkZXF1ZVsxXSA9IHZlcnRpY2VzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcXVlWzJdID0gdmVydGljZXNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHFmbTEgPSBxZiA9PSAwID8gZGVxdWUuTGVuZ3RoIC0gMSA6IHFmIC0gMTsgLy9xZm0xID0gcWYgLSAxO1xyXG4gICAgICAgICAgICBxYm0xID0gcWIgPT0gZGVxdWUuTGVuZ3RoIC0gMSA/IDAgOiBxYiArIDE7IC8vcWJtMSA9IHFiICsgMTtcclxuXHJcbiAgICAgICAgICAgIC8vQWRkIHZlcnRpY2VzIG9uZSBhdCBhIHRpbWUgYW5kIGFkanVzdCBjb252ZXggaHVsbCBhcyBuZWVkZWRcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IHN0YXJ0SW5kZXg7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG5leHRQdCA9IHZlcnRpY2VzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vSWdub3JlIGlmIGl0IGlzIGFscmVhZHkgd2l0aGluIHRoZSBjb252ZXggaHVsbCB3ZSBoYXZlIGNvbnN0cnVjdGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aFV0aWxzLkFyZWEocmVmIGRlcXVlW3FmbTFdLCByZWYgZGVxdWVbcWZdLCByZWYgbmV4dFB0KSA+IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQXJlYShyZWYgZGVxdWVbcWJdLCByZWYgZGVxdWVbcWJtMV0sIHJlZiBuZXh0UHQpID4gMClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1BvcCBmcm9udCB1bnRpbCBjb252ZXhcclxuICAgICAgICAgICAgICAgIHdoaWxlICghKE1hdGhVdGlscy5BcmVhKHJlZiBkZXF1ZVtxZm0xXSwgcmVmIGRlcXVlW3FmXSwgcmVmIG5leHRQdCkgPiAwKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1BvcCB0aGUgZnJvbnQgZWxlbWVudCBmcm9tIHRoZSBxdWV1ZVxyXG4gICAgICAgICAgICAgICAgICAgIHFmID0gcWZtMTsgLy9xZi0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHFmbTEgPSBxZiA9PSAwID8gZGVxdWUuTGVuZ3RoIC0gMSA6IHFmIC0gMTsgLy9xZm0xID0gcWYgLSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9BZGQgdmVydGV4IHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgICAgICAgICAgICAgIHFmID0gcWYgPT0gZGVxdWUuTGVuZ3RoIC0gMSA/IDAgOiBxZiArIDE7IC8vcWYrKztcclxuICAgICAgICAgICAgICAgIHFmbTEgPSBxZiA9PSAwID8gZGVxdWUuTGVuZ3RoIC0gMSA6IHFmIC0gMTsgLy9xZm0xID0gcWYgLSAxO1xyXG4gICAgICAgICAgICAgICAgZGVxdWVbcWZdID0gbmV4dFB0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vUG9wIGJhY2sgdW50aWwgY29udmV4XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIShNYXRoVXRpbHMuQXJlYShyZWYgZGVxdWVbcWJdLCByZWYgZGVxdWVbcWJtMV0sIHJlZiBuZXh0UHQpID4gMCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Qb3AgdGhlIGJhY2sgZWxlbWVudCBmcm9tIHRoZSBxdWV1ZVxyXG4gICAgICAgICAgICAgICAgICAgIHFiID0gcWJtMTsgLy9xYisrO1xyXG4gICAgICAgICAgICAgICAgICAgIHFibTEgPSBxYiA9PSBkZXF1ZS5MZW5ndGggLSAxID8gMCA6IHFiICsgMTsgLy9xYm0xID0gcWIgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9BZGQgdmVydGV4IHRvIHRoZSBiYWNrIG9mIHRoZSBxdWV1ZVxyXG4gICAgICAgICAgICAgICAgcWIgPSBxYiA9PSAwID8gZGVxdWUuTGVuZ3RoIC0gMSA6IHFiIC0gMTsgLy9xYi0tO1xyXG4gICAgICAgICAgICAgICAgcWJtMSA9IHFiID09IGRlcXVlLkxlbmd0aCAtIDEgPyAwIDogcWIgKyAxOyAvL3FibTEgPSBxYiArIDE7XHJcbiAgICAgICAgICAgICAgICBkZXF1ZVtxYl0gPSBuZXh0UHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vQ3JlYXRlIHRoZSBjb252ZXggaHVsbCBmcm9tIHdoYXQgaXMgbGVmdCBpbiB0aGUgZGVxdWVcclxuICAgICAgICAgICAgVmVydGljZXMgY29udmV4SHVsbCA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcy5Db3VudCArIDEpO1xyXG4gICAgICAgICAgICBpZiAocWIgPCBxZilcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSBxYjsgaSA8IHFmOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgY29udmV4SHVsbC5BZGQoZGVxdWVbaV0pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcWY7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBjb252ZXhIdWxsLkFkZChkZXF1ZVtpXSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gcWI7IGkgPCBkZXF1ZS5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBjb252ZXhIdWxsLkFkZChkZXF1ZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnZleEh1bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5Qb2x5Z29uTWFuaXB1bGF0aW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvblxyXG57XHJcbiAgICAvL0Zyb20gcGhlZCByZXYgMzZcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQ29udmV4IGRlY29tcG9zaXRpb24gYWxnb3JpdGhtIGNyZWF0ZWQgYnkgTWFyayBCYXlheml0IChodHRwOi8vbW5iYXlheml0LmNvbS8pXHJcbiAgICAvLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBhbGdvcml0aG0sIHNlZSBodHRwOi8vbW5iYXlheml0LmNvbS80MDYvYmF5YXppdFxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgQmF5YXppdERlY29tcG9zZXJcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBWZWN0b3IyIEF0KGludCBpLCBWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBzID0gdmVydGljZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlc1tpIDwgMCA/IHMgLSAoLWkgJSBzKSA6IGkgJSBzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlcnRpY2VzIENvcHkoaW50IGksIGludCBqLCBWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHAgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgd2hpbGUgKGogPCBpKSBqICs9IHZlcnRpY2VzLkNvdW50O1xyXG4gICAgICAgICAgICAvL3AucmVzZXJ2ZShqIC0gaSArIDEpO1xyXG4gICAgICAgICAgICBmb3IgKDsgaSA8PSBqOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHAuQWRkKEF0KGksIHZlcnRpY2VzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlY29tcG9zZSB0aGUgcG9seWdvbiBpbnRvIHNldmVyYWwgc21hbGxlciBub24tY29uY2F2ZSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyBJZiB0aGUgcG9seWdvbiBpcyBhbHJlYWR5IGNvbnZleCwgaXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIHBvbHlnb24sIHVubGVzcyBpdCBpcyBvdmVyIFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcy5cclxuICAgICAgICAvLy8gUHJlY29uZGl0aW9uOiBDb3VudGVyIENsb2Nrd2lzZSBwb2x5Z29uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IENvbnZleFBhcnRpdGlvbihWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vV2UgZm9yY2UgaXQgdG8gQ0NXIGFzIGl0IGlzIGEgcHJlY29uZGl0aW9uIGluIHRoaXMgYWxnb3JpdGhtLlxyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5Gb3JjZUNvdW50ZXJDbG9ja1dpc2UoKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IGxpc3QgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuICAgICAgICAgICAgZmxvYXQgZCwgbG93ZXJEaXN0LCB1cHBlckRpc3Q7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDtcclxuICAgICAgICAgICAgVmVjdG9yMiBsb3dlckludCA9IG5ldyBWZWN0b3IyKCk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdXBwZXJJbnQgPSBuZXcgVmVjdG9yMigpOyAvLyBpbnRlcnNlY3Rpb24gcG9pbnRzXHJcbiAgICAgICAgICAgIGludCBsb3dlckluZGV4ID0gMCwgdXBwZXJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIGxvd2VyUG9seSwgdXBwZXJQb2x5O1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUmVmbGV4KGksIHZlcnRpY2VzKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsb3dlckRpc3QgPSB1cHBlckRpc3QgPSBmbG9hdC5NYXhWYWx1ZTsgLy8gc3RkOjpudW1lcmljX2xpbWl0czxxcmVhbD46Om1heCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgdmVydGljZXMuQ291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExlZnQoQXQoaSAtIDEsIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpLCBBdChqLCB2ZXJ0aWNlcykpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSaWdodE9uKEF0KGkgLSAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSwgQXQoaiAtIDEsIHZlcnRpY2VzKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IExpbmVUb29scy5MaW5lSW50ZXJzZWN0KEF0KGkgLSAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF0KGogLSAxLCB2ZXJ0aWNlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJpZ2h0KEF0KGkgKyAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSwgcCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGl0J3MgaW5zaWRlIHRoZSBwb2x5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFNxdWFyZURpc3QoQXQoaSwgdmVydGljZXMpLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGxvd2VyRGlzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgb25seSB0aGUgY2xvc2VzdCBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJEaXN0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMZWZ0KEF0KGkgKyAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSwgQXQoaiArIDEsIHZlcnRpY2VzKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJpZ2h0T24oQXQoaSArIDEsIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpLCBBdChqLCB2ZXJ0aWNlcykpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gTGluZVRvb2xzLkxpbmVJbnRlcnNlY3QoQXQoaSArIDEsIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpLCBBdChqLCB2ZXJ0aWNlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXQoaiArIDEsIHZlcnRpY2VzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTGVmdChBdChpIC0gMSwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcyksIHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBTcXVhcmVEaXN0KEF0KGksIHZlcnRpY2VzKSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHZlcnRpY2VzIHRvIGNvbm5lY3QgdG8sIGNob29zZSBhIHBvaW50IGluIHRoZSBtaWRkbGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA9PSAodXBwZXJJbmRleCArIDEpICUgdmVydGljZXMuQ291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHNwID0gKChsb3dlckludCArIHVwcGVySW50KSAvIDIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5ID0gQ29weShpLCB1cHBlckluZGV4LCB2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5BZGQoc3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkgPSBDb3B5KGxvd2VySW5kZXgsIGksIHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LkFkZChzcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZSBoaWdoZXN0U2NvcmUgPSAwLCBiZXN0SW5kZXggPSBsb3dlckluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodXBwZXJJbmRleCA8IGxvd2VySW5kZXgpIHVwcGVySW5kZXggKz0gdmVydGljZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsrailcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENhblNlZShpLCBqLCB2ZXJ0aWNlcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlIHNjb3JlID0gMSAvIChTcXVhcmVEaXN0KEF0KGksIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSZWZsZXgoaiwgdmVydGljZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJpZ2h0T24oQXQoaiAtIDEsIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcykpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMZWZ0T24oQXQoaiArIDEsIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcykpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZSArPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmUgKz0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29yZSArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiBoaWdoZXN0U2NvcmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0SW5kZXggPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0U2NvcmUgPSBzY29yZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5ID0gQ29weShpLCAoaW50KWJlc3RJbmRleCwgdmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkgPSBDb3B5KChpbnQpYmVzdEluZGV4LCBpLCB2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QuQWRkUmFuZ2UoQ29udmV4UGFydGl0aW9uKGxvd2VyUG9seSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QuQWRkUmFuZ2UoQ29udmV4UGFydGl0aW9uKHVwcGVyUG9seSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBwb2x5Z29uIGlzIGFscmVhZHkgY29udmV4XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA+IFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbG93ZXJQb2x5ID0gQ29weSgwLCB2ZXJ0aWNlcy5Db3VudCAvIDIsIHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgIHVwcGVyUG9seSA9IENvcHkodmVydGljZXMuQ291bnQgLyAyLCAwLCB2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICBsaXN0LkFkZFJhbmdlKENvbnZleFBhcnRpdGlvbihsb3dlclBvbHkpKTtcclxuICAgICAgICAgICAgICAgIGxpc3QuQWRkUmFuZ2UoQ29udmV4UGFydGl0aW9uKHVwcGVyUG9seSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGxpc3QuQWRkKHZlcnRpY2VzKTtcclxuXHJcbiAgICAgICAgICAgIC8vVGhlIHBvbHlnb25zIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSB3aXRob3V0IGNvbGxpbmVhciBwb2ludHMuIFdlIHJlbW92ZVxyXG4gICAgICAgICAgICAvL3RoZW0gdG8gYmUgc3VyZS5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBsaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxpc3RbaV0gPSBTaW1wbGlmeVRvb2xzLkNvbGxpbmVhclNpbXBsaWZ5KGxpc3RbaV0sIDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1JlbW92ZSBlbXB0eSB2ZXJ0aWNlIGNvbGxlY3Rpb25zXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBsaXN0LkNvdW50IC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0W2ldLkNvdW50ID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5SZW1vdmVBdChpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIENhblNlZShpbnQgaSwgaW50IGosIFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFJlZmxleChpLCB2ZXJ0aWNlcykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChMZWZ0T24oQXQoaSwgdmVydGljZXMpLCBBdChpIC0gMSwgdmVydGljZXMpLCBBdChqLCB2ZXJ0aWNlcykpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgUmlnaHRPbihBdChpLCB2ZXJ0aWNlcyksIEF0KGkgKyAxLCB2ZXJ0aWNlcyksIEF0KGosIHZlcnRpY2VzKSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChSaWdodE9uKEF0KGksIHZlcnRpY2VzKSwgQXQoaSArIDEsIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIExlZnRPbihBdChpLCB2ZXJ0aWNlcyksIEF0KGkgLSAxLCB2ZXJ0aWNlcyksIEF0KGosIHZlcnRpY2VzKSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoUmVmbGV4KGosIHZlcnRpY2VzKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKExlZnRPbihBdChqLCB2ZXJ0aWNlcyksIEF0KGogLSAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBSaWdodE9uKEF0KGosIHZlcnRpY2VzKSwgQXQoaiArIDEsIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFJpZ2h0T24oQXQoaiwgdmVydGljZXMpLCBBdChqICsgMSwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgTGVmdE9uKEF0KGosIHZlcnRpY2VzKSwgQXQoaiAtIDEsIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaW50IGsgPSAwOyBrIDwgdmVydGljZXMuQ291bnQ7ICsraylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKChrICsgMSkgJSB2ZXJ0aWNlcy5Db3VudCA9PSBpIHx8IGsgPT0gaSB8fCAoayArIDEpICUgdmVydGljZXMuQ291bnQgPT0gaiB8fCBrID09IGopXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGlnbm9yZSBpbmNpZGVudCBlZGdlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpbnRlcnNlY3Rpb25Qb2ludDtcclxuICAgICAgICAgICAgICAgIGlmIChMaW5lVG9vbHMuTGluZUludGVyc2VjdChBdChpLCB2ZXJ0aWNlcyksIEF0KGosIHZlcnRpY2VzKSwgQXQoaywgdmVydGljZXMpLCBBdChrICsgMSwgdmVydGljZXMpLCBvdXQgaW50ZXJzZWN0aW9uUG9pbnQpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHByZWNvbmRpdGlvbjogY2N3XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBSZWZsZXgoaW50IGksIFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJpZ2h0KGksIHZlcnRpY2VzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgUmlnaHQoaW50IGksIFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJpZ2h0KEF0KGkgLSAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSwgQXQoaSArIDEsIHZlcnRpY2VzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIExlZnQoVmVjdG9yMiBhLCBWZWN0b3IyIGIsIFZlY3RvcjIgYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuQXJlYShyZWYgYSwgcmVmIGIsIHJlZiBjKSA+IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIExlZnRPbihWZWN0b3IyIGEsIFZlY3RvcjIgYiwgVmVjdG9yMiBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5BcmVhKHJlZiBhLCByZWYgYiwgcmVmIGMpID49IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIFJpZ2h0KFZlY3RvcjIgYSwgVmVjdG9yMiBiLCBWZWN0b3IyIGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLkFyZWEocmVmIGEsIHJlZiBiLCByZWYgYykgPCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBSaWdodE9uKFZlY3RvcjIgYSwgVmVjdG9yMiBiLCBWZWN0b3IyIGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLkFyZWEocmVmIGEsIHJlZiBiLCByZWYgYykgPD0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IFNxdWFyZURpc3QoVmVjdG9yMiBhLCBWZWN0b3IyIGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBkeCA9IGIuWCAtIGEuWDtcclxuICAgICAgICAgICAgZmxvYXQgZHkgPSBiLlkgLSBhLlk7XHJcbiAgICAgICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uO1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5O1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5LlN3ZWVwO1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLlBvbHlnb247XHJcblxyXG51c2luZyBTeXN0ZW0uTGlucTtcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvblxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIENEVERlY29tcG9zZXJcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IENvbnZleFBhcnRpdGlvbihWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvbHlnb24gcG9seSA9IG5ldyBQb2x5Z29uKCk7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChWZWN0b3IyIHZlcnRleCBpbiB2ZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcG9seS5Qb2ludHMuQWRkKG5ldyBUcmlhbmd1bGF0aW9uUG9pbnQodmVydGV4LlgsIHZlcnRleC5ZKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERUU3dlZXBDb250ZXh0IHRjeCA9IG5ldyBEVFN3ZWVwQ29udGV4dCgpO1xyXG4gICAgICAgICAgICB0Y3guUHJlcGFyZVRyaWFuZ3VsYXRpb24ocG9seSk7XHJcbiAgICAgICAgICAgIERUU3dlZXAuVHJpYW5ndWxhdGUodGN4KTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHJlc3VsdHMgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKERlbGF1bmF5VHJpYW5nbGUgdHJpYW5nbGUgaW4gcG9seS5UcmlhbmdsZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzIHYgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKFRyaWFuZ3VsYXRpb25Qb2ludCBwIGluIHRyaWFuZ2xlLlBvaW50cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2LkFkZChuZXcgVmVjdG9yMigoZmxvYXQpcC5YLCAoZmxvYXQpcC5ZKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLkFkZCh2KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IENvbnZleFBhcnRpdGlvbihEZXRlY3RlZFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9seWdvbiBwb2x5ID0gbmV3IFBvbHlnb24oKTtcclxuICAgICAgICAgICAgZm9yZWFjaCAodmFyIHZlcnRleCBpbiB2ZXJ0aWNlcylcclxuICAgICAgICAgICAgICAgIHBvbHkuUG9pbnRzLkFkZChuZXcgVHJpYW5ndWxhdGlvblBvaW50KHZlcnRleC5YLCB2ZXJ0ZXguWSkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLkhvbGVzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKHZhciBob2xlVmVydGljZXMgaW4gdmVydGljZXMuSG9sZXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgUG9seWdvbiBob2xlID0gbmV3IFBvbHlnb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3JlYWNoICh2YXIgdmVydGV4IGluIGhvbGVWZXJ0aWNlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZS5Qb2ludHMuQWRkKG5ldyBUcmlhbmd1bGF0aW9uUG9pbnQodmVydGV4LlgsIHZlcnRleC5ZKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBvbHkuQWRkSG9sZShob2xlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRFRTd2VlcENvbnRleHQgdGN4ID0gbmV3IERUU3dlZXBDb250ZXh0KCk7XHJcbiAgICAgICAgICAgIHRjeC5QcmVwYXJlVHJpYW5ndWxhdGlvbihwb2x5KTtcclxuICAgICAgICAgICAgRFRTd2VlcC5Ucmlhbmd1bGF0ZSh0Y3gpO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gcmVzdWx0cyA9IG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoRGVsYXVuYXlUcmlhbmdsZSB0cmlhbmdsZSBpbiBwb2x5LlRyaWFuZ2xlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVydGljZXMgdiA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoVHJpYW5ndWxhdGlvblBvaW50IHAgaW4gdHJpYW5nbGUuUG9pbnRzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHYuQWRkKG5ldyBWZWN0b3IyKChmbG9hdClwLlgsIChmbG9hdClwLlkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdHMuQWRkKHYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4gKiBDIyBWZXJzaW9uIFBvcnRlZCBieSBNYXR0IEJldHRjaGVyIGFuZCBJYW4gUXZpc3QgMjAwOS0yMDEwXHJcbiAqIFxyXG4gKiBPcmlnaW5hbCBDKysgVmVyc2lvbiBDb3B5cmlnaHQgKGMpIDIwMDcgRXJpYyBKb3JkYW5cclxuICpcclxuICogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcclxuICogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xyXG4gKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxyXG4gKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcclxuICogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxyXG4gKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XHJcbiAqIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XHJcbiAqIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXHJcbiAqIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxyXG4gKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxyXG4gKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxyXG4gKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXHJcbiAqIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uLlBvbHlnb25NYW5pcHVsYXRpb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5EZWNvbXBvc2l0aW9uXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBQb3J0ZWQgZnJvbSBqQm94MkQuIE9yaWdpbmFsIGF1dGhvcjogZXdqb3JkYW4gXHJcbiAgICAvLy8gVHJpYW5ndWxhdGVzIGEgcG9seWdvbiB1c2luZyBzaW1wbGUgZWFyLWNsaXBwaW5nIGFsZ29yaXRobS5cclxuICAgIC8vLyBcclxuICAgIC8vLyBPbmx5IHdvcmtzIG9uIHNpbXBsZSBwb2x5Z29ucy5cclxuICAgIC8vLyBcclxuICAgIC8vLyBUcmlhbmdsZXMgbWF5IGJlIGRlZ2VuZXJhdGUsIGVzcGVjaWFsbHkgaWYgeW91IGhhdmUgaWRlbnRpY2FsIHBvaW50c1xyXG4gICAgLy8vIGluIHRoZSBpbnB1dCB0byB0aGUgYWxnb3JpdGhtLiAgQ2hlY2sgdGhpcyBiZWZvcmUgeW91IHVzZSB0aGVtLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgRWFyY2xpcERlY29tcG9zZXJcclxuICAgIHtcclxuICAgICAgICAvL2JveDJEIHJldiAzMiAtIGZvciBkZXRhaWxzLCBzZWUgaHR0cDovL3d3dy5ib3gyZC5vcmcvZm9ydW0vdmlld3RvcGljLnBocD9mPTQmdD04MyZzdGFydD01MFxyXG5cclxuICAgICAgICBwcml2YXRlIGNvbnN0IGZsb2F0IFRvbCA9IC4wMDFmO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlY29tcG9zZXMgYSBub24tY29udmV4IHBvbHlnb24gaW50byBhIG51bWJlciBvZiBjb252ZXggcG9seWdvbnMsIHVwXHJcbiAgICAgICAgLy8vIHRvIG1heFBvbHlzIChyZW1haW5pbmcgcGllY2VzIGFyZSB0aHJvd24gb3V0KS5cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gRWFjaCByZXN1bHRpbmcgcG9seWdvbiB3aWxsIGhhdmUgbm8gbW9yZSB0aGFuIFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlc1xyXG4gICAgICAgIC8vLyB2ZXJ0aWNlcy5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIFdhcm5pbmc6IE9ubHkgd29ya3Mgb24gc2ltcGxlIHBvbHlnb25zXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBDb252ZXhQYXJ0aXRpb24oVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29udmV4UGFydGl0aW9uKHZlcnRpY2VzLCBpbnQuTWF4VmFsdWUsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZWNvbXBvc2VzIGEgbm9uLWNvbnZleCBwb2x5Z29uIGludG8gYSBudW1iZXIgb2YgY29udmV4IHBvbHlnb25zLCB1cFxyXG4gICAgICAgIC8vLyB0byBtYXhQb2x5cyAocmVtYWluaW5nIHBpZWNlcyBhcmUgdGhyb3duIG91dCkuXHJcbiAgICAgICAgLy8vIEVhY2ggcmVzdWx0aW5nIHBvbHlnb24gd2lsbCBoYXZlIG5vIG1vcmUgdGhhbiBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXNcclxuICAgICAgICAvLy8gdmVydGljZXMuXHJcbiAgICAgICAgLy8vIFdhcm5pbmc6IE9ubHkgd29ya3Mgb24gc2ltcGxlIHBvbHlnb25zXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heFBvbHlzXCI+VGhlIG1heGltdW0gbnVtYmVyIG9mIHBvbHlnb25zLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidG9sZXJhbmNlXCI+VGhlIHRvbGVyYW5jZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBDb252ZXhQYXJ0aXRpb24oVmVydGljZXMgdmVydGljZXMsIGludCBtYXhQb2x5cywgZmxvYXQgdG9sZXJhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLkNvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWw6OkJyaWRnZS5TY3JpcHQuQ2FsbEZvcihuZXcgTGlzdDxWZXJ0aWNlcz4oKSwoX28xKT0+e19vMS5BZGQodmVydGljZXMpO3JldHVybiBfbzE7fSk7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Jc0NvbnZleCgpICYmIHZlcnRpY2VzLkNvdW50IDw9IFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzLklzQ291bnRlckNsb2NrV2lzZSgpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzIHRlbXBQID0gbmV3IFZlcnRpY2VzKHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wUC5SZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFAgPSBTaW1wbGlmeVRvb2xzLkNvbGxpbmVhclNpbXBsaWZ5KHRlbXBQKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wUC5Gb3JjZUNvdW50ZXJDbG9ja1dpc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpc3Q8VmVydGljZXM+IHsgdGVtcFAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzID0gU2ltcGxpZnlUb29scy5Db2xsaW5lYXJTaW1wbGlmeSh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5Gb3JjZUNvdW50ZXJDbG9ja1dpc2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdDxWZXJ0aWNlcz4geyB2ZXJ0aWNlcyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIExpc3Q8VHJpYW5nbGU+IHRyaWFuZ3VsYXRlZDtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Jc0NvdW50ZXJDbG9ja1dpc2UoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVydGljZXMgdGVtcFAgPSBuZXcgVmVydGljZXModmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgdGVtcFAuUmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgdHJpYW5ndWxhdGVkID0gVHJpYW5ndWxhdGVQb2x5Z29uKHRlbXBQKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyaWFuZ3VsYXRlZCA9IFRyaWFuZ3VsYXRlUG9seWdvbih2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyaWFuZ3VsYXRlZC5Db3VudCA8IDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vU3RpbGwgbm8gbHVjaz8gIE9oIHdlbGwuLi5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJDYW4ndCB0cmlhbmd1bGF0ZSB5b3VyIHBvbHlnb24uXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiBwb2x5Z29uaXplZFRyaWFuZ2xlcyA9IFBvbHlnb25pemVUcmlhbmdsZXModHJpYW5ndWxhdGVkLCBtYXhQb2x5cywgdG9sZXJhbmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vVGhlIHBvbHlnb25pemVkIHRyaWFuZ2xlcyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgd2l0aG91dCBjb2xsaW5lYXIgcG9pbnRzLiBXZSByZW1vdmVcclxuICAgICAgICAgICAgLy90aGVtIHRvIGJlIHN1cmUuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcG9seWdvbml6ZWRUcmlhbmdsZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbml6ZWRUcmlhbmdsZXNbaV0gPSBTaW1wbGlmeVRvb2xzLkNvbGxpbmVhclNpbXBsaWZ5KHBvbHlnb25pemVkVHJpYW5nbGVzW2ldLCAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9SZW1vdmUgZW1wdHkgdmVydGljZSBjb2xsZWN0aW9uc1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gcG9seWdvbml6ZWRUcmlhbmdsZXMuQ291bnQgLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb25pemVkVHJpYW5nbGVzW2ldLkNvdW50ID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbml6ZWRUcmlhbmdsZXMuUmVtb3ZlQXQoaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uaXplZFRyaWFuZ2xlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHVybnMgYSBsaXN0IG9mIHRyaWFuZ2xlcyBpbnRvIGEgbGlzdCBvZiBjb252ZXggcG9seWdvbnMuIFZlcnkgc2ltcGxlXHJcbiAgICAgICAgLy8vIG1ldGhvZCAtIHN0YXJ0IHdpdGggYSBzZWVkIHRyaWFuZ2xlLCBrZWVwIGFkZGluZyB0cmlhbmdsZXMgdG8gaXQgdW50aWxcclxuICAgICAgICAvLy8geW91IGNhbid0IGFkZCBhbnkgbW9yZSB3aXRob3V0IG1ha2luZyB0aGUgcG9seWdvbiBub24tY29udmV4LlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIGludGVnZXIgdGVsbGluZyBob3cgbWFueSBwb2x5Z29ucyB3ZXJlIGNyZWF0ZWQuICBXaWxsIGZpbGxcclxuICAgICAgICAvLy8gcG9seXMgYXJyYXkgdXAgdG8gcG9seXNMZW5ndGggZW50cmllcywgd2hpY2ggbWF5IGJlIHNtYWxsZXIgb3IgbGFyZ2VyXHJcbiAgICAgICAgLy8vIHRoYW4gdGhlIHJldHVybiB2YWx1ZS5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIFRha2VzIE8oTi8vL1ApIHdoZXJlIFAgaXMgdGhlIG51bWJlciBvZiByZXN1bHRhbnQgcG9seWdvbnMsIE4gaXMgdHJpYW5nbGVcclxuICAgICAgICAvLy8gY291bnQuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBUaGUgZmluYWwgcG9seWdvbiBsaXN0IHdpbGwgbm90IG5lY2Vzc2FyaWx5IGJlIG1pbmltYWwsIHRob3VnaCBpblxyXG4gICAgICAgIC8vLyBwcmFjdGljZSBpdCB3b3JrcyBmYWlybHkgd2VsbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyaWFuZ3VsYXRlZFwiPlRoZSB0cmlhbmd1bGF0ZWQuPC9wYXJhbT5cclxuICAgICAgICAvLy88cGFyYW0gbmFtZT1cIm1heFBvbHlzXCI+VGhlIG1heGltdW4gbnVtYmVyIG9mIHBvbHlnb25zPC9wYXJhbT5cclxuICAgICAgICAvLy88cGFyYW0gbmFtZT1cInRvbGVyYW5jZVwiPlRoZSB0b2xlcmFuY2U8L3BhcmFtPlxyXG4gICAgICAgIC8vLzxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IFBvbHlnb25pemVUcmlhbmdsZXMoTGlzdDxUcmlhbmdsZT4gdHJpYW5ndWxhdGVkLCBpbnQgbWF4UG9seXMsIGZsb2F0IHRvbGVyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHBvbHlzID0gbmV3IExpc3Q8VmVydGljZXM+KDUwKTtcclxuXHJcbiAgICAgICAgICAgIGludCBwb2x5SW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRyaWFuZ3VsYXRlZC5Db3VudCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiBlbXB0eSBwb2x5Z29uIGxpc3RcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb2x5cztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYm9vbFtdIGNvdmVyZWQgPSBuZXcgYm9vbFt0cmlhbmd1bGF0ZWQuQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHRyaWFuZ3VsYXRlZC5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb3ZlcmVkW2ldID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9DaGVjayBoZXJlIGZvciBkZWdlbmVyYXRlIHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICAgICAgaWYgKCgodHJpYW5ndWxhdGVkW2ldLlhbMF0gPT0gdHJpYW5ndWxhdGVkW2ldLlhbMV0pICYmICh0cmlhbmd1bGF0ZWRbaV0uWVswXSA9PSB0cmlhbmd1bGF0ZWRbaV0uWVsxXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKHRyaWFuZ3VsYXRlZFtpXS5YWzFdID09IHRyaWFuZ3VsYXRlZFtpXS5YWzJdKSAmJiAodHJpYW5ndWxhdGVkW2ldLllbMV0gPT0gdHJpYW5ndWxhdGVkW2ldLllbMl0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCh0cmlhbmd1bGF0ZWRbaV0uWFswXSA9PSB0cmlhbmd1bGF0ZWRbaV0uWFsyXSkgJiYgKHRyaWFuZ3VsYXRlZFtpXS5ZWzBdID09IHRyaWFuZ3VsYXRlZFtpXS5ZWzJdKSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY292ZXJlZFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJvb2wgbm90RG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHdoaWxlIChub3REb25lKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgY3VyclRyaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB0cmlhbmd1bGF0ZWQuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZFtpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyclRyaSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VyclRyaSA9PSAtMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBub3REb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGljZXMgcG9seSA9IG5ldyBWZXJ0aWNlcygzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5LkFkZChuZXcgVmVjdG9yMih0cmlhbmd1bGF0ZWRbY3VyclRyaV0uWFtpXSwgdHJpYW5ndWxhdGVkW2N1cnJUcmldLllbaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWRbY3VyclRyaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAyICogdHJpYW5ndWxhdGVkLkNvdW50OyArK2ksICsraW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPj0gdHJpYW5ndWxhdGVkLkNvdW50KSBpbmRleCAtPSB0cmlhbmd1bGF0ZWQuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkW2luZGV4XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljZXMgbmV3UCA9IEFkZFRyaWFuZ2xlKHRyaWFuZ3VsYXRlZFtpbmRleF0sIHBvbHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIGlzIHRoaXMgcmlnaHRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQLkNvdW50ID4gU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UC5Jc0NvbnZleCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL09yIHNob3VsZCBpdCBiZSBJc1VzYWJsZT8gIE1heWJlIHJlLXdyaXRlIElzQ29udmV4IHRvIGFwcGx5IHRoZSBhbmdsZSB0aHJlc2hvbGQgZnJvbSBCb3gyZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seSA9IG5ldyBWZXJ0aWNlcyhuZXdQKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWRbaW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9XZSBoYXZlIGEgbWF4aW11bSBvZiBwb2x5Z29ucyB0aGF0IHdlIG5lZWQgdG8ga2VlcCB1bmRlci5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9seUluZGV4IDwgbWF4UG9seXMpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1NpbXBsaWZ5VG9vbHMuTWVyZ2VQYXJhbGxlbEVkZ2VzKHBvbHksIHRvbGVyYW5jZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0lmIGlkZW50aWNhbCBwb2ludHMgYXJlIHByZXNlbnQsIGEgdHJpYW5nbGUgZ2V0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2JvcmtlZCBieSB0aGUgTWVyZ2VQYXJhbGxlbEVkZ2VzIGZ1bmN0aW9uLCBoZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSB2ZXJ0ZXggbnVtYmVyIGNoZWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LkNvdW50ID49IDMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5cy5BZGQobmV3IFZlcnRpY2VzKHBvbHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9lbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHByaW50ZihcIlNraXBwaW5nIGNvcnJ1cHQgcG9seVxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHkuQ291bnQgPj0gMylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seUluZGV4Kys7IC8vTXVzdCBiZSBvdXRzaWRlIChwb2x5SW5kZXggPCBwb2x5c0xlbmd0aCkgdGVzdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcG9seXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gdXNpbmcgc2ltcGxlIGVhci1jbGlwcGluZyBhbGdvcml0aG0uIFJldHVybnNcclxuICAgICAgICAvLy8gc2l6ZSBvZiBUcmlhbmdsZSBhcnJheSB1bmxlc3MgdGhlIHBvbHlnb24gY2FuJ3QgYmUgdHJpYW5ndWxhdGVkLlxyXG4gICAgICAgIC8vLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgcG9seWdvbiBzZWxmLWludGVyc2VjdHMsXHJcbiAgICAgICAgLy8vIHRob3VnaCBpdCB3aWxsIG5vdCBfYWx3YXlzXyByZXR1cm4gbnVsbCBmb3IgYSBiYWQgcG9seWdvbiAtIGl0IGlzIHRoZVxyXG4gICAgICAgIC8vLyBjYWxsZXIncyByZXNwb25zaWJpbGl0eSB0byBjaGVjayBmb3Igc2VsZi1pbnRlcnNlY3Rpb24sIGFuZCBpZiBpdFxyXG4gICAgICAgIC8vLyBkb2Vzbid0LCBpdCBzaG91bGQgYXQgbGVhc3QgY2hlY2sgdGhhdCB0aGUgcmV0dXJuIHZhbHVlIGlzIG5vbi1udWxsXHJcbiAgICAgICAgLy8vIGJlZm9yZSB1c2luZy4gWW91J3JlIHdhcm5lZCFcclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gVHJpYW5nbGVzIG1heSBiZSBkZWdlbmVyYXRlLCBlc3BlY2lhbGx5IGlmIHlvdSBoYXZlIGlkZW50aWNhbCBwb2ludHNcclxuICAgICAgICAvLy8gaW4gdGhlIGlucHV0IHRvIHRoZSBhbGdvcml0aG0uICBDaGVjayB0aGlzIGJlZm9yZSB5b3UgdXNlIHRoZW0uXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIFRoaXMgaXMgdG90YWxseSB1bm9wdGltaXplZCwgc28gZm9yIGxhcmdlIHBvbHlnb25zIGl0IHNob3VsZCBub3QgYmUgcGFydFxyXG4gICAgICAgIC8vLyBvZiB0aGUgc2ltdWxhdGlvbiBsb29wLlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBPbmx5IHdvcmtzIG9uIHNpbXBsZSBwb2x5Z29ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFRyaWFuZ2xlPiBUcmlhbmd1bGF0ZVBvbHlnb24oVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaXN0PFRyaWFuZ2xlPiByZXN1bHRzID0gbmV3IExpc3Q8VHJpYW5nbGU+KCk7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpc3Q8VHJpYW5nbGU+KCk7XHJcblxyXG4gICAgICAgICAgICAvL1JlY3Vyc2UgYW5kIHNwbGl0IG9uIHBpbmNoIHBvaW50c1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBwQSwgcEI7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHBpbiA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgIGlmIChSZXNvbHZlUGluY2hQb2ludChwaW4sIG91dCBwQSwgb3V0IHBCKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTGlzdDxUcmlhbmdsZT4gbWVyZ2VBID0gVHJpYW5ndWxhdGVQb2x5Z29uKHBBKTtcclxuICAgICAgICAgICAgICAgIExpc3Q8VHJpYW5nbGU+IG1lcmdlQiA9IFRyaWFuZ3VsYXRlUG9seWdvbihwQik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlQS5Db3VudCA9PSAtMSB8fCBtZXJnZUIuQ291bnQgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIkNhbid0IHRyaWFuZ3VsYXRlIHlvdXIgcG9seWdvbi5cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtZXJnZUEuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLkFkZChuZXcgVHJpYW5nbGUobWVyZ2VBW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG1lcmdlQi5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuQWRkKG5ldyBUcmlhbmdsZShtZXJnZUJbaV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJpYW5nbGVbXSBidWZmZXIgPSBuZXcgVHJpYW5nbGVbdmVydGljZXMuQ291bnQgLSAyXTtcclxuICAgICAgICAgICAgaW50IGJ1ZmZlclNpemUgPSAwO1xyXG4gICAgICAgICAgICBmbG9hdFtdIHhyZW0gPSBuZXcgZmxvYXRbdmVydGljZXMuQ291bnRdO1xyXG4gICAgICAgICAgICBmbG9hdFtdIHlyZW0gPSBuZXcgZmxvYXRbdmVydGljZXMuQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHhyZW1baV0gPSB2ZXJ0aWNlc1tpXS5YO1xyXG4gICAgICAgICAgICAgICAgeXJlbVtpXSA9IHZlcnRpY2VzW2ldLlk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCB2TnVtID0gdmVydGljZXMuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAodk51bSA+IDMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgYW4gZWFyXHJcbiAgICAgICAgICAgICAgICBpbnQgZWFySW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGVhck1heE1pbkNyb3NzID0gLTEwLjBmO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2TnVtOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKElzRWFyKGksIHhyZW0sIHlyZW0sIHZOdW0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IGxvd2VyID0gUmVtYWluZGVyKGkgLSAxLCB2TnVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IHVwcGVyID0gUmVtYWluZGVyKGkgKyAxLCB2TnVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBkMSA9IG5ldyBWZWN0b3IyKHhyZW1bdXBwZXJdIC0geHJlbVtpXSwgeXJlbVt1cHBlcl0gLSB5cmVtW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBkMiA9IG5ldyBWZWN0b3IyKHhyZW1baV0gLSB4cmVtW2xvd2VyXSwgeXJlbVtpXSAtIHlyZW1bbG93ZXJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBkMyA9IG5ldyBWZWN0b3IyKHhyZW1bbG93ZXJdIC0geHJlbVt1cHBlcl0sIHlyZW1bbG93ZXJdIC0geXJlbVt1cHBlcl0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZDEuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQyLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3Jvc3MxMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiBkMSwgcmVmIGQyLCBvdXQgY3Jvc3MxMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzMTIgPSAoZmxvYXQpTWF0aC5BYnMoY3Jvc3MxMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjcm9zczIzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIGQyLCByZWYgZDMsIG91dCBjcm9zczIzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3MyMyA9IChmbG9hdClNYXRoLkFicyhjcm9zczIzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGNyb3NzMzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgZDMsIHJlZiBkMSwgb3V0IGNyb3NzMzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zczMxID0gKGZsb2F0KU1hdGguQWJzKGNyb3NzMzEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9GaW5kIHRoZSBtYXhpbXVtIG1pbmltdW0gYW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWluQ3Jvc3MgPSBNYXRoLk1pbihjcm9zczEyLCBNYXRoLk1pbihjcm9zczIzLCBjcm9zczMxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5Dcm9zcyA+IGVhck1heE1pbkNyb3NzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJNYXhNaW5Dcm9zcyA9IG1pbkNyb3NzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHN0aWxsIGhhdmVuJ3QgZm91bmQgYW4gZWFyLCB3ZSdyZSBzY3Jld2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogc29tZXRpbWVzIHRoaXMgaXMgaGFwcGVuaW5nIGJlY2F1c2UgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyByZW1haW5pbmcgcG9pbnRzIGFyZSBjb2xsaW5lYXIuICBSZWFsbHkgdGhlc2VcclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBqdXN0IGJlIHRocm93biBvdXQgd2l0aG91dCBoYWx0aW5nIHRyaWFuZ3VsYXRpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoZWFySW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBidWZmZXJTaXplOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLkFkZChuZXcgVHJpYW5nbGUoYnVmZmVyW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGlwIG9mZiB0aGUgZWFyOlxyXG4gICAgICAgICAgICAgICAgLy8gLSByZW1vdmUgdGhlIGVhciB0aXAgZnJvbSB0aGUgbGlzdFxyXG5cclxuICAgICAgICAgICAgICAgIC0tdk51bTtcclxuICAgICAgICAgICAgICAgIGZsb2F0W10gbmV3eCA9IG5ldyBmbG9hdFt2TnVtXTtcclxuICAgICAgICAgICAgICAgIGZsb2F0W10gbmV3eSA9IG5ldyBmbG9hdFt2TnVtXTtcclxuICAgICAgICAgICAgICAgIGludCBjdXJyRGVzdCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZOdW07ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyckRlc3QgPT0gZWFySW5kZXgpICsrY3VyckRlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3eFtpXSA9IHhyZW1bY3VyckRlc3RdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld3lbaV0gPSB5cmVtW2N1cnJEZXN0XTtcclxuICAgICAgICAgICAgICAgICAgICArK2N1cnJEZXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIC0gYWRkIHRoZSBjbGlwcGVkIHRyaWFuZ2xlIHRvIHRoZSB0cmlhbmdsZSBsaXN0XHJcbiAgICAgICAgICAgICAgICBpbnQgdW5kZXIgPSAoZWFySW5kZXggPT0gMCkgPyAodk51bSkgOiAoZWFySW5kZXggLSAxKTtcclxuICAgICAgICAgICAgICAgIGludCBvdmVyID0gKGVhckluZGV4ID09IHZOdW0pID8gMCA6IChlYXJJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgVHJpYW5nbGUgdG9BZGQgPSBuZXcgVHJpYW5nbGUoeHJlbVtlYXJJbmRleF0sIHlyZW1bZWFySW5kZXhdLCB4cmVtW292ZXJdLCB5cmVtW292ZXJdLCB4cmVtW3VuZGVyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlyZW1bdW5kZXJdKTtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltidWZmZXJTaXplXSA9IHRvQWRkO1xyXG4gICAgICAgICAgICAgICAgKytidWZmZXJTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIC0gcmVwbGFjZSB0aGUgb2xkIGxpc3Qgd2l0aCB0aGUgbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgeHJlbSA9IG5ld3g7XHJcbiAgICAgICAgICAgICAgICB5cmVtID0gbmV3eTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJpYW5nbGUgdG9vQWRkID0gbmV3IFRyaWFuZ2xlKHhyZW1bMV0sIHlyZW1bMV0sIHhyZW1bMl0sIHlyZW1bMl0sIHhyZW1bMF0sIHlyZW1bMF0pO1xyXG4gICAgICAgICAgICBidWZmZXJbYnVmZmVyU2l6ZV0gPSB0b29BZGQ7XHJcbiAgICAgICAgICAgICsrYnVmZmVyU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLkFkZChuZXcgVHJpYW5nbGUoYnVmZmVyW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kcyBhbmQgZml4ZXMgXCJwaW5jaCBwb2ludHMsXCIgcG9pbnRzIHdoZXJlIHR3byBwb2x5Z29uXHJcbiAgICAgICAgLy8vIHZlcnRpY2VzIGFyZSBhdCB0aGUgc2FtZSBwb2ludC5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIElmIGEgcGluY2ggcG9pbnQgaXMgZm91bmQsIHBpbiBpcyBicm9rZW4gdXAgaW50byBwb3V0QSBhbmQgcG91dEJcclxuICAgICAgICAvLy8gYW5kIHRydWUgaXMgcmV0dXJuZWQ7IG90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIE1vc3RseSBmb3IgaW50ZXJuYWwgdXNlLlxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gTyhOXjIpIHRpbWUsIHdoaWNoIHN1Y2tzLi4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwaW5cIj5UaGUgcGluLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG91dEFcIj5UaGUgcG91dCBBLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG91dEJcIj5UaGUgcG91dCBCLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIFJlc29sdmVQaW5jaFBvaW50KFZlcnRpY2VzIHBpbiwgb3V0IFZlcnRpY2VzIHBvdXRBLCBvdXQgVmVydGljZXMgcG91dEIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwb3V0QSA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICBwb3V0QiA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBpbi5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBib29sIGhhc1BpbmNoUG9pbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaW50IHBpbmNoSW5kZXhBID0gLTE7XHJcbiAgICAgICAgICAgIGludCBwaW5jaEluZGV4QiA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBpbi5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gaSArIDE7IGogPCBwaW4uQ291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0Rvbid0IHdvcnJ5IGFib3V0IHBpbmNoIHBvaW50cyB3aGVyZSB0aGUgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hcmUgYWN0dWFsbHkganVzdCBkdXBlIG5laWdoYm9yc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLkFicyhwaW5baV0uWCAtIHBpbltqXS5YKSA8IFRvbCAmJiBNYXRoLkFicyhwaW5baV0uWSAtIHBpbltqXS5ZKSA8IFRvbCAmJiBqICE9IGkgKyAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGluY2hJbmRleEEgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5jaEluZGV4QiA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1BpbmNoUG9pbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGluY2hQb2ludCkgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhc1BpbmNoUG9pbnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBzaXplQSA9IHBpbmNoSW5kZXhCIC0gcGluY2hJbmRleEE7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUEgPT0gcGluLkNvdW50KSByZXR1cm4gZmFsc2U7IC8vaGFzIGR1cGUgcG9pbnRzIGF0IHdyYXBhcm91bmQsIG5vdCBhIHByb2JsZW0gaGVyZVxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzaXplQTsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBpbmQgPSBSZW1haW5kZXIocGluY2hJbmRleEEgKyBpLCBwaW4uQ291bnQpOyAvLyBpcyB0aGlzIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgcG91dEEuQWRkKHBpbltpbmRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpbnQgc2l6ZUIgPSBwaW4uQ291bnQgLSBzaXplQTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgc2l6ZUI7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgaW5kID0gUmVtYWluZGVyKHBpbmNoSW5kZXhCICsgaSwgcGluLkNvdW50KTsgLy8gaXMgdGhpcyByaWdodCAgICBcclxuICAgICAgICAgICAgICAgICAgICBwb3V0Qi5BZGQocGluW2luZF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNQaW5jaFBvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXggZm9yIG9ibm94aW91cyBiZWhhdmlvciBmb3IgdGhlICUgb3BlcmF0b3IgZm9yIG5lZ2F0aXZlIG51bWJlcnMuLi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1vZHVsdXNcIj5UaGUgbW9kdWx1cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgaW50IFJlbWFpbmRlcihpbnQgeCwgaW50IG1vZHVsdXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgcmVtID0geCAlIG1vZHVsdXM7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZW0gPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZW0gKz0gbW9kdWx1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgVmVydGljZXMgQWRkVHJpYW5nbGUoVHJpYW5nbGUgdCwgVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCwgZmluZCB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RcclxuICAgICAgICAgICAgaW50IGZpcnN0UCA9IC0xO1xyXG4gICAgICAgICAgICBpbnQgZmlyc3RUID0gLTE7XHJcbiAgICAgICAgICAgIGludCBzZWNvbmRQID0gLTE7XHJcbiAgICAgICAgICAgIGludCBzZWNvbmRUID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHQuWFswXSA9PSB2ZXJ0aWNlc1tpXS5YICYmIHQuWVswXSA9PSB2ZXJ0aWNlc1tpXS5ZKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFAgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFAgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kVCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodC5YWzFdID09IHZlcnRpY2VzW2ldLlggJiYgdC5ZWzFdID09IHZlcnRpY2VzW2ldLlkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UCA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0VCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFAgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRUID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0LlhbMl0gPT0gdmVydGljZXNbaV0uWCAmJiB0LllbMl0gPT0gdmVydGljZXNbaV0uWSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RQID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RQID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RUID0gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFQgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGaXggb3JkZXJpbmcgaWYgZmlyc3Qgc2hvdWxkIGJlIGxhc3QgdmVydGV4IG9mIHBvbHlcclxuICAgICAgICAgICAgaWYgKGZpcnN0UCA9PSAwICYmIHNlY29uZFAgPT0gdmVydGljZXMuQ291bnQgLSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFAgPSB2ZXJ0aWNlcy5Db3VudCAtIDE7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmRQID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGlkbid0IGZpbmQgaXRcclxuICAgICAgICAgICAgaWYgKHNlY29uZFAgPT0gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRpcCBpbmRleCBvbiB0cmlhbmdsZVxyXG4gICAgICAgICAgICBpbnQgdGlwVCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aXBUID09IGZpcnN0VCB8fCB0aXBUID09IHNlY29uZFQpXHJcbiAgICAgICAgICAgICAgICB0aXBUID0gMTtcclxuICAgICAgICAgICAgaWYgKHRpcFQgPT0gZmlyc3RUIHx8IHRpcFQgPT0gc2Vjb25kVClcclxuICAgICAgICAgICAgICAgIHRpcFQgPSAyO1xyXG5cclxuICAgICAgICAgICAgVmVydGljZXMgcmVzdWx0ID0gbmV3IFZlcnRpY2VzKHZlcnRpY2VzLkNvdW50ICsgMSk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkFkZCh2ZXJ0aWNlc1tpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gZmlyc3RQKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BZGQobmV3IFZlY3RvcjIodC5YW3RpcFRdLCB0LllbdGlwVF0pKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hlY2tzIGlmIHZlcnRleCBpIGlzIHRoZSB0aXAgb2YgYW4gZWFyIGluIHBvbHlnb24gZGVmaW5lZCBieSB4dltdIGFuZFxyXG4gICAgICAgIC8vLyB5dltdLlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyBBc3N1bWVzIGNsb2Nrd2lzZSBvcmllbnRhdGlvbiBvZiBwb2x5Z29uLi4uaWNrXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpXCI+VGhlIGkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4dlwiPlRoZSB4di48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInl2XCI+VGhlIHl2LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieHZMZW5ndGhcIj5MZW5ndGggb2YgdGhlIHh2LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBcdDxjPnRydWU8L2M+IGlmIHRoZSBzcGVjaWZpZWQgaSBpcyBlYXI7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBJc0VhcihpbnQgaSwgZmxvYXRbXSB4diwgZmxvYXRbXSB5diwgaW50IHh2TGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgZHgwLCBkeTAsIGR4MSwgZHkxO1xyXG4gICAgICAgICAgICBpZiAoaSA+PSB4dkxlbmd0aCB8fCBpIDwgMCB8fCB4dkxlbmd0aCA8IDMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbnQgdXBwZXIgPSBpICsgMTtcclxuICAgICAgICAgICAgaW50IGxvd2VyID0gaSAtIDE7XHJcbiAgICAgICAgICAgIGlmIChpID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGR4MCA9IHh2WzBdIC0geHZbeHZMZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGR5MCA9IHl2WzBdIC0geXZbeHZMZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGR4MSA9IHh2WzFdIC0geHZbMF07XHJcbiAgICAgICAgICAgICAgICBkeTEgPSB5dlsxXSAtIHl2WzBdO1xyXG4gICAgICAgICAgICAgICAgbG93ZXIgPSB4dkxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSB4dkxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGR4MCA9IHh2W2ldIC0geHZbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgZHkwID0geXZbaV0gLSB5dltpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBkeDEgPSB4dlswXSAtIHh2W2ldO1xyXG4gICAgICAgICAgICAgICAgZHkxID0geXZbMF0gLSB5dltpXTtcclxuICAgICAgICAgICAgICAgIHVwcGVyID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGR4MCA9IHh2W2ldIC0geHZbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgZHkwID0geXZbaV0gLSB5dltpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBkeDEgPSB4dltpICsgMV0gLSB4dltpXTtcclxuICAgICAgICAgICAgICAgIGR5MSA9IHl2W2kgKyAxXSAtIHl2W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZsb2F0IGNyb3NzID0gZHgwICogZHkxIC0gZHgxICogZHkwO1xyXG4gICAgICAgICAgICBpZiAoY3Jvc3MgPiAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBUcmlhbmdsZSBteVRyaSA9IG5ldyBUcmlhbmdsZSh4dltpXSwgeXZbaV0sIHh2W3VwcGVyXSwgeXZbdXBwZXJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4dltsb3dlcl0sIHl2W2xvd2VyXSk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgeHZMZW5ndGg7ICsrailcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT0gaSB8fCBqID09IGxvd2VyIHx8IGogPT0gdXBwZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobXlUcmkuSXNJbnNpZGUoeHZbal0sIHl2W2pdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGFzcyBUcmlhbmdsZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdFtdIFg7XHJcbiAgICAgICAgcHVibGljIGZsb2F0W10gWTtcclxuXHJcbiAgICAgICAgLy9Db25zdHJ1Y3RvciBhdXRvbWF0aWNhbGx5IGZpeGVzIG9yaWVudGF0aW9uIHRvIGNjd1xyXG4gICAgICAgIHB1YmxpYyBUcmlhbmdsZShmbG9hdCB4MSwgZmxvYXQgeTEsIGZsb2F0IHgyLCBmbG9hdCB5MiwgZmxvYXQgeDMsIGZsb2F0IHkzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgWCA9IG5ldyBmbG9hdFszXTtcclxuICAgICAgICAgICAgWSA9IG5ldyBmbG9hdFszXTtcclxuICAgICAgICAgICAgZmxvYXQgZHgxID0geDIgLSB4MTtcclxuICAgICAgICAgICAgZmxvYXQgZHgyID0geDMgLSB4MTtcclxuICAgICAgICAgICAgZmxvYXQgZHkxID0geTIgLSB5MTtcclxuICAgICAgICAgICAgZmxvYXQgZHkyID0geTMgLSB5MTtcclxuICAgICAgICAgICAgZmxvYXQgY3Jvc3MgPSBkeDEgKiBkeTIgLSBkeDIgKiBkeTE7XHJcbiAgICAgICAgICAgIGJvb2wgY2N3ID0gKGNyb3NzID4gMCk7XHJcbiAgICAgICAgICAgIGlmIChjY3cpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFhbMF0gPSB4MTtcclxuICAgICAgICAgICAgICAgIFhbMV0gPSB4MjtcclxuICAgICAgICAgICAgICAgIFhbMl0gPSB4MztcclxuICAgICAgICAgICAgICAgIFlbMF0gPSB5MTtcclxuICAgICAgICAgICAgICAgIFlbMV0gPSB5MjtcclxuICAgICAgICAgICAgICAgIFlbMl0gPSB5MztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFhbMF0gPSB4MTtcclxuICAgICAgICAgICAgICAgIFhbMV0gPSB4MztcclxuICAgICAgICAgICAgICAgIFhbMl0gPSB4MjtcclxuICAgICAgICAgICAgICAgIFlbMF0gPSB5MTtcclxuICAgICAgICAgICAgICAgIFlbMV0gPSB5MztcclxuICAgICAgICAgICAgICAgIFlbMl0gPSB5MjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ2xlKFRyaWFuZ2xlIHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBYID0gbmV3IGZsb2F0WzNdO1xyXG4gICAgICAgICAgICBZID0gbmV3IGZsb2F0WzNdO1xyXG5cclxuICAgICAgICAgICAgWFswXSA9IHQuWFswXTtcclxuICAgICAgICAgICAgWFsxXSA9IHQuWFsxXTtcclxuICAgICAgICAgICAgWFsyXSA9IHQuWFsyXTtcclxuICAgICAgICAgICAgWVswXSA9IHQuWVswXTtcclxuICAgICAgICAgICAgWVsxXSA9IHQuWVsxXTtcclxuICAgICAgICAgICAgWVsyXSA9IHQuWVsyXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzSW5zaWRlKGZsb2F0IHgsIGZsb2F0IHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoeCA8IFhbMF0gJiYgeCA8IFhbMV0gJiYgeCA8IFhbMl0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHggPiBYWzBdICYmIHggPiBYWzFdICYmIHggPiBYWzJdKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh5IDwgWVswXSAmJiB5IDwgWVsxXSAmJiB5IDwgWVsyXSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoeSA+IFlbMF0gJiYgeSA+IFlbMV0gJiYgeSA+IFlbMl0pIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHZ4MiA9IHggLSBYWzBdO1xyXG4gICAgICAgICAgICBmbG9hdCB2eTIgPSB5IC0gWVswXTtcclxuICAgICAgICAgICAgZmxvYXQgdngxID0gWFsxXSAtIFhbMF07XHJcbiAgICAgICAgICAgIGZsb2F0IHZ5MSA9IFlbMV0gLSBZWzBdO1xyXG4gICAgICAgICAgICBmbG9hdCB2eDAgPSBYWzJdIC0gWFswXTtcclxuICAgICAgICAgICAgZmxvYXQgdnkwID0gWVsyXSAtIFlbMF07XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBkb3QwMCA9IHZ4MCAqIHZ4MCArIHZ5MCAqIHZ5MDtcclxuICAgICAgICAgICAgZmxvYXQgZG90MDEgPSB2eDAgKiB2eDEgKyB2eTAgKiB2eTE7XHJcbiAgICAgICAgICAgIGZsb2F0IGRvdDAyID0gdngwICogdngyICsgdnkwICogdnkyO1xyXG4gICAgICAgICAgICBmbG9hdCBkb3QxMSA9IHZ4MSAqIHZ4MSArIHZ5MSAqIHZ5MTtcclxuICAgICAgICAgICAgZmxvYXQgZG90MTIgPSB2eDEgKiB2eDIgKyB2eTEgKiB2eTI7XHJcbiAgICAgICAgICAgIGZsb2F0IGludkRlbm9tID0gMS4wZiAvIChkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSk7XHJcbiAgICAgICAgICAgIGZsb2F0IHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XHJcbiAgICAgICAgICAgIGZsb2F0IHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCh1ID4gMCkgJiYgKHYgPiAwKSAmJiAodSArIHYgPCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvblxyXG57XHJcbiAgICAvL0Zyb20gdGhlIFBvbHkyVHJpIHByb2plY3QgYnkgTWFzb24gR3JlZW46IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9zb3VyY2UvYnJvd3NlP3JlcG89YXJjaGl2ZSNoZy9zY2FsYS9zcmMvb3JnL3BvbHkydHJpL3NlaWRlbFxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBDb252ZXggZGVjb21wb3NpdGlvbiBhbGdvcml0aG0gYmFzZWQgb24gUmFpbXVuZCBTZWlkZWwncyBwYXBlciBcIkEgc2ltcGxlIGFuZCBmYXN0IGluY3JlbWVudGFsIHJhbmRvbWl6ZWRcclxuICAgIC8vLyBhbGdvcml0aG0gZm9yIGNvbXB1dGluZyB0cmFwZXpvaWRhbCBkZWNvbXBvc2l0aW9ucyBhbmQgZm9yIHRyaWFuZ3VsYXRpbmcgcG9seWdvbnNcIlxyXG4gICAgLy8vIFNlZSBhbHNvOiBcIkNvbXB1dGF0aW9uYWwgR2VvbWV0cnlcIiwgM3JkIGVkaXRpb24sIGJ5IE1hcmsgZGUgQmVyZyBldCBhbCwgQ2hhcHRlciA2LjJcclxuICAgIC8vLyAgICAgICAgICAgXCJDb21wdXRhdGlvbmFsIEdlb21ldHJ5IGluIENcIiwgMm5kIGVkaXRpb24sIGJ5IEpvc2VwaCBPJ1JvdXJrZVxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgU2VpZGVsRGVjb21wb3NlclxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVjb21wb3NlIHRoZSBwb2x5Z29uIGludG8gc2V2ZXJhbCBzbWFsbGVyIG5vbi1jb25jYXZlIHBvbHlnb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSBwb2x5Z29uIHRvIGRlY29tcG9zZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNoZWVyXCI+VGhlIHNoZWVyIHRvIHVzZS4gSWYgeW91IGdldCBiYWQgcmVzdWx0cywgdHJ5IHVzaW5nIGEgaGlnaGVyIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjAwMTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbGlzdCBvZiB0cmlhbmdsZXM8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBDb252ZXhQYXJ0aXRpb24oVmVydGljZXMgdmVydGljZXMsIGZsb2F0IHNoZWVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGlzdDxQb2ludD4gY29tcGF0TGlzdCA9IG5ldyBMaXN0PFBvaW50Pih2ZXJ0aWNlcy5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChWZWN0b3IyIHZlcnRleCBpbiB2ZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29tcGF0TGlzdC5BZGQobmV3IFBvaW50KHZlcnRleC5YLCB2ZXJ0ZXguWSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBUcmlhbmd1bGF0b3IgdCA9IG5ldyBUcmlhbmd1bGF0b3IoY29tcGF0TGlzdCwgc2hlZXIpO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gbGlzdCA9IG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoTGlzdDxQb2ludD4gdHJpYW5nbGUgaW4gdC5UcmlhbmdsZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRzID0gbmV3IFZlcnRpY2VzKHRyaWFuZ2xlLkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChQb2ludCBwb2ludCBpbiB0cmlhbmdsZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0cy5BZGQobmV3IFZlY3RvcjIocG9pbnQuWCwgcG9pbnQuWSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxpc3QuQWRkKHZlcnRzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlY29tcG9zZSB0aGUgcG9seWdvbiBpbnRvIHNldmVyYWwgc21hbGxlciBub24tY29uY2F2ZSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgcG9seWdvbiB0byBkZWNvbXBvc2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzaGVlclwiPlRoZSBzaGVlciB0byB1c2UuIElmIHlvdSBnZXQgYmFkIHJlc3VsdHMsIHRyeSB1c2luZyBhIGhpZ2hlciB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMC4wMDE8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIGxpc3Qgb2YgdHJhcGV6b2lkczwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IENvbnZleFBhcnRpdGlvblRyYXBlem9pZChWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgc2hlZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaXN0PFBvaW50PiBjb21wYXRMaXN0ID0gbmV3IExpc3Q8UG9pbnQ+KHZlcnRpY2VzLkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKFZlY3RvcjIgdmVydGV4IGluIHZlcnRpY2VzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb21wYXRMaXN0LkFkZChuZXcgUG9pbnQodmVydGV4LlgsIHZlcnRleC5ZKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRvciB0ID0gbmV3IFRyaWFuZ3VsYXRvcihjb21wYXRMaXN0LCBzaGVlcik7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiBsaXN0ID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChUcmFwZXpvaWQgdHJhcGV6b2lkIGluIHQuVHJhcGV6b2lkcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVydGljZXMgdmVydHMgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBMaXN0PFBvaW50PiBwb2ludHMgPSB0cmFwZXpvaWQuVmVydGljZXMoKTtcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKFBvaW50IHBvaW50IGluIHBvaW50cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0cy5BZGQobmV3IFZlY3RvcjIocG9pbnQuWCwgcG9pbnQuWSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxpc3QuQWRkKHZlcnRzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIGNsYXNzIE1vbm90b25lTW91bnRhaW5cclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIGNvbnN0IGZsb2F0IFBpU2xvcCA9IDMuMWY7XHJcbiAgICAgICAgcHVibGljIExpc3Q8TGlzdDxQb2ludD4+IFRyaWFuZ2xlcztcclxuICAgICAgICBwcml2YXRlIEhhc2hTZXQ8UG9pbnQ+IF9jb252ZXhQb2ludHM7XHJcbiAgICAgICAgcHJpdmF0ZSBQb2ludCBfaGVhZDtcclxuXHJcbiAgICAgICAgLy8gTW9ub3RvbmUgbW91bnRhaW4gcG9pbnRzXHJcbiAgICAgICAgcHJpdmF0ZSBMaXN0PFBvaW50PiBfbW9ub1BvbHk7XHJcblxyXG4gICAgICAgIC8vIFRyaWFuZ2xlcyB0aGF0IGNvbnN0aXR1dGUgdGhlIG1vdW50YWluXHJcblxyXG4gICAgICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hpY2ggc2lkZSBvZiB0aGUgbGluZSB3ZSBhcmUgb25cclxuICAgICAgICBwcml2YXRlIGJvb2wgX3Bvc2l0aXZlO1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9zaXplO1xyXG4gICAgICAgIHByaXZhdGUgUG9pbnQgX3RhaWw7XHJcblxyXG4gICAgICAgIC8vIEFsbW9zdCBQaSFcclxuXHJcbiAgICAgICAgcHVibGljIE1vbm90b25lTW91bnRhaW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3NpemUgPSAwO1xyXG4gICAgICAgICAgICBfdGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgIF9oZWFkID0gbnVsbDtcclxuICAgICAgICAgICAgX3Bvc2l0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF9jb252ZXhQb2ludHMgPSBuZXcgSGFzaFNldDxQb2ludD4oKTtcclxuICAgICAgICAgICAgX21vbm9Qb2x5ID0gbmV3IExpc3Q8UG9pbnQ+KCk7XHJcbiAgICAgICAgICAgIFRyaWFuZ2xlcyA9IG5ldyBMaXN0PExpc3Q8UG9pbnQ+PigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIGEgcG9pbnQgdG8gdGhlIGxpc3RcclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGQoUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX3NpemUgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2hlYWQgPSBwb2ludDtcclxuICAgICAgICAgICAgICAgIF9zaXplID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2l6ZSA9PSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHJlcGVhdCBwb2ludHMgb3V0IG9mIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICBfdGFpbCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgX3RhaWwuUHJldiA9IF9oZWFkO1xyXG4gICAgICAgICAgICAgICAgX2hlYWQuTmV4dCA9IF90YWlsO1xyXG4gICAgICAgICAgICAgICAgX3NpemUgPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gS2VlcCByZXBlYXQgcG9pbnRzIG91dCBvZiB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgX3RhaWwuTmV4dCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgcG9pbnQuUHJldiA9IF90YWlsO1xyXG4gICAgICAgICAgICAgICAgX3RhaWwgPSBwb2ludDtcclxuICAgICAgICAgICAgICAgIF9zaXplICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBhIHBvaW50IGZyb20gdGhlIGxpc3RcclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmUoUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludCBuZXh0ID0gcG9pbnQuTmV4dDtcclxuICAgICAgICAgICAgUG9pbnQgcHJldiA9IHBvaW50LlByZXY7XHJcbiAgICAgICAgICAgIHBvaW50LlByZXYuTmV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgIHBvaW50Lk5leHQuUHJldiA9IHByZXY7XHJcbiAgICAgICAgICAgIF9zaXplIC09IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQYXJ0aXRpb24gYSB4LW1vbm90b25lIG1vdW50YWluIGludG8gdHJpYW5nbGVzIE8obilcclxuICAgICAgICAvLyBTZWUgXCJDb21wdXRhdGlvbmFsIEdlb21ldHJ5IGluIENcIiwgMm5kIGVkaXRpb24sIGJ5IEpvc2VwaCBPJ1JvdXJrZSwgcGFnZSA1MlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFByb2Nlc3MoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRXN0YWJsaXNoIHRoZSBwcm9wZXIgc2lnblxyXG4gICAgICAgICAgICBfcG9zaXRpdmUgPSBBbmdsZVNpZ24oKTtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIG1vbm90b25lIHBvbHlnb24gLSBmb3IgZHVidWcgcHVycG9zZXNcclxuICAgICAgICAgICAgR2VuTW9ub1BvbHkoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgaW50ZXJuYWwgYW5nbGVzIGF0IGVhY2ggbm9uYmFzZSB2ZXJ0ZXhcclxuICAgICAgICAgICAgLy8gTGluayBzdHJpY3RseSBjb252ZXggdmVydGljZXMgaW50byBhIGxpc3QsIGlnbm9yZSByZWZsZXggdmVydGljZXNcclxuICAgICAgICAgICAgUG9pbnQgcCA9IF9oZWFkLk5leHQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChwLk5lcShfdGFpbCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGEgPSBBbmdsZShwKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwb2ludCBpcyBhbG1vc3QgY29saW5lYXIgd2l0aCBpdCdzIG5laWdoYm9yLCByZW1vdmUgaXQhXHJcbiAgICAgICAgICAgICAgICBpZiAoYSA+PSBQaVNsb3AgfHwgYSA8PSAtUGlTbG9wIHx8IGEgPT0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgIFJlbW92ZShwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKElzQ29udmV4KHApKVxyXG4gICAgICAgICAgICAgICAgICAgIF9jb252ZXhQb2ludHMuQWRkKHApO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJpYW5ndWxhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBUcmlhbmd1bGF0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aGlsZSAoX2NvbnZleFBvaW50cy5Db3VudCAhPSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBJRW51bWVyYXRvcjxQb2ludD4gZSA9IF9jb252ZXhQb2ludHMuR2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgICAgICAgICAgZS5Nb3ZlTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgUG9pbnQgZWFyID0gZS5DdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIF9jb252ZXhQb2ludHMuUmVtb3ZlKGVhcik7XHJcbiAgICAgICAgICAgICAgICBQb2ludCBhID0gZWFyLlByZXY7XHJcbiAgICAgICAgICAgICAgICBQb2ludCBiID0gZWFyO1xyXG4gICAgICAgICAgICAgICAgUG9pbnQgYyA9IGVhci5OZXh0O1xyXG4gICAgICAgICAgICAgICAgTGlzdDxQb2ludD4gdHJpYW5nbGUgPSBuZXcgTGlzdDxQb2ludD4oMyk7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZS5BZGQoYSk7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZS5BZGQoYik7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZS5BZGQoYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgVHJpYW5nbGVzLkFkZCh0cmlhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGVhciwgdXBkYXRlIGFuZ2xlcyBhbmQgY29udmV4IGxpc3RcclxuICAgICAgICAgICAgICAgIFJlbW92ZShlYXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFZhbGlkKGEpKVxyXG4gICAgICAgICAgICAgICAgICAgIF9jb252ZXhQb2ludHMuQWRkKGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFZhbGlkKGMpKVxyXG4gICAgICAgICAgICAgICAgICAgIF9jb252ZXhQb2ludHMuQWRkKGMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoX3NpemUgPD0gMywgXCJUcmlhbmd1bGF0aW9uIGJ1ZywgcGxlYXNlIHJlcG9ydFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBWYWxpZChQb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHAuTmVxKF9oZWFkKSAmJiBwLk5lcShfdGFpbCkgJiYgSXNDb252ZXgocCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIG1vbm90b25lIHBvbHlnb25cclxuICAgICAgICBwcml2YXRlIHZvaWQgR2VuTW9ub1BvbHkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnQgcCA9IF9oZWFkO1xyXG4gICAgICAgICAgICB3aGlsZSAocCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW9ub1BvbHkuQWRkKHApO1xyXG4gICAgICAgICAgICAgICAgcCA9IHAuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBBbmdsZShQb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnQgYSA9IChwLk5leHQgLSBwKTtcclxuICAgICAgICAgICAgUG9pbnQgYiA9IChwLlByZXYgLSBwKTtcclxuICAgICAgICAgICAgcmV0dXJuIChmbG9hdClNYXRoLkF0YW4yKGEuQ3Jvc3MoYiksIGEuRG90KGIpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBBbmdsZVNpZ24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnQgYSA9IChfaGVhZC5OZXh0IC0gX2hlYWQpO1xyXG4gICAgICAgICAgICBQb2ludCBiID0gKF90YWlsIC0gX2hlYWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5BdGFuMihhLkNyb3NzKGIpLCBhLkRvdChiKSkgPj0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgdGhlIGluc2xpZGUgYW5nbGUgaXMgY29udmV4IG9yIHJlZmxleFxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBJc0NvbnZleChQb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9wb3NpdGl2ZSAhPSAoQW5nbGUocCkgPj0gMCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBOb2RlIGZvciBhIERpcmVjdGVkIEFjeWNsaWMgZ3JhcGggKERBRylcclxuICAgIGludGVybmFsIGFic3RyYWN0IGNsYXNzIE5vZGVcclxuICAgIHtcclxuICAgICAgICBwcm90ZWN0ZWQgTm9kZSBMZWZ0Q2hpbGQ7XHJcbiAgICAgICAgcHVibGljIExpc3Q8Tm9kZT4gUGFyZW50TGlzdDtcclxuICAgICAgICBwcm90ZWN0ZWQgTm9kZSBSaWdodENoaWxkO1xyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgTm9kZShOb2RlIGxlZnQsIE5vZGUgcmlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYXJlbnRMaXN0ID0gbmV3IExpc3Q8Tm9kZT4oKTtcclxuICAgICAgICAgICAgTGVmdENoaWxkID0gbGVmdDtcclxuICAgICAgICAgICAgUmlnaHRDaGlsZCA9IHJpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlZnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGxlZnQuUGFyZW50TGlzdC5BZGQodGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChyaWdodCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmlnaHQuUGFyZW50TGlzdC5BZGQodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgU2luayBMb2NhdGUoRWRnZSBzKTtcclxuXHJcbiAgICAgICAgLy8gUmVwbGFjZSBhIG5vZGUgaW4gdGhlIGdyYXBoIHdpdGggdGhpcyBub2RlXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHBhcmVudCBwb2ludGVycyBhcmUgdXBkYXRlZFxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlcGxhY2UoTm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yZWFjaCAoTm9kZSBwYXJlbnQgaW4gbm9kZS5QYXJlbnRMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGNvcnJlY3Qgbm9kZSB0byByZXBsYWNlIChsZWZ0IG9yIHJpZ2h0IGNoaWxkKVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5MZWZ0Q2hpbGQgPT0gbm9kZSlcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuTGVmdENoaWxkID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuUmlnaHRDaGlsZCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUGFyZW50TGlzdC5BZGRSYW5nZShub2RlLlBhcmVudExpc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXJlY3RlZCBBY3ljbGljIGdyYXBoIChEQUcpXHJcbiAgICAvLyBTZWUgXCJDb21wdXRhdGlvbmFsIEdlb21ldHJ5XCIsIDNyZCBlZGl0aW9uLCBieSBNYXJrIGRlIEJlcmcgZXQgYWwsIENoYXB0ZXIgNi4yXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBRdWVyeUdyYXBoXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBOb2RlIF9oZWFkO1xyXG5cclxuICAgICAgICBwdWJsaWMgUXVlcnlHcmFwaChOb2RlIGhlYWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfaGVhZCA9IGhlYWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIFRyYXBlem9pZCBMb2NhdGUoRWRnZSBlZGdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9oZWFkLkxvY2F0ZShlZGdlKS5UcmFwZXpvaWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTGlzdDxUcmFwZXpvaWQ+IEZvbGxvd0VkZ2UoRWRnZSBlZGdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGlzdDxUcmFwZXpvaWQ+IHRyYXBlem9pZHMgPSBuZXcgTGlzdDxUcmFwZXpvaWQ+KCk7XHJcbiAgICAgICAgICAgIHRyYXBlem9pZHMuQWRkKExvY2F0ZShlZGdlKSk7XHJcbiAgICAgICAgICAgIGludCBqID0gMDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChlZGdlLlEuWCA+IHRyYXBlem9pZHNbal0uUmlnaHRQb2ludC5YKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS5Jc0Fib3ZlKHRyYXBlem9pZHNbal0uUmlnaHRQb2ludCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhcGV6b2lkcy5BZGQodHJhcGV6b2lkc1tqXS5VcHBlclJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFwZXpvaWRzLkFkZCh0cmFwZXpvaWRzW2pdLkxvd2VyUmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaiArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFwZXpvaWRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFJlcGxhY2UoU2luayBzaW5rLCBOb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc2luay5QYXJlbnRMaXN0LkNvdW50ID09IDApXHJcbiAgICAgICAgICAgICAgICBfaGVhZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG5vZGUuUmVwbGFjZShzaW5rKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENhc2UxKFNpbmsgc2luaywgRWRnZSBlZGdlLCBUcmFwZXpvaWRbXSB0TGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFlOb2RlIHlOb2RlID0gbmV3IFlOb2RlKGVkZ2UsIFNpbmsuSXNpbmsodExpc3RbMV0pLCBTaW5rLklzaW5rKHRMaXN0WzJdKSk7XHJcbiAgICAgICAgICAgIFhOb2RlIHFOb2RlID0gbmV3IFhOb2RlKGVkZ2UuUSwgeU5vZGUsIFNpbmsuSXNpbmsodExpc3RbM10pKTtcclxuICAgICAgICAgICAgWE5vZGUgcE5vZGUgPSBuZXcgWE5vZGUoZWRnZS5QLCBTaW5rLklzaW5rKHRMaXN0WzBdKSwgcU5vZGUpO1xyXG4gICAgICAgICAgICBSZXBsYWNlKHNpbmssIHBOb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENhc2UyKFNpbmsgc2luaywgRWRnZSBlZGdlLCBUcmFwZXpvaWRbXSB0TGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFlOb2RlIHlOb2RlID0gbmV3IFlOb2RlKGVkZ2UsIFNpbmsuSXNpbmsodExpc3RbMV0pLCBTaW5rLklzaW5rKHRMaXN0WzJdKSk7XHJcbiAgICAgICAgICAgIFhOb2RlIHBOb2RlID0gbmV3IFhOb2RlKGVkZ2UuUCwgU2luay5Jc2luayh0TGlzdFswXSksIHlOb2RlKTtcclxuICAgICAgICAgICAgUmVwbGFjZShzaW5rLCBwTm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDYXNlMyhTaW5rIHNpbmssIEVkZ2UgZWRnZSwgVHJhcGV6b2lkW10gdExpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBZTm9kZSB5Tm9kZSA9IG5ldyBZTm9kZShlZGdlLCBTaW5rLklzaW5rKHRMaXN0WzBdKSwgU2luay5Jc2luayh0TGlzdFsxXSkpO1xyXG4gICAgICAgICAgICBSZXBsYWNlKHNpbmssIHlOb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENhc2U0KFNpbmsgc2luaywgRWRnZSBlZGdlLCBUcmFwZXpvaWRbXSB0TGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFlOb2RlIHlOb2RlID0gbmV3IFlOb2RlKGVkZ2UsIFNpbmsuSXNpbmsodExpc3RbMF0pLCBTaW5rLklzaW5rKHRMaXN0WzFdKSk7XHJcbiAgICAgICAgICAgIFhOb2RlIHFOb2RlID0gbmV3IFhOb2RlKGVkZ2UuUSwgeU5vZGUsIFNpbmsuSXNpbmsodExpc3RbMl0pKTtcclxuICAgICAgICAgICAgUmVwbGFjZShzaW5rLCBxTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIGNsYXNzIFNpbmsgOiBOb2RlXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFRyYXBlem9pZCBUcmFwZXpvaWQ7XHJcblxyXG4gICAgICAgIHByaXZhdGUgU2luayhUcmFwZXpvaWQgdHJhcGV6b2lkKVxyXG4gICAgICAgICAgICA6IGJhc2UobnVsbCwgbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyYXBlem9pZCA9IHRyYXBlem9pZDtcclxuICAgICAgICAgICAgdHJhcGV6b2lkLlNpbmsgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTaW5rIElzaW5rKFRyYXBlem9pZCB0cmFwZXpvaWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodHJhcGV6b2lkLlNpbmsgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2luayh0cmFwZXpvaWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhcGV6b2lkLlNpbms7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgU2luayBMb2NhdGUoRWRnZSBlZGdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlZSBcIkNvbXB1dGF0aW9uYWwgR2VvbWV0cnlcIiwgM3JkIGVkaXRpb24sIGJ5IE1hcmsgZGUgQmVyZyBldCBhbCwgQ2hhcHRlciA2LjJcclxuICAgIGludGVybmFsIGNsYXNzIFRyYXBlem9pZGFsTWFwXHJcbiAgICB7XHJcbiAgICAgICAgLy8gVHJhcGV6b2lkIGNvbnRhaW5lclxyXG4gICAgICAgIHB1YmxpYyBIYXNoU2V0PFRyYXBlem9pZD4gTWFwO1xyXG5cclxuICAgICAgICAvLyBBQUJCIG1hcmdpblxyXG5cclxuICAgICAgICAvLyBCb3R0b20gc2VnbWVudCB0aGF0IHNwYW5zIG11bHRpcGxlIHRyYXBlem9pZHNcclxuICAgICAgICBwcml2YXRlIEVkZ2UgX2JDcm9zcztcclxuXHJcbiAgICAgICAgLy8gVG9wIHNlZ21lbnQgdGhhdCBzcGFucyBtdWx0aXBsZSB0cmFwZXpvaWRzXHJcbiAgICAgICAgcHJpdmF0ZSBFZGdlIF9jcm9zcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXJnaW47XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWRhbE1hcCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXAgPSBuZXcgSGFzaFNldDxUcmFwZXpvaWQ+KCk7XHJcbiAgICAgICAgICAgIF9tYXJnaW4gPSA1MC4wZjtcclxuICAgICAgICAgICAgX2JDcm9zcyA9IG51bGw7XHJcbiAgICAgICAgICAgIF9jcm9zcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfYkNyb3NzID0gbnVsbDtcclxuICAgICAgICAgICAgX2Nyb3NzID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhc2UgMTogc2VnbWVudCBjb21wbGV0ZWx5IGVuY2xvc2VkIGJ5IHRyYXBlem9pZFxyXG4gICAgICAgIC8vICAgICAgICAgYnJlYWsgdHJhcGV6b2lkIGludG8gNCBzbWFsbGVyIHRyYXBlem9pZHNcclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkW10gQ2FzZTEoVHJhcGV6b2lkIHQsIEVkZ2UgZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyYXBlem9pZFtdIHRyYXBlem9pZHMgPSBuZXcgVHJhcGV6b2lkWzRdO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzBdID0gbmV3IFRyYXBlem9pZCh0LkxlZnRQb2ludCwgZS5QLCB0LlRvcCwgdC5Cb3R0b20pO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzFdID0gbmV3IFRyYXBlem9pZChlLlAsIGUuUSwgdC5Ub3AsIGUpO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzJdID0gbmV3IFRyYXBlem9pZChlLlAsIGUuUSwgZSwgdC5Cb3R0b20pO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzNdID0gbmV3IFRyYXBlem9pZChlLlEsIHQuUmlnaHRQb2ludCwgdC5Ub3AsIHQuQm90dG9tKTtcclxuXHJcbiAgICAgICAgICAgIHRyYXBlem9pZHNbMF0uVXBkYXRlTGVmdCh0LlVwcGVyTGVmdCwgdC5Mb3dlckxlZnQpO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzFdLlVwZGF0ZUxlZnRSaWdodCh0cmFwZXpvaWRzWzBdLCBudWxsLCB0cmFwZXpvaWRzWzNdLCBudWxsKTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1syXS5VcGRhdGVMZWZ0UmlnaHQobnVsbCwgdHJhcGV6b2lkc1swXSwgbnVsbCwgdHJhcGV6b2lkc1szXSk7XHJcbiAgICAgICAgICAgIHRyYXBlem9pZHNbM10uVXBkYXRlUmlnaHQodC5VcHBlclJpZ2h0LCB0Lkxvd2VyUmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRyYXBlem9pZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYXNlIDI6IFRyYXBlem9pZCBjb250YWlucyBwb2ludCBwLCBxIGxpZXMgb3V0c2lkZVxyXG4gICAgICAgIC8vICAgICAgICAgYnJlYWsgdHJhcGV6b2lkIGludG8gMyBzbWFsbGVyIHRyYXBlem9pZHNcclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkW10gQ2FzZTIoVHJhcGV6b2lkIHQsIEVkZ2UgZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50IHJwO1xyXG4gICAgICAgICAgICBpZiAoZS5RLlggPT0gdC5SaWdodFBvaW50LlgpXHJcbiAgICAgICAgICAgICAgICBycCA9IGUuUTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcnAgPSB0LlJpZ2h0UG9pbnQ7XHJcblxyXG4gICAgICAgICAgICBUcmFwZXpvaWRbXSB0cmFwZXpvaWRzID0gbmV3IFRyYXBlem9pZFszXTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1swXSA9IG5ldyBUcmFwZXpvaWQodC5MZWZ0UG9pbnQsIGUuUCwgdC5Ub3AsIHQuQm90dG9tKTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1sxXSA9IG5ldyBUcmFwZXpvaWQoZS5QLCBycCwgdC5Ub3AsIGUpO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzJdID0gbmV3IFRyYXBlem9pZChlLlAsIHJwLCBlLCB0LkJvdHRvbSk7XHJcblxyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzBdLlVwZGF0ZUxlZnQodC5VcHBlckxlZnQsIHQuTG93ZXJMZWZ0KTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1sxXS5VcGRhdGVMZWZ0UmlnaHQodHJhcGV6b2lkc1swXSwgbnVsbCwgdC5VcHBlclJpZ2h0LCBudWxsKTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1syXS5VcGRhdGVMZWZ0UmlnaHQobnVsbCwgdHJhcGV6b2lkc1swXSwgbnVsbCwgdC5Mb3dlclJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIF9iQ3Jvc3MgPSB0LkJvdHRvbTtcclxuICAgICAgICAgICAgX2Nyb3NzID0gdC5Ub3A7XHJcblxyXG4gICAgICAgICAgICBlLkFib3ZlID0gdHJhcGV6b2lkc1sxXTtcclxuICAgICAgICAgICAgZS5CZWxvdyA9IHRyYXBlem9pZHNbMl07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJhcGV6b2lkcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhc2UgMzogVHJhcGV6b2lkIGlzIGJpc2VjdGVkXHJcbiAgICAgICAgcHVibGljIFRyYXBlem9pZFtdIENhc2UzKFRyYXBlem9pZCB0LCBFZGdlIGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludCBscDtcclxuICAgICAgICAgICAgaWYgKGUuUC5YID09IHQuTGVmdFBvaW50LlgpXHJcbiAgICAgICAgICAgICAgICBscCA9IGUuUDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbHAgPSB0LkxlZnRQb2ludDtcclxuXHJcbiAgICAgICAgICAgIFBvaW50IHJwO1xyXG4gICAgICAgICAgICBpZiAoZS5RLlggPT0gdC5SaWdodFBvaW50LlgpXHJcbiAgICAgICAgICAgICAgICBycCA9IGUuUTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcnAgPSB0LlJpZ2h0UG9pbnQ7XHJcblxyXG4gICAgICAgICAgICBUcmFwZXpvaWRbXSB0cmFwZXpvaWRzID0gbmV3IFRyYXBlem9pZFsyXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfY3Jvc3MgPT0gdC5Ub3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMF0gPSB0LlVwcGVyTGVmdDtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMF0uVXBkYXRlUmlnaHQodC5VcHBlclJpZ2h0LCBudWxsKTtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMF0uUmlnaHRQb2ludCA9IHJwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHJhcGV6b2lkc1swXSA9IG5ldyBUcmFwZXpvaWQobHAsIHJwLCB0LlRvcCwgZSk7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzBdLlVwZGF0ZUxlZnRSaWdodCh0LlVwcGVyTGVmdCwgZS5BYm92ZSwgdC5VcHBlclJpZ2h0LCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9iQ3Jvc3MgPT0gdC5Cb3R0b20pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMV0gPSB0Lkxvd2VyTGVmdDtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMV0uVXBkYXRlUmlnaHQobnVsbCwgdC5Mb3dlclJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMV0uUmlnaHRQb2ludCA9IHJwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHJhcGV6b2lkc1sxXSA9IG5ldyBUcmFwZXpvaWQobHAsIHJwLCBlLCB0LkJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzFdLlVwZGF0ZUxlZnRSaWdodChlLkJlbG93LCB0Lkxvd2VyTGVmdCwgbnVsbCwgdC5Mb3dlclJpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2JDcm9zcyA9IHQuQm90dG9tO1xyXG4gICAgICAgICAgICBfY3Jvc3MgPSB0LlRvcDtcclxuXHJcbiAgICAgICAgICAgIGUuQWJvdmUgPSB0cmFwZXpvaWRzWzBdO1xyXG4gICAgICAgICAgICBlLkJlbG93ID0gdHJhcGV6b2lkc1sxXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cmFwZXpvaWRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FzZSA0OiBUcmFwZXpvaWQgY29udGFpbnMgcG9pbnQgcSwgcCBsaWVzIG91dHNpZGVcclxuICAgICAgICAvLyAgICAgICAgIGJyZWFrIHRyYXBlem9pZCBpbnRvIDMgc21hbGxlciB0cmFwZXpvaWRzXHJcbiAgICAgICAgcHVibGljIFRyYXBlem9pZFtdIENhc2U0KFRyYXBlem9pZCB0LCBFZGdlIGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludCBscDtcclxuICAgICAgICAgICAgaWYgKGUuUC5YID09IHQuTGVmdFBvaW50LlgpXHJcbiAgICAgICAgICAgICAgICBscCA9IGUuUDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbHAgPSB0LkxlZnRQb2ludDtcclxuXHJcbiAgICAgICAgICAgIFRyYXBlem9pZFtdIHRyYXBlem9pZHMgPSBuZXcgVHJhcGV6b2lkWzNdO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9jcm9zcyA9PSB0LlRvcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHJhcGV6b2lkc1swXSA9IHQuVXBwZXJMZWZ0O1xyXG4gICAgICAgICAgICAgICAgdHJhcGV6b2lkc1swXS5SaWdodFBvaW50ID0gZS5RO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHJhcGV6b2lkc1swXSA9IG5ldyBUcmFwZXpvaWQobHAsIGUuUSwgdC5Ub3AsIGUpO1xyXG4gICAgICAgICAgICAgICAgdHJhcGV6b2lkc1swXS5VcGRhdGVMZWZ0KHQuVXBwZXJMZWZ0LCBlLkFib3ZlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9iQ3Jvc3MgPT0gdC5Cb3R0b20pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMV0gPSB0Lkxvd2VyTGVmdDtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMV0uUmlnaHRQb2ludCA9IGUuUTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMV0gPSBuZXcgVHJhcGV6b2lkKGxwLCBlLlEsIGUsIHQuQm90dG9tKTtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMV0uVXBkYXRlTGVmdChlLkJlbG93LCB0Lkxvd2VyTGVmdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRyYXBlem9pZHNbMl0gPSBuZXcgVHJhcGV6b2lkKGUuUSwgdC5SaWdodFBvaW50LCB0LlRvcCwgdC5Cb3R0b20pO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzJdLlVwZGF0ZUxlZnRSaWdodCh0cmFwZXpvaWRzWzBdLCB0cmFwZXpvaWRzWzFdLCB0LlVwcGVyUmlnaHQsIHQuTG93ZXJSaWdodCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJhcGV6b2lkcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhbiBBQUJCIGFyb3VuZCBzZWdtZW50c1xyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQgQm91bmRpbmdCb3goTGlzdDxFZGdlPiBlZGdlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50IG1heCA9IGVkZ2VzWzBdLlAgKyBfbWFyZ2luO1xyXG4gICAgICAgICAgICBQb2ludCBtaW4gPSBlZGdlc1swXS5RIC0gX21hcmdpbjtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEVkZ2UgZSBpbiBlZGdlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuUC5YID4gbWF4LlgpIG1heCA9IG5ldyBQb2ludChlLlAuWCArIF9tYXJnaW4sIG1heC5ZKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLlAuWSA+IG1heC5ZKSBtYXggPSBuZXcgUG9pbnQobWF4LlgsIGUuUC5ZICsgX21hcmdpbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5RLlggPiBtYXguWCkgbWF4ID0gbmV3IFBvaW50KGUuUS5YICsgX21hcmdpbiwgbWF4LlkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuUS5ZID4gbWF4LlkpIG1heCA9IG5ldyBQb2ludChtYXguWCwgZS5RLlkgKyBfbWFyZ2luKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLlAuWCA8IG1pbi5YKSBtaW4gPSBuZXcgUG9pbnQoZS5QLlggLSBfbWFyZ2luLCBtaW4uWSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5QLlkgPCBtaW4uWSkgbWluID0gbmV3IFBvaW50KG1pbi5YLCBlLlAuWSAtIF9tYXJnaW4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuUS5YIDwgbWluLlgpIG1pbiA9IG5ldyBQb2ludChlLlEuWCAtIF9tYXJnaW4sIG1pbi5ZKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLlEuWSA8IG1pbi5ZKSBtaW4gPSBuZXcgUG9pbnQobWluLlgsIGUuUS5ZIC0gX21hcmdpbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEVkZ2UgdG9wID0gbmV3IEVkZ2UobmV3IFBvaW50KG1pbi5YLCBtYXguWSksIG5ldyBQb2ludChtYXguWCwgbWF4LlkpKTtcclxuICAgICAgICAgICAgRWRnZSBib3R0b20gPSBuZXcgRWRnZShuZXcgUG9pbnQobWluLlgsIG1pbi5ZKSwgbmV3IFBvaW50KG1heC5YLCBtaW4uWSkpO1xyXG4gICAgICAgICAgICBQb2ludCBsZWZ0ID0gYm90dG9tLlA7XHJcbiAgICAgICAgICAgIFBvaW50IHJpZ2h0ID0gdG9wLlE7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYXBlem9pZChsZWZ0LCByaWdodCwgdG9wLCBib3R0b20pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBQb2ludFxyXG4gICAge1xyXG4gICAgICAgIC8vIFBvaW50ZXJzIHRvIG5leHQgYW5kIHByZXZpb3VzIHBvaW50cyBpbiBNb25vbnRvbmUgTW91bnRhaW5cclxuICAgICAgICBwdWJsaWMgUG9pbnQgTmV4dCwgUHJldjtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgWCwgWTtcclxuXHJcbiAgICAgICAgcHVibGljIFBvaW50KGZsb2F0IHgsIGZsb2F0IHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBYID0geDtcclxuICAgICAgICAgICAgWSA9IHk7XHJcbiAgICAgICAgICAgIE5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICBQcmV2ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUG9pbnQgb3BlcmF0b3IgLShQb2ludCBwMSwgUG9pbnQgcDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHAxLlggLSBwMi5YLCBwMS5ZIC0gcDIuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFBvaW50IG9wZXJhdG9yICsoUG9pbnQgcDEsIFBvaW50IHAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS5YICsgcDIuWCwgcDEuWSArIHAyLlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBQb2ludCBvcGVyYXRvciAtKFBvaW50IHAxLCBmbG9hdCBmKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS5YIC0gZiwgcDEuWSAtIGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBQb2ludCBvcGVyYXRvciArKFBvaW50IHAxLCBmbG9hdCBmKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS5YICsgZiwgcDEuWSArIGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IENyb3NzKFBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gWCAqIHAuWSAtIFkgKiBwLlg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRG90KFBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gWCAqIHAuWCArIFkgKiBwLlk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBOZXEoUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBwLlggIT0gWCB8fCBwLlkgIT0gWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBPcmllbnQyRChQb2ludCBwYiwgUG9pbnQgcGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBhY3ggPSBYIC0gcGMuWDtcclxuICAgICAgICAgICAgZmxvYXQgYmN4ID0gcGIuWCAtIHBjLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IGFjeSA9IFkgLSBwYy5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBiY3kgPSBwYi5ZIC0gcGMuWTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjeCAqIGJjeSAtIGFjeSAqIGJjeDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJuYWwgY2xhc3MgRWRnZVxyXG4gICAge1xyXG4gICAgICAgIC8vIFBvaW50ZXJzIHVzZWQgZm9yIGJ1aWxkaW5nIHRyYXBlem9pZGFsIG1hcFxyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQgQWJvdmU7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEI7XHJcbiAgICAgICAgcHVibGljIFRyYXBlem9pZCBCZWxvdztcclxuXHJcbiAgICAgICAgLy8gRXF1YXRpb24gb2YgYSBsaW5lOiB5ID0gbSp4ICsgYlxyXG4gICAgICAgIC8vIFNsb3BlIG9mIHRoZSBsaW5lIChtKVxyXG5cclxuICAgICAgICAvLyBNb250b25lIG1vdW50YWluIHBvaW50c1xyXG4gICAgICAgIHB1YmxpYyBIYXNoU2V0PFBvaW50PiBNUG9pbnRzO1xyXG4gICAgICAgIHB1YmxpYyBQb2ludCBQO1xyXG4gICAgICAgIHB1YmxpYyBQb2ludCBRO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBTbG9wZTtcclxuXHJcbiAgICAgICAgLy8gWSBpbnRlcmNlcHRcclxuXHJcbiAgICAgICAgcHVibGljIEVkZ2UoUG9pbnQgcCwgUG9pbnQgcSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFAgPSBwO1xyXG4gICAgICAgICAgICBRID0gcTtcclxuXHJcbiAgICAgICAgICAgIGlmIChxLlggLSBwLlggIT0gMClcclxuICAgICAgICAgICAgICAgIFNsb3BlID0gKHEuWSAtIHAuWSkgLyAocS5YIC0gcC5YKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgU2xvcGUgPSAwO1xyXG5cclxuICAgICAgICAgICAgQiA9IHAuWSAtIChwLlggKiBTbG9wZSk7XHJcbiAgICAgICAgICAgIEFib3ZlID0gbnVsbDtcclxuICAgICAgICAgICAgQmVsb3cgPSBudWxsO1xyXG4gICAgICAgICAgICBNUG9pbnRzID0gbmV3IEhhc2hTZXQ8UG9pbnQ+KCk7XHJcbiAgICAgICAgICAgIE1Qb2ludHMuQWRkKHApO1xyXG4gICAgICAgICAgICBNUG9pbnRzLkFkZChxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzQWJvdmUoUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUC5PcmllbnQyRChRLCBwb2ludCkgPCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNCZWxvdyhQb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQLk9yaWVudDJEKFEsIHBvaW50KSA+IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRNcG9pbnQoUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3JlYWNoIChQb2ludCBtcCBpbiBNUG9pbnRzKVxyXG4gICAgICAgICAgICAgICAgaWYgKCFtcC5OZXEocG9pbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIE1Qb2ludHMuQWRkKHBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJuYWwgY2xhc3MgVHJhcGV6b2lkXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIEVkZ2UgQm90dG9tO1xyXG4gICAgICAgIHB1YmxpYyBib29sIEluc2lkZTtcclxuICAgICAgICBwdWJsaWMgUG9pbnQgTGVmdFBvaW50O1xyXG5cclxuICAgICAgICAvLyBOZWlnaGJvciBwb2ludGVyc1xyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQgTG93ZXJMZWZ0O1xyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQgTG93ZXJSaWdodDtcclxuXHJcbiAgICAgICAgcHVibGljIFBvaW50IFJpZ2h0UG9pbnQ7XHJcbiAgICAgICAgcHVibGljIFNpbmsgU2luaztcclxuXHJcbiAgICAgICAgcHVibGljIEVkZ2UgVG9wO1xyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQgVXBwZXJMZWZ0O1xyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQgVXBwZXJSaWdodDtcclxuXHJcbiAgICAgICAgcHVibGljIFRyYXBlem9pZChQb2ludCBsZWZ0UG9pbnQsIFBvaW50IHJpZ2h0UG9pbnQsIEVkZ2UgdG9wLCBFZGdlIGJvdHRvbSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExlZnRQb2ludCA9IGxlZnRQb2ludDtcclxuICAgICAgICAgICAgUmlnaHRQb2ludCA9IHJpZ2h0UG9pbnQ7XHJcbiAgICAgICAgICAgIFRvcCA9IHRvcDtcclxuICAgICAgICAgICAgQm90dG9tID0gYm90dG9tO1xyXG4gICAgICAgICAgICBVcHBlckxlZnQgPSBudWxsO1xyXG4gICAgICAgICAgICBVcHBlclJpZ2h0ID0gbnVsbDtcclxuICAgICAgICAgICAgTG93ZXJMZWZ0ID0gbnVsbDtcclxuICAgICAgICAgICAgTG93ZXJSaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgIEluc2lkZSA9IHRydWU7XHJcbiAgICAgICAgICAgIFNpbmsgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIG5laWdoYm9ycyB0byB0aGUgbGVmdFxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFVwZGF0ZUxlZnQoVHJhcGV6b2lkIHVsLCBUcmFwZXpvaWQgbGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBVcHBlckxlZnQgPSB1bDtcclxuICAgICAgICAgICAgaWYgKHVsICE9IG51bGwpIHVsLlVwcGVyUmlnaHQgPSB0aGlzO1xyXG4gICAgICAgICAgICBMb3dlckxlZnQgPSBsbDtcclxuICAgICAgICAgICAgaWYgKGxsICE9IG51bGwpIGxsLkxvd2VyUmlnaHQgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIG5laWdoYm9ycyB0byB0aGUgcmlnaHRcclxuICAgICAgICBwdWJsaWMgdm9pZCBVcGRhdGVSaWdodChUcmFwZXpvaWQgdXIsIFRyYXBlem9pZCBscilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFVwcGVyUmlnaHQgPSB1cjtcclxuICAgICAgICAgICAgaWYgKHVyICE9IG51bGwpIHVyLlVwcGVyTGVmdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIExvd2VyUmlnaHQgPSBscjtcclxuICAgICAgICAgICAgaWYgKGxyICE9IG51bGwpIGxyLkxvd2VyTGVmdCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgbmVpZ2hib3JzIG9uIGJvdGggc2lkZXNcclxuICAgICAgICBwdWJsaWMgdm9pZCBVcGRhdGVMZWZ0UmlnaHQoVHJhcGV6b2lkIHVsLCBUcmFwZXpvaWQgbGwsIFRyYXBlem9pZCB1ciwgVHJhcGV6b2lkIGxyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVXBwZXJMZWZ0ID0gdWw7XHJcbiAgICAgICAgICAgIGlmICh1bCAhPSBudWxsKSB1bC5VcHBlclJpZ2h0ID0gdGhpcztcclxuICAgICAgICAgICAgTG93ZXJMZWZ0ID0gbGw7XHJcbiAgICAgICAgICAgIGlmIChsbCAhPSBudWxsKSBsbC5Mb3dlclJpZ2h0ID0gdGhpcztcclxuICAgICAgICAgICAgVXBwZXJSaWdodCA9IHVyO1xyXG4gICAgICAgICAgICBpZiAodXIgIT0gbnVsbCkgdXIuVXBwZXJMZWZ0ID0gdGhpcztcclxuICAgICAgICAgICAgTG93ZXJSaWdodCA9IGxyO1xyXG4gICAgICAgICAgICBpZiAobHIgIT0gbnVsbCkgbHIuTG93ZXJMZWZ0ID0gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHRyaW0gb3V0c2lkZSBuZWlnaGJvcnNcclxuICAgICAgICBwdWJsaWMgdm9pZCBUcmltTmVpZ2hib3JzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChJbnNpZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEluc2lkZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKFVwcGVyTGVmdCAhPSBudWxsKSBVcHBlckxlZnQuVHJpbU5laWdoYm9ycygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKExvd2VyTGVmdCAhPSBudWxsKSBMb3dlckxlZnQuVHJpbU5laWdoYm9ycygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFVwcGVyUmlnaHQgIT0gbnVsbCkgVXBwZXJSaWdodC5UcmltTmVpZ2hib3JzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTG93ZXJSaWdodCAhPSBudWxsKSBMb3dlclJpZ2h0LlRyaW1OZWlnaGJvcnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGlzIHBvaW50IGxpZXMgaW5zaWRlIHRoZSB0cmFwZXpvaWRcclxuICAgICAgICBwdWJsaWMgYm9vbCBDb250YWlucyhQb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAocG9pbnQuWCA+IExlZnRQb2ludC5YICYmIHBvaW50LlggPCBSaWdodFBvaW50LlggJiYgVG9wLklzQWJvdmUocG9pbnQpICYmIEJvdHRvbS5Jc0JlbG93KHBvaW50KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTGlzdDxQb2ludD4gVmVydGljZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGlzdDxQb2ludD4gdmVydHMgPSBuZXcgTGlzdDxQb2ludD4oNCk7XHJcbiAgICAgICAgICAgIHZlcnRzLkFkZChMaW5lSW50ZXJzZWN0KFRvcCwgTGVmdFBvaW50LlgpKTtcclxuICAgICAgICAgICAgdmVydHMuQWRkKExpbmVJbnRlcnNlY3QoQm90dG9tLCBMZWZ0UG9pbnQuWCkpO1xyXG4gICAgICAgICAgICB2ZXJ0cy5BZGQoTGluZUludGVyc2VjdChCb3R0b20sIFJpZ2h0UG9pbnQuWCkpO1xyXG4gICAgICAgICAgICB2ZXJ0cy5BZGQoTGluZUludGVyc2VjdChUb3AsIFJpZ2h0UG9pbnQuWCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmVydHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIFBvaW50IExpbmVJbnRlcnNlY3QoRWRnZSBlZGdlLCBmbG9hdCB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgeSA9IGVkZ2UuU2xvcGUgKiB4ICsgZWRnZS5CO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIHBvaW50cyB0byBtb25vdG9uZSBtb3VudGFpblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZFBvaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoTGVmdFBvaW50ICE9IEJvdHRvbS5QKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb3R0b20uQWRkTXBvaW50KExlZnRQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFJpZ2h0UG9pbnQgIT0gQm90dG9tLlEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvdHRvbS5BZGRNcG9pbnQoUmlnaHRQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKExlZnRQb2ludCAhPSBUb3AuUClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVG9wLkFkZE1wb2ludChMZWZ0UG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChSaWdodFBvaW50ICE9IFRvcC5RKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUb3AuQWRkTXBvaW50KFJpZ2h0UG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIGNsYXNzIFhOb2RlIDogTm9kZVxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgUG9pbnQgX3BvaW50O1xyXG5cclxuICAgICAgICBwdWJsaWMgWE5vZGUoUG9pbnQgcG9pbnQsIE5vZGUgbENoaWxkLCBOb2RlIHJDaGlsZClcclxuICAgICAgICAgICAgOiBiYXNlKGxDaGlsZCwgckNoaWxkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3BvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgU2luayBMb2NhdGUoRWRnZSBlZGdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGVkZ2UuUC5YID49IF9wb2ludC5YKVxyXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgcmlnaHQgaW4gdGhlIGdyYXBoXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUmlnaHRDaGlsZC5Mb2NhdGUoZWRnZSk7XHJcbiAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIGxlZnQgaW4gdGhlIGdyYXBoXHJcbiAgICAgICAgICAgIHJldHVybiBMZWZ0Q2hpbGQuTG9jYXRlKGVkZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBZTm9kZSA6IE5vZGVcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIEVkZ2UgX2VkZ2U7XHJcblxyXG4gICAgICAgIHB1YmxpYyBZTm9kZShFZGdlIGVkZ2UsIE5vZGUgbENoaWxkLCBOb2RlIHJDaGlsZClcclxuICAgICAgICAgICAgOiBiYXNlKGxDaGlsZCwgckNoaWxkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2VkZ2UgPSBlZGdlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFNpbmsgTG9jYXRlKEVkZ2UgZWRnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfZWRnZS5Jc0Fib3ZlKGVkZ2UuUCkpXHJcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGRvd24gdGhlIGdyYXBoXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUmlnaHRDaGlsZC5Mb2NhdGUoZWRnZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VkZ2UuSXNCZWxvdyhlZGdlLlApKVxyXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB1cCB0aGUgZ3JhcGhcclxuICAgICAgICAgICAgICAgIHJldHVybiBMZWZ0Q2hpbGQuTG9jYXRlKGVkZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gcyBhbmQgc2VnbWVudCBzaGFyZSB0aGUgc2FtZSBlbmRwb2ludCwgcFxyXG4gICAgICAgICAgICBpZiAoZWRnZS5TbG9wZSA8IF9lZGdlLlNsb3BlKVxyXG4gICAgICAgICAgICAgICAgLy8gTW92ZSBkb3duIHRoZSBncmFwaFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJpZ2h0Q2hpbGQuTG9jYXRlKGVkZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gTW92ZSB1cCB0aGUgZ3JhcGhcclxuICAgICAgICAgICAgcmV0dXJuIExlZnRDaGlsZC5Mb2NhdGUoZWRnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIGNsYXNzIFRyaWFuZ3VsYXRvclxyXG4gICAge1xyXG4gICAgICAgIC8vIFRyYXBlem9pZCBkZWNvbXBvc2l0aW9uIGxpc3RcclxuICAgICAgICBwdWJsaWMgTGlzdDxUcmFwZXpvaWQ+IFRyYXBlem9pZHM7XHJcbiAgICAgICAgcHVibGljIExpc3Q8TGlzdDxQb2ludD4+IFRyaWFuZ2xlcztcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0cmFwZXpvaWRhbCBtYXAgYW5kIHF1ZXJ5IHN0cnVjdHVyZVxyXG4gICAgICAgIHByaXZhdGUgVHJhcGV6b2lkIF9ib3VuZGluZ0JveDtcclxuICAgICAgICBwcml2YXRlIExpc3Q8RWRnZT4gX2VkZ2VMaXN0O1xyXG4gICAgICAgIHByaXZhdGUgUXVlcnlHcmFwaCBfcXVlcnlHcmFwaDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zaGVlciA9IDAuMDAxZjtcclxuICAgICAgICBwcml2YXRlIFRyYXBlem9pZGFsTWFwIF90cmFwZXpvaWRhbE1hcDtcclxuICAgICAgICBwcml2YXRlIExpc3Q8TW9ub3RvbmVNb3VudGFpbj4gX3hNb25vUG9seTtcclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRvcihMaXN0PFBvaW50PiBwb2x5TGluZSwgZmxvYXQgc2hlZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfc2hlZXIgPSBzaGVlcjtcclxuICAgICAgICAgICAgVHJpYW5nbGVzID0gbmV3IExpc3Q8TGlzdDxQb2ludD4+KCk7XHJcbiAgICAgICAgICAgIFRyYXBlem9pZHMgPSBuZXcgTGlzdDxUcmFwZXpvaWQ+KCk7XHJcbiAgICAgICAgICAgIF94TW9ub1BvbHkgPSBuZXcgTGlzdDxNb25vdG9uZU1vdW50YWluPigpO1xyXG4gICAgICAgICAgICBfZWRnZUxpc3QgPSBJbml0RWRnZXMocG9seUxpbmUpO1xyXG4gICAgICAgICAgICBfdHJhcGV6b2lkYWxNYXAgPSBuZXcgVHJhcGV6b2lkYWxNYXAoKTtcclxuICAgICAgICAgICAgX2JvdW5kaW5nQm94ID0gX3RyYXBlem9pZGFsTWFwLkJvdW5kaW5nQm94KF9lZGdlTGlzdCk7XHJcbiAgICAgICAgICAgIF9xdWVyeUdyYXBoID0gbmV3IFF1ZXJ5R3JhcGgoU2luay5Jc2luayhfYm91bmRpbmdCb3gpKTtcclxuXHJcbiAgICAgICAgICAgIFByb2Nlc3MoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0cmFwZXpvaWRhbCBtYXAgYW5kIHF1ZXJ5IGdyYXBoXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFByb2Nlc3MoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yZWFjaCAoRWRnZSBlZGdlIGluIF9lZGdlTGlzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTGlzdDxUcmFwZXpvaWQ+IHRyYXBzID0gX3F1ZXJ5R3JhcGguRm9sbG93RWRnZShlZGdlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhcGV6b2lkcyBmcm9tIHRyYXBlem9pZGFsIE1hcFxyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoVHJhcGV6b2lkIHQgaW4gdHJhcHMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RyYXBlem9pZGFsTWFwLk1hcC5SZW1vdmUodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgY3AgPSB0LkNvbnRhaW5zKGVkZ2UuUCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBjcSA9IHQuQ29udGFpbnMoZWRnZS5RKTtcclxuICAgICAgICAgICAgICAgICAgICBUcmFwZXpvaWRbXSB0TGlzdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNwICYmIGNxKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdExpc3QgPSBfdHJhcGV6b2lkYWxNYXAuQ2FzZTEodCwgZWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9xdWVyeUdyYXBoLkNhc2UxKHQuU2luaywgZWRnZSwgdExpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjcCAmJiAhY3EpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0TGlzdCA9IF90cmFwZXpvaWRhbE1hcC5DYXNlMih0LCBlZGdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3F1ZXJ5R3JhcGguQ2FzZTIodC5TaW5rLCBlZGdlLCB0TGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjcCAmJiAhY3EpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0TGlzdCA9IF90cmFwZXpvaWRhbE1hcC5DYXNlMyh0LCBlZGdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3F1ZXJ5R3JhcGguQ2FzZTModC5TaW5rLCBlZGdlLCB0TGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRMaXN0ID0gX3RyYXBlem9pZGFsTWFwLkNhc2U0KHQsIGVkZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcXVlcnlHcmFwaC5DYXNlNCh0LlNpbmssIGVkZ2UsIHRMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG5ldyB0cmFwZXpvaWRzIHRvIG1hcFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmVhY2ggKFRyYXBlem9pZCB5IGluIHRMaXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RyYXBlem9pZGFsTWFwLk1hcC5BZGQoeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RyYXBlem9pZGFsTWFwLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1hcmsgb3V0c2lkZSB0cmFwZXpvaWRzXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKFRyYXBlem9pZCB0IGluIF90cmFwZXpvaWRhbE1hcC5NYXApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1hcmtPdXRzaWRlKHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb2xsZWN0IGludGVyaW9yIHRyYXBlem9pZHNcclxuICAgICAgICAgICAgZm9yZWFjaCAoVHJhcGV6b2lkIHQgaW4gX3RyYXBlem9pZGFsTWFwLk1hcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHQuSW5zaWRlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFRyYXBlem9pZHMuQWRkKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuQWRkUG9pbnRzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSB0cmlhbmdsZXNcclxuICAgICAgICAgICAgQ3JlYXRlTW91bnRhaW5zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCdWlsZCBhIGxpc3Qgb2YgeC1tb25vdG9uZSBtb3VudGFpbnNcclxuICAgICAgICBwcml2YXRlIHZvaWQgQ3JlYXRlTW91bnRhaW5zKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEVkZ2UgZWRnZSBpbiBfZWRnZUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChlZGdlLk1Qb2ludHMuQ291bnQgPiAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIE1vbm90b25lTW91bnRhaW4gbW91bnRhaW4gPSBuZXcgTW9ub3RvbmVNb3VudGFpbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTb3J0aW5nIGlzIGEgcGVyZnJvbWFuY2UgaGl0LiBMaXRlcmF0dXJlIHNheXMgdGhpcyBjYW4gYmUgYWNjb21wbGlzZWQgaW5cclxuICAgICAgICAgICAgICAgICAgICAvLyBsaW5lYXIgdGltZSwgYWx0aG91Z2ggSSBkb24ndCBzZWUgYSB3YXkgYXJvdW5kIHVzaW5nIHRyYWRpdGlvbmFsIG1ldGhvZHNcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHVzaW5nIGEgcmFuZG9taXplZCBpbmNyZW1lbnRhbCBhbGdvcml0aG1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0aW9uIHNvcnQgaXMgb25lIG9mIHRoZSBmYXN0ZXN0IGFsZ29yaXRobXMgZm9yIHNvcnRpbmcgYXJyYXlzIGNvbnRhaW5pbmcgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmV3ZXIgdGhhbiB0ZW4gZWxlbWVudHMsIG9yIGZvciBsaXN0cyB0aGF0IGFyZSBhbHJlYWR5IG1vc3RseSBzb3J0ZWQuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIExpc3Q8UG9pbnQ+IHBvaW50cyA9IG5ldyBMaXN0PFBvaW50PihlZGdlLk1Qb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5Tb3J0KChnbG9iYWw6OlN5c3RlbS5Db21wYXJpc29uPGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb24uUG9pbnQ+KSgocDEsIHAyKSA9PiBwMS5YLkNvbXBhcmVUbyhwMi5YKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3JlYWNoIChQb2ludCBwIGluIHBvaW50cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRhaW4uQWRkKHApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbmd1bGF0ZSBtb25vdG9uZSBtb3VudGFpblxyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50YWluLlByb2Nlc3MoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgdHJpYW5nbGVzIGludG8gYSBzaW5nbGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmVhY2ggKExpc3Q8UG9pbnQ+IHQgaW4gbW91bnRhaW4uVHJpYW5nbGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVHJpYW5nbGVzLkFkZCh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF94TW9ub1BvbHkuQWRkKG1vdW50YWluKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTWFyayB0aGUgb3V0c2lkZSB0cmFwZXpvaWRzIHN1cnJvdW5kaW5nIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIE1hcmtPdXRzaWRlKFRyYXBlem9pZCB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHQuVG9wID09IF9ib3VuZGluZ0JveC5Ub3AgfHwgdC5Cb3R0b20gPT0gX2JvdW5kaW5nQm94LkJvdHRvbSlcclxuICAgICAgICAgICAgICAgIHQuVHJpbU5laWdoYm9ycygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHNlZ21lbnRzIGFuZCBjb25uZWN0IGVuZCBwb2ludHM7IHVwZGF0ZSBlZGdlIGV2ZW50IHBvaW50ZXJcclxuICAgICAgICBwcml2YXRlIExpc3Q8RWRnZT4gSW5pdEVkZ2VzKExpc3Q8UG9pbnQ+IHBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpc3Q8RWRnZT4gZWRnZXMgPSBuZXcgTGlzdDxFZGdlPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwb2ludHMuQ291bnQgLSAxOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVkZ2VzLkFkZChuZXcgRWRnZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlZGdlcy5BZGQobmV3IEVkZ2UocG9pbnRzWzBdLCBwb2ludHNbcG9pbnRzLkNvdW50IC0gMV0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGVyU2VnbWVudHMoZWRnZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBMaXN0PEVkZ2U+IE9yZGVyU2VnbWVudHMoTGlzdDxFZGdlPiBlZGdlSW5wdXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBJZ25vcmUgdmVydGljYWwgc2VnbWVudHMhXHJcbiAgICAgICAgICAgIExpc3Q8RWRnZT4gZWRnZXMgPSBuZXcgTGlzdDxFZGdlPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoRWRnZSBlIGluIGVkZ2VJbnB1dClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUG9pbnQgcCA9IFNoZWFyVHJhbnNmb3JtKGUuUCk7XHJcbiAgICAgICAgICAgICAgICBQb2ludCBxID0gU2hlYXJUcmFuc2Zvcm0oZS5RKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQb2ludCBwIG11c3QgYmUgdG8gdGhlIGxlZnQgb2YgcG9pbnQgcVxyXG4gICAgICAgICAgICAgICAgaWYgKHAuWCA+IHEuWClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlcy5BZGQobmV3IEVkZ2UocSwgcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocC5YIDwgcS5YKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLkFkZChuZXcgRWRnZShwLCBxKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJhbmRvbWl6ZWQgdHJpYW5ndWxhdGlvbiBpbXByb3ZlcyBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAgICAvLyBTZWUgU2VpZGVsJ3MgcGFwZXIsIG9yIE8nUm91cmtlJ3MgYm9vaywgcC4gNTcgXHJcbiAgICAgICAgICAgIFNodWZmbGU8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvbi5FZGdlPihlZGdlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBlZGdlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgU2h1ZmZsZTxUPihJTGlzdDxUPiBsaXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUmFuZG9tIHJuZyA9IG5ldyBSYW5kb20oKTtcclxuICAgICAgICAgICAgaW50IG4gPSBsaXN0LkNvdW50O1xyXG4gICAgICAgICAgICB3aGlsZSAobiA+IDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG4tLTtcclxuICAgICAgICAgICAgICAgIGludCBrID0gcm5nLk5leHQobiArIDEpO1xyXG4gICAgICAgICAgICAgICAgVCB2YWx1ZSA9IGxpc3Rba107XHJcbiAgICAgICAgICAgICAgICBsaXN0W2tdID0gbGlzdFtuXTtcclxuICAgICAgICAgICAgICAgIGxpc3Rbbl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudHMgYW55IHR3byBkaXN0aW5jdCBlbmRwb2ludHMgZnJvbSBseWluZyBvbiBhIGNvbW1vbiB2ZXJ0aWNhbCBsaW5lLCBhbmQgYXZvaWRpbmdcclxuICAgICAgICAvLyB0aGUgZGVnZW5lcmF0ZSBjYXNlLiBTZWUgTWFyayBkZSBCZXJnIGV0IGFsLCBDaGFwdGVyIDYuM1xyXG4gICAgICAgIHByaXZhdGUgUG9pbnQgU2hlYXJUcmFuc2Zvcm0oUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LlggKyBfc2hlZXIgKiBwb2ludC5ZLCBwb2ludC5ZKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb25cclxue1xyXG4gICAgLy8gT3JpZ2luYWwgY29kZSBjYW4gYmUgZm91bmQgaGVyZTogaHR0cDovL3d3dy5mbGlwY29kZS5jb20vYXJjaGl2ZXMvRWZmaWNpZW50X1BvbHlnb25fVHJpYW5ndWxhdGlvbi5zaHRtbFxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUcmlhbmd1bGF0ZXMgYSBwb2x5Z29uIGludG8gdHJpYW5nbGVzLlxyXG4gICAgLy8vIERvZXNuJ3QgaGFuZGxlIGhvbGVzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgRmxpcGNvZGVEZWNvbXBvc2VyXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgVmVjdG9yMiBfdG1wQTtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBWZWN0b3IyIF90bXBCO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlY3RvcjIgX3RtcEM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hlY2sgaWYgdGhlIHBvaW50IFAgaXMgaW5zaWRlIHRoZSB0cmlhbmdsZSBkZWZpbmVkIGJ5XHJcbiAgICAgICAgLy8vIHRoZSBwb2ludHMgQSwgQiwgQ1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYVwiPlRoZSBBIHBvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYlwiPlRoZSBCIHBvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY1wiPlRoZSBDIHBvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlRoZSBwb2ludCB0byBiZSB0ZXN0ZWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSB0cmlhbmdsZTwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIEluc2lkZVRyaWFuZ2xlKHJlZiBWZWN0b3IyIGEsIHJlZiBWZWN0b3IyIGIsIHJlZiBWZWN0b3IyIGMsIHJlZiBWZWN0b3IyIHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL0EgY3Jvc3MgYnBcclxuICAgICAgICAgICAgZmxvYXQgYWJwID0gKGMuWCAtIGIuWCkgKiAocC5ZIC0gYi5ZKSAtIChjLlkgLSBiLlkpICogKHAuWCAtIGIuWCk7XHJcblxyXG4gICAgICAgICAgICAvL0EgY3Jvc3MgYXBcclxuICAgICAgICAgICAgZmxvYXQgYWFwID0gKGIuWCAtIGEuWCkgKiAocC5ZIC0gYS5ZKSAtIChiLlkgLSBhLlkpICogKHAuWCAtIGEuWCk7XHJcblxyXG4gICAgICAgICAgICAvL2IgY3Jvc3MgY3BcclxuICAgICAgICAgICAgZmxvYXQgYmNwID0gKGEuWCAtIGMuWCkgKiAocC5ZIC0gYy5ZKSAtIChhLlkgLSBjLlkpICogKHAuWCAtIGMuWCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKChhYnAgPj0gMC4wZikgJiYgKGJjcCA+PSAwLjBmKSAmJiAoYWFwID49IDAuMGYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3V0IGEgdGhlIGNvbnRvdXIgYW5kIGFkZCBhIHRyaWFuZ2xlIGludG8gViB0byBkZXNjcmliZSB0aGUgXHJcbiAgICAgICAgLy8vIGxvY2F0aW9uIG9mIHRoZSBjdXRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbnRvdXJcIj5UaGUgbGlzdCBvZiBwb2ludHMgZGVmaW5pbmcgdGhlIHBvbHlnb248L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInVcIj5UaGUgaW5kZXggb2YgdGhlIGZpcnN0IHBvaW50PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2XCI+VGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgcG9pbnQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndcIj5UaGUgaW5kZXggb2YgdGhlIHRoaXJkIHBvaW50PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJuXCI+VGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJWXCI+VGhlIGFycmF5IHRvIHBvcHVsYXRlIHdpdGggaW5kaWNpZXMgb2YgdHJpYW5nbGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgYSB0cmlhbmdsZSB3YXMgZm91bmQ8L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBTbmlwKFZlcnRpY2VzIGNvbnRvdXIsIGludCB1LCBpbnQgdiwgaW50IHcsIGludCBuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXSBWKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVwc2lsb24gPiBNYXRoVXRpbHMuQXJlYShyZWYgX3RtcEEsIHJlZiBfdG1wQiwgcmVmIF90bXBDKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBwID0gMDsgcCA8IG47IHArKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwID09IHUpIHx8IChwID09IHYpIHx8IChwID09IHcpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnQgPSBjb250b3VyW1ZbcF1dO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChJbnNpZGVUcmlhbmdsZShyZWYgX3RtcEEsIHJlZiBfdG1wQiwgcmVmIF90bXBDLCByZWYgcG9pbnQpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlY29tcG9zZSB0aGUgcG9seWdvbiBpbnRvIHRyaWFuZ2xlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29udG91clwiPlRoZSBsaXN0IG9mIHBvaW50cyBkZXNjcmliaW5nIHRoZSBwb2x5Z29uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxWZXJ0aWNlcz4gQ29udmV4UGFydGl0aW9uKFZlcnRpY2VzIGNvbnRvdXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgbiA9IGNvbnRvdXIuQ291bnQ7XHJcbiAgICAgICAgICAgIGlmIChuIDwgMylcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuXHJcbiAgICAgICAgICAgIGludFtdIFYgPSBuZXcgaW50W25dO1xyXG5cclxuICAgICAgICAgICAgLy8gV2Ugd2FudCBhIGNvdW50ZXItY2xvY2t3aXNlIHBvbHlnb24gaW4gVlxyXG4gICAgICAgICAgICBpZiAoY29udG91ci5Jc0NvdW50ZXJDbG9ja1dpc2UoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgdiA9IDA7IHYgPCBuOyB2KyspXHJcbiAgICAgICAgICAgICAgICAgICAgVlt2XSA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB2ID0gMDsgdiA8IG47IHYrKylcclxuICAgICAgICAgICAgICAgICAgICBWW3ZdID0gKG4gLSAxKSAtIHY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCBudiA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgbnYtMiBWZXJ0aWNlcywgY3JlYXRpbmcgMSB0cmlhbmdsZSBldmVyeSB0aW1lXHJcbiAgICAgICAgICAgIGludCBjb3VudCA9IDIgKiBudjsgLyogZXJyb3IgZGV0ZWN0aW9uICovXHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiByZXN1bHQgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IHYgPSBudiAtIDE7IG52ID4gMjsgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiBcclxuICAgICAgICAgICAgICAgIGlmICgwID49IChjb3VudC0tKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+XHJcbiAgICAgICAgICAgICAgICBpbnQgdSA9IHY7XHJcbiAgICAgICAgICAgICAgICBpZiAobnYgPD0gdSlcclxuICAgICAgICAgICAgICAgICAgICB1ID0gMDsgLy8gUHJldmlvdXMgXHJcbiAgICAgICAgICAgICAgICB2ID0gdSArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAobnYgPD0gdilcclxuICAgICAgICAgICAgICAgICAgICB2ID0gMDsgLy8gTmV3IHYgICBcclxuICAgICAgICAgICAgICAgIGludCB3ID0gdiArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAobnYgPD0gdylcclxuICAgICAgICAgICAgICAgICAgICB3ID0gMDsgLy8gTmV4dCBcclxuXHJcbiAgICAgICAgICAgICAgICBfdG1wQSA9IGNvbnRvdXJbVlt1XV07XHJcbiAgICAgICAgICAgICAgICBfdG1wQiA9IGNvbnRvdXJbVlt2XV07XHJcbiAgICAgICAgICAgICAgICBfdG1wQyA9IGNvbnRvdXJbVlt3XV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFNuaXAoY29udG91ciwgdSwgdiwgdywgbnYsIFYpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBzLCB0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdXRwdXQgVHJpYW5nbGVcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcyB0cmlhbmdsZSA9IG5ldyBWZXJ0aWNlcygzKTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZS5BZGQoX3RtcEEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlLkFkZChfdG1wQik7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUuQWRkKF90bXBDKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQWRkKHRyaWFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHYgZnJvbSByZW1haW5pbmcgcG9seWdvbiBcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcysrLCB0KyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWW3NdID0gVlt0XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbnYtLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDIgKiBudjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIFN5c3RlbS5UZXh0O1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vblxyXG57XHJcbiNpZiAhKFhCT1gzNjApXHJcbiAgICBbRGVidWdnZXJEaXNwbGF5KFwiQ291bnQgPSB7Q291bnR9IFZlcnRpY2VzID0ge1RvU3RyaW5nKCl9XCIpXVxyXG4jZW5kaWZcclxuICAgIHB1YmxpYyBjbGFzcyBWZXJ0aWNlcyA6IExpc3Q8VmVjdG9yMj5cclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVydGljZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZXJ0aWNlcyhpbnQgY2FwYWNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDYXBhY2l0eSA9IGNhcGFjaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlcnRpY2VzKFZlY3RvcjJbXSB2ZWN0b3IyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZWN0b3IyLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBZGQodmVjdG9yMltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZXJ0aWNlcyhJTGlzdDxWZWN0b3IyPiB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQWRkKHZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZXh0cyB0aGUgaW5kZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGludCBOZXh0SW5kZXgoaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09IENvdW50IC0gMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIE5leHRWZXJ0ZXgoaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbTmV4dEluZGV4KGluZGV4KV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIHByZXZpb3VzIGluZGV4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhcIj5UaGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgUHJldmlvdXNJbmRleChpbnQgaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvdW50IC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXggLSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgUHJldmlvdXNWZXJ0ZXgoaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbUHJldmlvdXNJbmRleChpbmRleCldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBzaWduZWQgYXJlYS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEdldFNpZ25lZEFyZWEoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGk7XHJcbiAgICAgICAgICAgIGZsb2F0IGFyZWEgPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IENvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBqID0gKGkgKyAxKSAlIENvdW50O1xyXG4gICAgICAgICAgICAgICAgYXJlYSArPSB0aGlzW2ldLlggKiB0aGlzW2pdLlk7XHJcbiAgICAgICAgICAgICAgICBhcmVhIC09IHRoaXNbaV0uWSAqIHRoaXNbal0uWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmVhIC89IDIuMGY7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBhcmVhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgR2V0QXJlYSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgaTtcclxuICAgICAgICAgICAgZmxvYXQgYXJlYSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGogPSAoaSArIDEpICUgQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBhcmVhICs9IHRoaXNbaV0uWCAqIHRoaXNbal0uWTtcclxuICAgICAgICAgICAgICAgIGFyZWEgLT0gdGhpc1tpXS5ZICogdGhpc1tqXS5YO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFyZWEgLz0gMi4wZjtcclxuICAgICAgICAgICAgcmV0dXJuIChhcmVhIDwgMCA/IC1hcmVhIDogYXJlYSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGNlbnRyb2lkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRDZW50cm9pZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBTYW1lIGFsZ29yaXRobSBpcyB1c2VkIGJ5IEJveDJEXHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGMgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIGZsb2F0IGFyZWEgPSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZmxvYXQgaW52MyA9IDEuMGYgLyAzLjBmO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHBSZWYgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJpYW5nbGUgdmVydGljZXMuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAxID0gcFJlZjtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDIgPSB0aGlzW2ldO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMyA9IGkgKyAxIDwgQ291bnQgPyB0aGlzW2kgKyAxXSA6IHRoaXNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlMSA9IHAyIC0gcDE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGUyID0gcDMgLSBwMTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBEID0gTWF0aFV0aWxzLkNyb3NzKGUxLCBlMik7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgdHJpYW5nbGVBcmVhID0gMC41ZiAqIEQ7XHJcbiAgICAgICAgICAgICAgICBhcmVhICs9IHRyaWFuZ2xlQXJlYTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcmVhIHdlaWdodGVkIGNlbnRyb2lkXHJcbiAgICAgICAgICAgICAgICBjICs9IHRyaWFuZ2xlQXJlYSAqIGludjMgKiAocDEgKyBwMiArIHAzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2VudHJvaWRcclxuICAgICAgICAgICAgYyAqPSAxLjBmIC8gYXJlYTtcclxuICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIHJhZGl1cyBiYXNlZCBvbiBhcmVhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgR2V0UmFkaXVzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGFyZWEgPSBHZXRTaWduZWRBcmVhKCk7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgcmFkaXVzU3FyZCA9IChkb3VibGUpYXJlYSAvIE1hdGhIZWxwZXIuUGk7XHJcbiAgICAgICAgICAgIGlmIChyYWRpdXNTcXJkIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzU3FyZCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChmbG9hdClNYXRoLlNxcnQocmFkaXVzU3FyZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYW4gQUFCQiBmb3IgdmVydGV4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgQUFCQiBHZXRDb2xsaXNpb25Cb3goKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQUFCQiBhYWJiO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGxvd2VyQm91bmQgPSBuZXcgVmVjdG9yMihmbG9hdC5NYXhWYWx1ZSwgZmxvYXQuTWF4VmFsdWUpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHVwcGVyQm91bmQgPSBuZXcgVmVjdG9yMihmbG9hdC5NaW5WYWx1ZSwgZmxvYXQuTWluVmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXS5YIDwgbG93ZXJCb3VuZC5YKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmQuWCA9IHRoaXNbaV0uWDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLlggPiB1cHBlckJvdW5kLlgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJCb3VuZC5YID0gdGhpc1tpXS5YO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLlkgPCBsb3dlckJvdW5kLlkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJCb3VuZC5ZID0gdGhpc1tpXS5ZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0uWSA+IHVwcGVyQm91bmQuWSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB1cHBlckJvdW5kLlkgPSB0aGlzW2ldLlk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFhYmIuTG93ZXJCb3VuZCA9IGxvd2VyQm91bmQ7XHJcbiAgICAgICAgICAgIGFhYmIuVXBwZXJCb3VuZCA9IHVwcGVyQm91bmQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYWFiYjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFRyYW5zbGF0ZShWZWN0b3IyIHZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyYW5zbGF0ZShyZWYgdmVjdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJhbnNsYXRlcyB0aGUgdmVydGljZXMgd2l0aCB0aGUgc3BlY2lmaWVkIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlY3RvclwiPlRoZSB2ZWN0b3IuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBUcmFuc2xhdGUocmVmIFZlY3RvcjIgdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IFZlY3RvcjIuQWRkKHRoaXNbaV0sIHZlY3Rvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNjYWxlcyB0aGUgdmVydGljZXMgd2l0aCB0aGUgc3BlY2lmaWVkIHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+VGhlIFZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2NhbGUocmVmIFZlY3RvcjIgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gVmVjdG9yMi5NdWx0aXBseSh0aGlzW2ldLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJvdGF0ZSB0aGUgdmVydGljZXMgd2l0aCB0aGUgZGVmaW5lZCB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmFsdWVcIj5UaGUgYW1vdW50IHRvIHJvdGF0ZSBieSBpbiByYWRpYW5zLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUm90YXRlKGZsb2F0IHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4IHJvdGF0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICBNYXRyaXguQ3JlYXRlUm90YXRpb25aKHZhbHVlLCBvdXQgcm90YXRpb25NYXRyaXgpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IFZlY3RvcjIuVHJhbnNmb3JtKHRoaXNbaV0sIHJvdGF0aW9uTWF0cml4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXNzdW1pbmcgdGhlIHBvbHlnb24gaXMgc2ltcGxlOyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgY29udmV4LlxyXG4gICAgICAgIC8vLyBOT1RFOiBJdCB3aWxsIGFsc28gcmV0dXJuIGZhbHNlIGlmIHRoZSBpbnB1dCBjb250YWlucyBjb2xpbmVhciBlZGdlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gXHQ8Yz50cnVlPC9jPiBpZiBpdCBpcyBjb252ZXg7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNDb252ZXgoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBwb2x5Z29uIGlzIGNvbnZleCBhbmQgdGhlIGludGVyaW9yXHJcbiAgICAgICAgICAgIC8vIGlzIHRvIHRoZSBsZWZ0IG9mIGVhY2ggZWRnZS5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaTEgPSBpO1xyXG4gICAgICAgICAgICAgICAgaW50IGkyID0gaSArIDEgPCBDb3VudCA/IGkgKyAxIDogMDtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZWRnZSA9IHRoaXNbaTJdIC0gdGhpc1tpMV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIHZlcnRpY2VzIG9uIHRoZSBjdXJyZW50IGVkZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gaTEgfHwgaiA9PSBpMilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiByID0gdGhpc1tqXSAtIHRoaXNbaTFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzID0gZWRnZS5YICogci5ZIC0gZWRnZS5ZICogci5YO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0NvdW50ZXJDbG9ja1dpc2UoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9XZSBqdXN0IHJldHVybiB0cnVlIGZvciBsaW5lc1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKEdldFNpZ25lZEFyZWEoKSA+IDAuMGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGb3JjZXMgY291bnRlciBjbG9jayB3aXNlIG9yZGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgRm9yY2VDb3VudGVyQ2xvY2tXaXNlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghSXNDb3VudGVyQ2xvY2tXaXNlKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDaGVjayBmb3IgZWRnZSBjcm9zc2luZ3NcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNTaW1wbGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaXBsdXMgPSAoaSArIDEgPiBDb3VudCAtIDEpID8gMCA6IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBhMSA9IG5ldyBWZWN0b3IyKHRoaXNbaV0uWCwgdGhpc1tpXS5ZKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYTIgPSBuZXcgVmVjdG9yMih0aGlzW2lwbHVzXS5YLCB0aGlzW2lwbHVzXS5ZKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSBpICsgMTsgaiA8IENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGpwbHVzID0gKGogKyAxID4gQ291bnQgLSAxKSA/IDAgOiBqICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGIxID0gbmV3IFZlY3RvcjIodGhpc1tqXS5YLCB0aGlzW2pdLlkpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYjIgPSBuZXcgVmVjdG9yMih0aGlzW2pwbHVzXS5YLCB0aGlzW2pwbHVzXS5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB0ZW1wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoTGluZVRvb2xzLkxpbmVJbnRlcnNlY3QyKGExLCBhMiwgYjEsIGIyLCBvdXQgdGVtcCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPOiBUZXN0XHJcbiAgICAgICAgLy9JbXBsZW1lbnRhdGlvbiBmb3VuZCBoZXJlOiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L2NvbW11bml0eS9mb3J1bXMvdG9waWMuYXNwP3RvcGljX2lkPTU0ODQ3N1xyXG4gICAgICAgIHB1YmxpYyBib29sIElzU2ltcGxlMigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgQ291bnQgLSAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGggPSBpICsgMTsgaCA8IENvdW50OyArK2gpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyB0d28gdmVydGljZXMgbGllIG9uIHRvcCBvZiBvbmUgYW5vdGhlcj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT0gdGhpc1toXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IGogPSAoaSArIDEpICUgQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGlUb2ogPSB0aGlzW2pdIC0gdGhpc1tpXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaVRvak5vcm1hbCA9IG5ldyBWZWN0b3IyKGlUb2ouWSwgLWlUb2ouWCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSBpcyB0aGUgZmlyc3QgdmVydGV4IGFuZCBqIGlzIHRoZSBzZWNvbmRcclxuICAgICAgICAgICAgICAgIGludCBzdGFydEsgPSAoaiArIDEpICUgQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBpbnQgZW5kSyA9IChpIC0gMSArIENvdW50KSAlIENvdW50O1xyXG4gICAgICAgICAgICAgICAgZW5kSyArPSBzdGFydEsgPCBlbmRLID8gMCA6IHN0YXJ0SyArIDE7XHJcbiAgICAgICAgICAgICAgICBpbnQgayA9IHN0YXJ0SztcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaVRvayA9IHRoaXNba10gLSB0aGlzW2ldO1xyXG4gICAgICAgICAgICAgICAgYm9vbCBvbkxlZnRTaWRlID0gVmVjdG9yMi5Eb3QoaVRvaywgaVRvak5vcm1hbCkgPj0gMDtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcHJldksgPSB0aGlzW2tdO1xyXG4gICAgICAgICAgICAgICAgKytrO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGsgPD0gZW5kSzsgKytrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBtb2RLID0gayAlIENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlUb2sgPSB0aGlzW21vZEtdIC0gdGhpc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob25MZWZ0U2lkZSAhPSBWZWN0b3IyLkRvdChpVG9rLCBpVG9qTm9ybWFsKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwcmV2S3RvSyA9IHRoaXNbbW9kS10gLSBwcmV2SztcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwcmV2S3RvS05vcm1hbCA9IG5ldyBWZWN0b3IyKHByZXZLdG9LLlksIC1wcmV2S3RvSy5YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChWZWN0b3IyLkRvdCh0aGlzW2ldIC0gcHJldkssIHByZXZLdG9LTm9ybWFsKSA+PSAwKSAhPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFZlY3RvcjIuRG90KHRoaXNbal0gLSBwcmV2SywgcHJldkt0b0tOb3JtYWwpID49IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvbkxlZnRTaWRlID0gVmVjdG9yMi5Eb3QoaVRvaywgaVRvak5vcm1hbCkgPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZLID0gdGhpc1ttb2RLXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGcm9tIEVyaWMgSm9yZGFuJ3MgY29udmV4IGRlY29tcG9zaXRpb24gbGlicmFyeVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENoZWNrcyBpZiBwb2x5Z29uIGlzIHZhbGlkIGZvciB1c2UgaW4gQm94MmQgZW5naW5lLlxyXG4gICAgICAgIC8vLyBMYXN0IGRpdGNoIGVmZm9ydCB0byBlbnN1cmUgbm8gaW52YWxpZCBwb2x5Z29ucyBhcmVcclxuICAgICAgICAvLy8gYWRkZWQgdG8gd29ybGQgZ2VvbWV0cnkuXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIFBlcmZvcm1zIGEgZnVsbCBjaGVjaywgZm9yIHNpbXBsaWNpdHksIGNvbnZleGl0eSxcclxuICAgICAgICAvLy8gb3JpZW50YXRpb24sIG1pbmltdW0gYW5nbGUsIGFuZCB2b2x1bWUuICBUaGlzIHdvbid0XHJcbiAgICAgICAgLy8vIGJlIHZlcnkgZWZmaWNpZW50LCBhbmQgYSBsb3Qgb2YgaXQgaXMgcmVkdW5kYW50IHdoZW5cclxuICAgICAgICAvLy8gb3RoZXIgdG9vbHMgaW4gdGhpcyBzZWN0aW9uIGFyZSB1c2VkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBDaGVja1BvbHlnb24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGVycm9yID0gLTE7XHJcbiAgICAgICAgICAgIGlmIChDb3VudCA8IDMgfHwgQ291bnQgPiBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIUlzQ29udmV4KCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIUlzU2ltcGxlKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoR2V0QXJlYSgpIDwgU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSAzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL0NvbXB1dGUgbm9ybWFsc1xyXG4gICAgICAgICAgICBWZWN0b3IyW10gbm9ybWFscyA9IG5ldyBWZWN0b3IyW0NvdW50XTtcclxuICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoQ291bnQpO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMih0aGlzW2ldLlgsIHRoaXNbaV0uWSkpO1xyXG4gICAgICAgICAgICAgICAgaW50IGkxID0gaTtcclxuICAgICAgICAgICAgICAgIGludCBpMiA9IGkgKyAxIDwgQ291bnQgPyBpICsgMSA6IDA7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGVkZ2UgPSBuZXcgVmVjdG9yMih0aGlzW2kyXS5YIC0gdGhpc1tpMV0uWCwgdGhpc1tpMl0uWSAtIHRoaXNbaTFdLlkpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsc1tpXSA9IE1hdGhVdGlscy5Dcm9zcyhlZGdlLCAxLjBmKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbHNbaV0uTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vUmVxdWlyZWQgc2lkZSBjaGVja3NcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaW1pbnVzID0gKGkgPT0gMCkgPyBDb3VudCAtIDEgOiBpIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1BhcmFsbGVsIHNpZGVzIGNoZWNrXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBjcm9zcyA9IE1hdGhVdGlscy5Dcm9zcyhub3JtYWxzW2ltaW51c10sIG5vcm1hbHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgY3Jvc3MgPSBNYXRoVXRpbHMuQ2xhbXAoY3Jvc3MsIC0xLjBmLCAxLjBmKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGFuZ2xlID0gKGZsb2F0KU1hdGguQXNpbihjcm9zcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPD0gU2V0dGluZ3MuQW5ndWxhclNsb3ApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVG9vIHNraW5ueSBjaGVja1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGkgfHwgaiA9PSAoaSArIDEpICUgQ291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcyA9IFZlY3RvcjIuRG90KG5vcm1hbHNbaV0sIHZlcnRpY2VzW2pdIC0gdmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzID49IC1TZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSA1O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBjZW50cm9pZCA9IHZlcnRpY2VzLkdldENlbnRyb2lkKCk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG4xID0gbm9ybWFsc1tpbWludXNdO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuMiA9IG5vcm1hbHNbaV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHYgPSB2ZXJ0aWNlc1tpXSAtIGNlbnRyb2lkO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IG5ldyBWZWN0b3IyKCk7XHJcbiAgICAgICAgICAgICAgICBkLlggPSBWZWN0b3IyLkRvdChuMSwgdik7IC8vIC0gdG9pU2xvcDtcclxuICAgICAgICAgICAgICAgIGQuWSA9IFZlY3RvcjIuRG90KG4yLCB2KTsgLy8gLSB0b2lTbG9wO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNoaWZ0aW5nIHRoZSBlZGdlIGlud2FyZCBieSB0b2lTbG9wIHNob3VsZFxyXG4gICAgICAgICAgICAgICAgLy8gbm90IGNhdXNlIHRoZSBwbGFuZSB0byBwYXNzIHRoZSBjZW50cm9pZC5cclxuICAgICAgICAgICAgICAgIGlmICgoZC5YIDwgMC4wZikgfHwgKGQuWSA8IDAuMGYpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gNjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGVycm9yICE9IC0xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJGb3VuZCBpbnZhbGlkIHBvbHlnb24sIFwiKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXJyb3IpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoc3RyaW5nLkZvcm1hdChcIm11c3QgaGF2ZSBiZXR3ZWVuIDMgYW5kIHswfSB2ZXJ0aWNlcy5cXG5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwibXVzdCBiZSBjb252ZXguXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShcIm11c3QgYmUgc2ltcGxlIChjYW5ub3QgaW50ZXJzZWN0IGl0c2VsZikuXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShcImFyZWEgaXMgdG9vIHNtYWxsLlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJzaWRlcyBhcmUgdG9vIGNsb3NlIHRvIHBhcmFsbGVsLlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJwb2x5Z29uIGlzIHRvbyB0aGluLlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJjb3JlIHNoYXBlIGdlbmVyYXRpb24gd291bGQgbW92ZSBlZGdlIHBhc3QgY2VudHJvaWQgKHRvbyB0aGluKS5cXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShcImRvbid0IGtub3cgd2h5LlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yICE9IC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRnJvbSBFcmljIEpvcmRhbidzIGNvbnZleCBkZWNvbXBvc2l0aW9uIGxpYnJhcnlcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUcmFjZSB0aGUgZWRnZSBvZiBhIG5vbi1zaW1wbGUgcG9seWdvbiBhbmQgcmV0dXJuIGEgc2ltcGxlIHBvbHlnb24uXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBNZXRob2Q6XHJcbiAgICAgICAgLy8vIFN0YXJ0IGF0IHZlcnRleCB3aXRoIG1pbmltdW0geSAocGljayBtYXhpbXVtIHggb25lIGlmIHRoZXJlIGFyZSB0d28pLlxyXG4gICAgICAgIC8vLyBXZSBhaW0gb3VyIFwibGFzdERpclwiIHZlY3RvciBhdCAoMS4wLCAwKVxyXG4gICAgICAgIC8vLyBXZSBsb29rIGF0IHRoZSB0d28gcmF5cyBnb2luZyBvZmYgZnJvbSBvdXIgc3RhcnQgdmVydGV4LCBhbmQgZm9sbG93IHdoaWNoZXZlclxyXG4gICAgICAgIC8vLyBoYXMgdGhlIHNtYWxsZXN0IGFuZ2xlIChpbiAtUGkgLiBQaSkgd3J0IGxhc3REaXIgKFwicmlnaHRlc3RcIiB0dXJuKVxyXG4gICAgICAgIC8vLyBMb29wIHVudGlsIHdlIGhpdCBzdGFydGluZyB2ZXJ0ZXg6XHJcbiAgICAgICAgLy8vIFdlIGFkZCBvdXIgY3VycmVudCB2ZXJ0ZXggdG8gdGhlIGxpc3QuXHJcbiAgICAgICAgLy8vIFdlIGNoZWNrIHRoZSBzZWcgZnJvbSBjdXJyZW50IHZlcnRleCB0byBuZXh0IHZlcnRleCBmb3IgaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgIC8vLyAtIGlmIG5vIGludGVyc2VjdGlvbnMsIGZvbGxvdyB0byBuZXh0IHZlcnRleCBhbmQgY29udGludWVcclxuICAgICAgICAvLy8gLSBpZiBpbnRlcnNlY3Rpb25zLCBwaWNrIG9uZSB3aXRoIG1pbmltdW0gZGlzdGFuY2VcclxuICAgICAgICAvLy8gLSBpZiBtb3JlIHRoYW4gb25lLCBwaWNrIG9uZSB3aXRoIFwicmlnaHRlc3RcIiBuZXh0IHBvaW50ICh0d28gcG9zc2liaWxpdGllcyBmb3IgZWFjaClcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVydGljZXMgVHJhY2VFZGdlKFZlcnRpY2VzIHZlcnRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9seU5vZGVbXSBub2RlcyA9IG5ldyBQb2x5Tm9kZVt2ZXJ0cy5Db3VudCAqIHZlcnRzLkNvdW50XTtcclxuICAgICAgICAgICAgLy9vdmVya2lsbCwgYnV0IHN1ZmZpY2llbnQgKG9yZGVyIG9mIG1hZy4gaXMgcmlnaHQpXHJcbiAgICAgICAgICAgIGludCBuTm9kZXMgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy9BZGQgYmFzZSBub2RlcyAocmF3IG91dGxpbmUpXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydHMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwb3MgPSBuZXcgVmVjdG9yMih2ZXJ0c1tpXS5YLCB2ZXJ0c1tpXS5ZKTtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldLlBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgKytuTm9kZXM7XHJcbiAgICAgICAgICAgICAgICBpbnQgaXBsdXMgPSAoaSA9PSB2ZXJ0cy5Db3VudCAtIDEpID8gMCA6IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgaW50IGltaW51cyA9IChpID09IDApID8gdmVydHMuQ291bnQgLSAxIDogaSAtIDE7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5BZGRDb25uZWN0aW9uKG5vZGVzW2lwbHVzXSk7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5BZGRDb25uZWN0aW9uKG5vZGVzW2ltaW51c10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1Byb2Nlc3MgaW50ZXJzZWN0aW9uIG5vZGVzIC0gaG9ycmlibHkgaW5lZmZpY2llbnRcclxuICAgICAgICAgICAgYm9vbCBkaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIGludCBjb3VudGVyID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGRpcnR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuTm9kZXM7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IG5vZGVzW2ldLk5Db25uZWN0ZWQ7ICsrailcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSAwOyBrIDwgbk5vZGVzOyArK2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrID09IGkgfHwgbm9kZXNba10gPT0gbm9kZXNbaV0uQ29ubmVjdGVkW2pdKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGwgPSAwOyBsIDwgbm9kZXNba10uTkNvbm5lY3RlZDsgKytsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2Rlc1trXS5Db25uZWN0ZWRbbF0gPT0gbm9kZXNbaV0uQ29ubmVjdGVkW2pdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2tdLkNvbm5lY3RlZFtsXSA9PSBub2Rlc1tpXSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ2hlY2sgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBpbnRlcnNlY3RQdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBjcm9zc2VzID0gTGluZVRvb2xzLkxpbmVJbnRlcnNlY3Qobm9kZXNbaV0uUG9zaXRpb24sIG5vZGVzW2ldLkNvbm5lY3RlZFtqXS5Qb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1trXS5Qb3NpdGlvbiwgbm9kZXNba10uQ29ubmVjdGVkW2xdLlBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBpbnRlcnNlY3RQdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyb3NzZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRGVzdHJveSBhbmQgcmUtaG9vayBjb25uZWN0aW9ucyBhdCBjcm9zc2luZyBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Tm9kZSBjb25uaiA9IG5vZGVzW2ldLkNvbm5lY3RlZFtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seU5vZGUgY29ubmwgPSBub2Rlc1trXS5Db25uZWN0ZWRbbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLkNvbm5lY3RlZFtqXS5SZW1vdmVDb25uZWN0aW9uKG5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0uUmVtb3ZlQ29ubmVjdGlvbihjb25uaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2tdLkNvbm5lY3RlZFtsXS5SZW1vdmVDb25uZWN0aW9uKG5vZGVzW2tdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNba10uUmVtb3ZlQ29ubmVjdGlvbihjb25ubCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW25Ob2Rlc10gPSBuZXcgUG9seU5vZGUoaW50ZXJzZWN0UHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tuTm9kZXNdLkFkZENvbm5lY3Rpb24obm9kZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXS5BZGRDb25uZWN0aW9uKG5vZGVzW25Ob2Rlc10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tuTm9kZXNdLkFkZENvbm5lY3Rpb24obm9kZXNba10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1trXS5BZGRDb25uZWN0aW9uKG5vZGVzW25Ob2Rlc10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tuTm9kZXNdLkFkZENvbm5lY3Rpb24oY29ubmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uai5BZGRDb25uZWN0aW9uKG5vZGVzW25Ob2Rlc10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tuTm9kZXNdLkFkZENvbm5lY3Rpb24oY29ubmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25ubC5BZGRDb25uZWN0aW9uKG5vZGVzW25Ob2Rlc10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK25Ob2RlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ290byBTa2lwT3V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2tpcE91dDpcclxuICAgICAgICAgICAgICAgICsrY291bnRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9Db2xsYXBzZSBkdXBsaWNhdGUgcG9pbnRzXHJcbiAgICAgICAgICAgIGJvb2wgZm91bmREdXBlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaW50IG5BY3RpdmUgPSBuTm9kZXM7XHJcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZER1cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kRHVwZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuTm9kZXM7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXNbaV0uTkNvbm5lY3RlZCA9PSAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gaSArIDE7IGogPCBuTm9kZXM7ICsrailcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2Rlc1tqXS5OQ29ubmVjdGVkID09IDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGRpZmYgPSBub2Rlc1tpXS5Qb3NpdGlvbiAtIG5vZGVzW2pdLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZi5MZW5ndGhTcXVhcmVkKCkgPD0gU2V0dGluZ3MuRXBzaWxvbiAqIFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuQWN0aXZlIDw9IDMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHJpbnRmKFwiRm91bmQgZHVwZSwgJWQgbGVmdFxcblwiLG5BY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1uQWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmREdXBlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlOb2RlIGlub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Tm9kZSBqbm9kZSA9IG5vZGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Nb3ZlIGFsbCBvZiBqJ3MgY29ubmVjdGlvbnMgdG8gaSwgYW5kIG9ycGhhbiBqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgbmpDb25uID0gam5vZGUuTkNvbm5lY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSAwOyBrIDwgbmpDb25uOyArK2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seU5vZGUga25vZGUgPSBqbm9kZS5Db25uZWN0ZWRba107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGtub2RlICE9IGpub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa25vZGUgIT0gaW5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm9kZS5BZGRDb25uZWN0aW9uKGtub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga25vZGUuQWRkQ29ubmVjdGlvbihpbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtub2RlLlJlbW92ZUNvbm5lY3Rpb24oam5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgam5vZGUuTkNvbm5lY3RlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vTm93IHdhbGsgdGhlIGVkZ2Ugb2YgdGhlIGxpc3RcclxuXHJcbiAgICAgICAgICAgIC8vRmluZCBub2RlIHdpdGggbWluaW11bSB5IHZhbHVlIChtYXggeCBpZiBlcXVhbClcclxuICAgICAgICAgICAgZmxvYXQgbWluWSA9IGZsb2F0Lk1heFZhbHVlO1xyXG4gICAgICAgICAgICBmbG9hdCBtYXhYID0gLWZsb2F0Lk1heFZhbHVlO1xyXG4gICAgICAgICAgICBpbnQgbWluWUluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbk5vZGVzOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2Rlc1tpXS5Qb3NpdGlvbi5ZIDwgbWluWSAmJiBub2Rlc1tpXS5OQ29ubmVjdGVkID4gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gbm9kZXNbaV0uUG9zaXRpb24uWTtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBub2Rlc1tpXS5Qb3NpdGlvbi5YO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZXNbaV0uUG9zaXRpb24uWSA9PSBtaW5ZICYmIG5vZGVzW2ldLlBvc2l0aW9uLlggPiBtYXhYICYmIG5vZGVzW2ldLk5Db25uZWN0ZWQgPiAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbllJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IG5vZGVzW2ldLlBvc2l0aW9uLlg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgb3JpZ0RpciA9IG5ldyBWZWN0b3IyKDEuMGYsIDAuMGYpO1xyXG4gICAgICAgICAgICBWZWN0b3IyW10gcmVzdWx0VmVjcyA9IG5ldyBWZWN0b3IyWzQgKiBuTm9kZXNdO1xyXG4gICAgICAgICAgICAvLyBub2RlcyBtYXkgYmUgdmlzaXRlZCBtb3JlIHRoYW4gb25jZSwgdW5mb3J0dW5hdGVseSAtIGNoYW5nZSB0byBncm93YWJsZSBhcnJheSFcclxuICAgICAgICAgICAgaW50IG5SZXN1bHRWZWNzID0gMDtcclxuICAgICAgICAgICAgUG9seU5vZGUgY3VycmVudE5vZGUgPSBub2Rlc1ttaW5ZSW5kZXhdO1xyXG4gICAgICAgICAgICBQb2x5Tm9kZSBzdGFydE5vZGUgPSBjdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGN1cnJlbnROb2RlLk5Db25uZWN0ZWQgPiAwKTtcclxuICAgICAgICAgICAgUG9seU5vZGUgbmV4dE5vZGUgPSBjdXJyZW50Tm9kZS5HZXRSaWdodGVzdENvbm5lY3Rpb24ob3JpZ0Rpcik7XHJcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyhuUmVzdWx0VmVjcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuUmVzdWx0VmVjczsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChyZXN1bHRWZWNzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEJvcmtlZCwgY2xlYW4gdXAgb3VyIG1lc3MgYW5kIHJldHVyblxyXG4gICAgICAgICAgICByZXN1bHRWZWNzWzBdID0gc3RhcnROb2RlLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICArK25SZXN1bHRWZWNzO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dE5vZGUgIT0gc3RhcnROb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoblJlc3VsdFZlY3MgPiA0ICogbk5vZGVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRWZWNzW25SZXN1bHRWZWNzKytdID0gbmV4dE5vZGUuUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBQb2x5Tm9kZSBvbGROb2RlID0gY3VycmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBjdXJyZW50Tm9kZS5HZXRSaWdodGVzdENvbm5lY3Rpb24ob2xkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyhuUmVzdWx0VmVjcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuUmVzdWx0VmVjczsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKHJlc3VsdFZlY3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSB3YXMgYSBwcm9ibGVtLCBzbyBqdW1wIG91dCBvZiB0aGUgbG9vcCBhbmQgdXNlIHdoYXRldmVyIGdhcmJhZ2Ugd2UndmUgZ2VuZXJhdGVkIHNvIGZhclxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGNsYXNzIFBvbHlOb2RlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcml2YXRlIGNvbnN0IGludCBNYXhDb25uZWN0ZWQgPSAzMjtcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIEdpdmVuIHNpbmVzIGFuZCBjb3NpbmVzLCB0ZWxscyBpZiBBJ3MgYW5nbGUgaXMgbGVzcyB0aGFuIEIncyBvbiAtUGksIFBpXHJcbiAgICAgICAgICAgICAqIChpbiBvdGhlciB3b3JkcywgaXMgQSBcInJpZ2h0ZXJcIiB0aGFuIEIpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwdWJsaWMgUG9seU5vZGVbXSBDb25uZWN0ZWQgPSBuZXcgUG9seU5vZGVbTWF4Q29ubmVjdGVkXTtcclxuICAgICAgICAgICAgcHVibGljIGludCBOQ29ubmVjdGVkO1xyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yMiBQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBQb2x5Tm9kZShWZWN0b3IyIHBvcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUG9zaXRpb24gPSBwb3M7XHJcbiAgICAgICAgICAgICAgICBOQ29ubmVjdGVkID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJpdmF0ZSBib29sIElzUmlnaHRlcihmbG9hdCBzaW5BLCBmbG9hdCBjb3NBLCBmbG9hdCBzaW5CLCBmbG9hdCBjb3NCKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luQSA8IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbkIgPiAwIHx8IGNvc0EgPD0gY29zQikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbkIgPCAwIHx8IGNvc0EgPD0gY29zQikgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyB2b2lkIEFkZENvbm5lY3Rpb24oUG9seU5vZGUgdG9NZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KE5Db25uZWN0ZWQgPCBNYXhDb25uZWN0ZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBkdXBsaWNhdGUgYWRkaXRpb25zXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IE5Db25uZWN0ZWQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ29ubmVjdGVkW2ldID09IHRvTWUpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIENvbm5lY3RlZFtOQ29ubmVjdGVkXSA9IHRvTWU7XHJcbiAgICAgICAgICAgICAgICArK05Db25uZWN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZUNvbm5lY3Rpb24oUG9seU5vZGUgZnJvbU1lKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib29sIGlzRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGludCBmb3VuZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IE5Db25uZWN0ZWQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbU1lID09IENvbm5lY3RlZFtpXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLnBvc2l0aW9uID09IGNvbm5lY3RlZFtpXS5wb3NpdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGlzRm91bmQpO1xyXG4gICAgICAgICAgICAgICAgLS1OQ29ubmVjdGVkO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IGZvdW5kSW5kZXg7IGkgPCBOQ29ubmVjdGVkOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29ubmVjdGVkW2ldID0gQ29ubmVjdGVkW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIFBvbHlOb2RlIEdldFJpZ2h0ZXN0Q29ubmVjdGlvbihQb2x5Tm9kZSBpbmNvbWluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKE5Db25uZWN0ZWQgPT0gMCkgRGVidWcuQXNzZXJ0KGZhbHNlKTsgLy8gVGhpcyBtZWFucyB0aGUgY29ubmVjdGlvbiBncmFwaCBpcyBpbmNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICAgIGlmIChOQ29ubmVjdGVkID09IDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9iMkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGUgcG9zc2liaWxpdHkgb2YgY29sbGFwc2luZyBuZWFyYnkgcG9pbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG1heSBlbmQgdXAgd2l0aCBcInNwaWRlciBsZWdzXCIgZGFuZ2xpbmcgb2ZmIG9mIGEgcmVnaW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb3JyZWN0IGJlaGF2aW9yIGhlcmUgaXMgdG8gdHVybiBhcm91bmQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluY29taW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpbkRpciA9IFBvc2l0aW9uIC0gaW5jb21pbmcuUG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW5MZW5ndGggPSBpbkRpci5MZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGluRGlyLk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChpbkxlbmd0aCA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIFBvbHlOb2RlIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IE5Db25uZWN0ZWQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ29ubmVjdGVkW2ldID09IGluY29taW5nKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRlc3REaXIgPSBDb25uZWN0ZWRbaV0uUG9zaXRpb24gLSBQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB0ZXN0TGVuZ3RoU3FyID0gdGVzdERpci5MZW5ndGhTcXVhcmVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdERpci5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQodGVzdExlbmd0aFNxciA+PSBTZXR0aW5ncy5FcHNpbG9uICogU2V0dGluZ3MuRXBzaWxvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbXlDb3MgPSBWZWN0b3IyLkRvdChpbkRpciwgdGVzdERpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbXlTaW4gPSBNYXRoVXRpbHMuQ3Jvc3MoaW5EaXIsIHRlc3REaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcmVzdWx0RGlyID0gcmVzdWx0LlBvc2l0aW9uIC0gUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdERpci5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcmVzQ29zID0gVmVjdG9yMi5Eb3QoaW5EaXIsIHJlc3VsdERpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHJlc1NpbiA9IE1hdGhVdGlscy5Dcm9zcyhpbkRpciwgcmVzdWx0RGlyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElzUmlnaHRlcihteVNpbiwgbXlDb3MsIHJlc1NpbiwgcmVzQ29zKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQ29ubmVjdGVkW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IENvbm5lY3RlZFtpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHJlc3VsdCAhPSBudWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgUG9seU5vZGUgR2V0UmlnaHRlc3RDb25uZWN0aW9uKFZlY3RvcjIgaW5jb21pbmdEaXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZGlmZiA9IFBvc2l0aW9uIC0gaW5jb21pbmdEaXI7XHJcbiAgICAgICAgICAgICAgICBQb2x5Tm9kZSB0ZW1wID0gbmV3IFBvbHlOb2RlKGRpZmYpO1xyXG4gICAgICAgICAgICAgICAgUG9seU5vZGUgcmVzID0gR2V0UmlnaHRlc3RDb25uZWN0aW9uKHRlbXApO1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHJlcyAhPSBudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBzdHJpbmcgVG9TdHJpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU3RyaW5nQnVpbGRlciBidWlsZGVyID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLkFwcGVuZCh0aGlzW2ldLlRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBDb3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5BcHBlbmQoXCIgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLlRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFByb2plY3RzIHRvIGF4aXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJheGlzXCI+VGhlIGF4aXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtaW5cIj5UaGUgbWluLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWF4XCI+VGhlIG1heC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFByb2plY3RUb0F4aXMocmVmIFZlY3RvcjIgYXhpcywgb3V0IGZsb2F0IG1pbiwgb3V0IGZsb2F0IG1heClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRvIHByb2plY3QgYSBwb2ludCBvbiBhbiBheGlzIHVzZSB0aGUgZG90IHByb2R1Y3RcclxuICAgICAgICAgICAgZmxvYXQgZG90UHJvZHVjdCA9IFZlY3RvcjIuRG90KGF4aXMsIHRoaXNbMF0pO1xyXG4gICAgICAgICAgICBtaW4gPSBkb3RQcm9kdWN0O1xyXG4gICAgICAgICAgICBtYXggPSBkb3RQcm9kdWN0O1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkb3RQcm9kdWN0ID0gVmVjdG9yMi5Eb3QodGhpc1tpXSwgYXhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG90UHJvZHVjdCA8IG1pbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkb3RQcm9kdWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb3RQcm9kdWN0ID4gbWF4KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gZG90UHJvZHVjdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV2luZGluZyBudW1iZXIgdGVzdCBmb3IgYSBwb2ludCBpbiBhIHBvbHlnb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gU2VlIG1vcmUgaW5mbyBhYm91dCB0aGUgYWxnb3JpdGhtIGhlcmU6IGh0dHA6Ly9zb2Z0c3VyZmVyLmNvbS9BcmNoaXZlL2FsZ29yaXRobV8wMTAzL2FsZ29yaXRobV8wMTAzLmh0bVxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+VGhlIHBvaW50IHRvIGJlIHRlc3RlZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz4tMSBpZiB0aGUgd2luZGluZyBudW1iZXIgaXMgemVybyBhbmQgdGhlIHBvaW50IGlzIG91dHNpZGVcclxuICAgICAgICAvLy8gdGhlIHBvbHlnb24sIDEgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcG9seWdvbiwgYW5kIDAgaWYgdGhlIHBvaW50XHJcbiAgICAgICAgLy8vIGlzIG9uIHRoZSBwb2x5Z29ucyBlZGdlLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgaW50IFBvaW50SW5Qb2x5Z29uKHJlZiBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gV2luZGluZyBudW1iZXJcclxuICAgICAgICAgICAgaW50IHduID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBwb2x5Z29uJ3MgZWRnZXNcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAxID0gdGhpc1tpXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDIgPSB0aGlzW05leHRJbmRleChpKV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBpZiBhIHBvaW50IGlzIGRpcmVjdGx5IG9uIHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGVkZ2UgPSBwMiAtIHAxO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgYXJlYSA9IE1hdGhVdGlscy5BcmVhKHJlZiBwMSwgcmVmIHAyLCByZWYgcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPT0gMGYgJiYgVmVjdG9yMi5Eb3QocG9pbnQgLSBwMSwgZWRnZSkgPj0gMGYgJiYgVmVjdG9yMi5Eb3QocG9pbnQgLSBwMiwgZWRnZSkgPD0gMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGVkZ2UgZm9yIGludGVyc2VjdGlvbiB3aXRoIHJheSBmcm9tIHBvaW50XHJcbiAgICAgICAgICAgICAgICBpZiAocDEuWSA8PSBwb2ludC5ZKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwMi5ZID4gcG9pbnQuWSAmJiBhcmVhID4gMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArK3duO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocDIuWSA8PSBwb2ludC5ZICYmIGFyZWEgPCAwZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0td247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAod24gPT0gMCA/IC0xIDogMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIHN1bSBvZiB0aGUgYW5nbGVzIG1hZGUgYmV0d2VlbiB0aGUgdGVzdCBwb2ludCBhbmQgZWFjaCBwYWlyIG9mIHBvaW50cyBtYWtpbmcgdXAgdGhlIHBvbHlnb24uIFxyXG4gICAgICAgIC8vLyBJZiB0aGlzIHN1bSBpcyAycGkgdGhlbiB0aGUgcG9pbnQgaXMgYW4gaW50ZXJpb3IgcG9pbnQsIGlmIDAgdGhlbiB0aGUgcG9pbnQgaXMgYW4gZXh0ZXJpb3IgcG9pbnQuIFxyXG4gICAgICAgIC8vLyByZWY6IGh0dHA6Ly9venZpei53YXNwLnV3YS5lZHUuYXUvfnBib3Vya2UvZ2VvbWV0cnkvaW5zaWRlcG9seS8gIC0gU29sdXRpb24gMiBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIFBvaW50SW5Qb2x5Z29uQW5nbGUocmVmIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgYW5nbGUgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHBvbHlnb24ncyBlZGdlc1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBwb2ludHNcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDEgPSB0aGlzW2ldIC0gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gdGhpc1tOZXh0SW5kZXgoaSldIC0gcG9pbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gTWF0aFV0aWxzLlZlY3RvckFuZ2xlKHJlZiBwMSwgcmVmIHAyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKE1hdGguQWJzKGFuZ2xlKSA8IE1hdGguUEkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uXHJcbntcclxuICAgIHB1YmxpYyBzdHJ1Y3QgRml4ZWRBcnJheTI8VD5cclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMDtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMTtcclxuXHJcbiAgICAgICAgcHVibGljIFQgdGhpc1tpbnQgaW5kZXhdXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGluZGV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlMCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgRml4ZWRBcnJheTM8VD5cclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMDtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMTtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMjtcclxuXHJcbiAgICAgICAgcHVibGljIFQgdGhpc1tpbnQgaW5kZXhdXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMjtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZlJhbmdlRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUwID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlMSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgRml4ZWRBcnJheTQ8VD5cclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMDtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMTtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMjtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMztcclxuXHJcbiAgICAgICAgcHVibGljIFQgdGhpc1tpbnQgaW5kZXhdXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUzO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTAgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUxID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlMiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgRml4ZWRBcnJheTg8VD5cclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMDtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMTtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMjtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlMztcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlNDtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlNTtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlNjtcclxuICAgICAgICBwcml2YXRlIFQgX3ZhbHVlNztcclxuXHJcbiAgICAgICAgcHVibGljIFQgdGhpc1tpbnQgaW5kZXhdXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlNTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWU2O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTc7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGluZGV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlMCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlMyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWU1ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlNiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTcgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb25cclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIENvbGxlY3Rpb24gb2YgaGVscGVyIG1ldGhvZHMgZm9yIG1pc2MgY29sbGlzaW9ucy5cclxuICAgIC8vLyBEb2VzIGZsb2F0IHRvbGVyYW5jZSBhbmQgbGluZSBjb2xsaXNpb25zIHdpdGggbGluZXMgYW5kIEFBQkJzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgTGluZVRvb2xzXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBEaXN0YW5jZUJldHdlZW5Qb2ludEFuZFBvaW50KHJlZiBWZWN0b3IyIHBvaW50MSwgcmVmIFZlY3RvcjIgcG9pbnQyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiB2O1xyXG4gICAgICAgICAgICBWZWN0b3IyLlN1YnRyYWN0KHJlZiBwb2ludDEsIHJlZiBwb2ludDIsIG91dCB2KTtcclxuICAgICAgICAgICAgcmV0dXJuIHYuTGVuZ3RoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IERpc3RhbmNlQmV0d2VlblBvaW50QW5kTGluZVNlZ21lbnQocmVmIFZlY3RvcjIgcG9pbnQsIHJlZiBWZWN0b3IyIGxpbmVFbmRQb2ludDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBWZWN0b3IyIGxpbmVFbmRQb2ludDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYgPSBWZWN0b3IyLlN1YnRyYWN0KGxpbmVFbmRQb2ludDIsIGxpbmVFbmRQb2ludDEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHcgPSBWZWN0b3IyLlN1YnRyYWN0KHBvaW50LCBsaW5lRW5kUG9pbnQxKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGMxID0gVmVjdG9yMi5Eb3Qodywgdik7XHJcbiAgICAgICAgICAgIGlmIChjMSA8PSAwKSByZXR1cm4gRGlzdGFuY2VCZXR3ZWVuUG9pbnRBbmRQb2ludChyZWYgcG9pbnQsIHJlZiBsaW5lRW5kUG9pbnQxKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGMyID0gVmVjdG9yMi5Eb3Qodiwgdik7XHJcbiAgICAgICAgICAgIGlmIChjMiA8PSBjMSkgcmV0dXJuIERpc3RhbmNlQmV0d2VlblBvaW50QW5kUG9pbnQocmVmIHBvaW50LCByZWYgbGluZUVuZFBvaW50Mik7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBiID0gYzEgLyBjMjtcclxuICAgICAgICAgICAgVmVjdG9yMiBwb2ludE9uTGluZSA9IFZlY3RvcjIuQWRkKGxpbmVFbmRQb2ludDEsIFZlY3RvcjIuTXVsdGlwbHkodiwgYikpO1xyXG4gICAgICAgICAgICByZXR1cm4gRGlzdGFuY2VCZXR3ZWVuUG9pbnRBbmRQb2ludChyZWYgcG9pbnQsIHJlZiBwb2ludE9uTGluZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGcm9tIEVyaWMgSm9yZGFuJ3MgY29udmV4IGRlY29tcG9zaXRpb24gbGlicmFyeVxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy9DaGVjayBpZiB0aGUgbGluZXMgYTAtPmExIGFuZCBiMC0+YjEgY3Jvc3MuXHJcbiAgICAgICAgLy8vSWYgdGhleSBkbywgaW50ZXJzZWN0aW9uUG9pbnQgd2lsbCBiZSBmaWxsZWRcclxuICAgICAgICAvLy93aXRoIHRoZSBwb2ludCBvZiBjcm9zc2luZy5cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy9HcmF6aW5nIGxpbmVzIHNob3VsZCBub3QgcmV0dXJuIHRydWUuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYTBcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImExXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJiMFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYjFcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImludGVyc2VjdGlvblBvaW50XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBMaW5lSW50ZXJzZWN0MihWZWN0b3IyIGEwLCBWZWN0b3IyIGExLCBWZWN0b3IyIGIwLCBWZWN0b3IyIGIxLCBvdXQgVmVjdG9yMiBpbnRlcnNlY3Rpb25Qb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50ID0gVmVjdG9yMi5aZXJvO1xyXG5cclxuICAgICAgICAgICAgaWYgKGEwID09IGIwIHx8IGEwID09IGIxIHx8IGExID09IGIwIHx8IGExID09IGIxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgeDEgPSBhMC5YO1xyXG4gICAgICAgICAgICBmbG9hdCB5MSA9IGEwLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IHgyID0gYTEuWDtcclxuICAgICAgICAgICAgZmxvYXQgeTIgPSBhMS5ZO1xyXG4gICAgICAgICAgICBmbG9hdCB4MyA9IGIwLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IHkzID0gYjAuWTtcclxuICAgICAgICAgICAgZmxvYXQgeDQgPSBiMS5YO1xyXG4gICAgICAgICAgICBmbG9hdCB5NCA9IGIxLlk7XHJcblxyXG4gICAgICAgICAgICAvL0FBQkIgZWFybHkgZXhpdFxyXG4gICAgICAgICAgICBpZiAoTWF0aC5NYXgoeDEsIHgyKSA8IE1hdGguTWluKHgzLCB4NCkgfHwgTWF0aC5NYXgoeDMsIHg0KSA8IE1hdGguTWluKHgxLCB4MikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5NYXgoeTEsIHkyKSA8IE1hdGguTWluKHkzLCB5NCkgfHwgTWF0aC5NYXgoeTMsIHk0KSA8IE1hdGguTWluKHkxLCB5MikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCB1YSA9ICgoeDQgLSB4MykgKiAoeTEgLSB5MykgLSAoeTQgLSB5MykgKiAoeDEgLSB4MykpO1xyXG4gICAgICAgICAgICBmbG9hdCB1YiA9ICgoeDIgLSB4MSkgKiAoeTEgLSB5MykgLSAoeTIgLSB5MSkgKiAoeDEgLSB4MykpO1xyXG4gICAgICAgICAgICBmbG9hdCBkZW5vbSA9ICh5NCAtIHkzKSAqICh4MiAtIHgxKSAtICh4NCAtIHgzKSAqICh5MiAtIHkxKTtcclxuICAgICAgICAgICAgaWYgKE1hdGguQWJzKGRlbm9tKSA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vTGluZXMgYXJlIHRvbyBjbG9zZSB0byBwYXJhbGxlbCB0byBjYWxsXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdWEgLz0gZGVub207XHJcbiAgICAgICAgICAgIHViIC89IGRlbm9tO1xyXG5cclxuICAgICAgICAgICAgaWYgKCgwIDwgdWEpICYmICh1YSA8IDEpICYmICgwIDwgdWIpICYmICh1YiA8IDEpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC5YID0gKHgxICsgdWEgKiAoeDIgLSB4MSkpO1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQuWSA9ICh5MSArIHVhICogKHkyIC0geTEpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0Zyb20gTWFyayBCYXlheml0J3MgY29udmV4IGRlY29tcG9zaXRpb24gYWxnb3JpdGhtXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIExpbmVJbnRlcnNlY3QoVmVjdG9yMiBwMSwgVmVjdG9yMiBwMiwgVmVjdG9yMiBxMSwgVmVjdG9yMiBxMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgaSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgZmxvYXQgYTEgPSBwMi5ZIC0gcDEuWTtcclxuICAgICAgICAgICAgZmxvYXQgYjEgPSBwMS5YIC0gcDIuWDtcclxuICAgICAgICAgICAgZmxvYXQgYzEgPSBhMSAqIHAxLlggKyBiMSAqIHAxLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IGEyID0gcTIuWSAtIHExLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IGIyID0gcTEuWCAtIHEyLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IGMyID0gYTIgKiBxMS5YICsgYjIgKiBxMS5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBkZXQgPSBhMSAqIGIyIC0gYTIgKiBiMTtcclxuXHJcbiAgICAgICAgICAgIGlmICghTWF0aFV0aWxzLkZsb2F0RXF1YWxzKGRldCwgMCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGxpbmVzIGFyZSBub3QgcGFyYWxsZWxcclxuICAgICAgICAgICAgICAgIGkuWCA9IChiMiAqIGMxIC0gYjEgKiBjMikgLyBkZXQ7XHJcbiAgICAgICAgICAgICAgICBpLlkgPSAoYTEgKiBjMiAtIGEyICogYzEpIC8gZGV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIG1ldGhvZCBkZXRlY3RzIGlmIHR3byBsaW5lIHNlZ21lbnRzIChvciBsaW5lcykgaW50ZXJzZWN0LFxyXG4gICAgICAgIC8vLyBhbmQsIGlmIHNvLCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uLiBVc2UgdGhlIDxwYXJhbXJlZiBuYW1lPVwiZmlyc3RJc1NlZ21lbnRcIi8+IGFuZFxyXG4gICAgICAgIC8vLyA8cGFyYW1yZWYgbmFtZT1cInNlY29uZElzU2VnbWVudFwiLz4gcGFyYW1ldGVycyB0byBzZXQgd2hldGhlciB0aGUgaW50ZXJzZWN0aW9uIHBvaW50XHJcbiAgICAgICAgLy8vIG11c3QgYmUgb24gdGhlIGZpcnN0IGFuZCBzZWNvbmQgbGluZSBzZWdtZW50cy4gU2V0dGluZyB0aGVzZVxyXG4gICAgICAgIC8vLyBib3RoIHRvIHRydWUgbWVhbnMgeW91IGFyZSBkb2luZyBhIGxpbmUtc2VnbWVudCB0byBsaW5lLXNlZ21lbnRcclxuICAgICAgICAvLy8gaW50ZXJzZWN0aW9uLiBTZXR0aW5nIG9uZSBvZiB0aGVtIHRvIHRydWUgbWVhbnMgeW91IGFyZSBkb2luZyBhXHJcbiAgICAgICAgLy8vIGxpbmUgdG8gbGluZS1zZWdtZW50IGludGVyc2VjdGlvbiB0ZXN0LCBhbmQgc28gb24uXHJcbiAgICAgICAgLy8vIE5vdGU6IElmIHR3byBsaW5lIHNlZ21lbnRzIGFyZSBjb2luY2lkZW50LCB0aGVuIFxyXG4gICAgICAgIC8vLyBubyBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQgKHRoZXJlIGFyZSBhY3R1YWxseVxyXG4gICAgICAgIC8vLyBpbmZpbml0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzKS5cclxuICAgICAgICAvLy8gQXV0aG9yOiBKZXJlbXkgQmVsbFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQxXCI+VGhlIGZpcnN0IHBvaW50IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDJcIj5UaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDNcIj5UaGUgZmlyc3QgcG9pbnQgb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDRcIj5UaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRcIj5UaGlzIGlzIHNldCB0byB0aGUgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgLy8vIHBvaW50IGlmIGFuIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZpcnN0SXNTZWdtZW50XCI+U2V0IHRoaXMgdG8gdHJ1ZSB0byByZXF1aXJlIHRoYXQgdGhlIFxyXG4gICAgICAgIC8vLyBpbnRlcnNlY3Rpb24gcG9pbnQgYmUgb24gdGhlIGZpcnN0IGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNlY29uZElzU2VnbWVudFwiPlNldCB0aGlzIHRvIHRydWUgdG8gcmVxdWlyZSB0aGF0IHRoZVxyXG4gICAgICAgIC8vLyBpbnRlcnNlY3Rpb24gcG9pbnQgYmUgb24gdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiBhbiBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQsIGZhbHNlIG90aGVyd2lzZS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIExpbmVJbnRlcnNlY3QocmVmIFZlY3RvcjIgcG9pbnQxLCByZWYgVmVjdG9yMiBwb2ludDIsIHJlZiBWZWN0b3IyIHBvaW50MywgcmVmIFZlY3RvcjIgcG9pbnQ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgZmlyc3RJc1NlZ21lbnQsIGJvb2wgc2Vjb25kSXNTZWdtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcG9pbnQgPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuICAgICAgICAgICAgLy8gdGhlc2UgYXJlIHJldXNlZCBsYXRlci5cclxuICAgICAgICAgICAgLy8gZWFjaCBsZXR0ZXJlZCBzdWItY2FsY3VsYXRpb24gaXMgdXNlZCB0d2ljZSwgZXhjZXB0XHJcbiAgICAgICAgICAgIC8vIGZvciBiIGFuZCBkLCB3aGljaCBhcmUgdXNlZCAzIHRpbWVzXHJcbiAgICAgICAgICAgIGZsb2F0IGEgPSBwb2ludDQuWSAtIHBvaW50My5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBiID0gcG9pbnQyLlggLSBwb2ludDEuWDtcclxuICAgICAgICAgICAgZmxvYXQgYyA9IHBvaW50NC5YIC0gcG9pbnQzLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IGQgPSBwb2ludDIuWSAtIHBvaW50MS5ZO1xyXG5cclxuICAgICAgICAgICAgLy8gZGVub21pbmF0b3IgdG8gc29sdXRpb24gb2YgbGluZWFyIHN5c3RlbVxyXG4gICAgICAgICAgICBmbG9hdCBkZW5vbSA9IChhICogYikgLSAoYyAqIGQpO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgZGVub21pbmF0b3IgaXMgMCwgdGhlbiBsaW5lcyBhcmUgcGFyYWxsZWxcclxuICAgICAgICAgICAgaWYgKCEoZGVub20gPj0gLVNldHRpbmdzLkVwc2lsb24gJiYgZGVub20gPD0gU2V0dGluZ3MuRXBzaWxvbikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGUgPSBwb2ludDEuWSAtIHBvaW50My5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZiA9IHBvaW50MS5YIC0gcG9pbnQzLlg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbmVPdmVyRGVub20gPSAxLjBmIC8gZGVub207XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbnVtZXJhdG9yIG9mIGZpcnN0IGVxdWF0aW9uXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB1YSA9IChjICogZSkgLSAoYSAqIGYpO1xyXG4gICAgICAgICAgICAgICAgdWEgKj0gb25lT3ZlckRlbm9tO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGludGVyc2VjdGlvbiBwb2ludCBvZiB0aGUgdHdvIGxpbmVzIGlzIG9uIGxpbmUgc2VnbWVudCAxXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0SXNTZWdtZW50IHx8IHVhID49IDAuMGYgJiYgdWEgPD0gMS4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBudW1lcmF0b3Igb2Ygc2Vjb25kIGVxdWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdWIgPSAoYiAqIGUpIC0gKGQgKiBmKTtcclxuICAgICAgICAgICAgICAgICAgICB1YiAqPSBvbmVPdmVyRGVub207XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGludGVyc2VjdGlvbiBwb2ludCBvZiB0aGUgdHdvIGxpbmVzIGlzIG9uIGxpbmUgc2VnbWVudCAyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVhbnMgdGhlIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0LCBzaW5jZSB3ZSBrbm93IGl0IGlzIG9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VnbWVudCAxIGFzIHdlbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWNvbmRJc1NlZ21lbnQgfHwgdWIgPj0gMC4wZiAmJiB1YiA8PSAxLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhleSBhcmUgY29pbmNpZGVudCAobm8gY29sbGlzaW9uIGluIHRoaXMgY2FzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVhICE9IDBmIHx8IHViICE9IDBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RoZXJlIGlzIGFuIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQuWCA9IHBvaW50MS5YICsgdWEgKiBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQuWSA9IHBvaW50MS5ZICsgdWEgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBtZXRob2QgZGV0ZWN0cyBpZiB0d28gbGluZSBzZWdtZW50cyAob3IgbGluZXMpIGludGVyc2VjdCxcclxuICAgICAgICAvLy8gYW5kLCBpZiBzbywgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbi4gVXNlIHRoZSA8cGFyYW1yZWYgbmFtZT1cImZpcnN0SXNTZWdtZW50XCIvPiBhbmRcclxuICAgICAgICAvLy8gPHBhcmFtcmVmIG5hbWU9XCJzZWNvbmRJc1NlZ21lbnRcIi8+IHBhcmFtZXRlcnMgdG8gc2V0IHdoZXRoZXIgdGhlIGludGVyc2VjdGlvbiBwb2ludFxyXG4gICAgICAgIC8vLyBtdXN0IGJlIG9uIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpbmUgc2VnbWVudHMuIFNldHRpbmcgdGhlc2VcclxuICAgICAgICAvLy8gYm90aCB0byB0cnVlIG1lYW5zIHlvdSBhcmUgZG9pbmcgYSBsaW5lLXNlZ21lbnQgdG8gbGluZS1zZWdtZW50XHJcbiAgICAgICAgLy8vIGludGVyc2VjdGlvbi4gU2V0dGluZyBvbmUgb2YgdGhlbSB0byB0cnVlIG1lYW5zIHlvdSBhcmUgZG9pbmcgYVxyXG4gICAgICAgIC8vLyBsaW5lIHRvIGxpbmUtc2VnbWVudCBpbnRlcnNlY3Rpb24gdGVzdCwgYW5kIHNvIG9uLlxyXG4gICAgICAgIC8vLyBOb3RlOiBJZiB0d28gbGluZSBzZWdtZW50cyBhcmUgY29pbmNpZGVudCwgdGhlbiBcclxuICAgICAgICAvLy8gbm8gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkICh0aGVyZSBhcmUgYWN0dWFsbHlcclxuICAgICAgICAvLy8gaW5maW5pdGUgaW50ZXJzZWN0aW9uIHBvaW50cykuXHJcbiAgICAgICAgLy8vIEF1dGhvcjogSmVyZW15IEJlbGxcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50MVwiPlRoZSBmaXJzdCBwb2ludCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQyXCI+VGhlIHNlY29uZCBwb2ludCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQzXCI+VGhlIGZpcnN0IHBvaW50IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQ0XCI+VGhlIHNlY29uZCBwb2ludCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImludGVyc2VjdGlvblBvaW50XCI+VGhpcyBpcyBzZXQgdG8gdGhlIGludGVyc2VjdGlvblxyXG4gICAgICAgIC8vLyBwb2ludCBpZiBhbiBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmaXJzdElzU2VnbWVudFwiPlNldCB0aGlzIHRvIHRydWUgdG8gcmVxdWlyZSB0aGF0IHRoZSBcclxuICAgICAgICAvLy8gaW50ZXJzZWN0aW9uIHBvaW50IGJlIG9uIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzZWNvbmRJc1NlZ21lbnRcIj5TZXQgdGhpcyB0byB0cnVlIHRvIHJlcXVpcmUgdGhhdCB0aGVcclxuICAgICAgICAvLy8gaW50ZXJzZWN0aW9uIHBvaW50IGJlIG9uIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgYW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLCBmYWxzZSBvdGhlcndpc2UuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBMaW5lSW50ZXJzZWN0KFZlY3RvcjIgcG9pbnQxLCBWZWN0b3IyIHBvaW50MiwgVmVjdG9yMiBwb2ludDMsIFZlY3RvcjIgcG9pbnQ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgZmlyc3RJc1NlZ21lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBzZWNvbmRJc1NlZ21lbnQsIG91dCBWZWN0b3IyIGludGVyc2VjdGlvblBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIExpbmVJbnRlcnNlY3QocmVmIHBvaW50MSwgcmVmIHBvaW50MiwgcmVmIHBvaW50MywgcmVmIHBvaW50NCwgZmlyc3RJc1NlZ21lbnQsIHNlY29uZElzU2VnbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IGludGVyc2VjdGlvblBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBtZXRob2QgZGV0ZWN0cyBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3QsXHJcbiAgICAgICAgLy8vIGFuZCwgaWYgc28sIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24uIFxyXG4gICAgICAgIC8vLyBOb3RlOiBJZiB0d28gbGluZSBzZWdtZW50cyBhcmUgY29pbmNpZGVudCwgdGhlbiBcclxuICAgICAgICAvLy8gbm8gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkICh0aGVyZSBhcmUgYWN0dWFsbHlcclxuICAgICAgICAvLy8gaW5maW5pdGUgaW50ZXJzZWN0aW9uIHBvaW50cykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDFcIj5UaGUgZmlyc3QgcG9pbnQgb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50MlwiPlRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50M1wiPlRoZSBmaXJzdCBwb2ludCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50NFwiPlRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnRlcnNlY3Rpb25Qb2ludFwiPlRoaXMgaXMgc2V0IHRvIHRoZSBpbnRlcnNlY3Rpb25cclxuICAgICAgICAvLy8gcG9pbnQgaWYgYW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgYW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLCBmYWxzZSBvdGhlcndpc2UuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBMaW5lSW50ZXJzZWN0KHJlZiBWZWN0b3IyIHBvaW50MSwgcmVmIFZlY3RvcjIgcG9pbnQyLCByZWYgVmVjdG9yMiBwb2ludDMsIHJlZiBWZWN0b3IyIHBvaW50NCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgVmVjdG9yMiBpbnRlcnNlY3Rpb25Qb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0KHJlZiBwb2ludDEsIHJlZiBwb2ludDIsIHJlZiBwb2ludDMsIHJlZiBwb2ludDQsIHRydWUsIHRydWUsIG91dCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgbWV0aG9kIGRldGVjdHMgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0LFxyXG4gICAgICAgIC8vLyBhbmQsIGlmIHNvLCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uLiBcclxuICAgICAgICAvLy8gTm90ZTogSWYgdHdvIGxpbmUgc2VnbWVudHMgYXJlIGNvaW5jaWRlbnQsIHRoZW4gXHJcbiAgICAgICAgLy8vIG5vIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZCAodGhlcmUgYXJlIGFjdHVhbGx5XHJcbiAgICAgICAgLy8vIGluZmluaXRlIGludGVyc2VjdGlvbiBwb2ludHMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQxXCI+VGhlIGZpcnN0IHBvaW50IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDJcIj5UaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDNcIj5UaGUgZmlyc3QgcG9pbnQgb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDRcIj5UaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW50ZXJzZWN0aW9uUG9pbnRcIj5UaGlzIGlzIHNldCB0byB0aGUgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgLy8vIHBvaW50IGlmIGFuIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZCwgZmFsc2Ugb3RoZXJ3aXNlLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgTGluZUludGVyc2VjdChWZWN0b3IyIHBvaW50MSwgVmVjdG9yMiBwb2ludDIsIFZlY3RvcjIgcG9pbnQzLCBWZWN0b3IyIHBvaW50NCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgVmVjdG9yMiBpbnRlcnNlY3Rpb25Qb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0KHJlZiBwb2ludDEsIHJlZiBwb2ludDIsIHJlZiBwb2ludDMsIHJlZiBwb2ludDQsIHRydWUsIHRydWUsIG91dCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCBhbGwgaW50ZXJzZWN0aW9ucyBiZXR3ZWVuIGEgbGluZSBzZWdtZW50IGFuZCBhIGxpc3Qgb2YgdmVydGljZXNcclxuICAgICAgICAvLy8gcmVwcmVzZW50aW5nIGEgcG9seWdvbi4gVGhlIHZlcnRpY2VzIHJldXNlIGFkamFjZW50IHBvaW50cywgc28gZm9yIGV4YW1wbGVcclxuICAgICAgICAvLy8gZWRnZXMgb25lIGFuZCB0d28gYXJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgdmVydGljZXMgYW5kIGJldHdlZW4gdGhlXHJcbiAgICAgICAgLy8vIHNlY29uZCBhbmQgdGhpcmQgdmVydGljZXMuIFRoZSBsYXN0IGVkZ2UgaXMgYmV0d2VlbiB2ZXJ0ZXggdmVydGljZXMuQ291bnQgLSAxXHJcbiAgICAgICAgLy8vIGFuZCB2ZXJ0czAuIChpZSwgdmVydGljZXMgZnJvbSBhIEdlb21ldHJ5IG9yIEFBQkIpXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDFcIj5UaGUgZmlyc3QgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudCB0byB0ZXN0PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDJcIj5UaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnQgdG8gdGVzdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLCBhcyBkZXNjcmliZWQgYWJvdmU8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImludGVyc2VjdGlvblBvaW50c1wiPkFuIGxpc3Qgb2YgaW50ZXJzZWN0aW9uIHBvaW50cy4gQW55IGludGVyc2VjdGlvbiBwb2ludHNcclxuICAgICAgICAvLy8gZm91bmQgd2lsbCBiZSBhZGRlZCB0byB0aGlzIGxpc3QuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgTGluZVNlZ21lbnRWZXJ0aWNlc0ludGVyc2VjdChyZWYgVmVjdG9yMiBwb2ludDEsIHJlZiBWZWN0b3IyIHBvaW50MiwgVmVydGljZXMgdmVydGljZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmIExpc3Q8VmVjdG9yMj4gaW50ZXJzZWN0aW9uUG9pbnRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKExpbmVJbnRlcnNlY3QodmVydGljZXNbaV0sIHZlcnRpY2VzW3ZlcnRpY2VzLk5leHRJbmRleChpKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDEsIHBvaW50MiwgdHJ1ZSwgdHJ1ZSwgb3V0IHBvaW50KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMuQWRkKHBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgYWxsIGludGVyc2VjdGlvbnMgYmV0d2VlbiBhIGxpbmUgc2VnbWVudCBhbmQgYW4gQUFCQi4gXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDFcIj5UaGUgZmlyc3QgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudCB0byB0ZXN0PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDJcIj5UaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnQgdG8gdGVzdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgQUFCQiB0aGF0IGlzIHVzZWQgZm9yIHRlc3RpbmcgaW50ZXJzZWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW50ZXJzZWN0aW9uUG9pbnRzXCI+QW4gbGlzdCBvZiBpbnRlcnNlY3Rpb24gcG9pbnRzLiBBbnkgaW50ZXJzZWN0aW9uIHBvaW50cyBmb3VuZCB3aWxsIGJlIGFkZGVkIHRvIHRoaXMgbGlzdC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBMaW5lU2VnbWVudEFBQkJJbnRlcnNlY3QocmVmIFZlY3RvcjIgcG9pbnQxLCByZWYgVmVjdG9yMiBwb2ludDIsIEFBQkIgYWFiYixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBMaXN0PFZlY3RvcjI+IGludGVyc2VjdGlvblBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpbmVTZWdtZW50VmVydGljZXNJbnRlcnNlY3QocmVmIHBvaW50MSwgcmVmIHBvaW50MiwgYWFiYi5WZXJ0aWNlcywgcmVmIGludGVyc2VjdGlvblBvaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uXHJcbntcclxuICAgIC8vIFBvcnRlZCBieSBNYXR0aGV3IEJldHRjaGVyIC0gRmViIDIwMTFcclxuXHJcbiAgICAvKlxyXG4gICAgQ29weXJpZ2h0IChjKSAyMDEwLCBMdWNhIERlbHRvZGVzY29cclxuICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZFxyXG4gICAgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zXHJcblx0ICAgICAgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXHJcblx0ICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcclxuXHQgICAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAgICAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBuYXBlIHByb2plY3Qgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2VcclxuXHQgICAgIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcblxyXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SXHJcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcclxuICAgIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUlxyXG4gICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxyXG4gICAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxyXG4gICAgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVJcclxuICAgIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVRcclxuICAgIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICAgICovXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBNYXJjaGluZ1NxdWFyZXNcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1hcmNoaW5nIHNxdWFyZXMgb3ZlciB0aGUgZ2l2ZW4gZG9tYWluIHVzaW5nIHRoZSBtZXNoIGRlZmluZWQgdmlhIHRoZSBkaW1lbnNpb25zXHJcbiAgICAgICAgLy8vICAgICh3aWQsaGVpKSB0byBidWlsZCBhIHNldCBvZiBwb2x5Z29ucyBzdWNoIHRoYXQgZih4LHkpIGxlc3MgdGhhbiAwLCB1c2luZyB0aGUgZ2l2ZW4gbnVtYmVyXHJcbiAgICAgICAgLy8vICAgICdiaW4nIGZvciByZWN1cnNpdmUgbGluZWFyIGludGVwcm9sYXRpb24gYWxvbmcgY2VsbCBib3VuZGFyaWVzLlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyAgICBpZiAnY29tYicgaXMgdHJ1ZSwgdGhlbiB0aGUgcG9seWdvbnMgd2lsbCBhbHNvIGJlIGNvbXBvc2l0ZWQgaW50byBsYXJnZXIgcG9zc2libGUgY29uY2F2ZVxyXG4gICAgICAgIC8vLyAgICBwb2x5Z29ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRvbWFpblwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2VsbFdpZHRoXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjZWxsSGVpZ2h0XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsZXJwQ291bnRcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbWJpbmVcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBEZXRlY3RTcXVhcmVzKEFBQkIgZG9tYWluLCBmbG9hdCBjZWxsV2lkdGgsIGZsb2F0IGNlbGxIZWlnaHQsIHNieXRlWyxdIGYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBsZXJwQ291bnQsIGJvb2wgY29tYmluZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEN4RmFzdExpc3Q8R2VvbVBvbHk+IHJldCA9IG5ldyBDeEZhc3RMaXN0PEdlb21Qb2x5PigpO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gdmVydGljZXNMaXN0ID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICAvL05PVEU6IHJlbW92ZWQgYXNzaWdubWVudHMgYXMgdGhleSB3ZXJlIG5vdCB1c2VkLlxyXG4gICAgICAgICAgICBMaXN0PEdlb21Qb2x5PiBwb2x5TGlzdDtcclxuICAgICAgICAgICAgR2VvbVBvbHkgZ3A7XHJcblxyXG4gICAgICAgICAgICBpbnQgeG4gPSAoaW50KShkb21haW4uRXh0ZW50cy5YICogMiAvIGNlbGxXaWR0aCk7XHJcbiAgICAgICAgICAgIGJvb2wgeHAgPSB4biA9PSAoZG9tYWluLkV4dGVudHMuWCAqIDIgLyBjZWxsV2lkdGgpO1xyXG4gICAgICAgICAgICBpbnQgeW4gPSAoaW50KShkb21haW4uRXh0ZW50cy5ZICogMiAvIGNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICBib29sIHlwID0geW4gPT0gKGRvbWFpbi5FeHRlbnRzLlkgKiAyIC8gY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgIGlmICgheHApIHhuKys7XHJcbiAgICAgICAgICAgIGlmICgheXApIHluKys7XHJcblxyXG4gICAgICAgICAgICBzYnl0ZVssXSBmcyA9IG5ldyBzYnl0ZVt4biArIDEsIHluICsgMV07XHJcbiAgICAgICAgICAgIEdlb21Qb2x5VmFsWyxdIHBzID0gbmV3IEdlb21Qb2x5VmFsW3huICsgMSwgeW4gKyAxXTtcclxuXHJcbiAgICAgICAgICAgIC8vcG9wdWxhdGUgc2hhcmVkIGZ1bmN0aW9uIGxvb2t1cHMuXHJcbiAgICAgICAgICAgIGZvciAoaW50IHggPSAwOyB4IDwgeG4gKyAxOyB4KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCB4MDtcclxuICAgICAgICAgICAgICAgIGlmICh4ID09IHhuKSB4MCA9IChpbnQpZG9tYWluLlVwcGVyQm91bmQuWDtcclxuICAgICAgICAgICAgICAgIGVsc2UgeDAgPSAoaW50KSh4ICogY2VsbFdpZHRoICsgZG9tYWluLkxvd2VyQm91bmQuWCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB5ID0gMDsgeSA8IHluICsgMTsgeSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCB5MDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeSA9PSB5bikgeTAgPSAoaW50KWRvbWFpbi5VcHBlckJvdW5kLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB5MCA9IChpbnQpKHkgKiBjZWxsSGVpZ2h0ICsgZG9tYWluLkxvd2VyQm91bmQuWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnNbeCwgeV0gPSBmW3gwLCB5MF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZ2VuZXJhdGUgc3ViLXBvbHlzIGFuZCBjb21iaW5lIHRvIHNjYW4gbGluZXNcclxuICAgICAgICAgICAgZm9yIChpbnQgeSA9IDA7IHkgPCB5bjsgeSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB5MCA9IHkgKiBjZWxsSGVpZ2h0ICsgZG9tYWluLkxvd2VyQm91bmQuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHkxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPT0geW4gLSAxKSB5MSA9IGRvbWFpbi5VcHBlckJvdW5kLlk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHkxID0geTAgKyBjZWxsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgR2VvbVBvbHkgcHJlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHggPSAwOyB4IDwgeG47IHgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB4MCA9IHggKiBjZWxsV2lkdGggKyBkb21haW4uTG93ZXJCb3VuZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID09IHhuIC0gMSkgeDEgPSBkb21haW4uVXBwZXJCb3VuZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeDEgPSB4MCArIGNlbGxXaWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ3AgPSBuZXcgR2VvbVBvbHkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGtleSA9IE1hcmNoU3F1YXJlKGYsIGZzLCByZWYgZ3AsIHgsIHksIHgwLCB5MCwgeDEsIHkxLCBsZXJwQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncC5MZW5ndGggIT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5lICYmIHByZSAhPSBudWxsICYmIChrZXkgJiA5KSAhPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21iTGVmdChyZWYgcHJlLCByZWYgZ3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3AgPSBwcmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LkFkZChncCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzW3gsIHldID0gbmV3IEdlb21Qb2x5VmFsKGdwLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBwcmUgPSBncDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNvbWJpbmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBvbHlMaXN0ID0gcmV0LkdldExpc3RPZkVsZW1lbnRzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoR2VvbVBvbHkgcG9seSBpbiBwb2x5TGlzdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc0xpc3QuQWRkKG5ldyBWZXJ0aWNlcyhwb2x5LlBvaW50cy5HZXRMaXN0T2ZFbGVtZW50cygpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzTGlzdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jb21iaW5lIHNjYW4gbGluZXMgdG9nZXRoZXJcclxuICAgICAgICAgICAgZm9yIChpbnQgeSA9IDE7IHkgPCB5bjsgeSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoeCA8IHhuKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEdlb21Qb2x5VmFsIHAgPSBwc1t4LCB5XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9za2lwIGFsb25nIHNjYW4gbGluZSBpZiBubyBwb2x5Z29uIGV4aXN0cyBhdCB0aGlzIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NraXAgYWxvbmcgaWYgY3VycmVudCBwb2x5Z29uIGNhbm5vdCBiZSBjb21iaW5lZCBhYm92ZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHAuS2V5ICYgMTIpID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9za2lwIGFsb25nIGlmIG5vIHBvbHlnb24gZXhpc3RzIGFib3ZlLlxyXG4gICAgICAgICAgICAgICAgICAgIEdlb21Qb2x5VmFsIHUgPSBwc1t4LCB5IC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NraXAgYWxvbmcgaWYgcG9seWdvbiBhYm92ZSBjYW5ub3QgYmUgY29tYmluZWQgd2l0aC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHUuS2V5ICYgMykgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBheCA9IHggKiBjZWxsV2lkdGggKyBkb21haW4uTG93ZXJCb3VuZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGF5ID0geSAqIGNlbGxIZWlnaHQgKyBkb21haW4uTG93ZXJCb3VuZC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBDeEZhc3RMaXN0PFZlY3RvcjI+IGJwID0gcC5HZW9tUC5Qb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgQ3hGYXN0TGlzdDxWZWN0b3IyPiBhcCA9IHUuR2VvbVAuUG9pbnRzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NraXAgaWYgaXQncyBhbHJlYWR5IGJlZW4gY29tYmluZWQgd2l0aCBhYm92ZSBwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUuR2VvbVAgPT0gcC5HZW9tUClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbWJpbmUgYWJvdmUgKGJ1dCBkaXNhbGxvdyB0aGUgaG9sZSB0aGluZ2llc1xyXG4gICAgICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFZlY3RvcjI+IGJpID0gYnAuQmVnaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoU3F1YXJlKGJpLkVsZW0oKS5ZIC0gYXkpID4gU2V0dGluZ3MuRXBzaWxvbiB8fCBiaS5FbGVtKCkuWCA8IGF4KSBiaSA9IGJpLk5leHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9OT1RFOiBVbnVzZWRcclxuICAgICAgICAgICAgICAgICAgICAvL1ZlY3RvcjIgYjAgPSBiaS5lbGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBiMSA9IGJpLk5leHQoKS5FbGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNxdWFyZShiMS5ZIC0gYXkpID4gU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBib29sIGJyayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VmVjdG9yMj4gYWkgPSBhcC5CZWdpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhaSAhPSBhcC5FbmQoKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWZWNEc3EoYWkuRWxlbSgpLCBiMSkgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmsgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFpID0gYWkuTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFZlY3RvcjI+IGJqID0gYmkuTmV4dCgpLk5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmogPT0gYnAuRW5kKCkpIGJqID0gYnAuQmVnaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYmogIT0gYmkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhaSA9IGFwLkluc2VydChhaSwgYmouRWxlbSgpKTsgLy8gLmNsb25lKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmogPSBiai5OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaiA9PSBicC5FbmQoKSkgYmogPSBicC5CZWdpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1Lkdlb21QLkxlbmd0aCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL3UucC5zaW1wbGlmeShmbG9hdC5FcHNpbG9uLGZsb2F0LkVwc2lsb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgYXggPSB4ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYXggPCB4bilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEdlb21Qb2x5VmFsIHAyID0gcHNbKGludClheCwgeV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwMiA9PSBudWxsIHx8IHAyLkdlb21QICE9IHAuR2VvbVApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwMi5HZW9tUCA9IHUuR2VvbVA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF4ID0geCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGF4ID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHZW9tUG9seVZhbCBwMiA9IHBzWyhpbnQpYXgsIHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocDIgPT0gbnVsbCB8fCBwMi5HZW9tUCAhPSBwLkdlb21QKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcDIuR2VvbVAgPSB1Lkdlb21QO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBheC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXQuUmVtb3ZlKHAuR2VvbVApO1xyXG4gICAgICAgICAgICAgICAgICAgIHAuR2VvbVAgPSB1Lkdlb21QO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4ID0gKGludCkoKGJpLk5leHQoKS5FbGVtKCkuWCAtIGRvbWFpbi5Mb3dlckJvdW5kLlgpIC8gY2VsbFdpZHRoKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy94Kys7IHRoaXMgd2FzIGFscmVhZHkgY29tbWVudGVkIG91dCFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcG9seUxpc3QgPSByZXQuR2V0TGlzdE9mRWxlbWVudHMoKTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEdlb21Qb2x5IHBvbHkgaW4gcG9seUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzTGlzdC5BZGQobmV3IFZlcnRpY2VzKHBvbHkuUG9pbnRzLkdldExpc3RPZkVsZW1lbnRzKCkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzTGlzdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gUHJpdmF0ZSBNZXRob2RzXHJcblxyXG4gICAgICAgIC8vLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIFxyXG5cclxuICAgICAgICAvKiogTGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2VlbiAoeDAgdG8geDEpIGdpdmVuIGEgdmFsdWUgYXQgdGhlc2UgY29vcmRpbmF0ZXMgKHYwIGFuZCB2MSlcclxuICAgICAgICAgICAgc3VjaCBhcyB0byBhcHByb3hpbWF0ZSB2YWx1ZShyZXR1cm4pID0gMFxyXG4gICAgICAgICoqL1xyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBpbnRbXSBfbG9va01hcmNoID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMCwgMHhFMCwgMHgzOCwgMHhEOCwgMHgwRSwgMHhFRSwgMHgzNiwgMHhENiwgMHg4MywgMHg2MywgMTg3LCA5MSwgMHg4RCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NkQsIDE4MSwgMHg1NVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBMZXJwKGZsb2F0IHgwLCBmbG9hdCB4MSwgZmxvYXQgdjAsIGZsb2F0IHYxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgZHYgPSB2MCAtIHYxO1xyXG4gICAgICAgICAgICBmbG9hdCB0O1xyXG4gICAgICAgICAgICBpZiAoZHYgKiBkdiA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICB0ID0gMC41ZjtcclxuICAgICAgICAgICAgZWxzZSB0ID0gdjAgLyBkdjtcclxuICAgICAgICAgICAgcmV0dXJuIHgwICsgdCAqICh4MSAtIHgwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIFxyXG5cclxuICAgICAgICAvKiogUmVjdXJzaXZlIGxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciB1c2UgaW4gbWFyY2hpbmcgc3F1YXJlcyAqKi9cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgWGxlcnAoZmxvYXQgeDAsIGZsb2F0IHgxLCBmbG9hdCB5LCBmbG9hdCB2MCwgZmxvYXQgdjEsIHNieXRlWyxdIGYsIGludCBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgeG0gPSBMZXJwKHgwLCB4MSwgdjAsIHYxKTtcclxuICAgICAgICAgICAgaWYgKGMgPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB4bTtcclxuXHJcbiAgICAgICAgICAgIHNieXRlIHZtID0gZlsoaW50KXhtLCAoaW50KXldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHYwICogdm0gPCAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFhsZXJwKHgwLCB4bSwgeSwgdjAsIHZtLCBmLCBjIC0gMSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gWGxlcnAoeG0sIHgxLCB5LCB2bSwgdjEsIGYsIGMgLSAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiBSZWN1cnNpdmUgbGluZWFyIGludGVycG9sYXRpb24gZm9yIHVzZSBpbiBtYXJjaGluZyBzcXVhcmVzICoqL1xyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBZbGVycChmbG9hdCB5MCwgZmxvYXQgeTEsIGZsb2F0IHgsIGZsb2F0IHYwLCBmbG9hdCB2MSwgc2J5dGVbLF0gZiwgaW50IGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCB5bSA9IExlcnAoeTAsIHkxLCB2MCwgdjEpO1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHltO1xyXG5cclxuICAgICAgICAgICAgc2J5dGUgdm0gPSBmWyhpbnQpeCwgKGludCl5bV07XHJcblxyXG4gICAgICAgICAgICBpZiAodjAgKiB2bSA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWWxlcnAoeTAsIHltLCB4LCB2MCwgdm0sIGYsIGMgLSAxKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBZbGVycCh5bSwgeTEsIHgsIHZtLCB2MSwgZiwgYyAtIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIFNxdWFyZSB2YWx1ZSBmb3IgdXNlIGluIG1hcmNoaW5nIHNxdWFyZXMgKiovXHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IFNxdWFyZShmbG9hdCB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHggKiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgVmVjRHNxKFZlY3RvcjIgYSwgVmVjdG9yMiBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gYSAtIGI7XHJcbiAgICAgICAgICAgIHJldHVybiBkLlggKiBkLlggKyBkLlkgKiBkLlk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBWZWNDcm9zcyhWZWN0b3IyIGEsIFZlY3RvcjIgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLlggKiBiLlkgLSBhLlkgKiBiLlg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiogTG9vay11cCB0YWJsZSB0byByZWxhdGUgcG9seWdvbiBrZXkgd2l0aCB0aGUgdmVydGljZXMgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3JcclxuICAgICAgICAgICAgdGhlIHN1YiBwb2x5Z29uIGluIG1hcmNoaW5nIHNxdWFyZXNcclxuICAgICAgICAqKi9cclxuXHJcbiAgICAgICAgLyoqIFBlcmZvcm0gYSBzaW5nbGUgY2VsbGVkIG1hcmNoaW5nIHNxdWFyZSBmb3IgZm9yIHRoZSBnaXZlbiBjZWxsIGRlZmluZWQgYnkgKHgwLHkwKSAoeDEseTEpXHJcbiAgICAgICAgICAgIHVzaW5nIHRoZSBmdW5jdGlvbiBmIGZvciByZWN1cnNpdmUgaW50ZXJwb2xhdGlvbiwgZ2l2ZW4gdGhlIGxvb2stdXAgdGFibGUgJ2ZzJyBvZlxyXG4gICAgICAgICAgICB0aGUgdmFsdWVzIG9mICdmJyBhdCBjZWxsIHZlcnRpY2VzIHdpdGggdGhlIHJlc3VsdCB0byBiZSBzdG9yZWQgaW4gJ3BvbHknIGdpdmVuIHRoZSBhY3R1YWxcclxuICAgICAgICAgICAgY29vcmRpbmF0ZXMgb2YgJ2F4JyAnYXknIGluIHRoZSBtYXJjaGluZyBzcXVhcmVzIG1lc2guXHJcbiAgICAgICAgKiovXHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGludCBNYXJjaFNxdWFyZShzYnl0ZVssXSBmLCBzYnl0ZVssXSBmcywgcmVmIEdlb21Qb2x5IHBvbHksIGludCBheCwgaW50IGF5LCBmbG9hdCB4MCwgZmxvYXQgeTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHgxLCBmbG9hdCB5MSwgaW50IGJpbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8va2V5IGxvb2t1cFxyXG4gICAgICAgICAgICBpbnQga2V5ID0gMDtcclxuICAgICAgICAgICAgc2J5dGUgdjAgPSBmc1theCwgYXldO1xyXG4gICAgICAgICAgICBpZiAodjAgPCAwKSBrZXkgfD0gODtcclxuICAgICAgICAgICAgc2J5dGUgdjEgPSBmc1theCArIDEsIGF5XTtcclxuICAgICAgICAgICAgaWYgKHYxIDwgMCkga2V5IHw9IDQ7XHJcbiAgICAgICAgICAgIHNieXRlIHYyID0gZnNbYXggKyAxLCBheSArIDFdO1xyXG4gICAgICAgICAgICBpZiAodjIgPCAwKSBrZXkgfD0gMjtcclxuICAgICAgICAgICAgc2J5dGUgdjMgPSBmc1theCwgYXkgKyAxXTtcclxuICAgICAgICAgICAgaWYgKHYzIDwgMCkga2V5IHw9IDE7XHJcblxyXG4gICAgICAgICAgICBpbnQgdmFsID0gX2xvb2tNYXJjaFtrZXldO1xyXG4gICAgICAgICAgICBpZiAodmFsICE9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFZlY3RvcjI+IHBpID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgODsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGkpKSAhPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gNyAmJiAodmFsICYgMSkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHkuUG9pbnRzLkFkZChwID0gbmV3IFZlY3RvcjIoeDAsIFlsZXJwKHkwLCB5MSwgeDAsIHYwLCB2MywgZiwgYmluKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDApIHAgPSBuZXcgVmVjdG9yMih4MCwgeTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSAyKSBwID0gbmV3IFZlY3RvcjIoeDEsIHkwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gNCkgcCA9IG5ldyBWZWN0b3IyKHgxLCB5MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IDYpIHAgPSBuZXcgVmVjdG9yMih4MCwgeTEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gMSkgcCA9IG5ldyBWZWN0b3IyKFhsZXJwKHgwLCB4MSwgeTAsIHYwLCB2MSwgZiwgYmluKSwgeTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSA1KSBwID0gbmV3IFZlY3RvcjIoWGxlcnAoeDAsIHgxLCB5MSwgdjMsIHYyLCBmLCBiaW4pLCB5MSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSAzKSBwID0gbmV3IFZlY3RvcjIoeDEsIFlsZXJwKHkwLCB5MSwgeDEsIHYxLCB2MiwgZiwgYmluKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHAgPSBuZXcgVmVjdG9yMih4MCwgWWxlcnAoeTAsIHkxLCB4MCwgdjAsIHYzLCBmLCBiaW4pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaSA9IHBvbHkuUG9pbnRzLkluc2VydChwaSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seS5MZW5ndGgrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3BvbHkuc2ltcGxpZnkoZmxvYXQuRXBzaWxvbixmbG9hdC5FcHNpbG9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIFVzZWQgaW4gcG9seWdvbiBjb21wb3NpdGlvbiB0byBjb21wb3NpdCBwb2x5Z29ucyBpbnRvIHNjYW4gbGluZXNcclxuICAgICAgICAgICAgQ29tYmluaW5nIHBvbHlhIGFuZCBwb2x5YiBpbnRvIG9uZSBzdXBlci1wb2x5Z29uIHN0b3JlZCBpbiBwb2x5YS5cclxuICAgICAgICAqKi9cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBjb21iTGVmdChyZWYgR2VvbVBvbHkgcG9seWEsIHJlZiBHZW9tUG9seSBwb2x5YilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEN4RmFzdExpc3Q8VmVjdG9yMj4gYXAgPSBwb2x5YS5Qb2ludHM7XHJcbiAgICAgICAgICAgIEN4RmFzdExpc3Q8VmVjdG9yMj4gYnAgPSBwb2x5Yi5Qb2ludHM7XHJcbiAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFZlY3RvcjI+IGFpID0gYXAuQmVnaW4oKTtcclxuICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VmVjdG9yMj4gYmkgPSBicC5CZWdpbigpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBiID0gYmkuRWxlbSgpO1xyXG4gICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxWZWN0b3IyPiBwcmVhID0gbnVsbDtcclxuICAgICAgICAgICAgd2hpbGUgKGFpICE9IGFwLkVuZCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGEgPSBhaS5FbGVtKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoVmVjRHNxKGEsIGIpIDwgU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2lnbm9yZSBzaGFyZWQgdmVydGV4IGlmIHBhcmFsbGVsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWEgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYTAgPSBwcmVhLkVsZW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGJpLk5leHQoKS5FbGVtKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHUgPSBhIC0gYTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmVjX25ldyh1KTsgdmVjX3N1YihhLnAucCwgYTAucC5wLCB1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB2ID0gYiAtIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmVjX25ldyh2KTsgdmVjX3N1YihiLnAucCwgYS5wLnAsIHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkb3QgPSBWZWNDcm9zcyh1LCB2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvdCAqIGRvdCA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwLkVyYXNlKHByZWEsIGFpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlhLkxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWkgPSBwcmVhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2luc2VydCBwb2x5YiBpbnRvIHBvbHlhXHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBmc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFZlY3RvcjI+IHByZWIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghYnAuRW1wdHkoKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYmIgPSBicC5Gcm9udCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicC5Qb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmc3QgJiYgIWJwLkVtcHR5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFpID0gYXAuSW5zZXJ0KGFpLCBiYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5YS5MZW5ndGgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWIgPSBhaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWdub3JlIHNoYXJlZCB2ZXJ0ZXggaWYgcGFyYWxsZWxcclxuICAgICAgICAgICAgICAgICAgICBhaSA9IGFpLk5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGExID0gYWkuRWxlbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFpID0gYWkuTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhaSA9PSBhcC5FbmQoKSkgYWkgPSBhcC5CZWdpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYTIgPSBhaS5FbGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBhMDAgPSBwcmViLkVsZW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHV1ID0gYTEgLSBhMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy92ZWNfbmV3KHUpOyB2ZWNfc3ViKGExLnAsIGEwLnAsIHUpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdnYgPSBhMiAtIGExO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdmVjX25ldyh2KTsgdmVjX3N1YihhMi5wLCBhMS5wLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBkb3QxID0gVmVjQ3Jvc3ModXUsIHZ2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG90MSAqIGRvdDEgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXAuRXJhc2UocHJlYiwgcHJlYi5OZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5YS5MZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZWEgPSBhaTtcclxuICAgICAgICAgICAgICAgIGFpID0gYWkuTmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gQ3hGYXN0TGlzdCBmcm9tIG5hcGUgcGh5c2ljc1xyXG5cclxuICAgICAgICAjcmVnaW9uIE5lc3RlZCB0eXBlOiBDeEZhc3RMaXN0XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVzaWduZWQgYXMgYSBjb21wbGV0ZSBwb3J0IG9mIEN4RmFzdExpc3QgZnJvbSBDeFN0ZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIGludGVybmFsIGNsYXNzIEN4RmFzdExpc3Q8VD5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGZpcnN0IG5vZGUgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgcHJpdmF0ZSBDeEZhc3RMaXN0Tm9kZTxUPiBfaGVhZDtcclxuICAgICAgICAgICAgcHJpdmF0ZSBpbnQgX2NvdW50O1xyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gSXRlcmF0b3IgdG8gc3RhcnQgb2YgbGlzdCAoTygxKSlcclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3ROb2RlPFQ+IEJlZ2luKClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9oZWFkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBJdGVyYXRvciB0byBlbmQgb2YgbGlzdCAoTygxKSlcclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3ROb2RlPFQ+IEVuZCgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBSZXR1cm5zIGZpcnN0IGVsZW1lbnQgb2YgbGlzdCAoTygxKSlcclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIFQgRnJvbnQoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2hlYWQuRWxlbSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBhZGQgb2JqZWN0IHRvIGxpc3QgKE8oMSkpXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBDeEZhc3RMaXN0Tm9kZTxUPiBBZGQoVCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VD4gbmV3Tm9kZSA9IG5ldyBDeEZhc3RMaXN0Tm9kZTxUPih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2hlYWQgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLl9uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBfaGVhZCA9IG5ld05vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlLl9uZXh0ID0gX2hlYWQ7XHJcbiAgICAgICAgICAgICAgICBfaGVhZCA9IG5ld05vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgX2NvdW50Kys7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIHJlbW92ZSBvYmplY3QgZnJvbSBsaXN0LCByZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZCAoTyhuKSlcclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIGJvb2wgUmVtb3ZlKFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFQ+IGhlYWQgPSBfaGVhZDtcclxuICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFQ+IHByZXYgPSBfaGVhZDtcclxuXHJcbiAgICAgICAgICAgICAgICBFcXVhbGl0eUNvbXBhcmVyPFQ+IGNvbXBhcmVyID0gRXF1YWxpdHlDb21wYXJlcjxUPi5EZWZhdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChoZWFkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgb24gdGhlIHZhbHVlIHRvIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlci5FcXVhbHMoaGVhZC5fZWx0LCB2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHBhdGNoIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSByZW1vdmluZyB0aGUgX2hlYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZCA9PSBfaGVhZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oZWFkID0gaGVhZC5fbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZXJlIG5vdCBhdCB0aGUgaGVhZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0ID0gaGVhZC5fbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBjdXJyZW50IGFzIHRoZSBwcmV2aW91cyBmb3IgdGhlIG5leHQgZ28gYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gaGVhZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgPSBoZWFkLl9uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChoZWFkICE9IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gcG9wIGVsZW1lbnQgZnJvbSBoZWFkIG9mIGxpc3QgKE8oMSkpIE5vdGU6IHRoaXMgZG9lcyBub3QgcmV0dXJuIHRoZSBvYmplY3QgcG9wcGVkISBcclxuICAgICAgICAgICAgLy8vIFRoZXJlIGlzIGdvb2QgcmVhc29uIHRvIHRoaXMsIGFuZCBpdCByZWdhcmRzIHRoZSBBbGxvYyBsaXN0IHZhcmlhbnRzIHdoaWNoIGd1YXJhbnRlZSBcclxuICAgICAgICAgICAgLy8vIG9iamVjdHMgYXJlIHJlbGVhc2VkIHRvIHRoZSBvYmplY3QgcG9vbC4gWW91IGRvIG5vdCB3YW50IHRvIHJldHJpZXZlIGFuIGVsZW1lbnQgXHJcbiAgICAgICAgICAgIC8vLyB0aHJvdWdoIHBvcCBvciBlbHNlIHRoYXQgb2JqZWN0IG1heSBzdWRkZW5seSBiZSB1c2VkIGJ5IGFub3RoZXIgcGllY2Ugb2YgY29kZSB3aGljaCBcclxuICAgICAgICAgICAgLy8vIHJldHJpZXZlcyBpdCBmcm9tIHRoZSBvYmplY3QgcG9vbC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3ROb2RlPFQ+IFBvcCgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBFcmFzZShudWxsLCBfaGVhZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIGluc2VydCBvYmplY3QgYWZ0ZXIgJ25vZGUnIHJldHVybmluZyBhbiBpdGVyYXRvciB0byB0aGUgaW5zZXJ0ZWQgb2JqZWN0LlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgQ3hGYXN0TGlzdE5vZGU8VD4gSW5zZXJ0KEN4RmFzdExpc3ROb2RlPFQ+IG5vZGUsIFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFkZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxUPiBuZXdOb2RlID0gbmV3IEN4RmFzdExpc3ROb2RlPFQ+KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFQ+IG5leHROb2RlID0gbm9kZS5fbmV4dDtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUuX25leHQgPSBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUuX25leHQgPSBuZXdOb2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jb3VudCsrO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyByZW1vdmVzIHRoZSBlbGVtZW50IHBvaW50ZWQgdG8gYnkgJ25vZGUnIHdpdGggJ3ByZXYnIGJlaW5nIHRoZSBwcmV2aW91cyBpdGVyYXRvciwgXHJcbiAgICAgICAgICAgIC8vLyByZXR1cm5pbmcgYW4gaXRlcmF0b3IgdG8gdGhlIGVsZW1lbnQgZm9sbG93aW5nIHRoYXQgb2YgJ25vZGUnIChPKDEpKVxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgQ3hGYXN0TGlzdE5vZGU8VD4gRXJhc2UoQ3hGYXN0TGlzdE5vZGU8VD4gcHJldiwgQ3hGYXN0TGlzdE5vZGU8VD4gbm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gY2FjaGUgdGhlIG5vZGUgYWZ0ZXIgdGhlIG5vZGUgdG8gYmUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VD4gbmV4dE5vZGUgPSBub2RlLl9uZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0ID0gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfaGVhZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIF9oZWFkID0gX2hlYWQuX25leHQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgX2NvdW50LS07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIHdoZXRoZXIgdGhlIGxpc3QgaXMgZW1wdHkgKE8oMSkpXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBib29sIEVtcHR5KClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9oZWFkID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIGNvbXB1dGVzIHNpemUgb2YgbGlzdCAoTyhuKSlcclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIGludCBTaXplKClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VD4gaSA9IEJlZ2luKCk7XHJcbiAgICAgICAgICAgICAgICBpbnQgY291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkuTmV4dCgpICE9IG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gZW1wdHkgdGhlIGxpc3QgKE8oMSkgaWYgQ3hNaXhMaXN0LCBPKG4pIG90aGVyd2lzZSlcclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxUPiBoZWFkID0gX2hlYWQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaGVhZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFQ+IG5vZGUyID0gaGVhZDtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkID0gaGVhZC5fbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBub2RlMi5fbmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfaGVhZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfY291bnQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyByZXR1cm5zIHRydWUgaWYgJ3ZhbHVlJyBpcyBhbiBlbGVtZW50IG9mIHRoZSBsaXN0IChPKG4pKVxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgYm9vbCBIYXMoVCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChGaW5kKHZhbHVlKSAhPSBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm9uIEN4RmFzdExpc3QgTWV0aG9kcyBcclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3ROb2RlPFQ+IEZpbmQoVCB2YWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaGVhZFxyXG4gICAgICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VD4gaGVhZCA9IF9oZWFkO1xyXG4gICAgICAgICAgICAgICAgRXF1YWxpdHlDb21wYXJlcjxUPiBjb21wYXJlciA9IEVxdWFsaXR5Q29tcGFyZXI8VD4uRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgIGlmIChoZWFkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZXIuRXF1YWxzKGhlYWQuX2VsdCwgdmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGhlYWQuX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGhlYWQgIT0gX2hlYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZC5fZWx0ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkID0gaGVhZC5fbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaGVhZCAhPSBfaGVhZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBMaXN0PFQ+IEdldExpc3RPZkVsZW1lbnRzKClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTGlzdDxUPiBsaXN0ID0gbmV3IExpc3Q8VD4oKTtcclxuXHJcbiAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxUPiBpdGVyID0gQmVnaW4oKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LkFkZChpdGVyLl9lbHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyID0gaXRlci5fbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpdGVyICE9IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBOZXN0ZWQgdHlwZTogQ3hGYXN0TGlzdE5vZGVcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgY2xhc3MgQ3hGYXN0TGlzdE5vZGU8VD5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludGVybmFsIFQgX2VsdDtcclxuICAgICAgICAgICAgaW50ZXJuYWwgQ3hGYXN0TGlzdE5vZGU8VD4gX25leHQ7XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgQ3hGYXN0TGlzdE5vZGUoVCBvYmopXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9lbHQgPSBvYmo7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBUIEVsZW0oKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2VsdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3ROb2RlPFQ+IE5leHQoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX25leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIEludGVybmFsIFN0dWZmXHJcblxyXG4gICAgICAgICNyZWdpb24gTmVzdGVkIHR5cGU6IEdlb21Qb2x5XHJcblxyXG4gICAgICAgIGludGVybmFsIGNsYXNzIEdlb21Qb2x5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwdWJsaWMgaW50IExlbmd0aDtcclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3Q8VmVjdG9yMj4gUG9pbnRzO1xyXG5cclxuICAgICAgICAgICAgcHVibGljIEdlb21Qb2x5KClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUG9pbnRzID0gbmV3IEN4RmFzdExpc3Q8VmVjdG9yMj4oKTtcclxuICAgICAgICAgICAgICAgIExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBOZXN0ZWQgdHlwZTogR2VvbVBvbHlWYWxcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBjbGFzcyBHZW9tUG9seVZhbFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLyoqIEFzc29jaWF0ZWQgcG9seWdvbiBhdCBjb29yZGluYXRlICoqL1xyXG4gICAgICAgICAgICAvKiogS2V5IG9mIG9yaWdpbmFsIHN1Yi1wb2x5Z29uICoqL1xyXG4gICAgICAgICAgICBwdWJsaWMgaW50IEtleTtcclxuICAgICAgICAgICAgcHVibGljIEdlb21Qb2x5IEdlb21QO1xyXG5cclxuICAgICAgICAgICAgcHVibGljIEdlb21Qb2x5VmFsKEdlb21Qb2x5IGdlb21QLCBpbnQgSylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgR2VvbVAgPSBnZW9tUDtcclxuICAgICAgICAgICAgICAgIEtleSA9IEs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb25cclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBNYXRoVXRpbHNcclxuICAgIHtcclxuXHRcdHB1YmxpYyBzdGF0aWMgYm9vbCBJc0Nsb3NlKFZlY3RvcjIgdjEsIFZlY3RvcjIgdjIsIGZsb2F0IHRvbGVyZW5jZSlcclxuXHRcdHtcclxuXHRcdFx0cmV0dXJuIChWZWN0b3IyLkRpc3RhbmNlKHYxLCB2MikgPCB0b2xlcmVuY2UpO1xyXG5cdFx0fVxyXG5cdFx0XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIElzRXF1YWwoVmVjdG9yMiB2MSwgVmVjdG9yMiB2MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAodjEuWCA9PSB2Mi5YICYmIHYxLlkgPT0gdjIuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgQ2xvbmVWZWN0b3IoVmVjdG9yMiB2ZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIodmVjdG9yLlgsIHZlY3Rvci5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgVmVjdG9yQW5nbGUoVmVjdG9yMiB2ZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKGZsb2F0KU1hdGguQXRhbjIodmVjdG9yLlksIHZlY3Rvci5YKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplIGEgVmVjdG9yIHVzaW5nIHBvbGFyIGNvb3JkaW5hdGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJhZGl1c1wiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYW5nbGVcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIFZlY3RvclBvbGFyKGZsb2F0IHJhZGl1cywgZmxvYXQgYW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIocmFkaXVzICogKGZsb2F0KU1hdGguQ29zKChkb3VibGUpYW5nbGUpLCByYWRpdXMgKiAoZmxvYXQpTWF0aC5TaW4oKGRvdWJsZSlhbmdsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBDcm9zcyhWZWN0b3IyIGEsIFZlY3RvcjIgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLlggKiBiLlkgLSBhLlkgKiBiLlg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgQ3Jvc3MoVmVjdG9yMiBhLCBmbG9hdCBzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHMgKiBhLlksIC1zICogYS5YKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBDcm9zcyhmbG9hdCBzLCBWZWN0b3IyIGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoLXMgKiBhLlksIHMgKiBhLlgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIEFicyhWZWN0b3IyIHYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoKGZsb2F0KU1hdGguQWJzKHYuWCksIChmbG9hdClNYXRoLkFicyh2LlkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBNdWx0aXBseShyZWYgTWF0MjIgQSwgVmVjdG9yMiB2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpcGx5KHJlZiBBLCByZWYgdik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgTXVsdGlwbHkocmVmIE1hdDIyIEEsIHJlZiBWZWN0b3IyIHYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoQS5Db2wxLlggKiB2LlggKyBBLkNvbDIuWCAqIHYuWSwgQS5Db2wxLlkgKiB2LlggKyBBLkNvbDIuWSAqIHYuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgTXVsdGlwbHlUKHJlZiBNYXQyMiBBLCBWZWN0b3IyIHYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlwbHlUKHJlZiBBLCByZWYgdik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgTXVsdGlwbHlUKHJlZiBNYXQyMiBBLCByZWYgVmVjdG9yMiB2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHYuWCAqIEEuQ29sMS5YICsgdi5ZICogQS5Db2wxLlksIHYuWCAqIEEuQ29sMi5YICsgdi5ZICogQS5Db2wyLlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIE11bHRpcGx5KHJlZiBUcmFuc2Zvcm0gVCwgVmVjdG9yMiB2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpcGx5KHJlZiBULCByZWYgdik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgTXVsdGlwbHkocmVmIFRyYW5zZm9ybSBULCByZWYgVmVjdG9yMiB2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKFQuUG9zaXRpb24uWCArIFQuUi5Db2wxLlggKiB2LlggKyBULlIuQ29sMi5YICogdi5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVC5Qb3NpdGlvbi5ZICsgVC5SLkNvbDEuWSAqIHYuWCArIFQuUi5Db2wyLlkgKiB2LlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIE11bHRpcGx5VChyZWYgVHJhbnNmb3JtIFQsIFZlY3RvcjIgdilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aXBseVQocmVmIFQsIHJlZiB2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBNdWx0aXBseVQocmVmIFRyYW5zZm9ybSBULCByZWYgVmVjdG9yMiB2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiB0bXAgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIHRtcC5YID0gdi5YIC0gVC5Qb3NpdGlvbi5YO1xyXG4gICAgICAgICAgICB0bXAuWSA9IHYuWSAtIFQuUG9zaXRpb24uWTtcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpcGx5VChyZWYgVC5SLCByZWYgdG1wKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFeVCAqIEJcclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgTXVsdGlwbHlUKHJlZiBNYXQyMiBBLCByZWYgTWF0MjIgQiwgb3V0IE1hdDIyIEMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDID0gbmV3IE1hdDIyKCk7XHJcbiAgICAgICAgICAgIEMuQ29sMS5YID0gQS5Db2wxLlggKiBCLkNvbDEuWCArIEEuQ29sMS5ZICogQi5Db2wxLlk7XHJcbiAgICAgICAgICAgIEMuQ29sMS5ZID0gQS5Db2wyLlggKiBCLkNvbDEuWCArIEEuQ29sMi5ZICogQi5Db2wxLlk7XHJcbiAgICAgICAgICAgIEMuQ29sMi5YID0gQS5Db2wxLlggKiBCLkNvbDIuWCArIEEuQ29sMS5ZICogQi5Db2wyLlk7XHJcbiAgICAgICAgICAgIEMuQ29sMi5ZID0gQS5Db2wyLlggKiBCLkNvbDIuWCArIEEuQ29sMi5ZICogQi5Db2wyLlk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB2MiA9IEEuUicgKiAoQi5SICogdjEgKyBCLnAgLSBBLnApID0gKEEuUicgKiBCLlIpICogdjEgKyAoQi5wIC0gQS5wKVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBNdWx0aXBseVQocmVmIFRyYW5zZm9ybSBBLCByZWYgVHJhbnNmb3JtIEIsIG91dCBUcmFuc2Zvcm0gQylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEMgPSBuZXcgVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIE11bHRpcGx5VChyZWYgQS5SLCByZWYgQi5SLCBvdXQgQy5SKTtcclxuICAgICAgICAgICAgQy5Qb3NpdGlvbi5YID0gQi5Qb3NpdGlvbi5YIC0gQS5Qb3NpdGlvbi5YO1xyXG4gICAgICAgICAgICBDLlBvc2l0aW9uLlkgPSBCLlBvc2l0aW9uLlkgLSBBLlBvc2l0aW9uLlk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgU3dhcDxUPihyZWYgVCBhLCByZWYgVCBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVCB0bXAgPSBhO1xyXG4gICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgYiA9IHRtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGlzXHJcbiAgICAgICAgLy8vIG5vdCBhIE5hTiBvciBpbmZpbml0eS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gXHQ8Yz50cnVlPC9jPiBpZiB0aGUgc3BlY2lmaWVkIHggaXMgdmFsaWQ7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIElzVmFsaWQoZmxvYXQgeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChmbG9hdC5Jc05hTih4KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gTmFOLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gIWZsb2F0LklzSW5maW5pdHkoeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgSXNWYWxpZCh0aGlzIFZlY3RvcjIgeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBJc1ZhbGlkKHguWCkgJiYgSXNWYWxpZCh4LlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGlzIGEgYXBwcm94aW1hdGUgeWV0IGZhc3QgaW52ZXJzZSBzcXVhcmUtcm9vdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhcIj5UaGUgeC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBJbnZTcXJ0KGZsb2F0IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGbG9hdENvbnZlcnRlciBjb252ZXJ0ID0gbmV3IEZsb2F0Q29udmVydGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnZlcnQueCA9IHg7XHJcbiAgICAgICAgICAgIGZsb2F0IHhoYWxmID0gMC41ZiAqIHg7XHJcbiAgICAgICAgICAgIGNvbnZlcnQuaSA9IDB4NWYzNzU5ZGYgLSAoY29udmVydC5pID4+IDEpO1xyXG4gICAgICAgICAgICB4ID0gY29udmVydC54O1xyXG4gICAgICAgICAgICB4ID0geCAqICgxLjVmIC0geGhhbGYgKiB4ICogeCk7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgQ2xhbXAoaW50IGEsIGludCBsb3csIGludCBoaWdoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguTWF4KGxvdywgTWF0aC5NaW4oYSwgaGlnaCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBDbGFtcChmbG9hdCBhLCBmbG9hdCBsb3csIGZsb2F0IGhpZ2gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5NYXgobG93LCBNYXRoLk1pbihhLCBoaWdoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgQ2xhbXAoVmVjdG9yMiBhLCBWZWN0b3IyIGxvdywgVmVjdG9yMiBoaWdoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuTWF4KGxvdywgVmVjdG9yMi5NaW4oYSwgaGlnaCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIENyb3NzKHJlZiBWZWN0b3IyIGEsIHJlZiBWZWN0b3IyIGIsIG91dCBmbG9hdCBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYyA9IGEuWCAqIGIuWSAtIGEuWSAqIGIuWDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJuIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIG9uIGEgcGxhbmVcclxuICAgICAgICAvLy8gVGhlIGFuZ2xlIGlzIGZyb20gdmVjdG9yIDEgdG8gdmVjdG9yIDIsIHBvc2l0aXZlIGFudGljbG9ja3dpc2VcclxuICAgICAgICAvLy8gVGhlIHJlc3VsdCBpcyBiZXR3ZWVuIC1waSAtPiBwaVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBkb3VibGUgVmVjdG9yQW5nbGUocmVmIFZlY3RvcjIgcDEsIHJlZiBWZWN0b3IyIHAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIHRoZXRhMSA9IE1hdGguQXRhbjIocDEuWSwgcDEuWCk7XHJcbiAgICAgICAgICAgIGRvdWJsZSB0aGV0YTIgPSBNYXRoLkF0YW4yKHAyLlksIHAyLlgpO1xyXG4gICAgICAgICAgICBkb3VibGUgZHRoZXRhID0gdGhldGEyIC0gdGhldGExO1xyXG4gICAgICAgICAgICB3aGlsZSAoZHRoZXRhID4gTWF0aC5QSSlcclxuICAgICAgICAgICAgICAgIGR0aGV0YSAtPSAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgICB3aGlsZSAoZHRoZXRhIDwgLU1hdGguUEkpXHJcbiAgICAgICAgICAgICAgICBkdGhldGEgKz0gKDIgKiBNYXRoLlBJKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoZHRoZXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZG91YmxlIFZlY3RvckFuZ2xlKFZlY3RvcjIgcDEsIFZlY3RvcjIgcDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yQW5nbGUocmVmIHAxLCByZWYgcDIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGMgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIGxpbmUgZ29pbmcgZnJvbSBhIHRvIGIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+UG9zaXRpdmUgbnVtYmVyIGlmIHBvaW50IGlzIGxlZnQsIG5lZ2F0aXZlIGlmIHBvaW50IGlzIHJpZ2h0LCBcclxuICAgICAgICAvLy8gYW5kIDAgaWYgcG9pbnRzIGFyZSBjb2xsaW5lYXIuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgQXJlYShWZWN0b3IyIGEsIFZlY3RvcjIgYiwgVmVjdG9yMiBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFyZWEocmVmIGEsIHJlZiBiLCByZWYgYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSBwb3NpdGl2ZSBudW1iZXIgaWYgYyBpcyB0byB0aGUgbGVmdCBvZiB0aGUgbGluZSBnb2luZyBmcm9tIGEgdG8gYi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5Qb3NpdGl2ZSBudW1iZXIgaWYgcG9pbnQgaXMgbGVmdCwgbmVnYXRpdmUgaWYgcG9pbnQgaXMgcmlnaHQsIFxyXG4gICAgICAgIC8vLyBhbmQgMCBpZiBwb2ludHMgYXJlIGNvbGxpbmVhci48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBBcmVhKHJlZiBWZWN0b3IyIGEsIHJlZiBWZWN0b3IyIGIsIHJlZiBWZWN0b3IyIGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5YICogKGIuWSAtIGMuWSkgKyBiLlggKiAoYy5ZIC0gYS5ZKSArIGMuWCAqIChhLlkgLSBiLlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlcm1pbmVzIGlmIHRocmVlIHZlcnRpY2VzIGFyZSBjb2xsaW5lYXIgKGllLiBvbiBhIHN0cmFpZ2h0IGxpbmUpXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhXCI+Rmlyc3QgdmVydGV4PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJiXCI+U2Vjb25kIHZlcnRleDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY1wiPlRoaXJkIHZlcnRleDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgQ29sbGluZWFyKHJlZiBWZWN0b3IyIGEsIHJlZiBWZWN0b3IyIGIsIHJlZiBWZWN0b3IyIGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGluZWFyKHJlZiBhLCByZWYgYiwgcmVmIGMsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIENvbGxpbmVhcihyZWYgVmVjdG9yMiBhLCByZWYgVmVjdG9yMiBiLCByZWYgVmVjdG9yMiBjLCBmbG9hdCB0b2xlcmFuY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRmxvYXRJblJhbmdlKEFyZWEocmVmIGEsIHJlZiBiLCByZWYgYyksIC10b2xlcmFuY2UsIHRvbGVyYW5jZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgQ3Jvc3MoZmxvYXQgcywgcmVmIFZlY3RvcjIgYSwgb3V0IFZlY3RvcjIgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGIgPSBuZXcgVmVjdG9yMigtcyAqIGEuWSwgcyAqIGEuWCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgRmxvYXRFcXVhbHMoZmxvYXQgdmFsdWUxLCBmbG9hdCB2YWx1ZTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5BYnModmFsdWUxIC0gdmFsdWUyKSA8PSBTZXR0aW5ncy5FcHNpbG9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDaGVja3MgaWYgYSBmbG9hdGluZyBwb2ludCBWYWx1ZSBpcyBlcXVhbCB0byBhbm90aGVyLFxyXG4gICAgICAgIC8vLyB3aXRoaW4gYSBjZXJ0YWluIHRvbGVyYW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlMVwiPlRoZSBmaXJzdCBmbG9hdGluZyBwb2ludCBWYWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlMlwiPlRoZSBzZWNvbmQgZmxvYXRpbmcgcG9pbnQgVmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkZWx0YVwiPlRoZSBmbG9hdGluZyBwb2ludCB0b2xlcmFuY2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgdmFsdWVzIGFyZSBcImVxdWFsXCIsIGZhbHNlIG90aGVyd2lzZS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIEZsb2F0RXF1YWxzKGZsb2F0IHZhbHVlMSwgZmxvYXQgdmFsdWUyLCBmbG9hdCBkZWx0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBGbG9hdEluUmFuZ2UodmFsdWUxLCB2YWx1ZTIgLSBkZWx0YSwgdmFsdWUyICsgZGVsdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDaGVja3MgaWYgYSBmbG9hdGluZyBwb2ludCBWYWx1ZSBpcyB3aXRoaW4gYSBzcGVjaWZpZWRcclxuICAgICAgICAvLy8gcmFuZ2Ugb2YgdmFsdWVzIChpbmNsdXNpdmUpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmFsdWVcIj5UaGUgVmFsdWUgdG8gY2hlY2suPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtaW5cIj5UaGUgbWluaW11bSBWYWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heFwiPlRoZSBtYXhpbXVtIFZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIFZhbHVlIGlzIHdpdGhpbiB0aGUgcmFuZ2Ugc3BlY2lmaWVkLFxyXG4gICAgICAgIC8vLyBmYWxzZSBvdGhlcndpc2UuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBGbG9hdEluUmFuZ2UoZmxvYXQgdmFsdWUsIGZsb2F0IG1pbiwgZmxvYXQgbWF4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gTmVzdGVkIHR5cGU6IEZsb2F0Q29udmVydGVyXHJcblxyXG4gICAgICAgIFtTdHJ1Y3RMYXlvdXQoTGF5b3V0S2luZC5FeHBsaWNpdCldXHJcbiAgICAgICAgcHJpdmF0ZSBzdHJ1Y3QgRmxvYXRDb252ZXJ0ZXJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFtGaWVsZE9mZnNldCgwKV1cclxuICAgICAgICAgICAgcHVibGljIGZsb2F0IHg7XHJcbiAgICAgICAgICAgIFtGaWVsZE9mZnNldCgwKV1cclxuICAgICAgICAgICAgcHVibGljIGludCBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIDItYnktMiBtYXRyaXguIFN0b3JlZCBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBNYXQyMlxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIENvbDEsIENvbDI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29uc3RydWN0IHRoaXMgbWF0cml4IHVzaW5nIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjMVwiPlRoZSBjMS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImMyXCI+VGhlIGMyLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIE1hdDIyKFZlY3RvcjIgYzEsIFZlY3RvcjIgYzIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDb2wxID0gYzE7XHJcbiAgICAgICAgICAgIENvbDIgPSBjMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29uc3RydWN0IHRoaXMgbWF0cml4IHVzaW5nIHNjYWxhcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhMTFcIj5UaGUgYTExLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYTEyXCI+VGhlIGExMi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImEyMVwiPlRoZSBhMjEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhMjJcIj5UaGUgYTIyLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIE1hdDIyKGZsb2F0IGExMSwgZmxvYXQgYTEyLCBmbG9hdCBhMjEsIGZsb2F0IGEyMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbDEgPSBuZXcgVmVjdG9yMihhMTEsIGEyMSk7XHJcbiAgICAgICAgICAgIENvbDIgPSBuZXcgVmVjdG9yMihhMTIsIGEyMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnN0cnVjdCB0aGlzIG1hdHJpeCB1c2luZyBhbiBhbmdsZS4gVGhpcyBtYXRyaXggYmVjb21lc1xyXG4gICAgICAgIC8vLyBhbiBvcnRob25vcm1hbCByb3RhdGlvbiBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhbmdsZVwiPlRoZSBhbmdsZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXQyMihmbG9hdCBhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiBjb21wdXRlIHNpbitjb3MgdG9nZXRoZXIuXHJcbiAgICAgICAgICAgIGZsb2F0IGMgPSAoZmxvYXQpTWF0aC5Db3MoYW5nbGUpLCBzID0gKGZsb2F0KU1hdGguU2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgQ29sMSA9IG5ldyBWZWN0b3IyKGMsIHMpO1xyXG4gICAgICAgICAgICBDb2wyID0gbmV3IFZlY3RvcjIoLXMsIGMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFeHRyYWN0IHRoZSBhbmdsZSBmcm9tIHRoaXMgbWF0cml4IChhc3N1bWVkIHRvIGJlXHJcbiAgICAgICAgLy8vIGEgcm90YXRpb24gbWF0cml4KS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQW5nbGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoZmxvYXQpTWF0aC5BdGFuMihDb2wxLlksIENvbDEuWCk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBNYXQyMiBJbnZlcnNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgYSA9IENvbDEuWCwgYiA9IENvbDIuWCwgYyA9IENvbDEuWSwgZCA9IENvbDIuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRldCA9IGEgKiBkIC0gYiAqIGM7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGV0ICE9IDAuMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV0ID0gMS4wZiAvIGRldDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBNYXQyMiByZXN1bHQgPSBuZXcgTWF0MjIoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5Db2wxLlggPSBkZXQgKiBkO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkNvbDEuWSA9IC1kZXQgKiBjO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5Db2wyLlggPSAtZGV0ICogYjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5Db2wyLlkgPSBkZXQgKiBhO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZSB0aGlzIG1hdHJpeCB1c2luZyBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYzFcIj5UaGUgYzEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjMlwiPlRoZSBjMi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldChWZWN0b3IyIGMxLCBWZWN0b3IyIGMyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29sMSA9IGMxO1xyXG4gICAgICAgICAgICBDb2wyID0gYzI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemUgdGhpcyBtYXRyaXggdXNpbmcgYW4gYW5nbGUuIFRoaXMgbWF0cml4IGJlY29tZXNcclxuICAgICAgICAvLy8gYW4gb3J0aG9ub3JtYWwgcm90YXRpb24gbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYW5nbGVcIj5UaGUgYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXQoZmxvYXQgYW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBjID0gKGZsb2F0KU1hdGguQ29zKGFuZ2xlKSwgcyA9IChmbG9hdClNYXRoLlNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIENvbDEuWCA9IGM7XHJcbiAgICAgICAgICAgIENvbDIuWCA9IC1zO1xyXG4gICAgICAgICAgICBDb2wxLlkgPSBzO1xyXG4gICAgICAgICAgICBDb2wyLlkgPSBjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhpcyB0byB0aGUgaWRlbnRpdHkgbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0SWRlbnRpdHkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29sMS5YID0gMS4wZjtcclxuICAgICAgICAgICAgQ29sMi5YID0gMC4wZjtcclxuICAgICAgICAgICAgQ29sMS5ZID0gMC4wZjtcclxuICAgICAgICAgICAgQ29sMi5ZID0gMS4wZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoaXMgbWF0cml4IHRvIGFsbCB6ZXJvcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldFplcm8oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29sMS5YID0gMC4wZjtcclxuICAgICAgICAgICAgQ29sMi5YID0gMC4wZjtcclxuICAgICAgICAgICAgQ29sMS5ZID0gMC4wZjtcclxuICAgICAgICAgICAgQ29sMi5ZID0gMC4wZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmUgQSAqIHggPSBiLCB3aGVyZSBiIGlzIGEgY29sdW1uIHZlY3Rvci4gVGhpcyBpcyBtb3JlIGVmZmljaWVudFxyXG4gICAgICAgIC8vLyB0aGFuIGNvbXB1dGluZyB0aGUgaW52ZXJzZSBpbiBvbmUtc2hvdCBjYXNlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJcIj5UaGUgYi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgU29sdmUoVmVjdG9yMiBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgYTExID0gQ29sMS5YLCBhMTIgPSBDb2wyLlgsIGEyMSA9IENvbDEuWSwgYTIyID0gQ29sMi5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBkZXQgPSBhMTEgKiBhMjIgLSBhMTIgKiBhMjE7XHJcbiAgICAgICAgICAgIGlmIChkZXQgIT0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGV0ID0gMS4wZiAvIGRldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKGRldCAqIChhMjIgKiBiLlggLSBhMTIgKiBiLlkpLCBkZXQgKiAoYTExICogYi5ZIC0gYTIxICogYi5YKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgQWRkKHJlZiBNYXQyMiBBLCByZWYgTWF0MjIgQiwgb3V0IE1hdDIyIFIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBSLkNvbDEgPSBBLkNvbDEgKyBCLkNvbDE7XHJcbiAgICAgICAgICAgIFIuQ29sMiA9IEEuQ29sMiArIEIuQ29sMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgMy1ieS0zIG1hdHJpeC4gU3RvcmVkIGluIGNvbHVtbi1tYWpvciBvcmRlci5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IE1hdDMzXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjMgQ29sMSwgQ29sMiwgQ29sMztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25zdHJ1Y3QgdGhpcyBtYXRyaXggdXNpbmcgY29sdW1ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImMxXCI+VGhlIGMxLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYzJcIj5UaGUgYzIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjM1wiPlRoZSBjMy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXQzMyhWZWN0b3IzIGMxLCBWZWN0b3IzIGMyLCBWZWN0b3IzIGMzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29sMSA9IGMxO1xyXG4gICAgICAgICAgICBDb2wyID0gYzI7XHJcbiAgICAgICAgICAgIENvbDMgPSBjMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoaXMgbWF0cml4IHRvIGFsbCB6ZXJvcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldFplcm8oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29sMSA9IFZlY3RvcjMuWmVybztcclxuICAgICAgICAgICAgQ29sMiA9IFZlY3RvcjMuWmVybztcclxuICAgICAgICAgICAgQ29sMyA9IFZlY3RvcjMuWmVybztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmUgQSAqIHggPSBiLCB3aGVyZSBiIGlzIGEgY29sdW1uIHZlY3Rvci4gVGhpcyBpcyBtb3JlIGVmZmljaWVudFxyXG4gICAgICAgIC8vLyB0aGFuIGNvbXB1dGluZyB0aGUgaW52ZXJzZSBpbiBvbmUtc2hvdCBjYXNlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJcIj5UaGUgYi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjMgU29sdmUzMyhWZWN0b3IzIGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBkZXQgPSBWZWN0b3IzLkRvdChDb2wxLCBWZWN0b3IzLkNyb3NzKENvbDIsIENvbDMpKTtcclxuICAgICAgICAgICAgaWYgKGRldCAhPSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkZXQgPSAxLjBmIC8gZGV0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoZGV0ICogVmVjdG9yMy5Eb3QoYiwgVmVjdG9yMy5Dcm9zcyhDb2wyLCBDb2wzKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXQgKiBWZWN0b3IzLkRvdChDb2wxLCBWZWN0b3IzLkNyb3NzKGIsIENvbDMpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldCAqIFZlY3RvcjMuRG90KENvbDEsIFZlY3RvcjMuQ3Jvc3MoQ29sMiwgYikpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmUgQSAqIHggPSBiLCB3aGVyZSBiIGlzIGEgY29sdW1uIHZlY3Rvci4gVGhpcyBpcyBtb3JlIGVmZmljaWVudFxyXG4gICAgICAgIC8vLyB0aGFuIGNvbXB1dGluZyB0aGUgaW52ZXJzZSBpbiBvbmUtc2hvdCBjYXNlcy4gU29sdmUgb25seSB0aGUgdXBwZXJcclxuICAgICAgICAvLy8gMi1ieS0yIG1hdHJpeCBlcXVhdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJcIj5UaGUgYi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgU29sdmUyMihWZWN0b3IyIGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBhMTEgPSBDb2wxLlgsIGExMiA9IENvbDIuWCwgYTIxID0gQ29sMS5ZLCBhMjIgPSBDb2wyLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IGRldCA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZXQgIT0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGV0ID0gMS4wZiAvIGRldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKGRldCAqIChhMjIgKiBiLlggLSBhMTIgKiBiLlkpLCBkZXQgKiAoYTExICogYi5ZIC0gYTIxICogYi5YKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIHRyYW5zZm9ybSBjb250YWlucyB0cmFuc2xhdGlvbiBhbmQgcm90YXRpb24uIEl0IGlzIHVzZWQgdG8gcmVwcmVzZW50XHJcbiAgICAvLy8gdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiByaWdpZCBmcmFtZXMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBUcmFuc2Zvcm1cclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBQb3NpdGlvbjtcclxuICAgICAgICBwdWJsaWMgTWF0MjIgUjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplIHVzaW5nIGEgcG9zaXRpb24gdmVjdG9yIGFuZCBhIHJvdGF0aW9uIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvc2l0aW9uXCI+VGhlIHBvc2l0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiclwiPlRoZSByLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFRyYW5zZm9ybShyZWYgVmVjdG9yMiBwb3NpdGlvbiwgcmVmIE1hdDIyIHIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICBSID0gcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlIHRoZSBhbmdsZSB0aGF0IHRoZSByb3RhdGlvbiBtYXRyaXggcmVwcmVzZW50cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQW5nbGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoZmxvYXQpTWF0aC5BdGFuMihSLkNvbDEuWSwgUi5Db2wxLlgpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGlzIHRvIHRoZSBpZGVudGl0eSB0cmFuc2Zvcm0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRJZGVudGl0eSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb3NpdGlvbiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgUi5TZXRJZGVudGl0eSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhpcyBiYXNlZCBvbiB0aGUgcG9zaXRpb24gYW5kIGFuZ2xlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9zaXRpb25cIj5UaGUgcG9zaXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhbmdsZVwiPlRoZSBhbmdsZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldChWZWN0b3IyIHBvc2l0aW9uLCBmbG9hdCBhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgIFIuU2V0KGFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgZGVzY3JpYmVzIHRoZSBtb3Rpb24gb2YgYSBib2R5L3NoYXBlIGZvciBUT0kgY29tcHV0YXRpb24uXHJcbiAgICAvLy8gU2hhcGVzIGFyZSBkZWZpbmVkIHdpdGggcmVzcGVjdCB0byB0aGUgYm9keSBvcmlnaW4sIHdoaWNoIG1heVxyXG4gICAgLy8vIG5vIGNvaW5jaWRlIHdpdGggdGhlIGNlbnRlciBvZiBtYXNzLiBIb3dldmVyLCB0byBzdXBwb3J0IGR5bmFtaWNzXHJcbiAgICAvLy8gd2UgbXVzdCBpbnRlcnBvbGF0ZSB0aGUgY2VudGVyIG9mIG1hc3MgcG9zaXRpb24uXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBTd2VlcFxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV29ybGQgYW5nbGVzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQTtcclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IEEwO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZyYWN0aW9uIG9mIHRoZSBjdXJyZW50IHRpbWUgc3RlcCBpbiB0aGUgcmFuZ2UgWzAsMV1cclxuICAgICAgICAvLy8gYzAgYW5kIGEwIGFyZSB0aGUgcG9zaXRpb25zIGF0IGFscGhhMC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBBbHBoYTA7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2VudGVyIHdvcmxkIHBvc2l0aW9uc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgQztcclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgQzA7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTG9jYWwgY2VudGVyIG9mIG1hc3MgcG9zaXRpb25cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQ2VudGVyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgaW50ZXJwb2xhdGVkIHRyYW5zZm9ybSBhdCBhIHNwZWNpZmljIHRpbWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4ZlwiPlRoZSB0cmFuc2Zvcm0uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJiZXRhXCI+YmV0YSBpcyBhIGZhY3RvciBpbiBbMCwxXSwgd2hlcmUgMCBpbmRpY2F0ZXMgYWxwaGEwLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgR2V0VHJhbnNmb3JtKG91dCBUcmFuc2Zvcm0geGYsIGZsb2F0IGJldGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB4ZiA9IG5ldyBUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgeGYuUG9zaXRpb24uWCA9ICgxLjBmIC0gYmV0YSkgKiBDMC5YICsgYmV0YSAqIEMuWDtcclxuICAgICAgICAgICAgeGYuUG9zaXRpb24uWSA9ICgxLjBmIC0gYmV0YSkgKiBDMC5ZICsgYmV0YSAqIEMuWTtcclxuICAgICAgICAgICAgZmxvYXQgYW5nbGUgPSAoMS4wZiAtIGJldGEpICogQTAgKyBiZXRhICogQTtcclxuICAgICAgICAgICAgeGYuUi5TZXQoYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hpZnQgdG8gb3JpZ2luXHJcbiAgICAgICAgICAgIHhmLlBvc2l0aW9uIC09IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYuUiwgcmVmIExvY2FsQ2VudGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWR2YW5jZSB0aGUgc3dlZXAgZm9yd2FyZCwgeWllbGRpbmcgYSBuZXcgaW5pdGlhbCBzdGF0ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFscGhhXCI+bmV3IGluaXRpYWwgdGltZS4uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZHZhbmNlKGZsb2F0IGFscGhhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEFscGhhMCA8IDEuMGYpO1xyXG4gICAgICAgICAgICBmbG9hdCBiZXRhID0gKGFscGhhIC0gQWxwaGEwKSAvICgxLjBmIC0gQWxwaGEwKTtcclxuICAgICAgICAgICAgQzAuWCA9ICgxLjBmIC0gYmV0YSkgKiBDMC5YICsgYmV0YSAqIEMuWDtcclxuICAgICAgICAgICAgQzAuWSA9ICgxLjBmIC0gYmV0YSkgKiBDMC5ZICsgYmV0YSAqIEMuWTtcclxuICAgICAgICAgICAgQTAgPSAoMS4wZiAtIGJldGEpICogQTAgKyBiZXRhICogQTtcclxuICAgICAgICAgICAgQWxwaGEwID0gYWxwaGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE5vcm1hbGl6ZSB0aGUgYW5nbGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTm9ybWFsaXplKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGQgPSBNYXRoSGVscGVyLlR3b1BpICogKGZsb2F0KU1hdGguRmxvb3IoQTAgLyBNYXRoSGVscGVyLlR3b1BpKTtcclxuICAgICAgICAgICAgQTAgLT0gZDtcclxuICAgICAgICAgICAgQSAtPSBkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcmsuR3JhcGhpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkZhY3RvcmllcztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb25cclxue1xyXG4gICAgcHVibGljIGVudW0gRGVjb21wb3NlclxyXG4gICAge1xyXG4gICAgICAgIEJheWF6aXQsXHJcbiAgICAgICAgQ0RULFxyXG4gICAgICAgIEVhcmNsaXAsXHJcbiAgICAgICAgRmxpcGNvZGUsXHJcbiAgICAgICAgU2VpZGVsLFxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNvbG9yIGlzIGluc2lkZSB0aGUgdGVycmFpbi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgZGVsZWdhdGUgYm9vbCBUZXJyYWluVGVzdGVyKENvbG9yIENvbG9yKTtcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gU2ltcGxlIGNsYXNzIHRvIG1haW50YWluIGEgdGVycmFpbi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgTVNUZXJyYWluXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBXb3JsZCB0byBtYW5hZ2UgdGVycmFpbiBpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBXb3JsZCBXb3JsZDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDZW50ZXIgb2YgdGVycmFpbiBpbiB3b3JsZCB1bml0cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIENlbnRlcjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBXaWR0aCBvZiB0ZXJyYWluIGluIHdvcmxkIHVuaXRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFdpZHRoO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEhlaWdodCBvZiB0ZXJyYWluIGluIHdvcmxkIHVuaXRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEhlaWdodDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHMgcGVyIGVhY2ggd29ybGQgdW5pdCB1c2VkIHRvIGRlZmluZSB0aGUgdGVycmFpbiBpbiB0aGUgcG9pbnQgY2xvdWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IFBvaW50c1BlclVuaXQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnRzIHBlciBjZWxsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGludCBDZWxsU2l6ZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludHMgcGVyIHN1YiBjZWxsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGludCBTdWJDZWxsU2l6ZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOdW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtIGluIHRoZSBNYXJjaGluZyBTcXVhcmVzIGFsZ29yaXRobS5cclxuICAgICAgICAvLy8gTm90ZTogTW9yZSB0aGVuIDMgaGFzIGFsbW9zdCBubyBlZmZlY3Qgb24gcXVhbGl0eS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBpbnQgSXRlcmF0aW9ucyA9IDI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVjb21wb3NlciB0byB1c2Ugd2hlbiByZWdlbmVyYXRpbmcgdGVycmFpbi4gQ2FuIGJlIGNoYW5nZWQgb24gdGhlIGZseSB3aXRob3V0IGNvbnNlcXVlbmNlLlxyXG4gICAgICAgIC8vLyBOb3RlOiBTb21lIGRlY29tcG9zZXJlcnMgYXJlIHVuc3RhYmxlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIERlY29tcG9zZXIgRGVjb21wb3NlcjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb2ludCBjbG91ZCBkZWZpbmluZyB0aGUgdGVycmFpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc2J5dGVbLF0gX3RlcnJhaW5NYXA7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2VuZXJhdGVkIGJvZGllcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgTGlzdDxCb2R5PlssXSBfYm9keU1hcDtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbG9jYWxXaWR0aDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9sb2NhbEhlaWdodDtcclxuICAgICAgICBwcml2YXRlIGludCBfeG51bTtcclxuICAgICAgICBwcml2YXRlIGludCBfeW51bTtcclxuICAgICAgICBwcml2YXRlIEFBQkIgX2RpcnR5QXJlYTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3RvcExlZnQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBNU1RlcnJhaW4oV29ybGQgd29ybGQsIEFBQkIgYXJlYSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFdvcmxkID0gd29ybGQ7XHJcbiAgICAgICAgICAgIFdpZHRoID0gYXJlYS5FeHRlbnRzLlggKiAyO1xyXG4gICAgICAgICAgICBIZWlnaHQgPSBhcmVhLkV4dGVudHMuWSAqIDI7XHJcbiAgICAgICAgICAgIENlbnRlciA9IGFyZWEuQ2VudGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplIHRoZSB0ZXJyYWluIGZvciB1c2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBJbml0aWFsaXplKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgdG9wIGxlZnQgb2YgdGVycmFpbiBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAgICBfdG9wTGVmdCA9IG5ldyBWZWN0b3IyKENlbnRlci5YIC0gKFdpZHRoICogMC41ZiksIENlbnRlci5ZIC0gKC1IZWlnaHQgKiAwLjVmKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSB0ZXJyYWlucyBzaXplIHRvIGEgcG9pbnQgY2xvdWQgc2l6ZVxyXG4gICAgICAgICAgICBfbG9jYWxXaWR0aCA9IFdpZHRoICogUG9pbnRzUGVyVW5pdDtcclxuICAgICAgICAgICAgX2xvY2FsSGVpZ2h0ID0gSGVpZ2h0ICogUG9pbnRzUGVyVW5pdDtcclxuXHJcbiAgICAgICAgICAgIF90ZXJyYWluTWFwID0gbmV3IHNieXRlWyhpbnQpX2xvY2FsV2lkdGggKyAxLCAoaW50KV9sb2NhbEhlaWdodCArIDFdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgeCA9IDA7IHggPCBfbG9jYWxXaWR0aDsgeCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB5ID0gMDsgeSA8IF9sb2NhbEhlaWdodDsgeSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXJyYWluTWFwW3gsIHldID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3hudW0gPSAoaW50KShfbG9jYWxXaWR0aCAvIENlbGxTaXplKTtcclxuICAgICAgICAgICAgX3ludW0gPSAoaW50KShfbG9jYWxIZWlnaHQgLyBDZWxsU2l6ZSk7XHJcbiAgICAgICAgICAgIF9ib2R5TWFwID0gbmV3IExpc3Q8Qm9keT5bX3hudW0sIF95bnVtXTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBtYXJrIHRoZSBkaXJ0eSBhcmVhIHRvIGFuIGluZmluaXRlbHkgc21hbGwgYm94XHJcbiAgICAgICAgICAgIF9kaXJ0eUFyZWEgPSBuZXcgQUFCQihuZXcgVmVjdG9yMihmbG9hdC5NYXhWYWx1ZSwgZmxvYXQuTWF4VmFsdWUpLCBuZXcgVmVjdG9yMihmbG9hdC5NaW5WYWx1ZSwgZmxvYXQuTWluVmFsdWUpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbHkgYSB0ZXh0dXJlIHRvIHRoZSB0ZXJyYWluIHVzaW5nIHRoZSBzcGVjaWZpZWQgVGVycmFpblRlc3Rlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRleHR1cmVcIj5UZXh0dXJlIHRvIGFwcGx5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9zaXRpb25cIj5Ub3AgbGVmdCBwb3NpdGlvbiBvZiB0aGUgdGV4dHVyZSByZWxhdGl2ZSB0byB0aGUgdGVycmFpbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRlc3RlclwiPkRlbGVnYXRlIG1ldGhvZCB1c2VkIHRvIGRldGVybWluZSB3aGF0IGNvbG9ycyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHRlcnJhaW4uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBseVRleHR1cmUoVGV4dHVyZTJEIHRleHR1cmUsIFZlY3RvcjIgcG9zaXRpb24sIFRlcnJhaW5UZXN0ZXIgdGVzdGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29sb3JbXSBjb2xvckRhdGEgPSBuZXcgQ29sb3JbdGV4dHVyZS5XaWR0aCAqIHRleHR1cmUuSGVpZ2h0XTtcclxuXHJcbiAgICAgICAgICAgIHRleHR1cmUuR2V0RGF0YTxnbG9iYWw6Ok1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLkNvbG9yPihjb2xvckRhdGEpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgeSA9IChpbnQpcG9zaXRpb24uWTsgeSA8IHRleHR1cmUuSGVpZ2h0ICsgKGludClwb3NpdGlvbi5ZOyB5KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHggPSAoaW50KXBvc2l0aW9uLlg7IHggPCB0ZXh0dXJlLldpZHRoICsgKGludClwb3NpdGlvbi5YOyB4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB4IDwgX2xvY2FsV2lkdGggJiYgeSA+PSAwICYmIHkgPCBfbG9jYWxIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sIGluc2lkZSA9IHRlc3Rlcihjb2xvckRhdGFbKCh5IC0gKGludClwb3NpdGlvbi5ZKSAqIHRleHR1cmUuV2lkdGgpICsgKHggLSAoaW50KXBvc2l0aW9uLlgpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2lkZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90ZXJyYWluTWFwW3gsIHldID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RlcnJhaW5NYXBbeCwgeV0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRlcnJhaW5cclxuICAgICAgICAgICAgZm9yIChpbnQgZ3kgPSAwOyBneSA8IF95bnVtOyBneSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBneCA9IDA7IGd4IDwgX3hudW07IGd4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgb2xkIHRlcnJhaW4gb2JqZWN0IGF0IGdyaWQgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfYm9keU1hcFtneCwgZ3ldICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9ib2R5TWFwW2d4LCBneV0uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV29ybGQuUmVtb3ZlQm9keShfYm9keU1hcFtneCwgZ3ldW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2JvZHlNYXBbZ3gsIGd5XSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2VuZXJhdGUgbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIEdlbmVyYXRlVGVycmFpbihneCwgZ3kpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGx5IGEgdGV4dHVyZSB0byB0aGUgdGVycmFpbiB1c2luZyB0aGUgc3BlY2lmaWVkIFRlcnJhaW5UZXN0ZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb3NpdGlvblwiPlRvcCBsZWZ0IHBvc2l0aW9uIG9mIHRoZSB0ZXh0dXJlIHJlbGF0aXZlIHRvIHRoZSB0ZXJyYWluLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQXBwbHlEYXRhKHNieXRlWyxdIGRhdGEsIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCB5ID0gKGludClwb3NpdGlvbi5ZOyB5IDwgZGF0YS5HZXRVcHBlckJvdW5kKDEpICsgKGludClwb3NpdGlvbi5ZOyB5KyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHggPSAoaW50KXBvc2l0aW9uLlg7IHggPCBkYXRhLkdldFVwcGVyQm91bmQoMCkgKyAoaW50KXBvc2l0aW9uLlg7IHgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPCBfbG9jYWxXaWR0aCAmJiB5ID49IDAgJiYgeSA8IF9sb2NhbEhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ZXJyYWluTWFwW3gsIHldID0gZGF0YVt4LCB5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRlcnJhaW5cclxuICAgICAgICAgICAgZm9yIChpbnQgZ3kgPSAwOyBneSA8IF95bnVtOyBneSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBneCA9IDA7IGd4IDwgX3hudW07IGd4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgb2xkIHRlcnJhaW4gb2JqZWN0IGF0IGdyaWQgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfYm9keU1hcFtneCwgZ3ldICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9ib2R5TWFwW2d4LCBneV0uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV29ybGQuUmVtb3ZlQm9keShfYm9keU1hcFtneCwgZ3ldW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2JvZHlNYXBbZ3gsIGd5XSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2VuZXJhdGUgbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIEdlbmVyYXRlVGVycmFpbihneCwgZ3kpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnZlcnQgYSB0ZXh0dXJlIHRvIGFuIHNidHllIGFycmF5IGNvbXBhdGlibGUgd2l0aCBBcHBseURhdGEoKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRleHR1cmVcIj5UZXh0dXJlIHRvIGNvbnZlcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0ZXN0ZXJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBzYnl0ZVssXSBDb252ZXJ0VGV4dHVyZVRvRGF0YShUZXh0dXJlMkQgdGV4dHVyZSwgVGVycmFpblRlc3RlciB0ZXN0ZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzYnl0ZVssXSBkYXRhID0gbmV3IHNieXRlW3RleHR1cmUuV2lkdGgsIHRleHR1cmUuSGVpZ2h0XTtcclxuICAgICAgICAgICAgQ29sb3JbXSBjb2xvckRhdGEgPSBuZXcgQ29sb3JbdGV4dHVyZS5XaWR0aCAqIHRleHR1cmUuSGVpZ2h0XTtcclxuXHJcbiAgICAgICAgICAgIHRleHR1cmUuR2V0RGF0YTxnbG9iYWw6Ok1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLkNvbG9yPihjb2xvckRhdGEpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgeSA9IDA7IHkgPCB0ZXh0dXJlLkhlaWdodDsgeSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB4ID0gMDsgeCA8IHRleHR1cmUuV2lkdGg7IHgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBib29sIGluc2lkZSA9IHRlc3Rlcihjb2xvckRhdGFbKHkgKiB0ZXh0dXJlLldpZHRoKSArIHhdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbeCwgeV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVt4LCB5XSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTW9kaWZ5IGEgc2luZ2xlIHBvaW50IGluIHRoZSB0ZXJyYWluLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYXRpb25cIj5Xb3JsZCBsb2NhdGlvbiB0byBtb2RpZnkuIEF1dG9tYXRpY2FsbHkgY2xpcHBlZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+LTEgPSBpbnNpZGUgdGVycmFpbiwgMSA9IG91dHNpZGUgdGVycmFpbjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTW9kaWZ5VGVycmFpbihWZWN0b3IyIGxvY2F0aW9uLCBzYnl0ZSB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgbG9jYWwgcG9zaXRpb25cclxuICAgICAgICAgICAgLy8gbWFrZSBwb3NpdGlvbiBsb2NhbCB0byBtYXAgc3BhY2VcclxuICAgICAgICAgICAgVmVjdG9yMiBwID0gbG9jYXRpb24gLSBfdG9wTGVmdDtcclxuXHJcbiAgICAgICAgICAgIC8vIGZpbmQgbWFwIHBvc2l0aW9uIGZvciBlYWNoIGF4aXNcclxuICAgICAgICAgICAgcC5YID0gcC5YICogX2xvY2FsV2lkdGggLyBXaWR0aDtcclxuICAgICAgICAgICAgcC5ZID0gcC5ZICogLV9sb2NhbEhlaWdodCAvIEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmIChwLlggPj0gMCAmJiBwLlggPCBfbG9jYWxXaWR0aCAmJiBwLlkgPj0gMCAmJiBwLlkgPCBfbG9jYWxIZWlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90ZXJyYWluTWFwWyhpbnQpcC5YLCAoaW50KXAuWV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBleHBhbmQgZGlydHkgYXJlYVxyXG4gICAgICAgICAgICAgICAgaWYgKHAuWCA8IF9kaXJ0eUFyZWEuTG93ZXJCb3VuZC5YKSBfZGlydHlBcmVhLkxvd2VyQm91bmQuWCA9IHAuWDtcclxuICAgICAgICAgICAgICAgIGlmIChwLlggPiBfZGlydHlBcmVhLlVwcGVyQm91bmQuWCkgX2RpcnR5QXJlYS5VcHBlckJvdW5kLlggPSBwLlg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHAuWSA8IF9kaXJ0eUFyZWEuTG93ZXJCb3VuZC5ZKSBfZGlydHlBcmVhLkxvd2VyQm91bmQuWSA9IHAuWTtcclxuICAgICAgICAgICAgICAgIGlmIChwLlkgPiBfZGlydHlBcmVhLlVwcGVyQm91bmQuWSkgX2RpcnR5QXJlYS5VcHBlckJvdW5kLlkgPSBwLlk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVnZW5lcmF0ZSB0aGUgdGVycmFpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlZ2VuZXJhdGVUZXJyYWluKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vaXRlcmF0ZSBlZmZlY3RlZCBjZWxsc1xyXG4gICAgICAgICAgICB2YXIgZ3gwID0gKGludCkoX2RpcnR5QXJlYS5Mb3dlckJvdW5kLlggLyBDZWxsU2l6ZSk7XHJcbiAgICAgICAgICAgIHZhciBneDEgPSAoaW50KShfZGlydHlBcmVhLlVwcGVyQm91bmQuWCAvIENlbGxTaXplKSArIDE7XHJcbiAgICAgICAgICAgIGlmIChneDAgPCAwKSBneDAgPSAwO1xyXG4gICAgICAgICAgICBpZiAoZ3gxID4gX3hudW0pIGd4MSA9IF94bnVtO1xyXG4gICAgICAgICAgICB2YXIgZ3kwID0gKGludCkoX2RpcnR5QXJlYS5Mb3dlckJvdW5kLlkgLyBDZWxsU2l6ZSk7XHJcbiAgICAgICAgICAgIHZhciBneTEgPSAoaW50KShfZGlydHlBcmVhLlVwcGVyQm91bmQuWSAvIENlbGxTaXplKSArIDE7XHJcbiAgICAgICAgICAgIGlmIChneTAgPCAwKSBneTAgPSAwO1xyXG4gICAgICAgICAgICBpZiAoZ3kxID4gX3ludW0pIGd5MSA9IF95bnVtO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgZ3ggPSBneDA7IGd4IDwgZ3gxOyBneCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBneSA9IGd5MDsgZ3kgPCBneTE7IGd5KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgb2xkIHRlcnJhaW4gb2JqZWN0IGF0IGdyaWQgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfYm9keU1hcFtneCwgZ3ldICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9ib2R5TWFwW2d4LCBneV0uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV29ybGQuUmVtb3ZlQm9keShfYm9keU1hcFtneCwgZ3ldW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2JvZHlNYXBbZ3gsIGd5XSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2VuZXJhdGUgbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIEdlbmVyYXRlVGVycmFpbihneCwgZ3kpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfZGlydHlBcmVhID0gbmV3IEFBQkIobmV3IFZlY3RvcjIoZmxvYXQuTWF4VmFsdWUsIGZsb2F0Lk1heFZhbHVlKSwgbmV3IFZlY3RvcjIoZmxvYXQuTWluVmFsdWUsIGZsb2F0Lk1pblZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgR2VuZXJhdGVUZXJyYWluKGludCBneCwgaW50IGd5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgYXggPSBneCAqIENlbGxTaXplO1xyXG4gICAgICAgICAgICBmbG9hdCBheSA9IGd5ICogQ2VsbFNpemU7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiBwb2x5cyA9IE1hcmNoaW5nU3F1YXJlcy5EZXRlY3RTcXVhcmVzKG5ldyBBQUJCKG5ldyBWZWN0b3IyKGF4LCBheSksIG5ldyBWZWN0b3IyKGF4ICsgQ2VsbFNpemUsIGF5ICsgQ2VsbFNpemUpKSwgU3ViQ2VsbFNpemUsIFN1YkNlbGxTaXplLCBfdGVycmFpbk1hcCwgSXRlcmF0aW9ucywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChwb2x5cy5Db3VudCA9PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBfYm9keU1hcFtneCwgZ3ldID0gbmV3IExpc3Q8Qm9keT4oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgc2NhbGUgdmVjdG9yXHJcbiAgICAgICAgICAgIFZlY3RvcjIgc2NhbGUgPSBuZXcgVmVjdG9yMigxZiAvIFBvaW50c1BlclVuaXQsIDFmIC8gLVBvaW50c1BlclVuaXQpO1xyXG5cclxuICAgICAgICAgICAgLy8gY3JlYXRlIHBoeXNpY3Mgb2JqZWN0IGZvciB0aGlzIGdyaWQgY2VsbFxyXG4gICAgICAgICAgICBmb3JlYWNoICh2YXIgaXRlbSBpbiBwb2x5cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gZG9lcyB0aGlzIG5lZWQgdG8gYmUgbmVnYXRpdmU/XHJcbiAgICAgICAgICAgICAgICBpdGVtLlNjYWxlKHJlZiBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLlRyYW5zbGF0ZShyZWYgX3RvcExlZnQpO1xyXG4gICAgICAgICAgICAgICAgaXRlbS5Gb3JjZUNvdW50ZXJDbG9ja1dpc2UoKTtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzIHAgPSBGYXJzZWVyUGh5c2ljcy5Db21tb24uUG9seWdvbk1hbmlwdWxhdGlvbi5TaW1wbGlmeVRvb2xzLkNvbGxpbmVhclNpbXBsaWZ5KGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gZGVjb21wUG9seXMgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKERlY29tcG9zZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvbXBvc2VyLkJheWF6aXQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcFBvbHlzID0gRGVjb21wb3NpdGlvbi5CYXlheml0RGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24ocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb21wb3Nlci5DRFQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcFBvbHlzID0gRGVjb21wb3NpdGlvbi5DRFREZWNvbXBvc2VyLkNvbnZleFBhcnRpdGlvbihwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvbXBvc2VyLkVhcmNsaXA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcFBvbHlzID0gRGVjb21wb3NpdGlvbi5FYXJjbGlwRGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24ocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb21wb3Nlci5GbGlwY29kZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb21wUG9seXMgPSBEZWNvbXBvc2l0aW9uLkZsaXBjb2RlRGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24ocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb21wb3Nlci5TZWlkZWw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcFBvbHlzID0gRGVjb21wb3NpdGlvbi5TZWlkZWxEZWNvbXBvc2VyLkNvbnZleFBhcnRpdGlvbihwLCAwLjAwMWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChWZXJ0aWNlcyBwb2x5IGluIGRlY29tcFBvbHlzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LkNvdW50ID4gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2JvZHlNYXBbZ3gsIGd5XS5BZGQoQm9keUZhY3RvcnkuQ3JlYXRlUG9seWdvbihXb3JsZCwgcG9seSwgMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29udHJvbGxlcnM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkNvbnRhY3RzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBDb250YWlucyBmaWx0ZXIgZGF0YSB0aGF0IGNhbiBkZXRlcm1pbmUgd2hldGhlciBhbiBvYmplY3Qgc2hvdWxkIGJlIHByb2Nlc3NlZCBvciBub3QuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIEZpbHRlckRhdGFcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgQ2F0ZWdvcnkgRGlzYWJsZWRPbkNhdGVnb3JpZXMgPSBDYXRlZ29yeS5Ob25lO1xyXG5cclxuICAgICAgICBwdWJsaWMgaW50IERpc2FibGVkT25Hcm91cDtcclxuICAgICAgICBwdWJsaWMgQ2F0ZWdvcnkgRW5hYmxlZE9uQ2F0ZWdvcmllcyA9IENhdGVnb3J5LkFsbDtcclxuICAgICAgICBwdWJsaWMgaW50IEVuYWJsZWRPbkdyb3VwO1xyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCBib29sIElzQWN0aXZlT24oQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCB8fCAhYm9keS5FbmFibGVkIHx8IGJvZHkuSXNTdGF0aWMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoYm9keS5GaXh0dXJlTGlzdCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoRml4dHVyZSBmaXh0dXJlIGluIGJvZHkuRml4dHVyZUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vRGlzYWJsZVxyXG4gICAgICAgICAgICAgICAgaWYgKChmaXh0dXJlLkNvbGxpc2lvbkdyb3VwID09IERpc2FibGVkT25Hcm91cCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBmaXh0dXJlLkNvbGxpc2lvbkdyb3VwICE9IDAgJiYgRGlzYWJsZWRPbkdyb3VwICE9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoZml4dHVyZS5Db2xsaXNpb25DYXRlZ29yaWVzICYgRGlzYWJsZWRPbkNhdGVnb3JpZXMpICE9IENhdGVnb3J5Lk5vbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChFbmFibGVkT25Hcm91cCAhPSAwIHx8IEVuYWJsZWRPbkNhdGVnb3JpZXMgIT0gQ2F0ZWdvcnkuQWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRW5hYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmaXh0dXJlLkNvbGxpc2lvbkdyb3VwID09IEVuYWJsZWRPbkdyb3VwKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXh0dXJlLkNvbGxpc2lvbkdyb3VwICE9IDAgJiYgRW5hYmxlZE9uR3JvdXAgIT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZml4dHVyZS5Db2xsaXNpb25DYXRlZ29yaWVzICYgRW5hYmxlZE9uQ2F0ZWdvcmllcykgIT0gQ2F0ZWdvcnkuTm9uZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBFbmFibGVkT25DYXRlZ29yaWVzICE9IENhdGVnb3J5LkFsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyB0aGUgY2F0ZWdvcnkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjYXRlZ29yeVwiPlRoZSBjYXRlZ29yeS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZERpc2FibGVkQ2F0ZWdvcnkoQ2F0ZWdvcnkgY2F0ZWdvcnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEaXNhYmxlZE9uQ2F0ZWdvcmllcyB8PSBjYXRlZ29yeTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVtb3ZlcyB0aGUgY2F0ZWdvcnkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjYXRlZ29yeVwiPlRoZSBjYXRlZ29yeS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZURpc2FibGVkQ2F0ZWdvcnkoQ2F0ZWdvcnkgY2F0ZWdvcnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEaXNhYmxlZE9uQ2F0ZWdvcmllcyAmPSB+Y2F0ZWdvcnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciB0aGlzIGJvZHkgaWdub3JlcyB0aGUgdGhlIHNwZWNpZmllZCBjb250cm9sbGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2F0ZWdvcnlcIj5UaGUgY2F0ZWdvcnkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgdGhlIG9iamVjdCBoYXMgdGhlIHNwZWNpZmllZCBjYXRlZ29yeTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0luRGlzYWJsZWRDYXRlZ29yeShDYXRlZ29yeSBjYXRlZ29yeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoRGlzYWJsZWRPbkNhdGVnb3JpZXMgJiBjYXRlZ29yeSkgPT0gY2F0ZWdvcnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgdGhlIGNhdGVnb3J5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2F0ZWdvcnlcIj5UaGUgY2F0ZWdvcnkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRFbmFibGVkQ2F0ZWdvcnkoQ2F0ZWdvcnkgY2F0ZWdvcnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFbmFibGVkT25DYXRlZ29yaWVzIHw9IGNhdGVnb3J5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZW1vdmVzIHRoZSBjYXRlZ29yeS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhdGVnb3J5XCI+VGhlIGNhdGVnb3J5LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlRW5hYmxlZENhdGVnb3J5KENhdGVnb3J5IGNhdGVnb3J5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRW5hYmxlZE9uQ2F0ZWdvcmllcyAmPSB+Y2F0ZWdvcnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciB0aGlzIGJvZHkgaWdub3JlcyB0aGUgdGhlIHNwZWNpZmllZCBjb250cm9sbGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2F0ZWdvcnlcIj5UaGUgY2F0ZWdvcnkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgdGhlIG9iamVjdCBoYXMgdGhlIHNwZWNpZmllZCBjYXRlZ29yeTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0luRW5hYmxlZENhdGVnb3J5KENhdGVnb3J5IGNhdGVnb3J5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChFbmFibGVkT25DYXRlZ29yaWVzICYgY2F0ZWdvcnkpID09IGNhdGVnb3J5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBbRmxhZ3NdXHJcbiAgICBwdWJsaWMgZW51bSBXb3JsZEZsYWdzXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGbGFnIHRoYXQgaW5kaWNhdGVzIGEgbmV3IGZpeHR1cmUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHdvcmxkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgTmV3Rml4dHVyZSA9ICgxIDw8IDApLFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZsYWcgdGhhdCBjbGVhciB0aGUgZm9yY2VzIGFmdGVyIGVhY2ggdGltZSBzdGVwLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgQ2xlYXJGb3JjZXMgPSAoMSA8PCAyKSxcclxuXHJcbiAgICAgICAgU3ViU3RlcHBpbmcgPSAoMSA8PCA0KSxcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhlIHdvcmxkIGNsYXNzIG1hbmFnZXMgYWxsIHBoeXNpY3MgZW50aXRpZXMsIGR5bmFtaWMgc2ltdWxhdGlvbixcclxuICAgIC8vLyBhbmQgYXN5bmNocm9ub3VzIHF1ZXJpZXMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFdvcmxkXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuZXZlciBhIGJvZHkgaGFzIGJlZW4gYWRkZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBCb2R5RGVsZWdhdGUgQm9keUFkZGVkO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIHdoZW5ldmVyIGEgYm9keSBoYXMgYmVlbiByZW1vdmVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQm9keURlbGVnYXRlIEJvZHlSZW1vdmVkO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBRdWV1ZTxDb250YWN0PiBDb250YWN0UG9vbCA9IG5ldyBRdWV1ZTxDb250YWN0PigyNTYpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIHdoZW5ldmVyIGEgZml4dHVyZSBoYXMgYmVlbiBhZGRlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEZpeHR1cmVEZWxlZ2F0ZSBGaXh0dXJlQWRkZWQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbmV2ZXIgYSBmaXh0dXJlIGhhcyBiZWVuIHJlbW92ZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlRGVsZWdhdGUgRml4dHVyZVJlbW92ZWQ7XHJcblxyXG4gICAgICAgIGludGVybmFsIFdvcmxkRmxhZ3MgRmxhZ3M7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbmV2ZXIgYSBqb2ludCBoYXMgYmVlbiBhZGRlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEpvaW50RGVsZWdhdGUgSm9pbnRBZGRlZDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuZXZlciBhIGpvaW50IGhhcyBiZWVuIHJlbW92ZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBKb2ludERlbGVnYXRlIEpvaW50UmVtb3ZlZDtcclxuXHJcbiAgICAgICAgcHVibGljIENvbnRyb2xsZXJEZWxlZ2F0ZSBDb250cm9sbGVyQWRkZWQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBDb250cm9sbGVyRGVsZWdhdGUgQ29udHJvbGxlclJlbW92ZWQ7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ludkR0MDtcclxuICAgICAgICBwdWJsaWMgSXNsYW5kIElzbGFuZCA9IG5ldyBJc2xhbmQoKTtcclxuICAgICAgICBwcml2YXRlIEJvZHlbXSBfc3RhY2sgPSBuZXcgQm9keVs2NF07XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9zdGVwQ29tcGxldGU7XHJcbiAgICAgICAgcHJpdmF0ZSBIYXNoU2V0PEJvZHk+IF9ib2R5QWRkTGlzdCA9IG5ldyBIYXNoU2V0PEJvZHk+KCk7XHJcbiAgICAgICAgcHJpdmF0ZSBIYXNoU2V0PEJvZHk+IF9ib2R5UmVtb3ZlTGlzdCA9IG5ldyBIYXNoU2V0PEJvZHk+KCk7XHJcbiAgICAgICAgcHJpdmF0ZSBIYXNoU2V0PEpvaW50PiBfam9pbnRBZGRMaXN0ID0gbmV3IEhhc2hTZXQ8Sm9pbnQ+KCk7XHJcbiAgICAgICAgcHJpdmF0ZSBIYXNoU2V0PEpvaW50PiBfam9pbnRSZW1vdmVMaXN0ID0gbmV3IEhhc2hTZXQ8Sm9pbnQ+KCk7XHJcbiAgICAgICAgcHJpdmF0ZSBUT0lJbnB1dCBfaW5wdXQgPSBuZXcgVE9JSW5wdXQoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJZiBmYWxzZSwgdGhlIHdob2xlIHNpbXVsYXRpb24gc3RvcHMuIEl0IHN0aWxsIHByb2Nlc3NlcyBhZGRlZCBhbmQgcmVtb3ZlZCBnZW9tZXRyaWVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgRW5hYmxlZCA9IHRydWU7XHJcblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSA8c2VlIGNyZWY9XCJXb3JsZFwiLz4gY2xhc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIFdvcmxkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZsYWdzID0gV29ybGRGbGFncy5DbGVhckZvcmNlcztcclxuXHJcbiAgICAgICAgICAgIENvbnRyb2xsZXJMaXN0ID0gbmV3IExpc3Q8Q29udHJvbGxlcj4oKTtcclxuICAgICAgICAgICAgQnJlYWthYmxlQm9keUxpc3QgPSBuZXcgTGlzdDxCcmVha2FibGVCb2R5PigpO1xyXG4gICAgICAgICAgICBCb2R5TGlzdCA9IG5ldyBMaXN0PEJvZHk+KDMyKTtcclxuICAgICAgICAgICAgSm9pbnRMaXN0ID0gbmV3IExpc3Q8Sm9pbnQ+KDMyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBXb3JsZChWZWN0b3IyIGdyYXZpdHksIEFBQkIgc3BhbilcclxuICAgICAgICAgICAgOiB0aGlzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEdyYXZpdHkgPSBncmF2aXR5O1xyXG4gICAgICAgICAgICBDb250YWN0TWFuYWdlciA9IG5ldyBDb250YWN0TWFuYWdlcihuZXcgUXVhZFRyZWVCcm9hZFBoYXNlKHNwYW4pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIDxzZWUgY3JlZj1cIldvcmxkXCIvPiBjbGFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImdyYXZpdHlcIj5UaGUgZ3Jhdml0eS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBXb3JsZChWZWN0b3IyIGdyYXZpdHkpXHJcbiAgICAgICAgICAgIDogdGhpcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDb250YWN0TWFuYWdlciA9IG5ldyBDb250YWN0TWFuYWdlcihuZXcgRHluYW1pY1RyZWVCcm9hZFBoYXNlKCkpO1xyXG4gICAgICAgICAgICBHcmF2aXR5ID0gZ3Jhdml0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBMaXN0PENvbnRyb2xsZXI+IENvbnRyb2xsZXJMaXN0IHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTGlzdDxCcmVha2FibGVCb2R5PiBCcmVha2FibGVCb2R5TGlzdCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IFVwZGF0ZVRpbWUgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBDb250aW51b3VzUGh5c2ljc1RpbWUgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBDb250cm9sbGVyc1VwZGF0ZVRpbWUgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBBZGRSZW1vdmVUaW1lIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQ29udGFjdHNVcGRhdGVUaW1lIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgU29sdmVVcGRhdGVUaW1lIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgbnVtYmVyIG9mIGJyb2FkLXBoYXNlIHByb3hpZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBwcm94eSBjb3VudC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgUHJveHlDb3VudFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIENvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2UuUHJveHlDb3VudDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDaGFuZ2UgdGhlIGdsb2JhbCBncmF2aXR5IHZlY3Rvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGdyYXZpdHkuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHcmF2aXR5O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCBmbGFnIHRvIGNvbnRyb2wgYXV0b21hdGljIGNsZWFyaW5nIG9mIGZvcmNlcyBhZnRlciBlYWNoIHRpbWUgc3RlcC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgaXQgc2hvdWxkIGF1dG8gY2xlYXIgZm9yY2VzOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIEF1dG9DbGVhckZvcmNlc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyB8PSBXb3JsZEZsYWdzLkNsZWFyRm9yY2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzICY9IH5Xb3JsZEZsYWdzLkNsZWFyRm9yY2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoRmxhZ3MgJiBXb3JsZEZsYWdzLkNsZWFyRm9yY2VzKSA9PSBXb3JsZEZsYWdzLkNsZWFyRm9yY2VzOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY29udGFjdCBtYW5hZ2VyIGZvciB0ZXN0aW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgY29udGFjdCBtYW5hZ2VyLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIENvbnRhY3RNYW5hZ2VyIENvbnRhY3RNYW5hZ2VyIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgYm9keSBsaXN0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGVoZWFkIG9mIHRoZSB3b3JsZCBib2R5IGxpc3QuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgTGlzdDxCb2R5PiBCb2R5TGlzdCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHdvcmxkIGpvaW50IGxpc3QuIFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgam9pbnQgbGlzdC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBMaXN0PEpvaW50PiBKb2ludExpc3QgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCBjb250YWN0IGxpc3QuIFdpdGggdGhlIHJldHVybmVkIGNvbnRhY3QsIHVzZSBDb250YWN0LkdldE5leHQgdG8gZ2V0XHJcbiAgICAgICAgLy8vIHRoZSBuZXh0IGNvbnRhY3QgaW4gdGhlIHdvcmxkIGxpc3QuIEEgbnVsbCBjb250YWN0IGluZGljYXRlcyB0aGUgZW5kIG9mIHRoZSBsaXN0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgaGVhZCBvZiB0aGUgd29ybGQgY29udGFjdCBsaXN0LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIExpc3Q8Q29udGFjdD4gQ29udGFjdExpc3RcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBDb250YWN0TWFuYWdlci5Db250YWN0TGlzdDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFbmFibGUvZGlzYWJsZSBzaW5nbGUgc3RlcHBlZCBjb250aW51b3VzIHBoeXNpY3MuIEZvciB0ZXN0aW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgRW5hYmxlU3ViU3RlcHBpbmdcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgfD0gV29ybGRGbGFncy5TdWJTdGVwcGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyAmPSB+V29ybGRGbGFncy5TdWJTdGVwcGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKEZsYWdzICYgV29ybGRGbGFncy5TdWJTdGVwcGluZykgPT0gV29ybGRGbGFncy5TdWJTdGVwcGluZzsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGQgYSByaWdpZCBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIEFkZEJvZHkoQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFfYm9keUFkZExpc3QuQ29udGFpbnMoYm9keSksIFwiWW91IGFyZSBhZGRpbmcgdGhlIHNhbWUgYm9keSBtb3JlIHRoYW4gb25jZS5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIV9ib2R5QWRkTGlzdC5Db250YWlucyhib2R5KSlcclxuICAgICAgICAgICAgICAgIF9ib2R5QWRkTGlzdC5BZGQoYm9keSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlc3Ryb3kgYSByaWdpZCBib2R5LlxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBUaGlzIGF1dG9tYXRpY2FsbHkgZGVsZXRlcyBhbGwgYXNzb2NpYXRlZCBzaGFwZXMgYW5kIGpvaW50cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlcIj5UaGUgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZUJvZHkoQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFfYm9keVJlbW92ZUxpc3QuQ29udGFpbnMoYm9keSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIlRoZSBib2R5IGlzIGFscmVhZHkgbWFya2VkIGZvciByZW1vdmFsLiBZb3UgYXJlIHJlbW92aW5nIHRoZSBib2R5IG1vcmUgdGhhbiBvbmNlLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghX2JvZHlSZW1vdmVMaXN0LkNvbnRhaW5zKGJvZHkpKVxyXG4gICAgICAgICAgICAgICAgX2JvZHlSZW1vdmVMaXN0LkFkZChib2R5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgam9pbnQgdG8gY29uc3RyYWluIGJvZGllcyB0b2dldGhlci4gVGhpcyBtYXkgY2F1c2UgdGhlIGNvbm5lY3RlZCBib2RpZXMgdG8gY2Vhc2UgY29sbGlkaW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiam9pbnRcIj5UaGUgam9pbnQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRKb2ludChKb2ludCBqb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCghX2pvaW50QWRkTGlzdC5Db250YWlucyhqb2ludCksIFwiWW91IGFyZSBhZGRpbmcgdGhlIHNhbWUgam9pbnQgbW9yZSB0aGFuIG9uY2UuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFfam9pbnRBZGRMaXN0LkNvbnRhaW5zKGpvaW50KSlcclxuICAgICAgICAgICAgICAgIF9qb2ludEFkZExpc3QuQWRkKGpvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBSZW1vdmVKb2ludChKb2ludCBqb2ludCwgYm9vbCBkb0NoZWNrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRvQ2hlY2spXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCghX2pvaW50UmVtb3ZlTGlzdC5Db250YWlucyhqb2ludCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgam9pbnQgaXMgYWxyZWFkeSBtYXJrZWQgZm9yIHJlbW92YWwuIFlvdSBhcmUgcmVtb3ZpbmcgdGhlIGpvaW50IG1vcmUgdGhhbiBvbmNlLlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFfam9pbnRSZW1vdmVMaXN0LkNvbnRhaW5zKGpvaW50KSlcclxuICAgICAgICAgICAgICAgIF9qb2ludFJlbW92ZUxpc3QuQWRkKGpvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVzdHJveSBhIGpvaW50LiBUaGlzIG1heSBjYXVzZSB0aGUgY29ubmVjdGVkIGJvZGllcyB0byBiZWdpbiBjb2xsaWRpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJqb2ludFwiPlRoZSBqb2ludC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZUpvaW50KEpvaW50IGpvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUmVtb3ZlSm9pbnQoam9pbnQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBbGwgYWRkcyBhbmQgcmVtb3ZlcyBhcmUgY2FjaGVkIGJ5IHRoZSBXb3JsZCBkdWluZyBhIFdvcmxkIHN0ZXAuXHJcbiAgICAgICAgLy8vIFRvIHByb2Nlc3MgdGhlIGNoYW5nZXMgYmVmb3JlIHRoZSB3b3JsZCB1cGRhdGVzIGFnYWluLCBjYWxsIHRoaXMgbWV0aG9kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUHJvY2Vzc0NoYW5nZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUHJvY2Vzc0FkZGVkQm9kaWVzKCk7XHJcbiAgICAgICAgICAgIFByb2Nlc3NBZGRlZEpvaW50cygpO1xyXG5cclxuICAgICAgICAgICAgUHJvY2Vzc1JlbW92ZWRCb2RpZXMoKTtcclxuICAgICAgICAgICAgUHJvY2Vzc1JlbW92ZWRKb2ludHMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBQcm9jZXNzUmVtb3ZlZEpvaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2pvaW50UmVtb3ZlTGlzdC5Db3VudCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKEpvaW50IGpvaW50IGluIF9qb2ludFJlbW92ZUxpc3QpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBjb2xsaWRlQ29ubmVjdGVkID0gam9pbnQuQ29sbGlkZUNvbm5lY3RlZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIHdvcmxkIGxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgSm9pbnRMaXN0LlJlbW92ZShqb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgZnJvbSBpc2xhbmQgZ3JhcGguXHJcbiAgICAgICAgICAgICAgICAgICAgQm9keSBib2R5QSA9IGpvaW50LkJvZHlBO1xyXG4gICAgICAgICAgICAgICAgICAgIEJvZHkgYm9keUIgPSBqb2ludC5Cb2R5QjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FrZSB1cCBjb25uZWN0ZWQgYm9kaWVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLkF3YWtlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV0lQIERhdmlkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2ludC5Jc0ZpeGVkVHlwZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYm9keSAxLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2ludC5FZGdlQS5QcmV2ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2ludC5FZGdlQS5QcmV2Lk5leHQgPSBqb2ludC5FZGdlQS5OZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW50LkVkZ2VBLk5leHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VBLk5leHQuUHJldiA9IGpvaW50LkVkZ2VBLlByZXY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoam9pbnQuRWRnZUEgPT0gYm9keUEuSm9pbnRMaXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEuSm9pbnRMaXN0ID0gam9pbnQuRWRnZUEuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VBLlByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VBLk5leHQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXSVAgRGF2aWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpvaW50LklzRml4ZWRUeXBlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBib2R5IDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW50LkVkZ2VCLlByZXYgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUIuUHJldi5OZXh0ID0gam9pbnQuRWRnZUIuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW50LkVkZ2VCLk5leHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUIuTmV4dC5QcmV2ID0gam9pbnQuRWRnZUIuUHJldjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW50LkVkZ2VCID09IGJvZHlCLkpvaW50TGlzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuSm9pbnRMaXN0ID0gam9pbnQuRWRnZUIuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUIuUHJldiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VCLk5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV0lQIERhdmlkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2ludC5Jc0ZpeGVkVHlwZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGpvaW50IHByZXZlbnRzIGNvbGxpc2lvbnMsIHRoZW4gZmxhZyBhbnkgY29udGFjdHMgZm9yIGZpbHRlcmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RFZGdlIGVkZ2UgPSBib2R5Qi5Db250YWN0TGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChlZGdlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVkZ2UuT3RoZXIgPT0gYm9keUEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIHRoZSBjb250YWN0IGZvciBmaWx0ZXJpbmcgYXQgdGhlIG5leHQgdGltZSBzdGVwICh3aGVyZSBlaXRoZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9keSBpcyBhd2FrZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2UuQ29udGFjdC5GbGFnRm9yRmlsdGVyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlID0gZWRnZS5OZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoSm9pbnRSZW1vdmVkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBKb2ludFJlbW92ZWQoam9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBfam9pbnRSZW1vdmVMaXN0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBQcm9jZXNzQWRkZWRKb2ludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9qb2ludEFkZExpc3QuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChKb2ludCBqb2ludCBpbiBfam9pbnRBZGRMaXN0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIHdvcmxkIGxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgSm9pbnRMaXN0LkFkZChqb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIGJvZGllcycgZG91Ymx5IGxpbmtlZCBsaXN0cy5cclxuICAgICAgICAgICAgICAgICAgICBqb2ludC5FZGdlQS5Kb2ludCA9IGpvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VBLk90aGVyID0gam9pbnQuQm9keUI7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUEuUHJldiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUEuTmV4dCA9IGpvaW50LkJvZHlBLkpvaW50TGlzdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW50LkJvZHlBLkpvaW50TGlzdCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2ludC5Cb2R5QS5Kb2ludExpc3QuUHJldiA9IGpvaW50LkVkZ2VBO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBqb2ludC5Cb2R5QS5Kb2ludExpc3QgPSBqb2ludC5FZGdlQTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV0lQIERhdmlkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2ludC5Jc0ZpeGVkVHlwZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUIuSm9pbnQgPSBqb2ludDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUIuT3RoZXIgPSBqb2ludC5Cb2R5QTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUIuUHJldiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VCLk5leHQgPSBqb2ludC5Cb2R5Qi5Kb2ludExpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoam9pbnQuQm9keUIuSm9pbnRMaXN0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2ludC5Cb2R5Qi5Kb2ludExpc3QuUHJldiA9IGpvaW50LkVkZ2VCO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuQm9keUIuSm9pbnRMaXN0ID0gam9pbnQuRWRnZUI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5IGJvZHlBID0gam9pbnQuQm9keUE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEJvZHkgYm9keUIgPSBqb2ludC5Cb2R5QjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBqb2ludCBwcmV2ZW50cyBjb2xsaXNpb25zLCB0aGVuIGZsYWcgYW55IGNvbnRhY3RzIGZvciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2ludC5Db2xsaWRlQ29ubmVjdGVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0RWRnZSBlZGdlID0gYm9keUIuQ29udGFjdExpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWRnZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGdlLk90aGVyID09IGJvZHlBKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyB0aGUgY29udGFjdCBmb3IgZmlsdGVyaW5nIGF0IHRoZSBuZXh0IHRpbWUgc3RlcCAod2hlcmUgZWl0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHkgaXMgYXdha2UpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlLkNvbnRhY3QuRmxhZ0ZvckZpbHRlcmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEpvaW50QWRkZWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgSm9pbnRBZGRlZChqb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGNyZWF0aW5nIGEgam9pbnQgZG9lc24ndCB3YWtlIHRoZSBib2RpZXMuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgX2pvaW50QWRkTGlzdC5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUHJvY2Vzc0FkZGVkQm9kaWVzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfYm9keUFkZExpc3QuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChCb2R5IGJvZHkgaW4gX2JvZHlBZGRMaXN0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byB3b3JsZCBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlMaXN0LkFkZChib2R5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJvZHlBZGRlZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5QWRkZWQoYm9keSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgX2JvZHlBZGRMaXN0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBQcm9jZXNzUmVtb3ZlZEJvZGllcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2JvZHlSZW1vdmVMaXN0LkNvdW50ID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoQm9keSBib2R5IGluIF9ib2R5UmVtb3ZlTGlzdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoQm9keUxpc3QuQ291bnQgPiAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWW91IHRyaWVkIHRvIHJlbW92ZSBhIGJvZHkgdGhhdCBpcyBub3QgY29udGFpbmVkIGluIHRoZSBCb2R5TGlzdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcmUgeW91IHJlbW92aW5nIHRoZSBib2R5IG1vcmUgdGhhbiBvbmNlP1xyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChCb2R5TGlzdC5Db250YWlucyhib2R5KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgYXR0YWNoZWQgam9pbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgIEpvaW50RWRnZSBqZSA9IGJvZHkuSm9pbnRMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgSm9pbnRFZGdlIGplMCA9IGplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqZSA9IGplLk5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSZW1vdmVKb2ludChqZTAuSm9pbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5Kb2ludExpc3QgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgdGhlIGF0dGFjaGVkIGNvbnRhY3RzLlxyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RFZGdlIGNlID0gYm9keS5Db250YWN0TGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2UgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RFZGdlIGNlMCA9IGNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZSA9IGNlLk5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RNYW5hZ2VyLkRlc3Ryb3koY2UwLkNvbnRhY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBib2R5LkNvbnRhY3RMaXN0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBhdHRhY2hlZCBmaXh0dXJlcy4gVGhpcyBkZXN0cm95cyBicm9hZC1waGFzZSBwcm94aWVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYm9keS5GaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5GaXh0dXJlTGlzdFtpXS5EZXN0cm95UHJveGllcyhDb250YWN0TWFuYWdlci5Ccm9hZFBoYXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5GaXh0dXJlTGlzdFtpXS5EZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBib2R5LkZpeHR1cmVMaXN0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHdvcmxkIGJvZHkgbGlzdC5cclxuICAgICAgICAgICAgICAgICAgICBCb2R5TGlzdC5SZW1vdmUoYm9keSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCb2R5UmVtb3ZlZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5UmVtb3ZlZChib2R5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBfYm9keVJlbW92ZUxpc3QuQ2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUYWtlIGEgdGltZSBzdGVwLiBUaGlzIHBlcmZvcm1zIGNvbGxpc2lvbiBkZXRlY3Rpb24sIGludGVncmF0aW9uLFxyXG4gICAgICAgIC8vLyBhbmQgY29uc3JhaW50IHNvbHV0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZHRcIj5UaGUgYW1vdW50IG9mIHRpbWUgdG8gc2ltdWxhdGUsIHRoaXMgc2hvdWxkIG5vdCB2YXJ5LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU3RlcChmbG9hdCBkdClcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICBQcm9jZXNzQ2hhbmdlcygpO1xyXG5cclxuICAgICAgICAgICAgLy9JZiB0aGVyZSBpcyBubyBjaGFuZ2UgaW4gdGltZSwgbm8gbmVlZCB0byBjYWxjdWxhdGUgYW55dGhpbmcuXHJcbiAgICAgICAgICAgIGlmIChkdCA9PSAwIHx8ICFFbmFibGVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5ldyBmaXh0dXJlcyB3ZXJlIGFkZGVkLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIG5ldyBjb250YWN0cy5cclxuICAgICAgICAgICAgaWYgKChGbGFncyAmIFdvcmxkRmxhZ3MuTmV3Rml4dHVyZSkgPT0gV29ybGRGbGFncy5OZXdGaXh0dXJlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0TWFuYWdlci5GaW5kTmV3Q29udGFjdHMoKTtcclxuICAgICAgICAgICAgICAgIEZsYWdzICY9IH5Xb3JsZEZsYWdzLk5ld0ZpeHR1cmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFRpbWVTdGVwIHN0ZXA7XHJcbiAgICAgICAgICAgIHN0ZXAuaW52X2R0ID0gMS4wZiAvIGR0O1xyXG4gICAgICAgICAgICBzdGVwLmR0ID0gZHQ7XHJcbiAgICAgICAgICAgIHN0ZXAuZHRSYXRpbyA9IF9pbnZEdDAgKiBkdDtcclxuXHJcbiAgICAgICAgICAgIC8vVXBkYXRlIGNvbnRyb2xsZXJzXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ29udHJvbGxlckxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udHJvbGxlckxpc3RbaV0uVXBkYXRlKGR0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250YWN0cy4gVGhpcyBpcyB3aGVyZSBzb21lIGNvbnRhY3RzIGFyZSBkZXN0cm95ZWQuXHJcbiAgICAgICAgICAgIENvbnRhY3RNYW5hZ2VyLkNvbGxpZGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEludGVncmF0ZSB2ZWxvY2l0aWVzLCBzb2x2ZSB2ZWxvY2l0eSByYWludHMsIGFuZCBpbnRlZ3JhdGUgcG9zaXRpb25zLlxyXG4gICAgICAgICAgICBTb2x2ZShyZWYgc3RlcCk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIFRPSSBldmVudHMuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5Db250aW51b3VzUGh5c2ljcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU29sdmVUT0kocmVmIHN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfaW52RHQwID0gc3RlcC5pbnZfZHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoKEZsYWdzICYgV29ybGRGbGFncy5DbGVhckZvcmNlcykgIT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ2xlYXJGb3JjZXMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBCcmVha2FibGVCb2R5TGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCcmVha2FibGVCb2R5TGlzdFtpXS5VcGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxsIHRoaXMgYWZ0ZXIgeW91IGFyZSBkb25lIHdpdGggdGltZSBzdGVwcyB0byBjbGVhciB0aGUgZm9yY2VzLiBZb3Ugbm9ybWFsbHlcclxuICAgICAgICAvLy8gY2FsbCB0aGlzIGFmdGVyIGVhY2ggY2FsbCB0byBTdGVwLCB1bmxlc3MgeW91IGFyZSBwZXJmb3JtaW5nIHN1Yi1zdGVwcy4gQnkgZGVmYXVsdCxcclxuICAgICAgICAvLy8gZm9yY2VzIHdpbGwgYmUgYXV0b21hdGljYWxseSBjbGVhcmVkLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhckZvcmNlcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEJvZHlMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keSA9IEJvZHlMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgYm9keS5Gb3JjZSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIGJvZHkuVG9ycXVlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBRdWVyeSB0aGUgd29ybGQgZm9yIGFsbCBmaXh0dXJlcyB0aGF0IHBvdGVudGlhbGx5IG92ZXJsYXAgdGhlXHJcbiAgICAgICAgLy8vIHByb3ZpZGVkIEFBQkIuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBJbnNpZGUgdGhlIGNhbGxiYWNrOlxyXG4gICAgICAgIC8vLyBSZXR1cm4gdHJ1ZTogQ29udGludWVzIHRoZSBxdWVyeVxyXG4gICAgICAgIC8vLyBSZXR1cm4gZmFsc2U6IFRlcm1pbmF0ZSB0aGUgcXVlcnlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhbGxiYWNrXCI+QSB1c2VyIGltcGxlbWVudGVkIGNhbGxiYWNrIGNsYXNzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiIHF1ZXJ5IGJveC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFF1ZXJ5QUFCQihGdW5jPEZpeHR1cmUsIGJvb2w+IGNhbGxiYWNrLCByZWYgQUFCQiBhYWJiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZS5RdWVyeSgoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxpbnQsIGJvb2w+KShwcm94eUlkID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpeHR1cmVQcm94eSBwcm94eSA9IENvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2UuR2V0UHJveHkocHJveHlJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socHJveHkuRml4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCByZWYgYWFiYik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJheS1jYXN0IHRoZSB3b3JsZCBmb3IgYWxsIGZpeHR1cmVzIGluIHRoZSBwYXRoIG9mIHRoZSByYXkuIFlvdXIgY2FsbGJhY2tcclxuICAgICAgICAvLy8gY29udHJvbHMgd2hldGhlciB5b3UgZ2V0IHRoZSBjbG9zZXN0IHBvaW50LCBhbnkgcG9pbnQsIG9yIG4tcG9pbnRzLlxyXG4gICAgICAgIC8vLyBUaGUgcmF5LWNhc3QgaWdub3JlcyBzaGFwZXMgdGhhdCBjb250YWluIHRoZSBzdGFydGluZyBwb2ludC5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIEluc2lkZSB0aGUgY2FsbGJhY2s6XHJcbiAgICAgICAgLy8vIHJldHVybiAtMTogaWdub3JlIHRoaXMgZml4dHVyZSBhbmQgY29udGludWVcclxuICAgICAgICAvLy8gcmV0dXJuIDA6IHRlcm1pbmF0ZSB0aGUgcmF5IGNhc3RcclxuICAgICAgICAvLy8gcmV0dXJuIGZyYWN0aW9uOiBjbGlwIHRoZSByYXkgdG8gdGhpcyBwb2ludFxyXG4gICAgICAgIC8vLyByZXR1cm4gMTogZG9uJ3QgY2xpcCB0aGUgcmF5IGFuZCBjb250aW51ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2FsbGJhY2tcIj5BIHVzZXIgaW1wbGVtZW50ZWQgY2FsbGJhY2sgY2xhc3MuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDFcIj5UaGUgcmF5IHN0YXJ0aW5nIHBvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQyXCI+VGhlIHJheSBlbmRpbmcgcG9pbnQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSYXlDYXN0KFJheUNhc3RDYWxsYmFjayBjYWxsYmFjaywgVmVjdG9yMiBwb2ludDEsIFZlY3RvcjIgcG9pbnQyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUmF5Q2FzdElucHV0IGlucHV0ID0gbmV3IFJheUNhc3RJbnB1dCgpO1xyXG4gICAgICAgICAgICBpbnB1dC5NYXhGcmFjdGlvbiA9IDEuMGY7XHJcbiAgICAgICAgICAgIGlucHV0LlBvaW50MSA9IHBvaW50MTtcclxuICAgICAgICAgICAgaW5wdXQuUG9pbnQyID0gcG9pbnQyO1xyXG5cclxuICAgICAgICAgICAgQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZS5SYXlDYXN0KChnbG9iYWw6OlN5c3RlbS5GdW5jPGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlJheUNhc3RJbnB1dCwgaW50LCBmbG9hdD4pKChyYXlDYXN0SW5wdXQsIHByb3h5SWQpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXh0dXJlUHJveHkgcHJveHkgPSBDb250YWN0TWFuYWdlci5Ccm9hZFBoYXNlLkdldFByb3h5KHByb3h5SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmUgPSBwcm94eS5GaXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSBwcm94eS5DaGlsZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSYXlDYXN0T3V0cHV0IG91dHB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBoaXQgPSBmaXh0dXJlLlJheUNhc3Qob3V0IG91dHB1dCwgcmVmIHJheUNhc3RJbnB1dCwgaW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZnJhY3Rpb24gPSBvdXRwdXQuRnJhY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50ID0gKDEuMGYgLSBmcmFjdGlvbikgKiBpbnB1dC5Qb2ludDEgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uICogaW5wdXQuUG9pbnQyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZpeHR1cmUsIHBvaW50LCBvdXRwdXQuTm9ybWFsLCBmcmFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC5NYXhGcmFjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgcmVmIGlucHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBTb2x2ZShyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFNpemUgdGhlIGlzbGFuZCBmb3IgdGhlIHdvcnN0IGNhc2UuXHJcbiAgICAgICAgICAgIElzbGFuZC5SZXNldChCb2R5TGlzdC5Db3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RNYW5hZ2VyLkNvbnRhY3RMaXN0LkNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgSm9pbnRMaXN0LkNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdE1hbmFnZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIHRoZSBpc2xhbmQgZmxhZ3MuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEJvZHkgYiBpbiBCb2R5TGlzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYi5GbGFncyAmPSB+Qm9keUZsYWdzLklzbGFuZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb250YWN0TWFuYWdlci5Db250YWN0TGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0IGMgPSBDb250YWN0TWFuYWdlci5Db250YWN0TGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGMuRmxhZ3MgJj0gfkNvbnRhY3RGbGFncy5Jc2xhbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yZWFjaCAoSm9pbnQgaiBpbiBKb2ludExpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGouSXNsYW5kRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCBhbmQgc2ltdWxhdGUgYWxsIGF3YWtlIGlzbGFuZHMuXHJcbiAgICAgICAgICAgIGludCBzdGFja1NpemUgPSBCb2R5TGlzdC5Db3VudDtcclxuICAgICAgICAgICAgaWYgKHN0YWNrU2l6ZSA+IF9zdGFjay5MZW5ndGgpXHJcbiAgICAgICAgICAgICAgICBfc3RhY2sgPSBuZXcgQm9keVtNYXRoLk1heChfc3RhY2suTGVuZ3RoICogMiwgc3RhY2tTaXplKV07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IEJvZHlMaXN0LkNvdW50IC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keSBzZWVkID0gQm9keUxpc3RbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKChzZWVkLkZsYWdzICYgKEJvZHlGbGFncy5Jc2xhbmQpKSAhPSBCb2R5RmxhZ3MuTm9uZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VlZC5Bd2FrZSA9PSBmYWxzZSB8fCBzZWVkLkVuYWJsZWQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNlZWQgY2FuIGJlIGR5bmFtaWMgb3Iga2luZW1hdGljLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNlZWQuQm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGlzbGFuZCBhbmQgc3RhY2suXHJcbiAgICAgICAgICAgICAgICBJc2xhbmQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIGludCBzdGFja0NvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIF9zdGFja1tzdGFja0NvdW50KytdID0gc2VlZDtcclxuICAgICAgICAgICAgICAgIHNlZWQuRmxhZ3MgfD0gQm9keUZsYWdzLklzbGFuZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGEgZGVwdGggZmlyc3Qgc2VhcmNoIChERlMpIG9uIHRoZSBjb25zdHJhaW50IGdyYXBoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrQ291bnQgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdyYWIgdGhlIG5leHQgYm9keSBvZmYgdGhlIHN0YWNrIGFuZCBhZGQgaXQgdG8gdGhlIGlzbGFuZC5cclxuICAgICAgICAgICAgICAgICAgICBCb2R5IGIgPSBfc3RhY2tbLS1zdGFja0NvdW50XTtcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoYi5FbmFibGVkKTtcclxuICAgICAgICAgICAgICAgICAgICBJc2xhbmQuQWRkKGIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGJvZHkgaXMgYXdha2UuXHJcbiAgICAgICAgICAgICAgICAgICAgYi5Bd2FrZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGtlZXAgaXNsYW5kcyBhcyBzbWFsbCBhcyBwb3NzaWJsZSwgd2UgZG9uJ3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgaXNsYW5kcyBhY3Jvc3Mgc3RhdGljIGJvZGllcy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBhbGwgY29udGFjdHMgY29ubmVjdGVkIHRvIHRoaXMgYm9keS5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKENvbnRhY3RFZGdlIGNlID0gYi5Db250YWN0TGlzdDsgY2UgIT0gbnVsbDsgY2UgPSBjZS5OZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdCBjb250YWN0ID0gY2UuQ29udGFjdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcyB0aGlzIGNvbnRhY3QgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIGFuIGlzbGFuZD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb250YWN0LkZsYWdzICYgQ29udGFjdEZsYWdzLklzbGFuZCkgIT0gQ29udGFjdEZsYWdzLk5vbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGNvbnRhY3Qgc29saWQgYW5kIHRvdWNoaW5nP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNlLkNvbnRhY3QuRW5hYmxlZCB8fCAhY2UuQ29udGFjdC5Jc1RvdWNoaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHNlbnNvcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgc2Vuc29yQSA9IGNvbnRhY3QuRml4dHVyZUEuSXNTZW5zb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgc2Vuc29yQiA9IGNvbnRhY3QuRml4dHVyZUIuSXNTZW5zb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZW5zb3JBIHx8IHNlbnNvckIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBJc2xhbmQuQWRkKGNvbnRhY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0LkZsYWdzIHw9IENvbnRhY3RGbGFncy5Jc2xhbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5IG90aGVyID0gY2UuT3RoZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYXMgdGhlIG90aGVyIGJvZHkgYWxyZWFkeSBhZGRlZCB0byB0aGlzIGlzbGFuZD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvdGhlci5GbGFncyAmIEJvZHlGbGFncy5Jc2xhbmQpICE9IEJvZHlGbGFncy5Ob25lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHN0YWNrQ291bnQgPCBzdGFja1NpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhY2tbc3RhY2tDb3VudCsrXSA9IG90aGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5GbGFncyB8PSBCb2R5RmxhZ3MuSXNsYW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGFsbCBqb2ludHMgY29ubmVjdCB0byB0aGlzIGJvZHkuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChKb2ludEVkZ2UgamUgPSBiLkpvaW50TGlzdDsgamUgIT0gbnVsbDsgamUgPSBqZS5OZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGplLkpvaW50LklzbGFuZEZsYWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5IG90aGVyID0gamUuT3RoZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXSVAgRGF2aWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9FbnRlciBoZXJlIHdoZW4gaXQncyBhIG5vbi1maXhlZCBqb2ludC4gTm9uLWZpeGVkIGpvaW50cyBoYXZlIGEgb3RoZXIgYm9keS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHNpbXVsYXRlIGpvaW50cyBjb25uZWN0ZWQgdG8gaW5hY3RpdmUgYm9kaWVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLkVuYWJsZWQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSXNsYW5kLkFkZChqZS5Kb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqZS5Kb2ludC5Jc2xhbmRGbGFnID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG90aGVyLkZsYWdzICYgQm9keUZsYWdzLklzbGFuZCkgIT0gQm9keUZsYWdzLk5vbmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHN0YWNrQ291bnQgPCBzdGFja1NpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YWNrW3N0YWNrQ291bnQrK10gPSBvdGhlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLkZsYWdzIHw9IEJvZHlGbGFncy5Jc2xhbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJc2xhbmQuQWRkKGplLkpvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGplLkpvaW50LklzbGFuZEZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIElzbGFuZC5Tb2x2ZShyZWYgc3RlcCwgcmVmIEdyYXZpdHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBvc3Qgc29sdmUgY2xlYW51cC5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgSXNsYW5kLkJvZHlDb3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHN0YXRpYyBib2RpZXMgdG8gcGFydGljaXBhdGUgaW4gb3RoZXIgaXNsYW5kcy5cclxuICAgICAgICAgICAgICAgICAgICBCb2R5IGIgPSBJc2xhbmQuQm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLkJvZHlUeXBlID09IEJvZHlUeXBlLlN0YXRpYylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuRmxhZ3MgJj0gfkJvZHlGbGFncy5Jc2xhbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTeW5jaHJvbml6ZSBmaXh0dXJlcywgY2hlY2sgZm9yIG91dCBvZiByYW5nZSBib2RpZXMuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEJvZHkgYiBpbiBCb2R5TGlzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBib2R5IHdhcyBub3QgaW4gYW4gaXNsYW5kIHRoZW4gaXQgZGlkIG5vdCBtb3ZlLlxyXG4gICAgICAgICAgICAgICAgaWYgKChiLkZsYWdzICYgQm9keUZsYWdzLklzbGFuZCkgIT0gQm9keUZsYWdzLklzbGFuZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYi5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGZpeHR1cmVzIChmb3IgYnJvYWQtcGhhc2UpLlxyXG4gICAgICAgICAgICAgICAgYi5TeW5jaHJvbml6ZUZpeHR1cmVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIG5ldyBjb250YWN0cy5cclxuICAgICAgICAgICAgQ29udGFjdE1hbmFnZXIuRmluZE5ld0NvbnRhY3RzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbmQgVE9JIGNvbnRhY3RzIGFuZCBzb2x2ZSB0aGVtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3RlcFwiPlRoZSBzdGVwLjwvcGFyYW0+XHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFNvbHZlVE9JKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSXNsYW5kLlJlc2V0KDIgKiBTZXR0aW5ncy5NYXhUT0lDb250YWN0cywgU2V0dGluZ3MuTWF4VE9JQ29udGFjdHMsIDAsIENvbnRhY3RNYW5hZ2VyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfc3RlcENvbXBsZXRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEJvZHlMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQm9keUxpc3RbaV0uRmxhZ3MgJj0gfkJvZHlGbGFncy5Jc2xhbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgQm9keUxpc3RbaV0uU3dlZXAuQWxwaGEwID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvbnRhY3RNYW5hZ2VyLkNvbnRhY3RMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdCBjID0gQ29udGFjdE1hbmFnZXIuQ29udGFjdExpc3RbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgVE9JXHJcbiAgICAgICAgICAgICAgICAgICAgYy5GbGFncyAmPSB+KENvbnRhY3RGbGFncy5UT0kgfCBDb250YWN0RmxhZ3MuSXNsYW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBjLlRPSUNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjLlRPSSA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgVE9JIGV2ZW50cyBhbmQgc29sdmUgdGhlbS5cclxuICAgICAgICAgICAgZm9yICg7IDsgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBUT0kuXHJcbiAgICAgICAgICAgICAgICBDb250YWN0IG1pbkNvbnRhY3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWluQWxwaGEgPSAxLjBmO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ29udGFjdE1hbmFnZXIuQ29udGFjdExpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0IGMgPSBDb250YWN0TWFuYWdlci5Db250YWN0TGlzdFtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBjb250YWN0IGRpc2FibGVkP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLkVuYWJsZWQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZXhjZXNzaXZlIHN1Yi1zdGVwcGluZy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5UT0lDb3VudCA+IFNldHRpbmdzLk1heFN1YlN0ZXBzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGMuRmxhZ3MgJiBDb250YWN0RmxhZ3MuVE9JKSA9PSBDb250YWN0RmxhZ3MuVE9JKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjb250YWN0IGhhcyBhIHZhbGlkIGNhY2hlZCBUT0kuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gYy5UT0k7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZkEgPSBjLkZpeHR1cmVBO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGZCID0gYy5GaXh0dXJlQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZXJlIGEgc2Vuc29yP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZkEuSXNTZW5zb3IgfHwgZkIuSXNTZW5zb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5IGJBID0gZkEuQm9keTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBiQiA9IGZCLkJvZHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5VHlwZSB0eXBlQSA9IGJBLkJvZHlUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5VHlwZSB0eXBlQiA9IGJCLkJvZHlUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQodHlwZUEgPT0gQm9keVR5cGUuRHluYW1pYyB8fCB0eXBlQiA9PSBCb2R5VHlwZS5EeW5hbWljKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgYXdha2VBID0gYkEuQXdha2UgJiYgdHlwZUEgIT0gQm9keVR5cGUuU3RhdGljO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sIGF3YWtlQiA9IGJCLkF3YWtlICYmIHR5cGVCICE9IEJvZHlUeXBlLlN0YXRpYztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIGF0IGxlYXN0IG9uZSBib2R5IGF3YWtlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXdha2VBID09IGZhbHNlICYmIGF3YWtlQiA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgY29sbGlkZUEgPSAoYkEuSXNCdWxsZXQgfHwgdHlwZUEgIT0gQm9keVR5cGUuRHluYW1pYykgJiYgIWJBLklnbm9yZUNDRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBjb2xsaWRlQiA9IChiQi5Jc0J1bGxldCB8fCB0eXBlQiAhPSBCb2R5VHlwZS5EeW5hbWljKSAmJiAhYkIuSWdub3JlQ0NEO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJlIHRoZXNlIHR3byBub24tYnVsbGV0IGR5bmFtaWMgYm9kaWVzP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlkZUEgPT0gZmFsc2UgJiYgY29sbGlkZUIgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBUT0kgZm9yIHRoaXMgY29udGFjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHV0IHRoZSBzd2VlcHMgb250byB0aGUgc2FtZSB0aW1lIGludGVydmFsLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBhbHBoYTAgPSBiQS5Td2VlcC5BbHBoYTA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYkEuU3dlZXAuQWxwaGEwIDwgYkIuU3dlZXAuQWxwaGEwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTAgPSBiQi5Td2VlcC5BbHBoYTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQS5Td2VlcC5BZHZhbmNlKGFscGhhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYkIuU3dlZXAuQWxwaGEwIDwgYkEuU3dlZXAuQWxwaGEwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTAgPSBiQS5Td2VlcC5BbHBoYTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQi5Td2VlcC5BZHZhbmNlKGFscGhhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChhbHBoYTAgPCAxLjBmKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHRpbWUgb2YgaW1wYWN0IGluIGludGVydmFsIFswLCBtaW5UT0ldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbnB1dC5Qcm94eUEuU2V0KGZBLlNoYXBlLCBjLkNoaWxkSW5kZXhBKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2lucHV0LlByb3h5Qi5TZXQoZkIuU2hhcGUsIGMuQ2hpbGRJbmRleEIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW5wdXQuU3dlZXBBID0gYkEuU3dlZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbnB1dC5Td2VlcEIgPSBiQi5Td2VlcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2lucHV0LlRNYXggPSAxLjBmO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVE9JT3V0cHV0IG91dHB1dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVGltZU9mSW1wYWN0LkNhbGN1bGF0ZVRpbWVPZkltcGFjdChvdXQgb3V0cHV0LCBfaW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmV0YSBpcyB0aGUgZnJhY3Rpb24gb2YgdGhlIHJlbWFpbmluZyBwb3J0aW9uIG9mIHRoZSAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGJldGEgPSBvdXRwdXQuVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5TdGF0ZSA9PSBUT0lPdXRwdXRTdGF0ZS5Ub3VjaGluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBNYXRoLk1pbihhbHBoYTAgKyAoMS4wZiAtIGFscGhhMCkgKiBiZXRhLCAxLjBmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gMS4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5UT0kgPSBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5GbGFncyB8PSBDb250YWN0RmxhZ3MuVE9JO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhIDwgbWluQWxwaGEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBtaW5pbXVtIFRPSSBmb3VuZCBzbyBmYXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvbnRhY3QgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BbHBoYSA9IGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWluQ29udGFjdCA9PSBudWxsIHx8IDEuMGYgLSAxMC4wZiAqIFNldHRpbmdzLkVwc2lsb24gPCBtaW5BbHBoYSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBtb3JlIFRPSSBldmVudHMuIERvbmUhXHJcbiAgICAgICAgICAgICAgICAgICAgX3N0ZXBDb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgYm9kaWVzIHRvIHRoZSBUT0kuXHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZBMSA9IG1pbkNvbnRhY3QuRml4dHVyZUE7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZCMSA9IG1pbkNvbnRhY3QuRml4dHVyZUI7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJBMSA9IGZBMS5Cb2R5O1xyXG4gICAgICAgICAgICAgICAgQm9keSBiQjEgPSBmQjEuQm9keTtcclxuXHJcbiAgICAgICAgICAgICAgICBTd2VlcCBiYWNrdXAxID0gYkExLlN3ZWVwO1xyXG4gICAgICAgICAgICAgICAgU3dlZXAgYmFja3VwMiA9IGJCMS5Td2VlcDtcclxuXHJcbiAgICAgICAgICAgICAgICBiQTEuQWR2YW5jZShtaW5BbHBoYSk7XHJcbiAgICAgICAgICAgICAgICBiQjEuQWR2YW5jZShtaW5BbHBoYSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIFRPSSBjb250YWN0IGxpa2VseSBoYXMgc29tZSBuZXcgY29udGFjdCBwb2ludHMuXHJcbiAgICAgICAgICAgICAgICBtaW5Db250YWN0LlVwZGF0ZShDb250YWN0TWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICBtaW5Db250YWN0LkZsYWdzICY9IH5Db250YWN0RmxhZ3MuVE9JO1xyXG4gICAgICAgICAgICAgICAgKyttaW5Db250YWN0LlRPSUNvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBjb250YWN0IHNvbGlkP1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbkNvbnRhY3QuRW5hYmxlZCA9PSBmYWxzZSB8fCBtaW5Db250YWN0LklzVG91Y2hpbmcoKSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBzd2VlcHMuXHJcbiAgICAgICAgICAgICAgICAgICAgbWluQ29udGFjdC5FbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYkExLlN3ZWVwID0gYmFja3VwMTtcclxuICAgICAgICAgICAgICAgICAgICBiQjEuU3dlZXAgPSBiYWNrdXAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJBMS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJCMS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJBMS5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBiQjEuQXdha2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBpc2xhbmRcclxuICAgICAgICAgICAgICAgIElzbGFuZC5DbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgSXNsYW5kLkFkZChiQTEpO1xyXG4gICAgICAgICAgICAgICAgSXNsYW5kLkFkZChiQjEpO1xyXG4gICAgICAgICAgICAgICAgSXNsYW5kLkFkZChtaW5Db250YWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBiQTEuRmxhZ3MgfD0gQm9keUZsYWdzLklzbGFuZDtcclxuICAgICAgICAgICAgICAgIGJCMS5GbGFncyB8PSBCb2R5RmxhZ3MuSXNsYW5kO1xyXG4gICAgICAgICAgICAgICAgbWluQ29udGFjdC5GbGFncyB8PSBDb250YWN0RmxhZ3MuSXNsYW5kO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBjb250YWN0cyBvbiBib2R5QSBhbmQgYm9keUIuXHJcbiAgICAgICAgICAgICAgICBCb2R5W10gYm9kaWVzID0geyBiQTEsIGJCMSB9O1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAyOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQm9keSBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5LkJvZHlUeXBlID09IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKENvbnRhY3RFZGdlIGNlID0gYm9keS5Db250YWN0TGlzdDsgY2UgJiYgSXNsYW5kLkJvZHlDb3VudCA8IFNldHRpbmdzLk1heFRPSUNvbnRhY3RzOyBjZSA9IGNlLk5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoQ29udGFjdEVkZ2UgY2UgPSBib2R5LkNvbnRhY3RMaXN0OyBjZSAhPSBudWxsOyBjZSA9IGNlLk5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3QgY29udGFjdCA9IGNlLkNvbnRhY3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFzIHRoaXMgY29udGFjdCBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIGlzbGFuZD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY29udGFjdC5GbGFncyAmIENvbnRhY3RGbGFncy5Jc2xhbmQpID09IENvbnRhY3RGbGFncy5Jc2xhbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgc3RhdGljLCBraW5lbWF0aWMsIG9yIGJ1bGxldCBib2RpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCb2R5IG90aGVyID0gY2UuT3RoZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIuQm9keVR5cGUgPT0gQm9keVR5cGUuRHluYW1pYyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuSXNCdWxsZXQgPT0gZmFsc2UgJiYgb3RoZXIuSXNCdWxsZXQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzZW5zb3JzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QuRml4dHVyZUEuSXNTZW5zb3IgfHwgY29udGFjdC5GaXh0dXJlQi5Jc1NlbnNvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZW50YXRpdmVseSBhZHZhbmNlIHRoZSBib2R5IHRvIHRoZSBUT0kuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTd2VlcCBiYWNrdXAgPSBvdGhlci5Td2VlcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob3RoZXIuRmxhZ3MgJiBCb2R5RmxhZ3MuSXNsYW5kKSA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLkFkdmFuY2UobWluQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGFjdCBwb2ludHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3QuVXBkYXRlKENvbnRhY3RNYW5hZ2VyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXYXMgdGhlIGNvbnRhY3QgZGlzYWJsZWQgYnkgdGhlIHVzZXI/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5FbmFibGVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLlN3ZWVwID0gYmFja3VwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJlIHRoZXJlIGNvbnRhY3QgcG9pbnRzP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QuSXNUb3VjaGluZygpID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLlN3ZWVwID0gYmFja3VwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb250YWN0IHRvIHRoZSBpc2xhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3QuRmxhZ3MgfD0gQ29udGFjdEZsYWdzLklzbGFuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIElzbGFuZC5BZGQoY29udGFjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFzIHRoZSBvdGhlciBib2R5IGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgaXNsYW5kP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvdGhlci5GbGFncyAmIEJvZHlGbGFncy5Jc2xhbmQpID09IEJvZHlGbGFncy5Jc2xhbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBvdGhlciBib2R5IHRvIHRoZSBpc2xhbmQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5GbGFncyB8PSBCb2R5RmxhZ3MuSXNsYW5kO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlci5Cb2R5VHlwZSAhPSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIElzbGFuZC5BZGQob3RoZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFRpbWVTdGVwIHN1YlN0ZXA7XHJcbiAgICAgICAgICAgICAgICBzdWJTdGVwLmR0ID0gKDEuMGYgLSBtaW5BbHBoYSkgKiBzdGVwLmR0O1xyXG4gICAgICAgICAgICAgICAgc3ViU3RlcC5pbnZfZHQgPSAxLjBmIC8gc3ViU3RlcC5kdDtcclxuICAgICAgICAgICAgICAgIHN1YlN0ZXAuZHRSYXRpbyA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICAvL3N1YlN0ZXAucG9zaXRpb25JdGVyYXRpb25zID0gMjA7XHJcbiAgICAgICAgICAgICAgICAvL3N1YlN0ZXAudmVsb2NpdHlJdGVyYXRpb25zID0gc3RlcC52ZWxvY2l0eUl0ZXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAvL3N1YlN0ZXAud2FybVN0YXJ0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBJc2xhbmQuU29sdmVUT0kocmVmIHN1YlN0ZXApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGlzbGFuZCBmbGFncyBhbmQgc3luY2hyb25pemUgYnJvYWQtcGhhc2UgcHJveGllcy5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgSXNsYW5kLkJvZHlDb3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEJvZHkgYm9keSA9IElzbGFuZC5Cb2RpZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5GbGFncyAmPSB+Qm9keUZsYWdzLklzbGFuZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkuQm9keVR5cGUgIT0gQm9keVR5cGUuRHluYW1pYylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5TeW5jaHJvbml6ZUZpeHR1cmVzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgYWxsIGNvbnRhY3QgVE9JcyBvbiB0aGlzIGRpc3BsYWNlZCBib2R5LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoQ29udGFjdEVkZ2UgY2UgPSBib2R5LkNvbnRhY3RMaXN0OyBjZSAhPSBudWxsOyBjZSA9IGNlLk5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZS5Db250YWN0LkZsYWdzICY9IH4oQ29udGFjdEZsYWdzLlRPSSB8IENvbnRhY3RGbGFncy5Jc2xhbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21taXQgZml4dHVyZSBwcm94eSBtb3ZlbWVudHMgdG8gdGhlIGJyb2FkLXBoYXNlIHNvIHRoYXQgbmV3IGNvbnRhY3RzIGFyZSBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgICAgLy8gQWxzbywgc29tZSBjb250YWN0cyBjYW4gYmUgZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAgICAgQ29udGFjdE1hbmFnZXIuRmluZE5ld0NvbnRhY3RzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKEVuYWJsZVN1YlN0ZXBwaW5nKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdGVwQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkQ29udHJvbGxlcihDb250cm9sbGVyIGNvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIUNvbnRyb2xsZXJMaXN0LkNvbnRhaW5zKGNvbnRyb2xsZXIpLCBcIllvdSBhcmUgYWRkaW5nIHRoZSBzYW1lIGNvbnRyb2xsZXIgbW9yZSB0aGFuIG9uY2UuXCIpO1xyXG5cclxuICAgICAgICAgICAgY29udHJvbGxlci5Xb3JsZCA9IHRoaXM7XHJcbiAgICAgICAgICAgIENvbnRyb2xsZXJMaXN0LkFkZChjb250cm9sbGVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChDb250cm9sbGVyQWRkZWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIENvbnRyb2xsZXJBZGRlZChjb250cm9sbGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZUNvbnRyb2xsZXIoQ29udHJvbGxlciBjb250cm9sbGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KENvbnRyb2xsZXJMaXN0LkNvbnRhaW5zKGNvbnRyb2xsZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJZb3UgYXJlIHJlbW92aW5nIGEgY29udHJvbGxlciB0aGF0IGlzIG5vdCBpbiB0aGUgc2ltdWxhdGlvbi5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoQ29udHJvbGxlckxpc3QuQ29udGFpbnMoY29udHJvbGxlcikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbnRyb2xsZXJMaXN0LlJlbW92ZShjb250cm9sbGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQ29udHJvbGxlclJlbW92ZWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBDb250cm9sbGVyUmVtb3ZlZChjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkQnJlYWthYmxlQm9keShCcmVha2FibGVCb2R5IGJyZWFrYWJsZUJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCcmVha2FibGVCb2R5TGlzdC5BZGQoYnJlYWthYmxlQm9keSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVCcmVha2FibGVCb2R5KEJyZWFrYWJsZUJvZHkgYnJlYWthYmxlQm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vVGhlIGJyZWFrYWJsZSBib2R5IGxpc3QgZG9lcyBub3QgY29udGFpbiB0aGUgYm9keSB5b3UgdHJpZWQgdG8gcmVtb3ZlLlxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoQnJlYWthYmxlQm9keUxpc3QuQ29udGFpbnMoYnJlYWthYmxlQm9keSkpO1xyXG5cclxuICAgICAgICAgICAgQnJlYWthYmxlQm9keUxpc3QuUmVtb3ZlKGJyZWFrYWJsZUJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEZpeHR1cmUgVGVzdFBvaW50KFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBQUJCIGFhYmI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IG5ldyBWZWN0b3IyKFNldHRpbmdzLkVwc2lsb24sIFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICBhYWJiLkxvd2VyQm91bmQgPSBwb2ludCAtIGQ7XHJcbiAgICAgICAgICAgIGFhYmIuVXBwZXJCb3VuZCA9IHBvaW50ICsgZDtcclxuXHJcbiAgICAgICAgICAgIEZpeHR1cmUgbXlGaXh0dXJlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFF1ZXJ5IHRoZSB3b3JsZCBmb3Igb3ZlcmxhcHBpbmcgc2hhcGVzLlxyXG4gICAgICAgICAgICBRdWVyeUFBQkIoXHJcbihnbG9iYWw6OlN5c3RlbS5GdW5jPGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuRHluYW1pY3MuRml4dHVyZSwgYm9vbD4pKCAgICAgICAgICAgICAgICBmaXh0dXJlID0+XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBpbnNpZGUgPSBmaXh0dXJlLlRlc3RQb2ludChyZWYgcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBteUZpeHR1cmUgPSBmaXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB0aGUgcXVlcnkuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KSwgcmVmIGFhYmIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG15Rml4dHVyZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIGxpc3Qgb2YgZml4dHVyZXMgdGhhdCBhcmUgYXQgdGhlIHNwZWNpZmllZCBwb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+VGhlIHBvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgTGlzdDxGaXh0dXJlPiBUZXN0UG9pbnRBbGwoVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFBQkIgYWFiYjtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gbmV3IFZlY3RvcjIoU2V0dGluZ3MuRXBzaWxvbiwgU2V0dGluZ3MuRXBzaWxvbik7XHJcbiAgICAgICAgICAgIGFhYmIuTG93ZXJCb3VuZCA9IHBvaW50IC0gZDtcclxuICAgICAgICAgICAgYWFiYi5VcHBlckJvdW5kID0gcG9pbnQgKyBkO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxGaXh0dXJlPiBmaXh0dXJlcyA9IG5ldyBMaXN0PEZpeHR1cmU+KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBRdWVyeSB0aGUgd29ybGQgZm9yIG92ZXJsYXBwaW5nIHNoYXBlcy5cclxuICAgICAgICAgICAgUXVlcnlBQUJCKFxyXG4oZ2xvYmFsOjpTeXN0ZW0uRnVuYzxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkZpeHR1cmUsIGJvb2w+KSggICAgICAgICAgICAgICAgZml4dHVyZSA9PlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgaW5zaWRlID0gZml4dHVyZS5UZXN0UG9pbnQocmVmIHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXh0dXJlcy5BZGQoZml4dHVyZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHRoZSBxdWVyeS5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pLCByZWYgYWFiYik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZml4dHVyZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQcm9jZXNzQ2hhbmdlcygpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IEJvZHlMaXN0LkNvdW50IC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFJlbW92ZUJvZHkoQm9keUxpc3RbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gQ29udHJvbGxlckxpc3QuQ291bnQgLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUmVtb3ZlQ29udHJvbGxlcihDb250cm9sbGVyTGlzdFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBCcmVha2FibGVCb2R5TGlzdC5Db3VudCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBSZW1vdmVCcmVha2FibGVCb2R5KEJyZWFrYWJsZUJvZHlMaXN0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgUHJvY2Vzc0NoYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWNcclxue1xyXG4gICAgW0ZsYWdzXVxyXG4gICAgcHVibGljIGVudW0gUGh5c2ljc0xvZ2ljVHlwZVxyXG4gICAge1xyXG4gICAgICAgIEV4cGxvc2lvbiA9ICgxIDw8IDApXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0cnVjdCBQaHlzaWNzTG9naWNGaWx0ZXJcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgUGh5c2ljc0xvZ2ljVHlwZSBDb250cm9sbGVySWdub3JlcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJZ25vcmVzIHRoZSBjb250cm9sbGVyLiBUaGUgY29udHJvbGxlciBoYXMgbm8gZWZmZWN0IG9uIHRoaXMgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInR5cGVcIj5UaGUgbG9naWMgdHlwZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIElnbm9yZVBoeXNpY3NMb2dpYyhQaHlzaWNzTG9naWNUeXBlIHR5cGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDb250cm9sbGVySWdub3JlcyB8PSB0eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXN0b3JlIHRoZSBjb250cm9sbGVyLiBUaGUgY29udHJvbGxlciBhZmZlY3RzIHRoaXMgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInR5cGVcIj5UaGUgbG9naWMgdHlwZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlc3RvcmVQaHlzaWNzTG9naWMoUGh5c2ljc0xvZ2ljVHlwZSB0eXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29udHJvbGxlcklnbm9yZXMgJj0gfnR5cGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciB0aGlzIGJvZHkgaWdub3JlcyB0aGUgdGhlIHNwZWNpZmllZCBjb250cm9sbGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHlwZVwiPlRoZSBsb2dpYyB0eXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBcdDxjPnRydWU8L2M+IGlmIHRoZSBib2R5IGhhcyB0aGUgc3BlY2lmaWVkIGZsYWc7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNQaHlzaWNzTG9naWNJZ25vcmVkKFBoeXNpY3NMb2dpY1R5cGUgdHlwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoQ29udHJvbGxlcklnbm9yZXMgJiB0eXBlKSA9PSB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgY2xhc3MgUGh5c2ljc0xvZ2ljIDogRmlsdGVyRGF0YVxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgUGh5c2ljc0xvZ2ljVHlwZSBfdHlwZTtcclxuICAgICAgICBwdWJsaWMgV29ybGQgV29ybGQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIElzQWN0aXZlT24oQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGJvZHkuUGh5c2ljc0xvZ2ljRmlsdGVyLklzUGh5c2ljc0xvZ2ljSWdub3JlZChfdHlwZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5Jc0FjdGl2ZU9uKGJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFBoeXNpY3NMb2dpYyhXb3JsZCB3b3JsZCwgUGh5c2ljc0xvZ2ljVHlwZSB0eXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3R5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICBXb3JsZCA9IHdvcmxkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljXHJcbntcclxuICAgIGludGVybmFsIHN0cnVjdCBTaGFwZURhdGFcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgQm9keSBCb2R5O1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXg7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1pbjsgLy8gYWJzb2x1dGUgYW5nbGVzXHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgaXMgYSBjb21wcmFyZXIgdXNlZCBmb3IgXHJcbiAgICAvLy8gZGV0ZWN0aW5nIGFuZ2xlIGRpZmZlcmVuY2UgYmV0d2VlbiByYXlzXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgaW50ZXJuYWwgY2xhc3MgUmF5RGF0YUNvbXBhcmVyIDogSUNvbXBhcmVyPGZsb2F0PlxyXG4gICAge1xyXG4gICAgICAgICNyZWdpb24gSUNvbXBhcmVyPGZsb2F0PiBNZW1iZXJzXHJcblxyXG4gICAgICAgIGludCBJQ29tcGFyZXI8ZmxvYXQ+LkNvbXBhcmUoZmxvYXQgYSwgZmxvYXQgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGRpZmYgPSAoYSAtIGIpO1xyXG4gICAgICAgICAgICBpZiAoZGlmZiA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgaWYgKGRpZmYgPCAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuICAgIH1cclxuXHJcbiAgICAvKiBNZXRob2RvbG9neTpcclxuICAgICAqIEZvcmNlIGFwcGxpZWQgYXQgYSByYXkgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgc3F1YXJlIG9mIGRpc3RhbmNlIGZyb20gc291cmNlXHJcbiAgICAgKiBBQUJCIGlzIHVzZWQgdG8gcXVlcnkgZm9yIHNoYXBlcyB0aGF0IG1heSBiZSBhZmZlY3RlZFxyXG4gICAgICogRm9yIGVhY2ggUklHSUQgQk9EWSAobm90IHNoYXBlIC0tIHRoaXMgaXMgYW4gb3B0aW1pemF0aW9uKSB0aGF0IGlzIG1hdGNoZWQsIGxvb3AgdGhyb3VnaCBpdHMgdmVydGljZXMgdG8gZGV0ZXJtaW5lXHJcbiAgICAgKlx0XHR0aGUgZXh0cmVtZSBwb2ludHMgLS0gaWYgdGhlcmUgaXMgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgb3V0bGluaW5nIHBvbHlnb24sIHVzZSB0aGF0IGFzIGFuIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9uXHJcbiAgICAgKiBFdmVubHkgY2FzdCBhIG51bWJlciBvZiByYXlzIGFnYWluc3QgdGhlIHNoYXBlIC0gbnVtYmVyIHJvdWdobHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBhcmMgY292ZXJhZ2VcclxuICAgICAqXHRcdC1Tb21ldGhpbmcgbGlrZSBldmVyeSAzIGRlZ3JlZXMgc2hvdWxkIGRvIHRoZSB0cmljayBhbHRob3VnaCB0aGlzIGNhbiBiZSBhbHRlcmVkIGRlcGVuZGluZyBvbiB0aGUgZGlzdGFuY2UgKGlmIHJlYWxseSBjbG9zZSBkb24ndCBuZWVkIHN1Y2ggYSBoaWdoIGRlbnNpdHkgb2YgcmF5cylcclxuICAgICAqXHRcdC1UaGVyZSBzaG91bGQgYmUgYSBtaW5pbXVtIG51bWJlciBvZiByYXlzICgzLTU/KSBhcHBsaWVkIHRvIGVhY2ggYm9keSBzbyB0aGF0IHNtYWxsIGJvZGllcyBmYXIgYXdheSBhcmUgc3RpbGwgYWNjdXJhdGVseSBtb2RlbGVkXHJcbiAgICAgKlx0XHQtQmUgc3VyZSB0byBoYXZlIHRoZSBmb3JjZXMgb2YgZWFjaCByYXkgYmUgcHJvcG9ydGlvbmFsIHRvIHRoZSBhdmVyYWdlIGFyYyBsZW5ndGggY292ZXJlZCBieSBlYWNoLlxyXG4gICAgICogRm9yIGVhY2ggcmF5IHRoYXQgYWN0dWFsbHkgaW50ZXJzZWN0cyB3aXRoIHRoZSBzaGFwZSAobm9uIGludGVyc2VjdGlvbnMgaW5kaWNhdGUgc29tZXRoaW5nIGJsb2NraW5nIHRoZSBwYXRoIG9mIGV4cGxvc2lvbik6XHJcbiAgICAgKlx0XHQ+IGFwcGx5IHRoZSBhcHByb3ByaWF0ZSBmb3JjZSBkb3R0ZWQgd2l0aCB0aGUgbmVnYXRpdmUgb2YgdGhlIGNvbGxpc2lvbiBub3JtYWwgYXQgdGhlIGNvbGxpc2lvbiBwb2ludFxyXG4gICAgICpcdFx0PiBvcHRpb25hbGx5IGFwcGx5IGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYWZvcmVtZW50aW9uZWQgTm9ybWFsIGZvcmNlIGFuZCB0aGUgb3JpZ2luYWwgZXhwbG9zaW9uIGZvcmNlIGluIHRoZSBkaXJlY3Rpb24gb2YgcmF5IHRvIHNpbXVsYXRlIFwic3VyZmFjZSBmcmljdGlvblwiIG9mIHNvcnRzXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhpcyBpcyBhbiBleHBsb3NpdmUuLi4gaXQgZXhwbG9kZXMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgLy8vIDxyZW1hcmtzPlxyXG4gICAgLy8vIE9yaWdpbmFsIENvZGUgYnkgU3RldmVuIEx1IC0gc2VlIGh0dHA6Ly93d3cuYm94MmQub3JnL2ZvcnVtL3ZpZXd0b3BpYy5waHA/Zj0zJnQ9MTY4OFxyXG4gICAgLy8vIFBvcnRlZCB0byBGYXJzZWVyIDMuMCBieSBOaWNvbO+/vXMgSG9ybWF677+9YmFsXHJcbiAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgcHVibGljIHNlYWxlZCBjbGFzcyBFeHBsb3Npb24gOiBQaHlzaWNzTG9naWNcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFR3byBkZWdyZWVzOiBtYXhpbXVtIGFuZ2xlIGZyb20gZWRnZXMgdG8gZmlyc3QgcmF5IHRlc3RlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBmbG9hdCBNYXhFZGdlT2Zmc2V0ID0gTWF0aEhlbHBlci5QaSAvIDkwO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJhdGlvIG9mIGFyYyBsZW5ndGggdG8gYW5nbGUgZnJvbSBlZGdlcyB0byBmaXJzdCByYXkgdGVzdGVkLlxyXG4gICAgICAgIC8vLyBEZWZhdWx0cyB0byAxLzQwLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEVkZ2VSYXRpbyA9IDEuMGYgLyA0MC4wZjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJZ25vcmUgRXhwbG9zaW9uIGlmIGl0IGhhcHBlbnMgaW5zaWRlIGEgc2hhcGUuXHJcbiAgICAgICAgLy8vIERlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJZ25vcmVXaGVuSW5zaWRlU2hhcGUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNYXggYW5nbGUgYmV0d2VlbiByYXlzICh1c2VkIHdoZW4gc2VnbWVudCBpcyBsYXJnZSkuXHJcbiAgICAgICAgLy8vIERlZmF1bHRzIHRvIDE1IGRlZ3JlZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhBbmdsZSA9IE1hdGhIZWxwZXIuUGkgLyAxNTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNYXhpbXVtIG51bWJlciBvZiBzaGFwZXMgaW52b2x2ZWQgaW4gdGhlIGV4cGxvc2lvbi5cclxuICAgICAgICAvLy8gRGVmYXVsdHMgdG8gMTAwXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IE1heFNoYXBlcyA9IDEwMDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBIb3cgbWFueSByYXlzIHBlciBzaGFwZS9ib2R5L3NlZ21lbnQuXHJcbiAgICAgICAgLy8vIERlZmF1bHRzIHRvIDVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBpbnQgTWluUmF5cyA9IDU7XHJcblxyXG4gICAgICAgIHByaXZhdGUgTGlzdDxTaGFwZURhdGE+IF9kYXRhID0gbmV3IExpc3Q8U2hhcGVEYXRhPigpO1xyXG4gICAgICAgIHByaXZhdGUgRGljdGlvbmFyeTxGaXh0dXJlLCBMaXN0PFZlY3RvcjI+PiBfZXhwbG9kZWQ7XHJcbiAgICAgICAgcHJpdmF0ZSBSYXlEYXRhQ29tcGFyZXIgX3JkYztcclxuXHJcbiAgICAgICAgcHVibGljIEV4cGxvc2lvbihXb3JsZCB3b3JsZClcclxuICAgICAgICAgICAgOiBiYXNlKHdvcmxkLCBQaHlzaWNzTG9naWNUeXBlLkV4cGxvc2lvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9leHBsb2RlZCA9IG5ldyBEaWN0aW9uYXJ5PEZpeHR1cmUsIExpc3Q8VmVjdG9yMj4+KCk7XHJcbiAgICAgICAgICAgIF9yZGMgPSBuZXcgUmF5RGF0YUNvbXBhcmVyKCk7XHJcbiAgICAgICAgICAgIF9kYXRhID0gbmV3IExpc3Q8U2hhcGVEYXRhPigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIG1ha2VzIHRoZSBleHBsb3NpdmUgZXhwbG9kZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9zXCI+XHJcbiAgICAgICAgLy8vIFRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgZXhwbG9zaW9uIGhhcHBlbnNcclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyYWRpdXNcIj5cclxuICAgICAgICAvLy8gVGhlIGV4cGxvc2lvbiByYWRpdXNcclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhGb3JjZVwiPlxyXG4gICAgICAgIC8vLyBUaGUgZXhwbG9zaW9uIGZvcmNlIGF0IHRoZSBleHBsb3Npb24gcG9pbnRcclxuICAgICAgICAvLy8gKHRoZW4gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSlcclxuICAgICAgICAvLy8gPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIEEgZGljdGlvbm5hcnkgY29udGFpbmluZyBhbGwgdGhlIFwiZXhwbG9kZWRcIiBmaXh0dXJlc1xyXG4gICAgICAgIC8vLyB3aXRoIGEgbGlzdCBvZiB0aGUgYXBwbGllZCBpbXB1bHNlc1xyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIERpY3Rpb25hcnk8Rml4dHVyZSwgTGlzdDxWZWN0b3IyPj4gQWN0aXZhdGUoVmVjdG9yMiBwb3MsIGZsb2F0IHJhZGl1cywgZmxvYXQgbWF4Rm9yY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfZXhwbG9kZWQuQ2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIEFBQkIgYWFiYjtcclxuICAgICAgICAgICAgYWFiYi5Mb3dlckJvdW5kID0gcG9zICsgbmV3IFZlY3RvcjIoLXJhZGl1cywgLXJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFhYmIuVXBwZXJCb3VuZCA9IHBvcyArIG5ldyBWZWN0b3IyKHJhZGl1cywgcmFkaXVzKTtcclxuICAgICAgICAgICAgRml4dHVyZVtdIHNoYXBlcyA9IG5ldyBGaXh0dXJlW01heFNoYXBlc107XHJcblxyXG4gICAgICAgICAgICAvLyBNb3JlIHRoYW4gNSBzaGFwZXMgaW4gYW4gZXhwbG9zaW9uIGNvdWxkIGJlIHBvc3NpYmxlLCBidXQgc3RpbGwgc3RyYW5nZS5cclxuICAgICAgICAgICAgRml4dHVyZVtdIGNvbnRhaW5lZFNoYXBlcyA9IG5ldyBGaXh0dXJlWzVdO1xyXG4gICAgICAgICAgICBib29sIGV4aXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGludCBzaGFwZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgaW50IGNvbnRhaW5lZFNoYXBlQ291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gUXVlcnkgdGhlIHdvcmxkIGZvciBvdmVybGFwcGluZyBzaGFwZXMuXHJcbiAgICAgICAgICAgIFdvcmxkLlF1ZXJ5QUFCQihcclxuKGdsb2JhbDo6U3lzdGVtLkZ1bmM8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5GaXh0dXJlLCBib29sPikoICAgICAgICAgICAgICAgIGZpeHR1cmUgPT5cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZml4dHVyZS5UZXN0UG9pbnQocmVmIHBvcykpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSWdub3JlV2hlbkluc2lkZVNoYXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lZFNoYXBlc1tjb250YWluZWRTaGFwZUNvdW50KytdID0gZml4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW3NoYXBlQ291bnQrK10gPSBmaXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgdGhlIHF1ZXJ5LlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSksIHJlZiBhYWJiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChleGl0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4cGxvZGVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQZXIgc2hhcGUgbWF4L21pbiBhbmdsZXMgZm9yIG5vdy5cclxuICAgICAgICAgICAgZmxvYXRbXSB2YWxzID0gbmV3IGZsb2F0W3NoYXBlQ291bnQgKiAyXTtcclxuICAgICAgICAgICAgaW50IHZhbEluZGV4ID0gMDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzaGFwZUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwcztcclxuICAgICAgICAgICAgICAgIENpcmNsZVNoYXBlIGNzID0gc2hhcGVzW2ldLlNoYXBlIGFzIENpcmNsZVNoYXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNzICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY3JlYXRlIGEgXCJkaWFtb25kXCIgYXBwcm94aW1hdGlvbiBvZiB0aGUgY2lyY2xlXHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGljZXMgdiA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdmVjID0gVmVjdG9yMi5aZXJvICsgbmV3IFZlY3RvcjIoY3MuUmFkaXVzLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB2LkFkZCh2ZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYyA9IFZlY3RvcjIuWmVybyArIG5ldyBWZWN0b3IyKDAsIGNzLlJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5BZGQodmVjKTtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMgPSBWZWN0b3IyLlplcm8gKyBuZXcgVmVjdG9yMigtY3MuUmFkaXVzLCBjcy5SYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuQWRkKHZlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjID0gVmVjdG9yMi5aZXJvICsgbmV3IFZlY3RvcjIoMCwgLWNzLlJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5BZGQodmVjKTtcclxuICAgICAgICAgICAgICAgICAgICBwcyA9IG5ldyBQb2x5Z29uU2hhcGUodiwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcHMgPSBzaGFwZXNbaV0uU2hhcGUgYXMgUG9seWdvblNoYXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoc2hhcGVzW2ldLkJvZHkuQm9keVR5cGUgPT0gQm9keVR5cGUuRHluYW1pYykgJiYgcHMgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRvQ2VudHJvaWQgPSBzaGFwZXNbaV0uQm9keS5HZXRXb3JsZFBvaW50KHBzLk1hc3NEYXRhLkNlbnRyb2lkKSAtIHBvcztcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBhbmdsZVRvQ2VudHJvaWQgPSAoZmxvYXQpTWF0aC5BdGFuMih0b0NlbnRyb2lkLlksIHRvQ2VudHJvaWQuWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWluID0gZmxvYXQuTWF4VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWF4ID0gZmxvYXQuTWluVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWluQWJzb2x1dGUgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG1heEFic29sdXRlID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Db3VudDxnbG9iYWw6Ok1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLlZlY3RvcjI+KHBzLlZlcnRpY2VzKSk7ICsrailcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdG9WZXJ0ZXggPSAoc2hhcGVzW2ldLkJvZHkuR2V0V29ybGRQb2ludChwcy5WZXJ0aWNlc1tqXSkgLSBwb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXdBbmdsZSA9IChmbG9hdClNYXRoLkF0YW4yKHRvVmVydGV4LlksIHRvVmVydGV4LlgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkaWZmID0gKG5ld0FuZ2xlIC0gYW5nbGVUb0NlbnRyb2lkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSAoZGlmZiAtIE1hdGhIZWxwZXIuUGkpICUgKDIgKiBNYXRoSGVscGVyLlBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1pbnVzIHBpIGlzIGltcG9ydGFudC4gSXQgbWVhbnMgY3V0b2ZmIGZvciBnb2luZyBvdGhlciBkaXJlY3Rpb24gaXMgYXQgMTgwIGRlZyB3aGVyZSBpdCBuZWVkcyB0byBiZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPCAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiArPSAyICogTWF0aEhlbHBlci5QaTsgLy8gY29ycmVjdGlvbiBmb3Igbm90IGhhbmRsaW5nIG5lZ3NcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgLT0gTWF0aEhlbHBlci5QaTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLkFicyhkaWZmKSA+IE1hdGhIZWxwZXIuUGkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJPTUchXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcncyB3cm9uZywgcG9pbnQgbm90IGluIHNoYXBlIGJ1dCBleGlzdHMgYW5nbGUgZGlmZiA+IDE4MFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiBtYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IGRpZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhBYnNvbHV0ZSA9IG5ld0FuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmIDwgbWluKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQWJzb2x1dGUgPSBuZXdBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsc1t2YWxJbmRleF0gPSBtaW5BYnNvbHV0ZTtcclxuICAgICAgICAgICAgICAgICAgICArK3ZhbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHNbdmFsSW5kZXhdID0gbWF4QWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgKyt2YWxJbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQXJyYXkuU29ydDxmbG9hdD4odmFscywgMCwgdmFsSW5kZXgsIF9yZGMpO1xyXG4gICAgICAgICAgICBfZGF0YS5DbGVhcigpO1xyXG4gICAgICAgICAgICBib29sIHJheU1pc3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZhbEluZGV4OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgc2hhcGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWlkcHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IGlwbHVzID0gKGkgPT0gdmFsSW5kZXggLSAxID8gMCA6IGkgKyAxKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWxzW2ldID09IHZhbHNbaXBsdXNdKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpID09IHZhbEluZGV4IC0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2luZ2xlIGVkZ2VjYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgbWlkcHQgPSAodmFsc1swXSArIE1hdGhIZWxwZXIuUGkgKiAyICsgdmFsc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlkcHQgPSAodmFsc1tpICsgMV0gKyB2YWxzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBtaWRwdCA9IG1pZHB0IC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAxID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMiA9IHJhZGl1cyAqIG5ldyBWZWN0b3IyKChmbG9hdClNYXRoLkNvcyhtaWRwdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbG9hdClNYXRoLlNpbihtaWRwdCkpICsgcG9zO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJheWNhc3RPbmVcclxuICAgICAgICAgICAgICAgIGJvb2wgaGl0Q2xvc2VzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgV29ybGQuUmF5Q2FzdCgoZ2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5SYXlDYXN0Q2FsbGJhY2spKChmLCBwLCBuLCBmcikgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCb2R5IGJvZHkgPSBmLkJvZHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghSXNBY3RpdmVPbihib2R5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5LlVzZXJEYXRhICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSAoaW50KWJvZHkuVXNlckRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMS4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0Q2xvc2VzdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUgPSBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBwMSwgcDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZHJhd3MgcmFkaXVzIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKChoaXRDbG9zZXN0KSAmJiAoc2hhcGUuQm9keS5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5EeW5hbWljKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuQ291bnQ8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpID4gMCkgJiYgKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuTGFzdDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkuQm9keSA9PSBzaGFwZS5Cb2R5KSAmJiAoIXJheU1pc3NlZCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnQgbGFQb3MgPSBfZGF0YS5Db3VudCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNoYXBlRGF0YSBsYSA9IF9kYXRhW2xhUG9zXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGEuTWF4ID0gdmFsc1tpcGx1c107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhW2xhUG9zXSA9IGxhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIG5ld1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTaGFwZURhdGEgZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZC5Cb2R5ID0gc2hhcGUuQm9keTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZC5NaW4gPSB2YWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkLk1heCA9IHZhbHNbaXBsdXNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGF0YS5BZGQoZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuQ291bnQ8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpID4gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGkgPT0gdmFsSW5kZXggLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5MYXN0PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKS5Cb2R5ID09IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuRmlyc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLkJvZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkxhc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLk1heCA9PSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkZpcnN0PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKS5NaW4pKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2hhcGVEYXRhIGZpID0gX2RhdGFbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpLk1pbiA9IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuTGFzdDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkuTWluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGF0YS5SZW1vdmVBdChTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkNvdW50PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGF0YVswXSA9IGZpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5GaXJzdDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkuTWluID49IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuRmlyc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLk1heClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmkuTWluIC09IE1hdGhIZWxwZXIuUGkgKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGFbMF0gPSBmaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGxhc3RQb3MgPSBfZGF0YS5Db3VudCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgU2hhcGVEYXRhIGxhc3QgPSBfZGF0YVtsYXN0UG9zXTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuQ291bnQ8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuTGFzdDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkuTWluID49IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuTGFzdDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkuTWF4KSkgLy8ganVzdCBtYWtpbmcgc3VyZSBtaW48bWF4XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Lk1pbiA9IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuTGFzdDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkuTWluIC0gMiAqIE1hdGhIZWxwZXIuUGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhW2xhc3RQb3NdID0gbGFzdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmF5TWlzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF5TWlzc2VkID0gdHJ1ZTsgLy8gcmF5Y2FzdCBkaWQgbm90IGZpbmQgYSBzaGFwZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFN5c3RlbS5MaW5xLkVudW1lcmFibGUuQ291bnQ8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNBY3RpdmVPbihfZGF0YVtpXS5Cb2R5KSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBhcmNsZW4gPSBfZGF0YVtpXS5NYXggLSBfZGF0YVtpXS5NaW47XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgZmlyc3QgPSBNYXRoSGVscGVyLk1pbihNYXhFZGdlT2Zmc2V0LCBFZGdlUmF0aW8gKiBhcmNsZW4pO1xyXG4gICAgICAgICAgICAgICAgaW50IGluc2VydGVkUmF5cyA9IChpbnQpTWF0aC5DZWlsaW5nKCgoYXJjbGVuIC0gMi4wZiAqIGZpcnN0KSAtIChNaW5SYXlzIC0gMSkgKiBNYXhBbmdsZSkgLyBNYXhBbmdsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGluc2VydGVkUmF5cyA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRSYXlzID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvZmZzZXQgPSAoYXJjbGVuIC0gZmlyc3QgKiAyLjBmKSAvICgoZmxvYXQpTWluUmF5cyArIGluc2VydGVkUmF5cyAtIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vTm90ZTogVGhpcyBsb29wIGNhbiBnbyBpbnRvIGluZmluaXRlIGFzIGl0IG9wZXJhdGVzIG9uIGZsb2F0cy5cclxuICAgICAgICAgICAgICAgIC8vQWRkZWQgRmxvYXRFcXVhbHMgd2l0aCBhIGxhcmdlIGVwc2lsb24uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGZsb2F0IGogPSBfZGF0YVtpXS5NaW4gKyBmaXJzdDtcclxuICAgICAgICAgICAgICAgICAgICAgaiA8IF9kYXRhW2ldLk1heCB8fCBNYXRoVXRpbHMuRmxvYXRFcXVhbHMoaiwgX2RhdGFbaV0uTWF4LCAwLjAwMDFmKTtcclxuICAgICAgICAgICAgICAgICAgICAgaiArPSBvZmZzZXQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwMSA9IHBvcztcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gcG9zICsgcmFkaXVzICogbmV3IFZlY3RvcjIoKGZsb2F0KU1hdGguQ29zKGopLCAoZmxvYXQpTWF0aC5TaW4oaikpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgaGl0cG9pbnQgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWlubGFtYmRhID0gZmxvYXQuTWF4VmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIExpc3Q8Rml4dHVyZT4gZmwgPSBfZGF0YVtpXS5Cb2R5LkZpeHR1cmVMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IHggPSAwOyB4IDwgZmwuQ291bnQ7IHgrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IGZsW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSYXlDYXN0SW5wdXQgcmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpLlBvaW50MSA9IHAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaS5Qb2ludDIgPSBwMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmkuTWF4RnJhY3Rpb24gPSA1MGY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSYXlDYXN0T3V0cHV0IHJvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5SYXlDYXN0KG91dCBybywgcmVmIHJpLCAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmxhbWJkYSA+IHJvLkZyYWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmxhbWJkYSA9IHJvLkZyYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdHBvaW50ID0gcm8uRnJhY3Rpb24gKiBwMiArICgxIC0gcm8uRnJhY3Rpb24pICogcDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmb3JjZSB0aGF0IGlzIHRvIGJlIGFwcGxpZWQgZm9yIHRoaXMgcGFydGljdWxhciByYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCBpcyBhbmd1bGFyIGNvdmVyYWdlLiBsYW1iZGEqbGVuZ3RoIG9mIHNlZ21lbnQgaXMgZGlzdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAoYXJjbGVuIC8gKE1pblJheXMgKyBpbnNlcnRlZFJheXMpKSAqIG1heEZvcmNlICogMTgwLjBmIC8gTWF0aEhlbHBlci5QaSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMS4wZiAtIE1hdGguTWluKDEuMGYsIG1pbmxhbWJkYSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgQXBwbHkgdGhlIGltcHVsc2UhISFcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB2ZWN0SW1wID0gVmVjdG9yMi5Eb3QoaW1wdWxzZSAqIG5ldyBWZWN0b3IyKChmbG9hdClNYXRoLkNvcyhqKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxvYXQpTWF0aC5TaW4oaikpLCAtcm8uTm9ybWFsKSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKChmbG9hdClNYXRoLkNvcyhqKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsb2F0KU1hdGguU2luKGopKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhW2ldLkJvZHkuQXBwbHlMaW5lYXJJbXB1bHNlKHJlZiB2ZWN0SW1wLCByZWYgaGl0cG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2F0aGVyIHRoZSBmaXh0dXJlcyBmb3IgcmV0dXJuaW5nIHRoZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB2YWwgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3Q8VmVjdG9yMj4gdmVjdG9yTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9leHBsb2RlZC5UcnlHZXRWYWx1ZShmLCBvdXQgdmVjdG9yTGlzdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5YICs9IChmbG9hdClNYXRoLkFicyh2ZWN0SW1wLlgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLlkgKz0gKGZsb2F0KU1hdGguQWJzKHZlY3RJbXAuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjdG9yTGlzdC5BZGQodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlY3Rvckxpc3QgPSBuZXcgTGlzdDxWZWN0b3IyPigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLlggPSAoZmxvYXQpTWF0aC5BYnModmVjdEltcC5YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5ZID0gKGZsb2F0KU1hdGguQWJzKHZlY3RJbXAuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjdG9yTGlzdC5BZGQodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leHBsb2RlZC5BZGQoZiwgdmVjdG9yTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5sYW1iZGEgPiAxLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRwb2ludCA9IHAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBjaGVjayBjb250YWluZWQgc2hhcGVzXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgY29udGFpbmVkU2hhcGVDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeCA9IGNvbnRhaW5lZFNoYXBlc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQWN0aXZlT24oZml4LkJvZHkpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBNaW5SYXlzICogbWF4Rm9yY2UgKiAxODAuMGYgLyBNYXRoSGVscGVyLlBpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBoaXRQb2ludDtcclxuXHJcbiAgICAgICAgICAgICAgICBDaXJjbGVTaGFwZSBjaXJjU2hhcGUgPSBmaXguU2hhcGUgYXMgQ2lyY2xlU2hhcGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2lyY1NoYXBlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0UG9pbnQgPSBmaXguQm9keS5HZXRXb3JsZFBvaW50KGNpcmNTaGFwZS5Qb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHNoYXBlID0gZml4LlNoYXBlIGFzIFBvbHlnb25TaGFwZTtcclxuICAgICAgICAgICAgICAgICAgICBoaXRQb2ludCA9IGZpeC5Cb2R5LkdldFdvcmxkUG9pbnQoc2hhcGUuTWFzc0RhdGEuQ2VudHJvaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdmVjdEltcCA9IGltcHVsc2UgKiAoaGl0UG9pbnQgLSBwb3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIExpc3Q8VmVjdG9yMj4gdmVjdG9yTGlzdCA9IG5ldyBMaXN0PFZlY3RvcjI+KCk7XHJcbiAgICAgICAgICAgICAgICB2ZWN0b3JMaXN0LkFkZCh2ZWN0SW1wKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmaXguQm9keS5BcHBseUxpbmVhckltcHVsc2UocmVmIHZlY3RJbXAsIHJlZiBoaXRQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFfZXhwbG9kZWQuQ29udGFpbnNLZXkoZml4KSlcclxuICAgICAgICAgICAgICAgICAgICBfZXhwbG9kZWQuQWRkKGZpeCwgdmVjdG9yTGlzdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfZXhwbG9kZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkZhY3RvcmllcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uLlBvbHlnb25NYW5pcHVsYXRpb25cclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBDdXR0aW5nVG9vbHNcclxuICAgIHtcclxuICAgICAgICAvL0N1dHRpbmcgYSBzaGFwZSBpbnRvIHR3byBpcyBiYXNlZCBvbiB0aGUgd29yayBvZiBEYWlkIGFuZCBoaXMgcHJvdG90eXBlIEJveEN1dHRlcjogaHR0cDovL3d3dy5ib3gyZC5vcmcvZm9ydW0vdmlld3RvcGljLnBocD9mPTMmdD0xNDczXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3BsaXQgYSBmaXh0dXJlIGludG8gMiB2ZXJ0aWNlIGNvbGxlY3Rpb25zIHVzaW5nIHRoZSBnaXZlbiBlbnRyeSBhbmQgZXhpdC1wb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZpeHR1cmVcIj5UaGUgRml4dHVyZSB0byBzcGxpdDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZW50cnlQb2ludFwiPlRoZSBlbnRyeSBwb2ludCAtIFRoZSBzdGFydCBwb2ludDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXhpdFBvaW50XCI+VGhlIGV4aXQgcG9pbnQgLSBUaGUgZW5kIHBvaW50PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzcGxpdFNpemVcIj5UaGUgc2l6ZSBvZiB0aGUgc3BsaXQuIFRoaW5rIG9mIHRoaXMgYXMgdGhlIGxhc2VyLXdpZHRoPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmaXJzdFwiPlRoZSBmaXJzdCBjb2xsZWN0aW9uIG9mIHZlcnRleGVzPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzZWNvbmRcIj5UaGUgc2Vjb25kIGNvbGxlY3Rpb24gb2YgdmVydGV4ZXM8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBTcGxpdFNoYXBlKEZpeHR1cmUgZml4dHVyZSwgVmVjdG9yMiBlbnRyeVBvaW50LCBWZWN0b3IyIGV4aXRQb2ludCwgZmxvYXQgc3BsaXRTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBWZXJ0aWNlcyBmaXJzdCwgb3V0IFZlcnRpY2VzIHNlY29uZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxFbnRyeVBvaW50ID0gZml4dHVyZS5Cb2R5LkdldExvY2FsUG9pbnQocmVmIGVudHJ5UG9pbnQpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGxvY2FsRXhpdFBvaW50ID0gZml4dHVyZS5Cb2R5LkdldExvY2FsUG9pbnQocmVmIGV4aXRQb2ludCk7XHJcblxyXG4gICAgICAgICAgICBQb2x5Z29uU2hhcGUgc2hhcGUgPSBmaXh0dXJlLlNoYXBlIGFzIFBvbHlnb25TaGFwZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKHNoYXBlLlZlcnRpY2VzKTtcclxuICAgICAgICAgICAgVmVydGljZXNbXSBuZXdQb2x5Z29uID0gbmV3IFZlcnRpY2VzWzJdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuZXdQb2x5Z29uLkxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdQb2x5Z29uW2ldID0gbmV3IFZlcnRpY2VzKHZlcnRpY2VzLkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50W10gY3V0QWRkZWQgPSB7IC0xLCAtMSB9O1xyXG4gICAgICAgICAgICBpbnQgbGFzdCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBuO1xyXG4gICAgICAgICAgICAgICAgLy9GaW5kIG91dCBpZiB0aGlzIHZlcnRleCBpcyBvbiB0aGUgb2xkIG9yIG5ldyBzaGFwZS5cclxuICAgICAgICAgICAgICAgIGlmIChWZWN0b3IyLkRvdChNYXRoVXRpbHMuQ3Jvc3MobG9jYWxFeGl0UG9pbnQgLSBsb2NhbEVudHJ5UG9pbnQsIDEpLCB2ZXJ0aWNlc1tpXSAtIGxvY2FsRW50cnlQb2ludCkgPiBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSAwO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICE9IG4pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9JZiB3ZSBzd2l0Y2ggZnJvbSBvbmUgc2hhcGUgdG8gdGhlIG90aGVyIGFkZCB0aGUgY3V0IHZlcnRpY2VzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoY3V0QWRkZWRbMF0gPT0gLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRBZGRlZFswXSA9IG5ld1BvbHlnb25bbGFzdF0uQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvbHlnb25bbGFzdF0uQWRkKGxvY2FsRXhpdFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9seWdvbltsYXN0XS5BZGQobG9jYWxFbnRyeVBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPT0gMSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChjdXRBZGRlZFtsYXN0XSA9PSAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dEFkZGVkW2xhc3RdID0gbmV3UG9seWdvbltsYXN0XS5Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9seWdvbltsYXN0XS5BZGQobG9jYWxFbnRyeVBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9seWdvbltsYXN0XS5BZGQobG9jYWxFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBuZXdQb2x5Z29uW25dLkFkZCh2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBsYXN0ID0gbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9BZGQgdGhlIGN1dCBpbiBjYXNlIGl0IGhhcyBub3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgICAgIGlmIChjdXRBZGRlZFswXSA9PSAtMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY3V0QWRkZWRbMF0gPSBuZXdQb2x5Z29uWzBdLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgbmV3UG9seWdvblswXS5BZGQobG9jYWxFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9seWdvblswXS5BZGQobG9jYWxFbnRyeVBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3V0QWRkZWRbMV0gPT0gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGN1dEFkZGVkWzFdID0gbmV3UG9seWdvblsxXS5Db3VudDtcclxuICAgICAgICAgICAgICAgIG5ld1BvbHlnb25bMV0uQWRkKGxvY2FsRW50cnlQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBuZXdQb2x5Z29uWzFdLkFkZChsb2NhbEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IG4gPSAwOyBuIDwgMjsgbisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmIChjdXRBZGRlZFtuXSA+IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG5ld1BvbHlnb25bbl1bY3V0QWRkZWRbbl0gLSAxXSAtIG5ld1BvbHlnb25bbl1bY3V0QWRkZWRbbl1dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAobmV3UG9seWdvbltuXVtuZXdQb2x5Z29uW25dLkNvdW50IC0gMV0gLSBuZXdQb2x5Z29uW25dWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldC5Ob3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBuZXdQb2x5Z29uW25dW2N1dEFkZGVkW25dXSArPSBzcGxpdFNpemUgKiBvZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1dEFkZGVkW25dIDwgbmV3UG9seWdvbltuXS5Db3VudCAtIDIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG5ld1BvbHlnb25bbl1bY3V0QWRkZWRbbl0gKyAyXSAtIG5ld1BvbHlnb25bbl1bY3V0QWRkZWRbbl0gKyAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG5ld1BvbHlnb25bbl1bMF0gLSBuZXdQb2x5Z29uW25dW25ld1BvbHlnb25bbl0uQ291bnQgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3UG9seWdvbltuXVtjdXRBZGRlZFtuXSArIDFdICs9IHNwbGl0U2l6ZSAqIG9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmlyc3QgPSBuZXdQb2x5Z29uWzBdO1xyXG4gICAgICAgICAgICBzZWNvbmQgPSBuZXdQb2x5Z29uWzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGlzIGEgaGlnaC1sZXZlbCBmdW5jdGlvbiB0byBjdXRzIGZpeHR1cmVzIGluc2lkZSB0aGUgZ2l2ZW4gd29ybGQsIHVzaW5nIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cy5cclxuICAgICAgICAvLy8gTm90ZTogV2UgZG9uJ3Qgc3VwcG9ydCBjdXR0aW5nIHdoZW4gdGhlIHN0YXJ0IG9yIGVuZCBpcyBpbnNpZGUgYSBzaGFwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkXCI+VGhlIHdvcmxkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3RhcnRcIj5UaGUgc3RhcnRwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVuZFwiPlRoZSBlbmRwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRoaWNrbmVzc1wiPlRoZSB0aGlja25lc3Mgb2YgdGhlIGN1dDwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIEN1dChXb3JsZCB3b3JsZCwgVmVjdG9yMiBzdGFydCwgVmVjdG9yMiBlbmQsIGZsb2F0IHRoaWNrbmVzcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpc3Q8Rml4dHVyZT4gZml4dHVyZXMgPSBuZXcgTGlzdDxGaXh0dXJlPigpO1xyXG4gICAgICAgICAgICBMaXN0PFZlY3RvcjI+IGVudHJ5UG9pbnRzID0gbmV3IExpc3Q8VmVjdG9yMj4oKTtcclxuICAgICAgICAgICAgTGlzdDxWZWN0b3IyPiBleGl0UG9pbnRzID0gbmV3IExpc3Q8VmVjdG9yMj4oKTtcclxuXHJcbiAgICAgICAgICAgIC8vV2UgZG9uJ3Qgc3VwcG9ydCBjdXR0aW5nIHdoZW4gdGhlIHN0YXJ0IG9yIGVuZCBpcyBpbnNpZGUgYSBzaGFwZS5cclxuICAgICAgICAgICAgaWYgKHdvcmxkLlRlc3RQb2ludChzdGFydCkgIT0gbnVsbCB8fCB3b3JsZC5UZXN0UG9pbnQoZW5kKSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy9HZXQgdGhlIGVudHJ5IHBvaW50c1xyXG4gICAgICAgICAgICB3b3JsZC5SYXlDYXN0KChnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLlJheUNhc3RDYWxsYmFjaykoKGYsIHAsIG4sIGZyKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXh0dXJlcy5BZGQoZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeVBvaW50cy5BZGQocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgICAgICAgLy9SZXZlcnNlIHRoZSByYXkgdG8gZ2V0IHRoZSBleGl0cG9pbnRzXHJcbiAgICAgICAgICAgIHdvcmxkLlJheUNhc3QoKGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuRHluYW1pY3MuUmF5Q2FzdENhbGxiYWNrKSgoZiwgcCwgbiwgZnIpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXRQb2ludHMuQWRkKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlbmQsIHN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIC8vV2Ugb25seSBoYXZlIGEgc2luZ2xlIHBvaW50LiBXZSBuZWVkIGF0IGxlYXN0IDJcclxuICAgICAgICAgICAgaWYgKGVudHJ5UG9pbnRzLkNvdW50ICsgZXhpdFBvaW50cy5Db3VudCA8IDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGZpeHR1cmVzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNhbid0IGN1dCBjaXJjbGVzIHlldCAhXHJcbiAgICAgICAgICAgICAgICBpZiAoZml4dHVyZXNbaV0uU2hhcGUuU2hhcGVUeXBlICE9IFNoYXBlVHlwZS5Qb2x5Z29uKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlc1tpXS5Cb2R5LkJvZHlUeXBlICE9IEJvZHlUeXBlLlN0YXRpYylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1NwbGl0IHRoZSBzaGFwZSB1cCBpbnRvIHR3byBzaGFwZXNcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcyBmaXJzdDtcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcyBzZWNvbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgU3BsaXRTaGFwZShmaXh0dXJlc1tpXSwgZW50cnlQb2ludHNbaV0sIGV4aXRQb2ludHNbaV0sIHRoaWNrbmVzcywgb3V0IGZpcnN0LCBvdXQgc2Vjb25kKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9EZWxldGUgdGhlIG9yaWdpbmFsIHNoYXBlIGFuZCBjcmVhdGUgdHdvIG5ldy4gUmV0YWluIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBib2R5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTYW5pdHlDaGVjayhmaXJzdCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5IGZpcnN0Rml4dHVyZSA9IEJvZHlGYWN0b3J5LkNyZWF0ZVBvbHlnb24od29ybGQsIGZpcnN0LCBmaXh0dXJlc1tpXS5TaGFwZS5EZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4dHVyZXNbaV0uQm9keS5Qb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Rml4dHVyZS5Sb3RhdGlvbiA9IGZpeHR1cmVzW2ldLkJvZHkuUm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Rml4dHVyZS5MaW5lYXJWZWxvY2l0eSA9IGZpeHR1cmVzW2ldLkJvZHkuTGluZWFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Rml4dHVyZS5Bbmd1bGFyVmVsb2NpdHkgPSBmaXh0dXJlc1tpXS5Cb2R5LkFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RGaXh0dXJlLkJvZHlUeXBlID0gQm9keVR5cGUuRHluYW1pYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTYW5pdHlDaGVjayhzZWNvbmQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBzZWNvbmRGaXh0dXJlID0gQm9keUZhY3RvcnkuQ3JlYXRlUG9seWdvbih3b3JsZCwgc2Vjb25kLCBmaXh0dXJlc1tpXS5TaGFwZS5EZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeHR1cmVzW2ldLkJvZHkuUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRGaXh0dXJlLlJvdGF0aW9uID0gZml4dHVyZXNbaV0uQm9keS5Sb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kRml4dHVyZS5MaW5lYXJWZWxvY2l0eSA9IGZpeHR1cmVzW2ldLkJvZHkuTGluZWFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEZpeHR1cmUuQW5ndWxhclZlbG9jaXR5ID0gZml4dHVyZXNbaV0uQm9keS5Bbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEZpeHR1cmUuQm9keVR5cGUgPSBCb2R5VHlwZS5EeW5hbWljO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3b3JsZC5SZW1vdmVCb2R5KGZpeHR1cmVzW2ldLkJvZHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIFNhbml0eUNoZWNrKFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLkNvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5HZXRBcmVhKCkgPCAwLjAwMDAxZilcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGkxID0gaTtcclxuICAgICAgICAgICAgICAgIGludCBpMiA9IGkgKyAxIDwgdmVydGljZXMuQ291bnQgPyBpICsgMSA6IDA7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGVkZ2UgPSB2ZXJ0aWNlc1tpMl0gLSB2ZXJ0aWNlc1tpMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS5MZW5ndGhTcXVhcmVkKCkgPCBTZXR0aW5ncy5FcHNpbG9uICogU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGkxID0gaTtcclxuICAgICAgICAgICAgICAgIGludCBpMiA9IGkgKyAxIDwgdmVydGljZXMuQ291bnQgPyBpICsgMSA6IDA7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGVkZ2UgPSB2ZXJ0aWNlc1tpMl0gLSB2ZXJ0aWNlc1tpMV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCB2ZXJ0aWNlcy5Db3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIHZlcnRpY2VzIG9uIHRoZSBjdXJyZW50IGVkZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gaTEgfHwgaiA9PSBpMilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiByID0gdmVydGljZXNbal0gLSB2ZXJ0aWNlc1tpMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFlvdXIgcG9seWdvbiBpcyBub24tY29udmV4IChpdCBoYXMgYW4gaW5kZW50YXRpb24pIG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGNvbGluZWFyIGVkZ2VzLlxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBlZGdlLlggKiByLlkgLSBlZGdlLlkgKiByLlg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgMC4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5Qb2x5Z29uTWFuaXB1bGF0aW9uXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgU2ltcGxpZnlUb29sc1xyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2xbXSBfdXNlUHQ7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZG91YmxlIF9kaXN0YW5jZVRvbGVyYW5jZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZW1vdmVzIGFsbCBjb2xsaW5lYXIgcG9pbnRzIG9uIHRoZSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgcG9seWdvbiB0aGF0IG5lZWRzIHNpbXBsaWZpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29sbGluZWFyaXR5VG9sZXJhbmNlXCI+VGhlIGNvbGxpbmVhcml0eSB0b2xlcmFuY2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBzaW1wbGlmaWVkIHBvbHlnb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgQ29sbGluZWFyU2ltcGxpZnkoVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGNvbGxpbmVhcml0eVRvbGVyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vV2UgY2FuJ3Qgc2ltcGxpZnkgcG9seWdvbnMgdW5kZXIgMyB2ZXJ0aWNlc1xyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgICAgVmVydGljZXMgc2ltcGxpZmllZCA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgcHJldklkID0gdmVydGljZXMuUHJldmlvdXNJbmRleChpKTtcclxuICAgICAgICAgICAgICAgIGludCBuZXh0SWQgPSB2ZXJ0aWNlcy5OZXh0SW5kZXgoaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwcmV2ID0gdmVydGljZXNbcHJldklkXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgY3VycmVudCA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuZXh0ID0gdmVydGljZXNbbmV4dElkXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0lmIHRoZXkgY29sbGluZWFyLCBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGhVdGlscy5Db2xsaW5lYXIocmVmIHByZXYsIHJlZiBjdXJyZW50LCByZWYgbmV4dCwgY29sbGluZWFyaXR5VG9sZXJhbmNlKSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBzaW1wbGlmaWVkLkFkZChjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZpZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlbW92ZXMgYWxsIGNvbGxpbmVhciBwb2ludHMgb24gdGhlIHBvbHlnb24uXHJcbiAgICAgICAgLy8vIEhhcyBhIGRlZmF1bHQgYmlhcyBvZiAwXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSBwb2x5Z29uIHRoYXQgbmVlZHMgc2ltcGxpZmljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBzaW1wbGlmaWVkIHBvbHlnb24uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgQ29sbGluZWFyU2ltcGxpZnkoVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGluZWFyU2ltcGxpZnkodmVydGljZXMsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgcG9seWdvbiBzaW1wbGlmaWNhdGlvbiBhbGdvcml0aG0uIFRoaXMgaXMgdGhlIGdlbmVyYWwgcmVjdXJzaXZlIHZlcnNpb24gdGhhdCBkb2VzIG5vdCB1c2UgdGhlXHJcbiAgICAgICAgLy8vIHNwZWVkLXVwIHRlY2huaXF1ZSBieSB1c2luZyB0aGUgTWVsa21hbiBjb252ZXggaHVsbC5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIElmIHlvdSBwYXNzIGluIDAsIGl0IHdpbGwgcmVtb3ZlIGFsbCBjb2xsaW5lYXIgcG9pbnRzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHNpbXBsaWZpZWQgcG9seWdvbjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIERvdWdsYXNQZXVja2VyU2ltcGxpZnkoVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGRpc3RhbmNlVG9sZXJhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2Rpc3RhbmNlVG9sZXJhbmNlID0gZGlzdGFuY2VUb2xlcmFuY2U7XHJcblxyXG4gICAgICAgICAgICBfdXNlUHQgPSBuZXcgYm9vbFt2ZXJ0aWNlcy5Db3VudF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIF91c2VQdFtpXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBTaW1wbGlmeVNlY3Rpb24odmVydGljZXMsIDAsIHZlcnRpY2VzLkNvdW50IC0gMSk7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHJlc3VsdCA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKF91c2VQdFtpXSlcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQWRkKHZlcnRpY2VzW2ldKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIFNpbXBsaWZ5U2VjdGlvbihWZXJ0aWNlcyB2ZXJ0aWNlcywgaW50IGksIGludCBqKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKChpICsgMSkgPT0gailcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgQSA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICBWZWN0b3IyIEIgPSB2ZXJ0aWNlc1tqXTtcclxuICAgICAgICAgICAgZG91YmxlIG1heERpc3RhbmNlID0gLTEuMDtcclxuICAgICAgICAgICAgaW50IG1heEluZGV4ID0gaTtcclxuICAgICAgICAgICAgZm9yIChpbnQgayA9IGkgKyAxOyBrIDwgajsgaysrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkb3VibGUgZGlzdGFuY2UgPSBEaXN0YW5jZVBvaW50TGluZSh2ZXJ0aWNlc1trXSwgQSwgQik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1heERpc3RhbmNlIDw9IF9kaXN0YW5jZVRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGsgPSBpICsgMTsgayA8IGo7IGsrKylcclxuICAgICAgICAgICAgICAgICAgICBfdXNlUHRba10gPSBmYWxzZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBTaW1wbGlmeVNlY3Rpb24odmVydGljZXMsIGksIG1heEluZGV4KTtcclxuICAgICAgICAgICAgICAgIFNpbXBsaWZ5U2VjdGlvbih2ZXJ0aWNlcywgbWF4SW5kZXgsIGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBkb3VibGUgRGlzdGFuY2VQb2ludFBvaW50KFZlY3RvcjIgcCwgVmVjdG9yMiBwMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBkeCA9IHAuWCAtIHAyLlg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBkeSA9IHAuWSAtIHAyLlg7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLlNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZG91YmxlIERpc3RhbmNlUG9pbnRMaW5lKFZlY3RvcjIgcCwgVmVjdG9yMiBBLCBWZWN0b3IyIEIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBpZiBzdGFydCA9PSBlbmQsIHRoZW4gdXNlIHBvaW50LXRvLXBvaW50IGRpc3RhbmNlXHJcbiAgICAgICAgICAgIGlmIChBLlggPT0gQi5YICYmIEEuWSA9PSBCLlkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGlzdGFuY2VQb2ludFBvaW50KHAsIEEpO1xyXG5cclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHVzZSBjb21wLmdyYXBoaWNzLmFsZ29yaXRobXMgRnJlcXVlbnRseSBBc2tlZCBRdWVzdGlvbnMgbWV0aG9kXHJcbiAgICAgICAgICAgIC8qKDEpICAgICBcdCAgICAgIEFDIGRvdCBBQlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gICAtLS0tLS0tLS1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHxBQnx8XjJcclxuICAgICAgICAgICAgIFxyXG5cdFx0ICAgICAgICAgICAgICAgIHIgaGFzIHRoZSBmb2xsb3dpbmcgbWVhbmluZzpcclxuXHRcdCAgICAgICAgICAgICAgICByPTAgUG9pbnQgPSBBXHJcblx0XHQgICAgICAgICAgICAgICAgcj0xIFBvaW50ID0gQlxyXG5cdFx0ICAgICAgICAgICAgICAgIHI8MCBQb2ludCBpcyBvbiB0aGUgYmFja3dhcmQgZXh0ZW5zaW9uIG9mIEFCXHJcblx0XHQgICAgICAgICAgICAgICAgcj4xIFBvaW50IGlzIG9uIHRoZSBmb3J3YXJkIGV4dGVuc2lvbiBvZiBBQlxyXG5cdFx0ICAgICAgICAgICAgICAgIDA8cjwxIFBvaW50IGlzIGludGVyaW9yIHRvIEFCXHJcblx0ICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgZG91YmxlIHIgPSAoKHAuWCAtIEEuWCkgKiAoQi5YIC0gQS5YKSArIChwLlkgLSBBLlkpICogKEIuWSAtIEEuWSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICgoQi5YIC0gQS5YKSAqIChCLlggLSBBLlgpICsgKEIuWSAtIEEuWSkgKiAoQi5ZIC0gQS5ZKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAociA8PSAwLjApIHJldHVybiBEaXN0YW5jZVBvaW50UG9pbnQocCwgQSk7XHJcbiAgICAgICAgICAgIGlmIChyID49IDEuMCkgcmV0dXJuIERpc3RhbmNlUG9pbnRQb2ludChwLCBCKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvKigyKVxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICAoQXktQ3kpKEJ4LUF4KS0oQXgtQ3gpKEJ5LUF5KVxyXG5cdFx0ICAgICAgICAgICAgICAgIHMgPSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0ICAgICAgICAgICAgIFx0ICAgICAgICAgICAgICAgIEN1cnZlXjJcclxuXHJcblx0XHQgICAgICAgICAgICAgICAgVGhlbiB0aGUgZGlzdGFuY2UgZnJvbSBDIHRvIFBvaW50ID0gfHN8KkN1cnZlLlxyXG5cdCAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSBzID0gKChBLlkgLSBwLlkpICogKEIuWCAtIEEuWCkgLSAoQS5YIC0gcC5YKSAqIChCLlkgLSBBLlkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAoKEIuWCAtIEEuWCkgKiAoQi5YIC0gQS5YKSArIChCLlkgLSBBLlkpICogKEIuWSAtIEEuWSkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKHMpICogTWF0aC5TcXJ0KCgoQi5YIC0gQS5YKSAqIChCLlggLSBBLlgpICsgKEIuWSAtIEEuWSkgKiAoQi5ZIC0gQS5ZKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Gcm9tIHBoeXNpY3MyZC5uZXRcclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIFJlZHVjZUJ5QXJlYShWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgYXJlYVRvbGVyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8PSAzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFyZWFUb2xlcmFuY2UgPCAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwiYXJlYVRvbGVyYW5jZVwiLCBcIm11c3QgYmUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGVuIHplcm8uXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyByZXN1bHQgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MSwgdjIsIHYzO1xyXG4gICAgICAgICAgICBmbG9hdCBvbGQxLCBvbGQyLCBuZXcxO1xyXG4gICAgICAgICAgICB2MSA9IHZlcnRpY2VzW3ZlcnRpY2VzLkNvdW50IC0gMl07XHJcbiAgICAgICAgICAgIHYyID0gdmVydGljZXNbdmVydGljZXMuQ291bnQgLSAxXTtcclxuICAgICAgICAgICAgYXJlYVRvbGVyYW5jZSAqPSAyO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IDA7IGluZGV4IDwgdmVydGljZXMuQ291bnQ7ICsraW5kZXgsIHYyID0gdjMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB2ZXJ0aWNlcy5Db3VudCAtIDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5Db3VudCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImFyZWFUb2xlcmFuY2VcIiwgXCJUaGUgdG9sZXJhbmNlIGlzIHRvbyBoaWdoIVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdjMgPSByZXN1bHRbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdjMgPSB2ZXJ0aWNlc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHYxLCByZWYgdjIsIG91dCBvbGQxKTtcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgdjIsIHJlZiB2Mywgb3V0IG9sZDIpO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiB2MSwgcmVmIHYzLCBvdXQgbmV3MSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMobmV3MSAtIChvbGQxICsgb2xkMikpID4gYXJlYVRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQWRkKHYyKTtcclxuICAgICAgICAgICAgICAgICAgICB2MSA9IHYyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0Zyb20gRXJpYyBKb3JkYW4ncyBjb252ZXggZGVjb21wb3NpdGlvbiBsaWJyYXJ5XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTWVyZ2VzIGFsbCBwYXJhbGxlbCBlZGdlcyBpbiB0aGUgbGlzdCBvZiB2ZXJ0aWNlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgdmVydGljZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0b2xlcmFuY2VcIj5UaGUgdG9sZXJhbmNlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIE1lcmdlUGFyYWxsZWxFZGdlcyhWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgdG9sZXJhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLkNvdW50IDw9IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vQ2FuJ3QgZG8gYW55dGhpbmcgdXNlZnVsIGhlcmUgdG8gYSB0cmlhbmdsZVxyXG5cclxuICAgICAgICAgICAgYm9vbFtdIG1lcmdlTWUgPSBuZXcgYm9vbFt2ZXJ0aWNlcy5Db3VudF07XHJcbiAgICAgICAgICAgIGludCBuZXdOVmVydGljZXMgPSB2ZXJ0aWNlcy5Db3VudDtcclxuXHJcbiAgICAgICAgICAgIC8vR2F0aGVyIHBvaW50cyB0byBwcm9jZXNzXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGxvd2VyID0gKGkgPT0gMCkgPyAodmVydGljZXMuQ291bnQgLSAxKSA6IChpIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBpbnQgbWlkZGxlID0gaTtcclxuICAgICAgICAgICAgICAgIGludCB1cHBlciA9IChpID09IHZlcnRpY2VzLkNvdW50IC0gMSkgPyAoMCkgOiAoaSArIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGR4MCA9IHZlcnRpY2VzW21pZGRsZV0uWCAtIHZlcnRpY2VzW2xvd2VyXS5YO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZHkwID0gdmVydGljZXNbbWlkZGxlXS5ZIC0gdmVydGljZXNbbG93ZXJdLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkeDEgPSB2ZXJ0aWNlc1t1cHBlcl0uWSAtIHZlcnRpY2VzW21pZGRsZV0uWDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGR5MSA9IHZlcnRpY2VzW3VwcGVyXS5ZIC0gdmVydGljZXNbbWlkZGxlXS5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbm9ybTAgPSAoZmxvYXQpTWF0aC5TcXJ0KGR4MCAqIGR4MCArIGR5MCAqIGR5MCk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBub3JtMSA9IChmbG9hdClNYXRoLlNxcnQoZHgxICogZHgxICsgZHkxICogZHkxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIShub3JtMCA+IDAuMGYgJiYgbm9ybTEgPiAwLjBmKSAmJiBuZXdOVmVydGljZXMgPiAzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTWVyZ2UgaWRlbnRpY2FsIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlTWVbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC0tbmV3TlZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGR4MCAvPSBub3JtMDtcclxuICAgICAgICAgICAgICAgIGR5MCAvPSBub3JtMDtcclxuICAgICAgICAgICAgICAgIGR4MSAvPSBub3JtMTtcclxuICAgICAgICAgICAgICAgIGR5MSAvPSBub3JtMTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGNyb3NzID0gZHgwICogZHkxIC0gZHgxICogZHkwO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZG90ID0gZHgwICogZHgxICsgZHkwICogZHkxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLkFicyhjcm9zcykgPCB0b2xlcmFuY2UgJiYgZG90ID4gMCAmJiBuZXdOVmVydGljZXMgPiAzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlTWVbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC0tbmV3TlZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlTWVbaV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG5ld05WZXJ0aWNlcyA9PSB2ZXJ0aWNlcy5Db3VudCB8fCBuZXdOVmVydGljZXMgPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGludCBjdXJySW5kZXggPSAwO1xyXG5cclxuICAgICAgICAgICAgLy9Db3B5IHRoZSB2ZXJ0aWNlcyB0byBhIG5ldyBsaXN0IGFuZCBjbGVhciB0aGUgb2xkXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIG9sZFZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgdmVydGljZXMuQ2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgb2xkVmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlTWVbaV0gfHwgbmV3TlZlcnRpY2VzID09IDAgfHwgY3VyckluZGV4ID09IG5ld05WZXJ0aWNlcylcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoY3VyckluZGV4IDwgbmV3TlZlcnRpY2VzKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQob2xkVmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgKytjdXJySW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vTWlzY1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1lcmdlcyB0aGUgaWRlbnRpY2FsIHBvaW50cyBpbiB0aGUgcG9seWdvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIE1lcmdlSWRlbnRpY2FsUG9pbnRzKFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9XZSB1c2UgYSBkaWN0b25hcnkgaGVyZSBiZWNhdXNlIEhhc2hTZXQgaXMgbm90IGF2YWxpYWJsZSBvbiBhbGwgcGxhdGZvcm1zLlxyXG4gICAgICAgICAgICBIYXNoU2V0PFZlY3RvcjI+IHJlc3VsdHMgPSBuZXcgSGFzaFNldDxWZWN0b3IyPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLkFkZCh2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHJldHVyblJlc3VsdHMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgZm9yZWFjaCAoVmVjdG9yMiB2IGluIHJlc3VsdHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblJlc3VsdHMuQWRkKHYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuUmVzdWx0cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVkdWNlcyB0aGUgcG9seWdvbiBieSBkaXN0YW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGlzdGFuY2VcIj5UaGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMuIFBvaW50cyBjbG9zZXIgdGhhbiB0aGlzIHdpbGwgYmUgJ2pvaW5lZCcuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgUmVkdWNlQnlEaXN0YW5jZShWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGlzdGFuY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1dlIGNhbid0IHNpbXBsaWZ5IHBvbHlnb25zIHVuZGVyIDMgdmVydGljZXNcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLkNvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHNpbXBsaWZpZWQgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBjdXJyZW50ID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG5leHQgPSB2ZXJ0aWNlcy5OZXh0VmVydGV4KGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vSWYgdGhleSBhcmUgY2xvc2VyIHRoYW4gdGhlIGRpc3RhbmNlLCBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgaWYgKChuZXh0IC0gY3VycmVudCkuTGVuZ3RoU3F1YXJlZCgpIDw9IGRpc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQuQWRkKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2ltcGxpZmllZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVkdWNlcyB0aGUgcG9seWdvbiBieSByZW1vdmluZyB0aGUgTnRoIHZlcnRleCBpbiB0aGUgdmVydGljZXMgbGlzdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibnRoXCI+VGhlIE50aCBwb2ludCB0byByZW1vdmUuIEV4YW1wbGU6IDUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgUmVkdWNlQnlOdGgoVmVydGljZXMgdmVydGljZXMsIGludCBudGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1dlIGNhbid0IHNpbXBsaWZ5IHBvbHlnb25zIHVuZGVyIDMgdmVydGljZXNcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLkNvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgIGlmIChudGggPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHJlc3VsdCA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcy5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChpICUgbnRoID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkFkZCh2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uUG9seWdvbk1hbmlwdWxhdGlvblxyXG57XHJcbiAgICBpbnRlcm5hbCBlbnVtIFBvbHlDbGlwVHlwZVxyXG4gICAge1xyXG4gICAgICAgIEludGVyc2VjdCxcclxuICAgICAgICBVbmlvbixcclxuICAgICAgICBEaWZmZXJlbmNlXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGVudW0gUG9seUNsaXBFcnJvclxyXG4gICAge1xyXG4gICAgICAgIE5vbmUsXHJcbiAgICAgICAgRGVnZW5lcmF0ZWRPdXRwdXQsXHJcbiAgICAgICAgTm9uU2ltcGxlSW5wdXQsXHJcbiAgICAgICAgQnJva2VuUmVzdWx0XHJcbiAgICB9XHJcblxyXG4gICAgLy9DbGlwcGVyIGNvbnRyaWJ1dGVkIGJ5IEhlbGdlIEJhY2toYXVzXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBZdVBlbmdDbGlwcGVyXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBmbG9hdCBDbGlwcGVyRXBzaWxvblNxdWFyZWQgPSAxLjE5MjA5Mjg5NmUtMDdmO1xyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IFVuaW9uKFZlcnRpY2VzIHBvbHlnb24xLCBWZXJ0aWNlcyBwb2x5Z29uMiwgb3V0IFBvbHlDbGlwRXJyb3IgZXJyb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRXhlY3V0ZShwb2x5Z29uMSwgcG9seWdvbjIsIFBvbHlDbGlwVHlwZS5Vbmlvbiwgb3V0IGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxWZXJ0aWNlcz4gRGlmZmVyZW5jZShWZXJ0aWNlcyBwb2x5Z29uMSwgVmVydGljZXMgcG9seWdvbjIsIG91dCBQb2x5Q2xpcEVycm9yIGVycm9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV4ZWN1dGUocG9seWdvbjEsIHBvbHlnb24yLCBQb2x5Q2xpcFR5cGUuRGlmZmVyZW5jZSwgb3V0IGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxWZXJ0aWNlcz4gSW50ZXJzZWN0KFZlcnRpY2VzIHBvbHlnb24xLCBWZXJ0aWNlcyBwb2x5Z29uMiwgb3V0IFBvbHlDbGlwRXJyb3IgZXJyb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRXhlY3V0ZShwb2x5Z29uMSwgcG9seWdvbjIsIFBvbHlDbGlwVHlwZS5JbnRlcnNlY3QsIG91dCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEltcGxlbWVudHMgXCJBIG5ldyBhbGdvcml0aG0gZm9yIEJvb2xlYW4gb3BlcmF0aW9ucyBvbiBnZW5lcmFsIHBvbHlnb25zXCIgXHJcbiAgICAgICAgLy8vIGF2YWlsYWJsZSBoZXJlOiBodHRwOi8vbGlhbWEuaWEuYWMuY24vd2lraS9fbWVkaWEvdXNlcjpkb25nOmRvbmdfY2dfMDUucGRmXHJcbiAgICAgICAgLy8vIE1lcmdlcyB0d28gcG9seWdvbnMsIGEgc3ViamVjdCBhbmQgYSBjbGlwIHdpdGggdGhlIHNwZWNpZmllZCBvcGVyYXRpb24uIFBvbHlnb25zIG1heSBub3QgYmUgXHJcbiAgICAgICAgLy8vIHNlbGYtaW50ZXJzZWN0aW5nLlxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gV2FybmluZzogTWF5IHlpZWxkIGluY29ycmVjdCByZXN1bHRzIG9yIGV2ZW4gY3Jhc2ggaWYgcG9seWdvbnMgY29udGFpbiBjb2xsaW5lYXIgcG9pbnRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3ViamVjdFwiPlRoZSBzdWJqZWN0IHBvbHlnb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjbGlwXCI+VGhlIGNsaXAgcG9seWdvbiwgd2hpY2ggaXMgYWRkZWQsIFxyXG4gICAgICAgIC8vLyBzdWJzdHJhY3RlZCBvciBpbnRlcnNlY3RlZCB3aXRoIHRoZSBzdWJqZWN0PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjbGlwVHlwZVwiPlRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkLiBFaXRoZXJcclxuICAgICAgICAvLy8gVW5pb24sIERpZmZlcmVuY2Ugb3IgSW50ZXJzZWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXJyb3JcIj5UaGUgZXJyb3IgZ2VuZXJhdGVkIChpZiBhbnkpPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBsaXN0IG9mIGNsb3NlZCBwb2x5Z29ucywgd2hpY2ggbWFrZSB1cCB0aGUgcmVzdWx0IG9mIHRoZSBjbGlwcGluZyBvcGVyYXRpb24uXHJcbiAgICAgICAgLy8vIE91dGVyIGNvbnRvdXJzIGFyZSBvcmRlcmVkIGNvdW50ZXIgY2xvY2t3aXNlLCBob2xlcyBhcmUgb3JkZXJlZCBjbG9ja3dpc2UuPC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIExpc3Q8VmVydGljZXM+IEV4ZWN1dGUoVmVydGljZXMgc3ViamVjdCwgVmVydGljZXMgY2xpcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlDbGlwVHlwZSBjbGlwVHlwZSwgb3V0IFBvbHlDbGlwRXJyb3IgZXJyb3IpXHJcbiAgICAgICAge1xyXG4jaWYgIU5FVEZYX0NPUkVcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHN1YmplY3QuSXNTaW1wbGUoKSAmJiBjbGlwLklzU2ltcGxlKCksIFwiTm9uIHNpbXBsZSBpbnB1dCFcIiwgXCJJbnB1dCBwb2x5Z29ucyBtdXN0IGJlIHNpbXBsZSAoY2Fubm90IGludGVyc2VjdCB0aGVtc2VsdmVzKS5cIik7XHJcbiNlbmRpZlxyXG5cclxuICAgICAgICAgICAgLy8gQ29weSBwb2x5Z29uc1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBzbGljZWRTdWJqZWN0O1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBzbGljZWRDbGlwO1xyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGludGVyc2VjdGlvbiBhbmQgdG91Y2ggcG9pbnRzIGJldHdlZW5cclxuICAgICAgICAgICAgLy8gc3ViamVjdCBhbmQgY2xpcCBhbmQgYWRkIHRoZW0gdG8gYm90aFxyXG4gICAgICAgICAgICBDYWxjdWxhdGVJbnRlcnNlY3Rpb25zKHN1YmplY3QsIGNsaXAsIG91dCBzbGljZWRTdWJqZWN0LCBvdXQgc2xpY2VkQ2xpcCk7XHJcblxyXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgcG9seWdvbnMgaW50byB1cHBlciByaWdodCBxdWFkcmFudFxyXG4gICAgICAgICAgICAvLyBhcyB0aGUgYWxnb3JpdGhtIGRlcGVuZHMgb24gaXRcclxuICAgICAgICAgICAgVmVjdG9yMiBsYlN1YmplY3QgPSBzdWJqZWN0LkdldENvbGxpc2lvbkJveCgpLkxvd2VyQm91bmQ7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbGJDbGlwID0gY2xpcC5HZXRDb2xsaXNpb25Cb3goKS5Mb3dlckJvdW5kO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgVmVjdG9yMi5NaW4ocmVmIGxiU3ViamVjdCwgcmVmIGxiQ2xpcCwgb3V0IHRyYW5zbGF0ZSk7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZSA9IFZlY3RvcjIuT25lIC0gdHJhbnNsYXRlO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNsYXRlICE9IFZlY3RvcjIuWmVybylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2xpY2VkU3ViamVjdC5UcmFuc2xhdGUocmVmIHRyYW5zbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBzbGljZWRDbGlwLlRyYW5zbGF0ZShyZWYgdHJhbnNsYXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRW5mb3JjZSBjb3VudGVyY2xvY2t3aXNlIGNvbnRvdXJzXHJcbiAgICAgICAgICAgIHNsaWNlZFN1YmplY3QuRm9yY2VDb3VudGVyQ2xvY2tXaXNlKCk7XHJcbiAgICAgICAgICAgIHNsaWNlZENsaXAuRm9yY2VDb3VudGVyQ2xvY2tXaXNlKCk7XHJcblxyXG4gICAgICAgICAgICBMaXN0PEVkZ2U+IHN1YmplY3RTaW1wbGljZXM7XHJcbiAgICAgICAgICAgIExpc3Q8ZmxvYXQ+IHN1YmplY3RDb2VmZjtcclxuICAgICAgICAgICAgTGlzdDxFZGdlPiBjbGlwU2ltcGxpY2VzO1xyXG4gICAgICAgICAgICBMaXN0PGZsb2F0PiBjbGlwQ29lZmY7XHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIHNpbXBsaWNhbCBjaGFpbnMgZnJvbSB0aGUgcG9seWdvbnMgYW5kIGNhbGN1bGF0ZSB0aGVcclxuICAgICAgICAgICAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgIENhbGN1bGF0ZVNpbXBsaWNhbENoYWluKHNsaWNlZFN1YmplY3QsIG91dCBzdWJqZWN0Q29lZmYsIG91dCBzdWJqZWN0U2ltcGxpY2VzKTtcclxuICAgICAgICAgICAgQ2FsY3VsYXRlU2ltcGxpY2FsQ2hhaW4oc2xpY2VkQ2xpcCwgb3V0IGNsaXBDb2VmZiwgb3V0IGNsaXBTaW1wbGljZXMpO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxFZGdlPiByZXN1bHRTaW1wbGljZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNoYXJhY3RlcmlzdGljcyBmdW5jdGlvbiBmb3IgYWxsIG5vbi1vcmlnaW5hbCBlZGdlc1xyXG4gICAgICAgICAgICAvLyBpbiBzdWJqZWN0IGFuZCBjbGlwIHNpbXBsaWNhbCBjaGFpbiBhbmQgY29tYmluZSB0aGUgZWRnZXMgY29udHJpYnV0aW5nXHJcbiAgICAgICAgICAgIC8vIHRvIHRoZSByZXN1bHQsIGRlcGVuZGluZyBvbiB0aGUgY2xpcFR5cGVcclxuICAgICAgICAgICAgQ2FsY3VsYXRlUmVzdWx0Q2hhaW4oc3ViamVjdENvZWZmLCBzdWJqZWN0U2ltcGxpY2VzLCBjbGlwQ29lZmYsIGNsaXBTaW1wbGljZXMsIGNsaXBUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgcmVzdWx0U2ltcGxpY2VzKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHJlc3VsdDtcclxuICAgICAgICAgICAgLy8gQ29udmVydCByZXN1bHQgY2hhaW4gYmFjayB0byBwb2x5Z29uKHMpXHJcbiAgICAgICAgICAgIGVycm9yID0gQnVpbGRQb2x5Z29uc0Zyb21DaGFpbihyZXN1bHRTaW1wbGljZXMsIG91dCByZXN1bHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV2ZXJzZSB0aGUgcG9seWdvbiB0cmFuc2xhdGlvbiBmcm9tIHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgICAgLy8gYW5kIHJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGZyb20gb3V0cHV0XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZSAqPSAtMWY7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcmVzdWx0LkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5UcmFuc2xhdGUocmVmIHRyYW5zbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBTaW1wbGlmeVRvb2xzLkNvbGxpbmVhclNpbXBsaWZ5KHJlc3VsdFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyBhbGwgaW50ZXJzZWN0aW9ucyBiZXR3ZWVuIHR3byBwb2x5Z29ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHlnb24xXCI+VGhlIGZpcnN0IHBvbHlnb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2x5Z29uMlwiPlRoZSBzZWNvbmQgcG9seWdvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNsaWNlZFBvbHkxXCI+UmV0dXJucyB0aGUgZmlyc3QgcG9seWdvbiB3aXRoIGFkZGVkIGludGVyc2VjdGlvbiBwb2ludHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzbGljZWRQb2x5MlwiPlJldHVybnMgdGhlIHNlY29uZCBwb2x5Z29uIHdpdGggYWRkZWQgaW50ZXJzZWN0aW9uIHBvaW50cy48L3BhcmFtPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgQ2FsY3VsYXRlSW50ZXJzZWN0aW9ucyhWZXJ0aWNlcyBwb2x5Z29uMSwgVmVydGljZXMgcG9seWdvbjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBWZXJ0aWNlcyBzbGljZWRQb2x5MSwgb3V0IFZlcnRpY2VzIHNsaWNlZFBvbHkyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2xpY2VkUG9seTEgPSBuZXcgVmVydGljZXMocG9seWdvbjEpO1xyXG4gICAgICAgICAgICBzbGljZWRQb2x5MiA9IG5ldyBWZXJ0aWNlcyhwb2x5Z29uMik7XHJcblxyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggcG9seWdvbjEncyBlZGdlc1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHlnb24xLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBlZGdlIHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGEgPSBwb2x5Z29uMVtpXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYiA9IHBvbHlnb24xW3BvbHlnb24xLk5leHRJbmRleChpKV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IGludGVyc2VjdGlvbnMgYmV0d2VlbiB0aGlzIGVkZ2UgYW5kIHBvbHlnb24yXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IHBvbHlnb24yLkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBjID0gcG9seWdvbjJbal07XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gcG9seWdvbjJbcG9seWdvbjIuTmV4dEluZGV4KGopXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBpbnRlcnNlY3Rpb25Qb2ludDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZWRnZXMgaW50ZXJzZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpbmVUb29scy5MaW5lSW50ZXJzZWN0KGEsIGIsIGMsIGQsIG91dCBpbnRlcnNlY3Rpb25Qb2ludCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgYWxwaGEgdmFsdWVzIGZvciBzb3J0aW5nIG11bHRpcGxlIGludGVyc2VjdGlvbnMgcG9pbnRzIG9uIGEgZWRnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGludGVyc2VjdGlvbiBwb2ludCBpbnRvIGZpcnN0IHBvbHlnb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBHZXRBbHBoYShhLCBiLCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYSA+IDBmICYmIGFscGhhIDwgMWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBpbmRleCA9IHNsaWNlZFBvbHkxLkluZGV4T2YoYSkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgc2xpY2VkUG9seTEuQ291bnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHZXRBbHBoYShhLCBiLCBzbGljZWRQb2x5MVtpbmRleF0pIDw9IGFscGhhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZWRQb2x5MS5JbnNlcnQoaW5kZXgsIGludGVyc2VjdGlvblBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW50ZXJzZWN0aW9uIHBvaW50IGludG8gc2Vjb25kIHBvbHlnb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBHZXRBbHBoYShjLCBkLCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYSA+IDBmICYmIGFscGhhIDwgMWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBpbmRleCA9IHNsaWNlZFBvbHkyLkluZGV4T2YoYykgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgc2xpY2VkUG9seTIuQ291bnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHZXRBbHBoYShjLCBkLCBzbGljZWRQb2x5MltpbmRleF0pIDw9IGFscGhhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZWRQb2x5Mi5JbnNlcnQoaW5kZXgsIGludGVyc2VjdGlvblBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdmVyeSBzbWFsbCBlZGdlc1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHNsaWNlZFBvbHkxLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBpTmV4dCA9IHNsaWNlZFBvbHkxLk5leHRJbmRleChpKTtcclxuICAgICAgICAgICAgICAgIC8vSWYgdGhleSBhcmUgY2xvc2VyIHRoYW4gdGhlIGRpc3RhbmNlIHJlbW92ZSB2ZXJ0ZXhcclxuICAgICAgICAgICAgICAgIGlmICgoc2xpY2VkUG9seTFbaU5leHRdIC0gc2xpY2VkUG9seTFbaV0pLkxlbmd0aFNxdWFyZWQoKSA8PSBDbGlwcGVyRXBzaWxvblNxdWFyZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xpY2VkUG9seTEuUmVtb3ZlQXQoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgc2xpY2VkUG9seTIuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGlOZXh0ID0gc2xpY2VkUG9seTIuTmV4dEluZGV4KGkpO1xyXG4gICAgICAgICAgICAgICAgLy9JZiB0aGV5IGFyZSBjbG9zZXIgdGhhbiB0aGUgZGlzdGFuY2UgcmVtb3ZlIHZlcnRleFxyXG4gICAgICAgICAgICAgICAgaWYgKChzbGljZWRQb2x5MltpTmV4dF0gLSBzbGljZWRQb2x5MltpXSkuTGVuZ3RoU3F1YXJlZCgpIDw9IENsaXBwZXJFcHNpbG9uU3F1YXJlZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzbGljZWRQb2x5Mi5SZW1vdmVBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICAtLWk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgc2ltcGxpY2FsIGNoYWluIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlucHV0IHBvbHlnb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VXNlZCBieSBtZXRob2QgPGM+RXhlY3V0ZSgpPC9jPi48L3JlbWFya3M+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBDYWxjdWxhdGVTaW1wbGljYWxDaGFpbihWZXJ0aWNlcyBwb2x5LCBvdXQgTGlzdDxmbG9hdD4gY29lZmYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgTGlzdDxFZGdlPiBzaW1wbGljaWVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2ltcGxpY2llcyA9IG5ldyBMaXN0PEVkZ2U+KCk7XHJcbiAgICAgICAgICAgIGNvZWZmID0gbmV3IExpc3Q8ZmxvYXQ+KCk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcG9seS5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzaW1wbGljaWVzLkFkZChuZXcgRWRnZShwb2x5W2ldLCBwb2x5W3BvbHkuTmV4dEluZGV4KGkpXSkpO1xyXG4gICAgICAgICAgICAgICAgY29lZmYuQWRkKENhbGN1bGF0ZVNpbXBsZXhDb2VmZmljaWVudChWZWN0b3IyLlplcm8sIHBvbHlbaV0sIHBvbHlbcG9seS5OZXh0SW5kZXgoaSldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgY2hhcmFjdGVyaXN0aWNzIGZ1bmN0aW9uIGZvciBhbGwgZWRnZXMgb2ZcclxuICAgICAgICAvLy8gdGhlIGdpdmVuIHNpbXBsaWNhbCBjaGFpbnMgYW5kIGJ1aWxkcyB0aGUgcmVzdWx0IGNoYWluLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlVzZWQgYnkgbWV0aG9kIDxjPkV4ZWN1dGUoKTwvYz4uPC9yZW1hcmtzPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgQ2FsY3VsYXRlUmVzdWx0Q2hhaW4oTGlzdDxmbG9hdD4gcG9seTFDb2VmZiwgTGlzdDxFZGdlPiBwb2x5MVNpbXBsaWNpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3Q8ZmxvYXQ+IHBvbHkyQ29lZmYsIExpc3Q8RWRnZT4gcG9seTJTaW1wbGljaWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Q2xpcFR5cGUgY2xpcFR5cGUsIG91dCBMaXN0PEVkZ2U+IHJlc3VsdFNpbXBsaWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc3VsdFNpbXBsaWNlcyA9IG5ldyBMaXN0PEVkZ2U+KCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHkxU2ltcGxpY2llcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBlZGdlQ2hhcmFjdGVyID0gMGY7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9seTJTaW1wbGljaWVzLkNvbnRhaW5zKHBvbHkxU2ltcGxpY2llc1tpXSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAocG9seTJTaW1wbGljaWVzLkNvbnRhaW5zKC1wb2x5MVNpbXBsaWNpZXNbaV0pICYmIGNsaXBUeXBlID09IFBvbHlDbGlwVHlwZS5VbmlvbikpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZUNoYXJhY3RlciA9IDFmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgcG9seTJTaW1wbGljaWVzLkNvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvbHkyU2ltcGxpY2llcy5Db250YWlucygtcG9seTFTaW1wbGljaWVzW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZUNoYXJhY3RlciArPSBDYWxjdWxhdGVCZXRhKHBvbHkxU2ltcGxpY2llc1tpXS5HZXRDZW50ZXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5MlNpbXBsaWNpZXNbal0sIHBvbHkyQ29lZmZbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsaXBUeXBlID09IFBvbHlDbGlwVHlwZS5JbnRlcnNlY3QpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkZ2VDaGFyYWN0ZXIgPT0gMWYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTaW1wbGljZXMuQWRkKHBvbHkxU2ltcGxpY2llc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlQ2hhcmFjdGVyID09IDBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2ltcGxpY2VzLkFkZChwb2x5MVNpbXBsaWNpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHkyU2ltcGxpY2llcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFNpbXBsaWNlcy5Db250YWlucyhwb2x5MlNpbXBsaWNpZXNbaV0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXJlc3VsdFNpbXBsaWNlcy5Db250YWlucygtcG9seTJTaW1wbGljaWVzW2ldKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBlZGdlQ2hhcmFjdGVyID0gMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHkxU2ltcGxpY2llcy5Db250YWlucyhwb2x5MlNpbXBsaWNpZXNbaV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwb2x5MVNpbXBsaWNpZXMuQ29udGFpbnMoLXBvbHkyU2ltcGxpY2llc1tpXSkgJiYgY2xpcFR5cGUgPT0gUG9seUNsaXBUeXBlLlVuaW9uKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VDaGFyYWN0ZXIgPSAxZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBwb2x5MVNpbXBsaWNpZXMuQ291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2x5MVNpbXBsaWNpZXMuQ29udGFpbnMoLXBvbHkyU2ltcGxpY2llc1tpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZUNoYXJhY3RlciArPSBDYWxjdWxhdGVCZXRhKHBvbHkyU2ltcGxpY2llc1tpXS5HZXRDZW50ZXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seTFTaW1wbGljaWVzW2pdLCBwb2x5MUNvZWZmW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcFR5cGUgPT0gUG9seUNsaXBUeXBlLkludGVyc2VjdCB8fCBjbGlwVHlwZSA9PSBQb2x5Q2xpcFR5cGUuRGlmZmVyZW5jZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGdlQ2hhcmFjdGVyID09IDFmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTaW1wbGljZXMuQWRkKC1wb2x5MlNpbXBsaWNpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGdlQ2hhcmFjdGVyID09IDBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTaW1wbGljZXMuQWRkKHBvbHkyU2ltcGxpY2llc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsY3VsYXRlcyB0aGUgcG9seWdvbihzKSBmcm9tIHRoZSByZXN1bHQgc2ltcGxpY2FsIGNoYWluLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlVzZWQgYnkgbWV0aG9kIDxjPkV4ZWN1dGUoKTwvYz4uPC9yZW1hcmtzPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFBvbHlDbGlwRXJyb3IgQnVpbGRQb2x5Z29uc0Zyb21DaGFpbihMaXN0PEVkZ2U+IHNpbXBsaWNpZXMsIG91dCBMaXN0PFZlcnRpY2VzPiByZXN1bHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuICAgICAgICAgICAgUG9seUNsaXBFcnJvciBlcnJWYWwgPSBQb2x5Q2xpcEVycm9yLk5vbmU7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoc2ltcGxpY2llcy5Db3VudCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzIG91dHB1dCA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LkFkZChzaW1wbGljaWVzWzBdLkVkZ2VTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuQWRkKHNpbXBsaWNpZXNbMF0uRWRnZUVuZCk7XHJcbiAgICAgICAgICAgICAgICBzaW1wbGljaWVzLlJlbW92ZUF0KDApO1xyXG4gICAgICAgICAgICAgICAgYm9vbCBjbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGludCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpbnQgY291bnQgPSBzaW1wbGljaWVzLkNvdW50OyAvLyBOZWVkZWQgdG8gY2F0Y2ggaW5maW5pdGUgbG9vcHNcclxuICAgICAgICAgICAgICAgIHdoaWxlICghY2xvc2VkICYmIHNpbXBsaWNpZXMuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChWZWN0b3JFcXVhbChvdXRwdXRbb3V0cHV0LkNvdW50IC0gMV0sIHNpbXBsaWNpZXNbaW5kZXhdLkVkZ2VTdGFydCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmVjdG9yRXF1YWwoc2ltcGxpY2llc1tpbmRleF0uRWRnZUVuZCwgb3V0cHV0WzBdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5BZGQoc2ltcGxpY2llc1tpbmRleF0uRWRnZUVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxpY2llcy5SZW1vdmVBdChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFZlY3RvckVxdWFsKG91dHB1dFtvdXRwdXQuQ291bnQgLSAxXSwgc2ltcGxpY2llc1tpbmRleF0uRWRnZUVuZCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmVjdG9yRXF1YWwoc2ltcGxpY2llc1tpbmRleF0uRWRnZVN0YXJ0LCBvdXRwdXRbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LkFkZChzaW1wbGljaWVzW2luZGV4XS5FZGdlU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsaWNpZXMuUmVtb3ZlQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtLWluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2luZGV4ID09IHNpbXBsaWNpZXMuQ291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSBzaW1wbGljaWVzLkNvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShcIlVuZGVmaW5lZCBlcnJvciB3aGlsZSBidWlsZGluZyByZXN1bHQgcG9seWdvbihzKS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBvbHlDbGlwRXJyb3IuQnJva2VuUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSBzaW1wbGljaWVzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyVmFsID0gUG9seUNsaXBFcnJvci5EZWdlbmVyYXRlZE91dHB1dDtcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJEZWdlbmVyYXRlZCBvdXRwdXQgcG9seWdvbiBwcm9kdWNlZCAodmVydGljZXMgPCAzKS5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQWRkKG91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVyclZhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmVlZGVkIHRvIGNhbGN1bGF0ZSB0aGUgY2hhcmFjdGVyaXN0aWNzIGZ1bmN0aW9uIG9mIGEgc2ltcGxleC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5Vc2VkIGJ5IG1ldGhvZCA8Yz5DYWxjdWxhdGVFZGdlQ2hhcmFjdGVyKCk8L2M+LjwvcmVtYXJrcz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBDYWxjdWxhdGVCZXRhKFZlY3RvcjIgcG9pbnQsIEVkZ2UgZSwgZmxvYXQgY29lZmZpY2llbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCByZXN1bHQgPSAwZjtcclxuICAgICAgICAgICAgaWYgKFBvaW50SW5TaW1wbGV4KHBvaW50LCBlKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29lZmZpY2llbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFBvaW50T25MaW5lU2VnbWVudChWZWN0b3IyLlplcm8sIGUuRWRnZVN0YXJ0LCBwb2ludCkgfHxcclxuICAgICAgICAgICAgICAgIFBvaW50T25MaW5lU2VnbWVudChWZWN0b3IyLlplcm8sIGUuRWRnZUVuZCwgcG9pbnQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAuNWYgKiBjb2VmZmljaWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOZWVkZWQgZm9yIHNvcnRpbmcgbXVsdGlwbGUgaW50ZXJzZWN0aW9ucyBwb2ludHMgb24gdGhlIHNhbWUgZWRnZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5Vc2VkIGJ5IG1ldGhvZCA8Yz5DYWxjdWxhdGVJbnRlcnNlY3Rpb25zKCk8L2M+LjwvcmVtYXJrcz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBHZXRBbHBoYShWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZCwgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAocG9pbnQgLSBzdGFydCkuTGVuZ3RoU3F1YXJlZCgpIC8gKGVuZCAtIHN0YXJ0KS5MZW5ndGhTcXVhcmVkKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgdGhlIGNvZWZmaWNpZW50IG9mIGEgc2ltcGxleC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5Vc2VkIGJ5IG1ldGhvZCA8Yz5DYWxjdWxhdGVTaW1wbGljYWxDaGFpbigpPC9jPi48L3JlbWFya3M+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgQ2FsY3VsYXRlU2ltcGxleENvZWZmaWNpZW50KFZlY3RvcjIgYSwgVmVjdG9yMiBiLCBWZWN0b3IyIGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBpc0xlZnQgPSBNYXRoVXRpbHMuQXJlYShyZWYgYSwgcmVmIGIsIHJlZiBjKTtcclxuICAgICAgICAgICAgaWYgKGlzTGVmdCA8IDBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTFmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNMZWZ0ID4gMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIDBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBXaW5kaW5nIG51bWJlciB0ZXN0IGZvciBhIHBvaW50IGluIGEgc2ltcGxleC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+VGhlIHBvaW50IHRvIGJlIHRlc3RlZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVkZ2VcIj5UaGUgZWRnZSB0aGF0IHRoZSBwb2ludCBpcyB0ZXN0ZWQgYWdhaW5zdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5GYWxzZSBpZiB0aGUgd2luZGluZyBudW1iZXIgaXMgZXZlbiBhbmQgdGhlIHBvaW50IGlzIG91dHNpZGVcclxuICAgICAgICAvLy8gdGhlIHNpbXBsZXggYW5kIFRydWUgb3RoZXJ3aXNlLjwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIFBvaW50SW5TaW1wbGV4KFZlY3RvcjIgcG9pbnQsIEVkZ2UgZWRnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHBvbHlnb24gPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgcG9seWdvbi5BZGQoVmVjdG9yMi5aZXJvKTtcclxuICAgICAgICAgICAgcG9seWdvbi5BZGQoZWRnZS5FZGdlU3RhcnQpO1xyXG4gICAgICAgICAgICBwb2x5Z29uLkFkZChlZGdlLkVkZ2VFbmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHBvbHlnb24uUG9pbnRJblBvbHlnb24ocmVmIHBvaW50KSA9PSAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGVzdHMgaWYgYSBwb2ludCBsaWVzIG9uIGEgbGluZSBzZWdtZW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlVzZWQgYnkgbWV0aG9kIDxjPkNhbGN1bGF0ZUJldGEoKTwvYz4uPC9yZW1hcmtzPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgUG9pbnRPbkxpbmVTZWdtZW50KFZlY3RvcjIgc3RhcnQsIFZlY3RvcjIgZW5kLCBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBzZWdtZW50ID0gZW5kIC0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuQXJlYShyZWYgc3RhcnQsIHJlZiBlbmQsIHJlZiBwb2ludCkgPT0gMGYgJiZcclxuICAgICAgICAgICAgICAgICAgIFZlY3RvcjIuRG90KHBvaW50IC0gc3RhcnQsIHNlZ21lbnQpID49IDBmICYmXHJcbiAgICAgICAgICAgICAgICAgICBWZWN0b3IyLkRvdChwb2ludCAtIGVuZCwgc2VnbWVudCkgPD0gMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIFZlY3RvckVxdWFsKFZlY3RvcjIgdmVjMSwgVmVjdG9yMiB2ZWMyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuICh2ZWMyIC0gdmVjMSkuTGVuZ3RoU3F1YXJlZCgpIDw9IENsaXBwZXJFcHNpbG9uU3F1YXJlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gTmVzdGVkIHR5cGU6IEVkZ2VcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlNwZWNpZmllcyBhbiBFZGdlLiBFZGdlcyBhcmUgdXNlZCB0byByZXByZXNlbnQgc2ltcGxpY2llcyBpbiBzaW1wbGljYWwgY2hhaW5zPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc2VhbGVkIGNsYXNzIEVkZ2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHB1YmxpYyBFZGdlKFZlY3RvcjIgZWRnZVN0YXJ0LCBWZWN0b3IyIGVkZ2VFbmQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEVkZ2VTdGFydCA9IGVkZ2VTdGFydDtcclxuICAgICAgICAgICAgICAgIEVkZ2VFbmQgPSBlZGdlRW5kO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yMiBFZGdlU3RhcnQgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcbiAgICAgICAgICAgIHB1YmxpYyBWZWN0b3IyIEVkZ2VFbmQgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRDZW50ZXIoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKEVkZ2VTdGFydCArIEVkZ2VFbmQpIC8gMmY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBzdGF0aWMgRWRnZSBvcGVyYXRvciAtKEVkZ2UgZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFZGdlKGUuRWRnZUVuZCwgZS5FZGdlU3RhcnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBFcXVhbHMoT2JqZWN0IG9iailcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgcGFyYW1ldGVyIGlzIG51bGwgcmV0dXJuIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXJhbWV0ZXIgY2Fubm90IGJlIGNhc3QgdG8gUG9pbnQgcmV0dXJuIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVxdWFscyhvYmogYXMgRWRnZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBib29sIEVxdWFscyhFZGdlIGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHBhcmFtZXRlciBpcyBudWxsIHJldHVybiBmYWxzZTpcclxuICAgICAgICAgICAgICAgIGlmIChlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBmaWVsZHMgbWF0Y2hcclxuICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3JFcXVhbChFZGdlU3RhcnQsIGUuRWRnZVN0YXJ0KSAmJiBWZWN0b3JFcXVhbChFZGdlRW5kLCBlLkVkZ2VFbmQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IEdldEhhc2hDb2RlKClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkZ2VTdGFydC5HZXRIYXNoQ29kZSgpIF4gRWRnZUVuZC5HZXRIYXNoQ29kZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vblxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIFBvbHlnb25Ub29sc1xyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQnVpbGQgdmVydGljZXMgdG8gcmVwcmVzZW50IGFuIGF4aXMtYWxpZ25lZCBib3guXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoeFwiPnRoZSBoYWxmLXdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaHlcIj50aGUgaGFsZi1oZWlnaHQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZVJlY3RhbmdsZShmbG9hdCBoeCwgZmxvYXQgaHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyg0KTtcclxuICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKC1oeCwgLWh5KSk7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMihoeCwgLWh5KSk7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMihoeCwgaHkpKTtcclxuICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKC1oeCwgaHkpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQnVpbGQgdmVydGljZXMgdG8gcmVwcmVzZW50IGFuIG9yaWVudGVkIGJveC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImh4XCI+dGhlIGhhbGYtd2lkdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoeVwiPnRoZSBoYWxmLWhlaWdodC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNlbnRlclwiPnRoZSBjZW50ZXIgb2YgdGhlIGJveCBpbiBsb2NhbCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFuZ2xlXCI+dGhlIHJvdGF0aW9uIG9mIHRoZSBib3ggaW4gbG9jYWwgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZVJlY3RhbmdsZShmbG9hdCBoeCwgZmxvYXQgaHksIFZlY3RvcjIgY2VudGVyLCBmbG9hdCBhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRpY2VzID0gQ3JlYXRlUmVjdGFuZ2xlKGh4LCBoeSk7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYgPSBuZXcgVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIHhmLlBvc2l0aW9uID0gY2VudGVyO1xyXG4gICAgICAgICAgICB4Zi5SLlNldChhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdmVydGljZXNcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2ldID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZiwgdmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1JvdW5kZWQgcmVjdGFuZ2xlIGNvbnRyaWJ1dGVkIGJ5IEpvbmF0aGFuIFNtYXJzIC0ganNtYXJzQGdtYWlsLmNvbVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSByb3VuZGVkIHJlY3RhbmdsZSB3aXRoIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndpZHRoXCI+VGhlIHdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaGVpZ2h0XCI+VGhlIGhlaWdodC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhSYWRpdXNcIj5UaGUgcm91bmRpbmcgWCByYWRpdXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ5UmFkaXVzXCI+VGhlIHJvdW5kaW5nIFkgcmFkaXVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2VnbWVudHNcIj5UaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIHN1YmRpdmlkZSB0aGUgZWRnZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgQ3JlYXRlUm91bmRlZFJlY3RhbmdsZShmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCB4UmFkaXVzLCBmbG9hdCB5UmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgc2VnbWVudHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoeVJhZGl1cyA+IGhlaWdodCAvIDIgfHwgeFJhZGl1cyA+IHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJSb3VuZGluZyBhbW91bnQgY2FuJ3QgYmUgbW9yZSB0aGFuIGhhbGYgdGhlIGhlaWdodCBhbmQgd2lkdGggcmVzcGVjdGl2ZWx5LlwiKTtcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnRzIDwgMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJTZWdtZW50cyBtdXN0IGJlIHplcm8gb3IgbW9yZS5cIik7XHJcblxyXG4gICAgICAgICAgICAvL1dlIG5lZWQgYXQgbGVhc3QgOCB2ZXJ0aWNlcyB0byBjcmVhdGUgYSByb3VuZGVkIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzID49IDgpO1xyXG5cclxuICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnRzID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMih3aWR0aCAqIC41ZiAtIHhSYWRpdXMsIC1oZWlnaHQgKiAuNWYpKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMih3aWR0aCAqIC41ZiwgLWhlaWdodCAqIC41ZiArIHlSYWRpdXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIod2lkdGggKiAuNWYsIGhlaWdodCAqIC41ZiAtIHlSYWRpdXMpKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMih3aWR0aCAqIC41ZiAtIHhSYWRpdXMsIGhlaWdodCAqIC41ZikpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMigtd2lkdGggKiAuNWYgKyB4UmFkaXVzLCBoZWlnaHQgKiAuNWYpKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMigtd2lkdGggKiAuNWYsIGhlaWdodCAqIC41ZiAtIHlSYWRpdXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoLXdpZHRoICogLjVmLCAtaGVpZ2h0ICogLjVmICsgeVJhZGl1cykpO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKC13aWR0aCAqIC41ZiArIHhSYWRpdXMsIC1oZWlnaHQgKiAuNWYpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBudW1iZXJPZkVkZ2VzID0gKHNlZ21lbnRzICogNCArIDgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHN0ZXBTaXplID0gTWF0aEhlbHBlci5Ud29QaSAvIChudW1iZXJPZkVkZ2VzIC0gNCk7XHJcbiAgICAgICAgICAgICAgICBpbnQgcGVyUGhhc2UgPSBudW1iZXJPZkVkZ2VzIC8gNDtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBvc09mZnNldCA9IG5ldyBWZWN0b3IyKHdpZHRoIC8gMiAtIHhSYWRpdXMsIGhlaWdodCAvIDIgLSB5UmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChwb3NPZmZzZXQgKyBuZXcgVmVjdG9yMih4UmFkaXVzLCAteVJhZGl1cyArIHlSYWRpdXMpKTtcclxuICAgICAgICAgICAgICAgIHNob3J0IHBoYXNlID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgbnVtYmVyT2ZFZGdlczsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpIC0gcGVyUGhhc2UgPT0gMCB8fCBpIC0gcGVyUGhhc2UgKiAzID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NPZmZzZXQuWCAqPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGhhc2UtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSAtIHBlclBoYXNlICogMiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zT2Zmc2V0LlkgKj0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQocG9zT2Zmc2V0ICsgbmV3IFZlY3RvcjIoeFJhZGl1cyAqIChmbG9hdClNYXRoLkNvcyhzdGVwU2l6ZSAqIC0oaSArIHBoYXNlKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC15UmFkaXVzICogKGZsb2F0KU1hdGguU2luKHN0ZXBTaXplICogLShpICsgcGhhc2UpKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGlzIGFzIGEgc2luZ2xlIGVkZ2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdGFydFwiPlRoZSBmaXJzdCBwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVuZFwiPlRoZSBzZWNvbmQgcG9pbnQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZUxpbmUoVmVjdG9yMiBzdGFydCwgVmVjdG9yMiBlbmQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygyKTtcclxuICAgICAgICAgICAgdmVydGljZXMuQWRkKHN0YXJ0KTtcclxuICAgICAgICAgICAgdmVydGljZXMuQWRkKGVuZCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBjaXJjbGUgd2l0aCB0aGUgc3BlY2lmaWVkIHJhZGl1cyBhbmQgbnVtYmVyIG9mIGVkZ2VzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmFkaXVzXCI+VGhlIHJhZGl1cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm51bWJlck9mRWRnZXNcIj5UaGUgbnVtYmVyIG9mIGVkZ2VzLiBUaGUgbW9yZSBlZGdlcywgdGhlIG1vcmUgaXQgcmVzZW1ibGVzIGEgY2lyY2xlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgQ3JlYXRlQ2lyY2xlKGZsb2F0IHJhZGl1cywgaW50IG51bWJlck9mRWRnZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlRWxsaXBzZShyYWRpdXMsIHJhZGl1cywgbnVtYmVyT2ZFZGdlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBlbGxpcHNlIHdpdGggdGhlIHNwZWNpZmllZCB3aWR0aCwgaGVpZ2h0IGFuZCBudW1iZXIgb2YgZWRnZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4UmFkaXVzXCI+V2lkdGggb2YgdGhlIGVsbGlwc2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ5UmFkaXVzXCI+SGVpZ2h0IG9mIHRoZSBlbGxpcHNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibnVtYmVyT2ZFZGdlc1wiPlRoZSBudW1iZXIgb2YgZWRnZXMuIFRoZSBtb3JlIGVkZ2VzLCB0aGUgbW9yZSBpdCByZXNlbWJsZXMgYW4gZWxsaXBzZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZUVsbGlwc2UoZmxvYXQgeFJhZGl1cywgZmxvYXQgeVJhZGl1cywgaW50IG51bWJlck9mRWRnZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgc3RlcFNpemUgPSBNYXRoSGVscGVyLlR3b1BpIC8gbnVtYmVyT2ZFZGdlcztcclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMih4UmFkaXVzLCAwKSk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBudW1iZXJPZkVkZ2VzIC0gMTsgaSA+IDA7IC0taSlcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMih4UmFkaXVzICogKGZsb2F0KU1hdGguQ29zKHN0ZXBTaXplICogaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLXlSYWRpdXMgKiAoZmxvYXQpTWF0aC5TaW4oc3RlcFNpemUgKiBpKSkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVBcmMoZmxvYXQgcmFkaWFucywgaW50IHNpZGVzLCBmbG9hdCByYWRpdXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQocmFkaWFucyA+IDAsIFwiVGhlIGFyYyBuZWVkcyB0byBiZSBsYXJnZXIgdGhhbiAwXCIpO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoc2lkZXMgPiAxLCBcIlRoZSBhcmMgbmVlZHMgdG8gaGF2ZSBtb3JlIHRoYW4gMSBzaWRlc1wiKTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHJhZGl1cyA+IDAsIFwiVGhlIGFyYyBuZWVkcyB0byBoYXZlIGEgcmFkaXVzIGxhcmdlciB0aGFuIDBcIik7XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgc3RlcFNpemUgPSByYWRpYW5zIC8gc2lkZXM7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBzaWRlcyAtIDE7IGkgPiAwOyBpLS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMihyYWRpdXMgKiAoZmxvYXQpTWF0aC5Db3Moc3RlcFNpemUgKiBpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMgKiAoZmxvYXQpTWF0aC5TaW4oc3RlcFNpemUgKiBpKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0NhcHN1bGUgY29udHJpYnV0ZWQgYnkgWW9iaXZcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGFuIGNhcHN1bGUgd2l0aCB0aGUgc3BlY2lmaWVkIGhlaWdodCwgcmFkaXVzIGFuZCBudW1iZXIgb2YgZWRnZXMuXHJcbiAgICAgICAgLy8vIEEgY2Fwc3VsZSBoYXMgdGhlIHNhbWUgZm9ybSBhcyBhIHBpbGwgY2Fwc3VsZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImhlaWdodFwiPkhlaWdodCAoaW5uZXIgaGVpZ2h0ICsgMiAqIHJhZGl1cykgb2YgdGhlIGNhcHN1bGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlbmRSYWRpdXNcIj5SYWRpdXMgb2YgdGhlIGNhcHN1bGUgZW5kcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVkZ2VzXCI+VGhlIG51bWJlciBvZiBlZGdlcyBvZiB0aGUgY2Fwc3VsZSBlbmRzLiBUaGUgbW9yZSBlZGdlcywgdGhlIG1vcmUgaXQgcmVzZW1ibGVzIGFuIGNhcHN1bGU8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVDYXBzdWxlKGZsb2F0IGhlaWdodCwgZmxvYXQgZW5kUmFkaXVzLCBpbnQgZWRnZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZW5kUmFkaXVzID49IGhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgXCJUaGUgcmFkaXVzIG11c3QgYmUgbG93ZXIgdGhhbiBoZWlnaHQgLyAyLiBIaWdoZXIgdmFsdWVzIG9mIHJhZGl1cyB3b3VsZCBjcmVhdGUgYSBjaXJjbGUsIGFuZCBub3QgYSBoYWxmIGNpcmNsZS5cIixcclxuICAgICAgICAgICAgICAgICAgICBcImVuZFJhZGl1c1wiKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDYXBzdWxlKGhlaWdodCwgZW5kUmFkaXVzLCBlZGdlcywgZW5kUmFkaXVzLCBlZGdlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYW4gY2Fwc3VsZSB3aXRoIHRoZSBzcGVjaWZpZWQgIGhlaWdodCwgcmFkaXVzIGFuZCBudW1iZXIgb2YgZWRnZXMuXHJcbiAgICAgICAgLy8vIEEgY2Fwc3VsZSBoYXMgdGhlIHNhbWUgZm9ybSBhcyBhIHBpbGwgY2Fwc3VsZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImhlaWdodFwiPkhlaWdodCAoaW5uZXIgaGVpZ2h0ICsgcmFkaWkpIG9mIHRoZSBjYXBzdWxlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidG9wUmFkaXVzXCI+UmFkaXVzIG9mIHRoZSB0b3AuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0b3BFZGdlc1wiPlRoZSBudW1iZXIgb2YgZWRnZXMgb2YgdGhlIHRvcC4gVGhlIG1vcmUgZWRnZXMsIHRoZSBtb3JlIGl0IHJlc2VtYmxlcyBhbiBjYXBzdWxlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib3R0b21SYWRpdXNcIj5SYWRpdXMgb2YgYm90dG9tLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm90dG9tRWRnZXNcIj5UaGUgbnVtYmVyIG9mIGVkZ2VzIG9mIHRoZSBib3R0b20uIFRoZSBtb3JlIGVkZ2VzLCB0aGUgbW9yZSBpdCByZXNlbWJsZXMgYW4gY2Fwc3VsZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZUNhcHN1bGUoZmxvYXQgaGVpZ2h0LCBmbG9hdCB0b3BSYWRpdXMsIGludCB0b3BFZGdlcywgZmxvYXQgYm90dG9tUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgYm90dG9tRWRnZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDw9IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJIZWlnaHQgbXVzdCBiZSBsb25nZXIgdGhhbiAwXCIsIFwiaGVpZ2h0XCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRvcFJhZGl1cyA8PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiVGhlIHRvcCByYWRpdXMgbXVzdCBiZSBtb3JlIHRoYW4gMFwiLCBcInRvcFJhZGl1c1wiKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0b3BFZGdlcyA8PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9wIGVkZ2VzIG11c3QgYmUgbW9yZSB0aGFuIDBcIiwgXCJ0b3BFZGdlc1wiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChib3R0b21SYWRpdXMgPD0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlRoZSBib3R0b20gcmFkaXVzIG11c3QgYmUgbW9yZSB0aGFuIDBcIiwgXCJib3R0b21SYWRpdXNcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoYm90dG9tRWRnZXMgPD0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIkJvdHRvbSBlZGdlcyBtdXN0IGJlIG1vcmUgdGhhbiAwXCIsIFwiYm90dG9tRWRnZXNcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAodG9wUmFkaXVzID49IGhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgXCJUaGUgdG9wIHJhZGl1cyBtdXN0IGJlIGxvd2VyIHRoYW4gaGVpZ2h0IC8gMi4gSGlnaGVyIHZhbHVlcyBvZiB0b3AgcmFkaXVzIHdvdWxkIGNyZWF0ZSBhIGNpcmNsZSwgYW5kIG5vdCBhIGhhbGYgY2lyY2xlLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidG9wUmFkaXVzXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvdHRvbVJhZGl1cyA+PSBoZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlIGJvdHRvbSByYWRpdXMgbXVzdCBiZSBsb3dlciB0aGFuIGhlaWdodCAvIDIuIEhpZ2hlciB2YWx1ZXMgb2YgYm90dG9tIHJhZGl1cyB3b3VsZCBjcmVhdGUgYSBjaXJjbGUsIGFuZCBub3QgYSBoYWxmIGNpcmNsZS5cIixcclxuICAgICAgICAgICAgICAgICAgICBcImJvdHRvbVJhZGl1c1wiKTtcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBuZXdIZWlnaHQgPSAoaGVpZ2h0IC0gdG9wUmFkaXVzIC0gYm90dG9tUmFkaXVzKSAqIDAuNWY7XHJcblxyXG4gICAgICAgICAgICAvLyB0b3BcclxuICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKHRvcFJhZGl1cywgbmV3SGVpZ2h0KSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBzdGVwU2l6ZSA9IE1hdGhIZWxwZXIuUGkgLyB0b3BFZGdlcztcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCB0b3BFZGdlczsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIodG9wUmFkaXVzICogKGZsb2F0KU1hdGguQ29zKHN0ZXBTaXplICogaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wUmFkaXVzICogKGZsb2F0KU1hdGguU2luKHN0ZXBTaXplICogaSkgKyBuZXdIZWlnaHQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKC10b3BSYWRpdXMsIG5ld0hlaWdodCkpO1xyXG5cclxuICAgICAgICAgICAgLy8gYm90dG9tXHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMigtYm90dG9tUmFkaXVzLCAtbmV3SGVpZ2h0KSk7XHJcblxyXG4gICAgICAgICAgICBzdGVwU2l6ZSA9IE1hdGhIZWxwZXIuUGkgLyBib3R0b21FZGdlcztcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBib3R0b21FZGdlczsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoLWJvdHRvbVJhZGl1cyAqIChmbG9hdClNYXRoLkNvcyhzdGVwU2l6ZSAqIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1ib3R0b21SYWRpdXMgKiAoZmxvYXQpTWF0aC5TaW4oc3RlcFNpemUgKiBpKSAtIG5ld0hlaWdodCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoYm90dG9tUmFkaXVzLCAtbmV3SGVpZ2h0KSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBnZWFyIHNoYXBlIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMgYW5kIG51bWJlciBvZiB0ZWV0aC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJhZGl1c1wiPlRoZSByYWRpdXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJudW1iZXJPZlRlZXRoXCI+VGhlIG51bWJlciBvZiB0ZWV0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRpcFBlcmNlbnRhZ2VcIj5UaGUgdGlwIHBlcmNlbnRhZ2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0b290aEhlaWdodFwiPkhlaWdodCBvZiB0aGUgdG9vdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgQ3JlYXRlR2VhcihmbG9hdCByYWRpdXMsIGludCBudW1iZXJPZlRlZXRoLCBmbG9hdCB0aXBQZXJjZW50YWdlLCBmbG9hdCB0b290aEhlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBzdGVwU2l6ZSA9IE1hdGhIZWxwZXIuVHdvUGkgLyBudW1iZXJPZlRlZXRoO1xyXG4gICAgICAgICAgICB0aXBQZXJjZW50YWdlIC89IDEwMGY7XHJcbiAgICAgICAgICAgIE1hdGhIZWxwZXIuQ2xhbXAodGlwUGVyY2VudGFnZSwgMGYsIDFmKTtcclxuICAgICAgICAgICAgZmxvYXQgdG9vdGhUaXBTdGVwU2l6ZSA9IChzdGVwU2l6ZSAvIDJmKSAqIHRpcFBlcmNlbnRhZ2U7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCB0b290aEFuZ2xlU3RlcFNpemUgPSAoc3RlcFNpemUgLSAodG9vdGhUaXBTdGVwU2l6ZSAqIDJmKSkgLyAyZjtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBudW1iZXJPZlRlZXRoIC0gMTsgaSA+PSAwOyAtLWkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b290aFRpcFN0ZXBTaXplID4gMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMihyYWRpdXMgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxvYXQpTWF0aC5Db3Moc3RlcFNpemUgKiBpICsgdG9vdGhBbmdsZVN0ZXBTaXplICogMmYgKyB0b290aFRpcFN0ZXBTaXplKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLXJhZGl1cyAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbG9hdClNYXRoLlNpbihzdGVwU2l6ZSAqIGkgKyB0b290aEFuZ2xlU3RlcFNpemUgKiAyZiArIHRvb3RoVGlwU3RlcFNpemUpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoKHJhZGl1cyArIHRvb3RoSGVpZ2h0KSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbG9hdClNYXRoLkNvcyhzdGVwU2l6ZSAqIGkgKyB0b290aEFuZ2xlU3RlcFNpemUgKyB0b290aFRpcFN0ZXBTaXplKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLShyYWRpdXMgKyB0b290aEhlaWdodCkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxvYXQpTWF0aC5TaW4oc3RlcFNpemUgKiBpICsgdG9vdGhBbmdsZVN0ZXBTaXplICsgdG9vdGhUaXBTdGVwU2l6ZSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoKHJhZGl1cyArIHRvb3RoSGVpZ2h0KSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsb2F0KU1hdGguQ29zKHN0ZXBTaXplICogaSArIHRvb3RoQW5nbGVTdGVwU2l6ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLShyYWRpdXMgKyB0b290aEhlaWdodCkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbG9hdClNYXRoLlNpbihzdGVwU2l6ZSAqIGkgKyB0b290aEFuZ2xlU3RlcFNpemUpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKHJhZGl1cyAqIChmbG9hdClNYXRoLkNvcyhzdGVwU2l6ZSAqIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1yYWRpdXMgKiAoZmxvYXQpTWF0aC5TaW4oc3RlcFNpemUgKiBpKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVjdHMgdGhlIHZlcnRpY2VzIGJ5IGFuYWx5emluZyB0aGUgdGV4dHVyZSBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGF0YVwiPlRoZSB0ZXh0dXJlIGRhdGEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3aWR0aFwiPlRoZSB0ZXh0dXJlIHdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZVBvbHlnb24odWludFtdIGRhdGEsIGludCB3aWR0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlQ29udmVydGVyLkRldGVjdFZlcnRpY2VzKGRhdGEsIHdpZHRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZWN0cyB0aGUgdmVydGljZXMgYnkgYW5hbHl6aW5nIHRoZSB0ZXh0dXJlIGRhdGEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkYXRhXCI+VGhlIHRleHR1cmUgZGF0YS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndpZHRoXCI+VGhlIHRleHR1cmUgd2lkdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJob2xlRGV0ZWN0aW9uXCI+aWYgc2V0IHRvIDxjPnRydWU8L2M+IGl0IHdpbGwgcGVyZm9ybSBob2xlIGRldGVjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVQb2x5Z29uKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgsIGJvb2wgaG9sZURldGVjdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlQ29udmVydGVyLkRldGVjdFZlcnRpY2VzKGRhdGEsIHdpZHRoLCBob2xlRGV0ZWN0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZWN0cyB0aGUgdmVydGljZXMgYnkgYW5hbHl6aW5nIHRoZSB0ZXh0dXJlIGRhdGEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkYXRhXCI+VGhlIHRleHR1cmUgZGF0YS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndpZHRoXCI+VGhlIHRleHR1cmUgd2lkdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJodWxsVG9sZXJhbmNlXCI+VGhlIGh1bGwgdG9sZXJhbmNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWxwaGFUb2xlcmFuY2VcIj5UaGUgYWxwaGEgdG9sZXJhbmNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibXVsdGlQYXJ0RGV0ZWN0aW9uXCI+aWYgc2V0IHRvIDxjPnRydWU8L2M+IGl0IHdpbGwgcGVyZm9ybSBtdWx0aSBwYXJ0IGRldGVjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImhvbGVEZXRlY3Rpb25cIj5pZiBzZXQgdG8gPGM+dHJ1ZTwvYz4gaXQgd2lsbCBwZXJmb3JtIGhvbGUgZGV0ZWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IENyZWF0ZVBvbHlnb24odWludFtdIGRhdGEsIGludCB3aWR0aCwgZmxvYXQgaHVsbFRvbGVyYW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZSBhbHBoYVRvbGVyYW5jZSwgYm9vbCBtdWx0aVBhcnREZXRlY3Rpb24sIGJvb2wgaG9sZURldGVjdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0dXJlQ29udmVydGVyLkRldGVjdFZlcnRpY2VzKGRhdGEsIHdpZHRoLCBodWxsVG9sZXJhbmNlLCBhbHBoYVRvbGVyYW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlQYXJ0RGV0ZWN0aW9uLCBob2xlRGV0ZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vblxyXG57XHJcbiAgICAvLyBVc2VyIGNvbnRyaWJ1dGlvbiBmcm9tIFNpY2tiYXR0ZXJ5IGFrYSBEYXZpZCBSZXNjaGtlIDopLlxyXG5cclxuICAgICNyZWdpb24gVG9EbzogQ3JlYXRlIGEgbmV3IGZpbGUgZm9yIGVhY2ggLi4uXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhlIGRldGVjdGlvbiB0eXBlIGFmZmVjdHMgdGhlIHJlc3VsdGluZyBwb2x5Z29uIGRhdGEuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGVudW0gVmVydGljZXNEZXRlY3Rpb25UeXBlXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBIb2xlcyBhcmUgaW50ZWdyYXRlZCBpbnRvIHRoZSBtYWluIHBvbHlnb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBJbnRlZ3JhdGVkID0gMCxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZGF0YSBvZiB0aGUgbWFpbiBwb2x5Z29uIGFuZCBob2xlIHBvbHlnb25zIGlzIHJldHVybmVkIHNlcGFyYXRlbHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBTZXBhcmF0ZWQgPSAxXHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIERldGVjdGVkIHZlcnRpY2VzIG9mIGEgc2luZ2xlIHBvbHlnb24uXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIERldGVjdGVkVmVydGljZXMgOiBWZXJ0aWNlc1xyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgTGlzdDxWZXJ0aWNlcz4gX2hvbGVzO1xyXG5cclxuICAgICAgICBwdWJsaWMgTGlzdDxWZXJ0aWNlcz4gSG9sZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfaG9sZXM7IH1cclxuICAgICAgICAgICAgc2V0IHsgX2hvbGVzID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBEZXRlY3RlZFZlcnRpY2VzKClcclxuICAgICAgICAgICAgOiBiYXNlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgRGV0ZWN0ZWRWZXJ0aWNlcyhWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICAgICAgOiBiYXNlKHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFRyYW5zZm9ybShNYXRyaXggdHJhbnNmb3JtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIG1haW4gcG9seWdvblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHRoaXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBWZWN0b3IyLlRyYW5zZm9ybSh0aGlzW2ldLCB0cmFuc2Zvcm0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGhvbGVzXHJcbiAgICAgICAgICAgIFZlY3RvcjJbXSB0ZW1wID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKF9ob2xlcyAhPSBudWxsICYmIF9ob2xlcy5Db3VudCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX2hvbGVzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IF9ob2xlc1tpXS5Ub0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMi5UcmFuc2Zvcm0odGVtcCwgcmVmIHRyYW5zZm9ybSwgdGVtcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9ob2xlc1tpXSA9IG5ldyBWZXJ0aWNlcyh0ZW1wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHNlYWxlZCBjbGFzcyBUZXh0dXJlQ29udmVydGVyXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBpbnQgX0NMT1NFUElYRUxTX0xFTkdUSCA9IDg7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBhcnJheSBpcyBtZW50IHRvIGJlIHJlYWRvbmx5LlxyXG4gICAgICAgIC8vLyBJdCdzIG5vdCBiZWNhdXNlIGl0IGlzIGFjY2Vzc2VkIHZlcnkgZnJlcXVlbnRseS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIC8qcmVhZG9ubHkqLyBpbnRbLF0gQ2xvc2VQaXhlbHMgPVxyXG4gICAgICAgICAgICBuZXcgaW50W19DTE9TRVBJWEVMU19MRU5HVEgsIDJdIHsgeyAtMSwgLTEgfSwgeyAwLCAtMSB9LCB7IDEsIC0xIH0sIHsgMSwgMCB9LCB7IDEsIDEgfSwgeyAwLCAxIH0sIHsgLTEsIDEgfSwgeyAtMSwgMCB9IH07XHJcblxyXG4gICAgICAgIHByaXZhdGUgdWludFtdIF9kYXRhO1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9kYXRhTGVuZ3RoO1xyXG4gICAgICAgIHByaXZhdGUgaW50IF93aWR0aDtcclxuICAgICAgICBwcml2YXRlIGludCBfaGVpZ2h0O1xyXG5cclxuICAgICAgICBwcml2YXRlIFZlcnRpY2VzRGV0ZWN0aW9uVHlwZSBfcG9seWdvbkRldGVjdGlvblR5cGU7XHJcblxyXG4gICAgICAgIHByaXZhdGUgdWludCBfYWxwaGFUb2xlcmFuY2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfaHVsbFRvbGVyYW5jZTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9ob2xlRGV0ZWN0aW9uO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfbXVsdGlwYXJ0RGV0ZWN0aW9uO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfcGl4ZWxPZmZzZXRPcHRpbWl6YXRpb247XHJcblxyXG4gICAgICAgIHByaXZhdGUgTWF0cml4IF90cmFuc2Zvcm0gPSBNYXRyaXguSWRlbnRpdHk7XHJcblxyXG4gICAgICAgICNyZWdpb24gUHJvcGVydGllc1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IG9yIHNldCB0aGUgcG9seWdvbiBkZXRlY3Rpb24gdHlwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZXJ0aWNlc0RldGVjdGlvblR5cGUgUG9seWdvbkRldGVjdGlvblR5cGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcG9seWdvbkRldGVjdGlvblR5cGU7IH1cclxuICAgICAgICAgICAgc2V0IHsgX3BvbHlnb25EZXRlY3Rpb25UeXBlID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV2lsbCBkZXRlY3QgdGV4dHVyZSAnaG9sZXMnIGlmIHNldCB0byB0cnVlLiBTbG93cyBkb3duIHRoZSBkZXRlY3Rpb24uIERlZmF1bHQgaXMgZmFsc2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBIb2xlRGV0ZWN0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2hvbGVEZXRlY3Rpb247IH1cclxuICAgICAgICAgICAgc2V0IHsgX2hvbGVEZXRlY3Rpb24gPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBXaWxsIGRldGVjdCB0ZXh0dXJlIG11bHRpcGxlICdzb2xpZCcgaXNsZXMgaWYgc2V0IHRvIHRydWUuIFNsb3dzIGRvd24gdGhlIGRldGVjdGlvbi4gRGVmYXVsdCBpcyBmYWxzZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIE11bHRpcGFydERldGVjdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tdWx0aXBhcnREZXRlY3Rpb247IH1cclxuICAgICAgICAgICAgc2V0IHsgX211bHRpcGFydERldGVjdGlvbiA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFdpbGwgb3B0aW1pemUgdGhlIHZlcnRleCBwb3NpdGlvbnMgYWxvbmcgdGhlIGludGVycG9sYXRlZCBub3JtYWwgYmV0d2VlbiB0d28gZWRnZXMgYWJvdXQgYSBoYWxmIHBpeGVsIChwb3N0IHByb2Nlc3NpbmcpLiBEZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgUGl4ZWxPZmZzZXRPcHRpbWl6YXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcGl4ZWxPZmZzZXRPcHRpbWl6YXRpb247IH1cclxuICAgICAgICAgICAgc2V0IHsgX3BpeGVsT2Zmc2V0T3B0aW1pemF0aW9uID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FuIGJlIHVzZWQgZm9yIHNjYWxpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgTWF0cml4IFRyYW5zZm9ybVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF90cmFuc2Zvcm07IH1cclxuICAgICAgICAgICAgc2V0IHsgX3RyYW5zZm9ybSA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFscGhhIChjb3ZlcmFnZSkgdG9sZXJhbmNlLiBEZWZhdWx0IGlzIDIwOiBFdmVyeSBwaXhlbCB3aXRoIGEgY292ZXJhZ2UgdmFsdWUgZXF1YWwgb3IgZ3JlYXRlciB0byAyMCB3aWxsIGJlIGNvdW50cyBhcyBzb2xpZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBieXRlIEFscGhhVG9sZXJhbmNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKGJ5dGUpKF9hbHBoYVRvbGVyYW5jZSA+PiAyNCk7IH1cclxuICAgICAgICAgICAgc2V0IHsgX2FscGhhVG9sZXJhbmNlID0gKHVpbnQpdmFsdWUgPDwgMjQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVmYXVsdCBpcyAxLjVmLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEh1bGxUb2xlcmFuY2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfaHVsbFRvbGVyYW5jZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gNGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2h1bGxUb2xlcmFuY2UgPSA0ZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMC45ZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfaHVsbFRvbGVyYW5jZSA9IDAuOWY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2h1bGxUb2xlcmFuY2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gQ29uc3RydWN0b3JzXHJcbiAgICAgICAgcHVibGljIFRleHR1cmVDb252ZXJ0ZXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSW5pdGlhbGl6ZShudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUZXh0dXJlQ29udmVydGVyKGJ5dGU/IGFscGhhVG9sZXJhbmNlLCBmbG9hdD8gaHVsbFRvbGVyYW5jZSxcclxuICAgICAgICAgICAgYm9vbD8gaG9sZURldGVjdGlvbiwgYm9vbD8gbXVsdGlwYXJ0RGV0ZWN0aW9uLCBib29sPyBwaXhlbE9mZnNldE9wdGltaXphdGlvbiwgTWF0cml4PyB0cmFuc2Zvcm0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBJbml0aWFsaXplKG51bGwsIG51bGwsIGFscGhhVG9sZXJhbmNlLCBodWxsVG9sZXJhbmNlLCBob2xlRGV0ZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgbXVsdGlwYXJ0RGV0ZWN0aW9uLCBwaXhlbE9mZnNldE9wdGltaXphdGlvbiwgdHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUZXh0dXJlQ29udmVydGVyKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBJbml0aWFsaXplKGRhdGEsIHdpZHRoLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUZXh0dXJlQ29udmVydGVyKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgsIGJ5dGU/IGFscGhhVG9sZXJhbmNlLFxyXG4gICAgICAgICAgICBmbG9hdD8gaHVsbFRvbGVyYW5jZSwgYm9vbD8gaG9sZURldGVjdGlvbiwgYm9vbD8gbXVsdGlwYXJ0RGV0ZWN0aW9uLFxyXG4gICAgICAgICAgICBib29sPyBwaXhlbE9mZnNldE9wdGltaXphdGlvbiwgTWF0cml4PyB0cmFuc2Zvcm0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBJbml0aWFsaXplKGRhdGEsIHdpZHRoLCBhbHBoYVRvbGVyYW5jZSwgaHVsbFRvbGVyYW5jZSwgaG9sZURldGVjdGlvbixcclxuICAgICAgICAgICAgICAgIG11bHRpcGFydERldGVjdGlvbiwgcGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBJbml0aWFsaXphdGlvblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBJbml0aWFsaXplKHVpbnRbXSBkYXRhLCBpbnQ/IHdpZHRoLCBieXRlPyBhbHBoYVRvbGVyYW5jZSxcclxuICAgICAgICAgICAgZmxvYXQ/IGh1bGxUb2xlcmFuY2UsIGJvb2w/IGhvbGVEZXRlY3Rpb24sIGJvb2w/IG11bHRpcGFydERldGVjdGlvbixcclxuICAgICAgICAgICAgYm9vbD8gcGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24sIE1hdHJpeD8gdHJhbnNmb3JtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCAmJiAhd2lkdGguSGFzVmFsdWUpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwid2lkdGhcIiwgXCInd2lkdGgnIGNhbid0IGJlIG51bGwgaWYgJ2RhdGEnIGlzIHNldC5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsICYmIHdpZHRoLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImRhdGFcIiwgXCInZGF0YScgY2FuJ3QgYmUgbnVsbCBpZiAnd2lkdGgnIGlzIHNldC5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsICYmIHdpZHRoLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgU2V0VGV4dHVyZURhdGEoZGF0YSwgd2lkdGguVmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFscGhhVG9sZXJhbmNlLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgQWxwaGFUb2xlcmFuY2UgPSBhbHBoYVRvbGVyYW5jZS5WYWx1ZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgQWxwaGFUb2xlcmFuY2UgPSAyMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChodWxsVG9sZXJhbmNlLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgSHVsbFRvbGVyYW5jZSA9IGh1bGxUb2xlcmFuY2UuVmFsdWU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIEh1bGxUb2xlcmFuY2UgPSAxLjVmO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhvbGVEZXRlY3Rpb24uSGFzVmFsdWUpXHJcbiAgICAgICAgICAgICAgICBIb2xlRGV0ZWN0aW9uID0gaG9sZURldGVjdGlvbi5WYWx1ZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgSG9sZURldGVjdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKG11bHRpcGFydERldGVjdGlvbi5IYXNWYWx1ZSlcclxuICAgICAgICAgICAgICAgIE11bHRpcGFydERldGVjdGlvbiA9IG11bHRpcGFydERldGVjdGlvbi5WYWx1ZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgTXVsdGlwYXJ0RGV0ZWN0aW9uID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAocGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24uSGFzVmFsdWUpXHJcbiAgICAgICAgICAgICAgICBQaXhlbE9mZnNldE9wdGltaXphdGlvbiA9IHBpeGVsT2Zmc2V0T3B0aW1pemF0aW9uLlZhbHVlO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBQaXhlbE9mZnNldE9wdGltaXphdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybS5IYXNWYWx1ZSlcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSA9IHRyYW5zZm9ybS5WYWx1ZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtID0gTWF0cml4LklkZW50aXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkYXRhXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3aWR0aFwiPjwvcGFyYW0+XHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFNldFRleHR1cmVEYXRhKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcImRhdGFcIiwgXCInZGF0YScgY2FuJ3QgYmUgbnVsbC5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5MZW5ndGggPCA0KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImRhdGFcIiwgXCInZGF0YScgbGVuZ3RoIGNhbid0IGJlIGxlc3MgdGhlbiA0LiBZb3VyIHRleHR1cmUgbXVzdCBiZSBhdCBsZWFzdCAyIHggMiBwaXhlbHMgaW4gc2l6ZS5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAod2lkdGggPCAyKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcIndpZHRoXCIsIFwiJ3dpZHRoJyBjYW4ndCBiZSBsZXNzIHRoZW4gMi4gWW91ciB0ZXh0dXJlIG11c3QgYmUgYXQgbGVhc3QgMiB4IDIgcGl4ZWxzIGluIHNpemUuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEuTGVuZ3RoICUgd2lkdGggIT0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIid3aWR0aCcgaGFzIGFuIGludmFsaWQgdmFsdWUuXCIpO1xyXG5cclxuICAgICAgICAgICAgX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICBfZGF0YUxlbmd0aCA9IF9kYXRhLkxlbmd0aDtcclxuICAgICAgICAgICAgX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIF9oZWlnaHQgPSBfZGF0YUxlbmd0aCAvIHdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlY3RzIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgc3VwcGxpZWQgdGV4dHVyZSBkYXRhLiAoUG9seWdvbkRldGVjdGlvblR5cGUuSW50ZWdyYXRlZClcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRhdGFcIj5UaGUgdGV4dHVyZSBkYXRhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid2lkdGhcIj5UaGUgdGV4dHVyZSB3aWR0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBEZXRlY3RWZXJ0aWNlcyh1aW50W10gZGF0YSwgaW50IHdpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVGV4dHVyZUNvbnZlcnRlciB0YyA9IG5ldyBUZXh0dXJlQ29udmVydGVyKGRhdGEsIHdpZHRoKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8RGV0ZWN0ZWRWZXJ0aWNlcz4gZGV0ZWN0ZWRWZXJ0aWNlc0xpc3QgPSB0Yy5EZXRlY3RWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRldGVjdGVkVmVydGljZXNMaXN0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlY3RzIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgc3VwcGxpZWQgdGV4dHVyZSBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGF0YVwiPlRoZSB0ZXh0dXJlIGRhdGEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3aWR0aFwiPlRoZSB0ZXh0dXJlIHdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaG9sZURldGVjdGlvblwiPmlmIHNldCB0byA8Yz50cnVlPC9jPiBpdCB3aWxsIHBlcmZvcm0gaG9sZSBkZXRlY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgRGV0ZWN0VmVydGljZXModWludFtdIGRhdGEsIGludCB3aWR0aCwgYm9vbCBob2xlRGV0ZWN0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVGV4dHVyZUNvbnZlcnRlciB0YyA9XHJcbiAgICAgICAgICAgICAgICBuZXcgVGV4dHVyZUNvbnZlcnRlcihkYXRhLCB3aWR0aClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBIb2xlRGV0ZWN0aW9uID0gaG9sZURldGVjdGlvblxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8RGV0ZWN0ZWRWZXJ0aWNlcz4gZGV0ZWN0ZWRWZXJ0aWNlc0xpc3QgPSB0Yy5EZXRlY3RWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRldGVjdGVkVmVydGljZXNMaXN0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlY3RzIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgc3VwcGxpZWQgdGV4dHVyZSBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGF0YVwiPlRoZSB0ZXh0dXJlIGRhdGEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3aWR0aFwiPlRoZSB0ZXh0dXJlIHdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaG9sZURldGVjdGlvblwiPmlmIHNldCB0byA8Yz50cnVlPC9jPiBpdCB3aWxsIHBlcmZvcm0gaG9sZSBkZXRlY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJodWxsVG9sZXJhbmNlXCI+VGhlIGh1bGwgdG9sZXJhbmNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWxwaGFUb2xlcmFuY2VcIj5UaGUgYWxwaGEgdG9sZXJhbmNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibXVsdGlQYXJ0RGV0ZWN0aW9uXCI+aWYgc2V0IHRvIDxjPnRydWU8L2M+IGl0IHdpbGwgcGVyZm9ybSBtdWx0aSBwYXJ0IGRldGVjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBEZXRlY3RWZXJ0aWNlcyh1aW50W10gZGF0YSwgaW50IHdpZHRoLCBmbG9hdCBodWxsVG9sZXJhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZSBhbHBoYVRvbGVyYW5jZSwgYm9vbCBtdWx0aVBhcnREZXRlY3Rpb24sIGJvb2wgaG9sZURldGVjdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRleHR1cmVDb252ZXJ0ZXIgdGMgPVxyXG4gICAgICAgICAgICAgICAgbmV3IFRleHR1cmVDb252ZXJ0ZXIoZGF0YSwgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgSHVsbFRvbGVyYW5jZSA9IGh1bGxUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgQWxwaGFUb2xlcmFuY2UgPSBhbHBoYVRvbGVyYW5jZSxcclxuICAgICAgICAgICAgICAgICAgICBNdWx0aXBhcnREZXRlY3Rpb24gPSBtdWx0aVBhcnREZXRlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgSG9sZURldGVjdGlvbiA9IGhvbGVEZXRlY3Rpb25cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBMaXN0PERldGVjdGVkVmVydGljZXM+IGRldGVjdGVkVmVydGljZXNMaXN0ID0gdGMuRGV0ZWN0VmVydGljZXMoKTtcclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gcmVzdWx0ID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGRldGVjdGVkVmVydGljZXNMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5BZGQoZGV0ZWN0ZWRWZXJ0aWNlc0xpc3RbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIExpc3Q8RGV0ZWN0ZWRWZXJ0aWNlcz4gRGV0ZWN0VmVydGljZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgI3JlZ2lvbiBDaGVjayBUZXh0dXJlQ29udmVydGVyIHNldHVwLlxyXG5cclxuICAgICAgICAgICAgaWYgKF9kYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJ19kYXRhJyBjYW4ndCBiZSBudWxsLiBZb3UgaGF2ZSB0byB1c2UgU2V0VGV4dHVyZURhdGEodWludFtdIGRhdGEsIGludCB3aWR0aCkgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9kYXRhLkxlbmd0aCA8IDQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJ19kYXRhJyBsZW5ndGggY2FuJ3QgYmUgbGVzcyB0aGVuIDQuIFlvdXIgdGV4dHVyZSBtdXN0IGJlIGF0IGxlYXN0IDIgeCAyIHBpeGVscyBpbiBzaXplLiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJZb3UgaGF2ZSB0byB1c2UgU2V0VGV4dHVyZURhdGEodWludFtdIGRhdGEsIGludCB3aWR0aCkgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF93aWR0aCA8IDIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJ193aWR0aCcgY2FuJ3QgYmUgbGVzcyB0aGVuIDIuIFlvdXIgdGV4dHVyZSBtdXN0IGJlIGF0IGxlYXN0IDIgeCAyIHBpeGVscyBpbiBzaXplLiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJZb3UgaGF2ZSB0byB1c2UgU2V0VGV4dHVyZURhdGEodWludFtdIGRhdGEsIGludCB3aWR0aCkgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9kYXRhLkxlbmd0aCAlIF93aWR0aCAhPSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBcIidfd2lkdGgnIGhhcyBhbiBpbnZhbGlkIHZhbHVlLiBZb3UgaGF2ZSB0byB1c2UgU2V0VGV4dHVyZURhdGEodWludFtdIGRhdGEsIGludCB3aWR0aCkgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXCIpO1xyXG5cclxuICAgICAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAgICAgICAgIExpc3Q8RGV0ZWN0ZWRWZXJ0aWNlcz4gZGV0ZWN0ZWRQb2x5Z29ucyA9IG5ldyBMaXN0PERldGVjdGVkVmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICBEZXRlY3RlZFZlcnRpY2VzIHBvbHlnb247XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIGhvbGVQb2x5Z29uO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMj8gaG9sZUVudHJhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgVmVjdG9yMj8gcG9seWdvbkVudHJhbmNlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVjdG9yMj4gYmxhY2tMaXN0ID0gbmV3IExpc3Q8VmVjdG9yMj4oKTtcclxuXHJcbiAgICAgICAgICAgIGJvb2wgc2VhcmNoT247XHJcbiAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZXRlY3RlZFBvbHlnb25zLkNvdW50ID09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgcGFzcyAvIHNpbmdsZSBwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IG5ldyBEZXRlY3RlZFZlcnRpY2VzKENyZWF0ZVNpbXBsZVBvbHlnb24oVmVjdG9yMi5aZXJvLCBWZWN0b3IyLlplcm8pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlnb24uQ291bnQgPiAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uRW50cmFuY2UgPSBHZXRUb3BNb3N0VmVydGV4KHBvbHlnb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocG9seWdvbkVudHJhbmNlLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE11bHRpIHBhc3MgLyBtdWx0aXBsZSBwb2x5Z29uc1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24gPSBuZXcgRGV0ZWN0ZWRWZXJ0aWNlcyhDcmVhdGVTaW1wbGVQb2x5Z29uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uRW50cmFuY2UuVmFsdWUsIG5ldyBWZWN0b3IyKHBvbHlnb25FbnRyYW5jZS5WYWx1ZS5YIC0gMWYsIHBvbHlnb25FbnRyYW5jZS5WYWx1ZS5ZKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlYXJjaE9uID0gZmFsc2U7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uLkNvdW50ID4gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2hvbGVEZXRlY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xlRW50cmFuY2UgPSBTZWFyY2hIb2xlRW50cmFuY2UocG9seWdvbiwgaG9sZUVudHJhbmNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZUVudHJhbmNlLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmxhY2tMaXN0LkNvbnRhaW5zKGhvbGVFbnRyYW5jZS5WYWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFja0xpc3QuQWRkKGhvbGVFbnRyYW5jZS5WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGVQb2x5Z29uID0gQ3JlYXRlU2ltcGxlUG9seWdvbihob2xlRW50cmFuY2UuVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMihob2xlRW50cmFuY2UuVmFsdWUuWCArIDEsIGhvbGVFbnRyYW5jZS5WYWx1ZS5ZKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZVBvbHlnb24gIT0gbnVsbCAmJiBob2xlUG9seWdvbi5Db3VudCA+IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX3BvbHlnb25EZXRlY3Rpb25UeXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVmVydGljZXNEZXRlY3Rpb25UeXBlLkludGVncmF0ZWQ6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZmlyc3QgaG9sZSBwb2x5Z29uIHZlcnRleCB0byBjbG9zZSB0aGUgaG9sZSBwb2x5Z29uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xlUG9seWdvbi5BZGQoaG9sZVBvbHlnb25bMF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IHZlcnRleDFJbmRleCwgdmVydGV4MkluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU3BsaXRQb2x5Z29uRWRnZShwb2x5Z29uLCBob2xlRW50cmFuY2UuVmFsdWUsIG91dCB2ZXJ0ZXgxSW5kZXgsIG91dCB2ZXJ0ZXgySW5kZXgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5JbnNlcnRSYW5nZSh2ZXJ0ZXgySW5kZXgsIGhvbGVQb2x5Z29uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFZlcnRpY2VzRGV0ZWN0aW9uVHlwZS5TZXBhcmF0ZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uLkhvbGVzID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLkhvbGVzID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLkhvbGVzLkFkZChob2xlUG9seWdvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRQb2x5Z29ucy5BZGQocG9seWdvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9tdWx0aXBhcnREZXRlY3Rpb24gfHwgcG9seWdvbi5Db3VudCA8PSAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTZWFyY2hOZXh0SHVsbEVudHJhbmNlKGRldGVjdGVkUG9seWdvbnMsIHBvbHlnb25FbnRyYW5jZS5WYWx1ZSwgb3V0IHBvbHlnb25FbnRyYW5jZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaE9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoc2VhcmNoT24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRldGVjdGVkUG9seWdvbnMgPT0gbnVsbCB8fCAoZGV0ZWN0ZWRQb2x5Z29ucyAhPSBudWxsICYmIGRldGVjdGVkUG9seWdvbnMuQ291bnQgPT0gMCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiQ291bGRuJ3QgZGV0ZWN0IGFueSB2ZXJ0aWNlcy5cIik7XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gUG9zdCBwcm9jZXNzaW5nLlxyXG4gICAgICAgICAgICBpZiAoUG9seWdvbkRldGVjdGlvblR5cGUgPT0gVmVydGljZXNEZXRlY3Rpb25UeXBlLlNlcGFyYXRlZCkgLy8gT25seSB3aGVuIFZlcnRpY2VzRGV0ZWN0aW9uVHlwZS5TZXBhcmF0ZWQ/IC0+IFJlY2hlY2suXHJcbiAgICAgICAgICAgICAgICBBcHBseVRyaWFuZ3VsYXRpb25Db21wYXRpYmxlV2luZGluZyhyZWYgZGV0ZWN0ZWRQb2x5Z29ucyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3BpeGVsT2Zmc2V0T3B0aW1pemF0aW9uKVxyXG4gICAgICAgICAgICAgICAgQXBwbHlQaXhlbE9mZnNldE9wdGltaXphdGlvbihyZWYgZGV0ZWN0ZWRQb2x5Z29ucyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3RyYW5zZm9ybSAhPSBNYXRyaXguSWRlbnRpdHkpXHJcbiAgICAgICAgICAgICAgICBBcHBseVRyYW5zZm9ybShyZWYgZGV0ZWN0ZWRQb2x5Z29ucyk7XHJcblxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRldGVjdGVkUG9seWdvbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgQXBwbHlUcmlhbmd1bGF0aW9uQ29tcGF0aWJsZVdpbmRpbmcocmVmIExpc3Q8RGV0ZWN0ZWRWZXJ0aWNlcz4gZGV0ZWN0ZWRQb2x5Z29ucylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgZGV0ZWN0ZWRQb2x5Z29ucy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkZXRlY3RlZFBvbHlnb25zW2ldLlJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRQb2x5Z29uc1tpXS5Ib2xlcyAhPSBudWxsICYmIGRldGVjdGVkUG9seWdvbnNbaV0uSG9sZXMuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgZGV0ZWN0ZWRQb2x5Z29uc1tpXS5Ib2xlcy5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZFBvbHlnb25zW2ldLkhvbGVzW2pdLlJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIEFwcGx5UGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24ocmVmIExpc3Q8RGV0ZWN0ZWRWZXJ0aWNlcz4gZGV0ZWN0ZWRQb2x5Z29ucylcclxuICAgICAgICB7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIEFwcGx5VHJhbnNmb3JtKHJlZiBMaXN0PERldGVjdGVkVmVydGljZXM+IGRldGVjdGVkUG9seWdvbnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGRldGVjdGVkUG9seWdvbnMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIGRldGVjdGVkUG9seWdvbnNbaV0uVHJhbnNmb3JtKF90cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBEYXRhW10gZnVuY3Rpb25zXHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX3RlbXBJc1NvbGlkWDtcclxuICAgICAgICBwcml2YXRlIGludCBfdGVtcElzU29saWRZO1xyXG4gICAgICAgIHB1YmxpYyBib29sIElzU29saWQocmVmIFZlY3RvcjIgdilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90ZW1wSXNTb2xpZFggPSAoaW50KXYuWDtcclxuICAgICAgICAgICAgX3RlbXBJc1NvbGlkWSA9IChpbnQpdi5ZO1xyXG5cclxuICAgICAgICAgICAgaWYgKF90ZW1wSXNTb2xpZFggPj0gMCAmJiBfdGVtcElzU29saWRYIDwgX3dpZHRoICYmIF90ZW1wSXNTb2xpZFkgPj0gMCAmJiBfdGVtcElzU29saWRZIDwgX2hlaWdodClcclxuICAgICAgICAgICAgICAgIHJldHVybiAoX2RhdGFbX3RlbXBJc1NvbGlkWCArIF90ZW1wSXNTb2xpZFkgKiBfd2lkdGhdID49IF9hbHBoYVRvbGVyYW5jZSk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuICgoX2RhdGFbX3RlbXBJc1NvbGlkWCArIF90ZW1wSXNTb2xpZFkgKiBfd2lkdGhdICYgMHhGRjAwMDAwMCkgPj0gX2FscGhhVG9sZXJhbmNlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzU29saWQocmVmIGludCB4LCByZWYgaW50IHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPCBfd2lkdGggJiYgeSA+PSAwICYmIHkgPCBfaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfZGF0YVt4ICsgeSAqIF93aWR0aF0gPj0gX2FscGhhVG9sZXJhbmNlKTtcclxuICAgICAgICAgICAgLy9yZXR1cm4gKChfZGF0YVt4ICsgeSAqIF93aWR0aF0gJiAweEZGMDAwMDAwKSA+PSBfYWxwaGFUb2xlcmFuY2UpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNTb2xpZChyZWYgaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBfZGF0YUxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiAoX2RhdGFbaW5kZXhdID49IF9hbHBoYVRvbGVyYW5jZSk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuICgoX2RhdGFbaW5kZXhdICYgMHhGRjAwMDAwMCkgPj0gX2FscGhhVG9sZXJhbmNlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEluQm91bmRzKHJlZiBWZWN0b3IyIGNvb3JkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChjb29yZC5YID49IDBmICYmIGNvb3JkLlggPCBfd2lkdGggJiYgY29vcmQuWSA+PSAwZiAmJiBjb29yZC5ZIDwgX2hlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGdW5jdGlvbiB0byBzZWFyY2ggZm9yIGFuIGVudHJhbmNlIHBvaW50IG9mIGEgaG9sZSBpbiBhIHBvbHlnb24uIEl0IHNlYXJjaGVzIHRoZSBwb2x5Z29uIGZyb20gdG9wIHRvIGJvdHRvbSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGVkZ2VzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9seWdvblwiPlRoZSBwb2x5Z29uIHRvIHNlYXJjaCBpbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxhc3RIb2xlRW50cmFuY2VcIj5UaGUgbGFzdCBlbnRyYW5jZSBwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgbmV4dCBob2xlcyBlbnRyYW5jZSBwb2ludC4gTnVsbCBpZiB0aGVyIGFyZSBubyBob2xlcy48L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyPyBTZWFyY2hIb2xlRW50cmFuY2UoVmVydGljZXMgcG9seWdvbiwgVmVjdG9yMj8gbGFzdEhvbGVFbnRyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwiJ3BvbHlnb24nIGNhbid0IGJlIG51bGwuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBvbHlnb24uQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiJ3BvbHlnb24uTWFpblBvbHlnb24uQ291bnQnIGNhbid0IGJlIGxlc3MgdGhlbiAzLlwiKTtcclxuXHJcblxyXG4gICAgICAgICAgICBMaXN0PGZsb2F0PiB4Q29vcmRzO1xyXG4gICAgICAgICAgICBWZWN0b3IyPyBlbnRyYW5jZTtcclxuXHJcbiAgICAgICAgICAgIGludCBzdGFydFk7XHJcbiAgICAgICAgICAgIGludCBlbmRZO1xyXG5cclxuICAgICAgICAgICAgaW50IGxhc3RTb2xpZCA9IDA7XHJcbiAgICAgICAgICAgIGJvb2wgZm91bmRTb2xpZDtcclxuICAgICAgICAgICAgYm9vbCBmb3VuZFRyYW5zcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHN0YXJ0IHkgY29vcmRpbmF0ZS5cclxuICAgICAgICAgICAgaWYgKGxhc3RIb2xlRW50cmFuY2UuSGFzVmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdGhlIHkgY29vcmRpbmF0ZSBvbmx5LlxyXG4gICAgICAgICAgICAgICAgc3RhcnRZID0gKGludClsYXN0SG9sZUVudHJhbmNlLlZhbHVlLlk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSB0b3Agb2YgdGhlIHBvbHlnb24gaWYgbGFzdCBlbnRyYW5jZSA9PSBudWxsLlxyXG4gICAgICAgICAgICAgICAgc3RhcnRZID0gKGludClHZXRUb3BNb3N0Q29vcmQocG9seWdvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgZW5kIHkgY29vcmRpbmF0ZS5cclxuICAgICAgICAgICAgZW5kWSA9IChpbnQpR2V0Qm90dG9tTW9zdENvb3JkKHBvbHlnb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXJ0WSA+IDAgJiYgc3RhcnRZIDwgX2hlaWdodCAmJiBlbmRZID4gMCAmJiBlbmRZIDwgX2hlaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gZ28gZnJvbSB0b3AgdG8gYm90dG9tIG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB5ID0gc3RhcnRZOyB5IDw9IGVuZFk7IHkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgeC1jb29yZCBvZiBldmVyeSBwb2x5Z29uIGVkZ2Ugd2hpY2ggY3Jvc3NlcyB5XHJcbiAgICAgICAgICAgICAgICAgICAgeENvb3JkcyA9IFNlYXJjaENyb3NzaW5nRWRnZXMocG9seWdvbiwgeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgYW4gZXZlbiBudW1iZXIgb2YgY3Jvc3NpbmcgZWRnZXMuIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgYWx3YXlzIGEgcGFpciBvZiBzdGFydCBhbmQgZW5kIGVkZ2U6IG5vdGhpbmcgfCBwb2x5Z29uIHwgaG9sZSB8IHBvbHlnb24gfCBub3RoaW5nIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IHRoZW4gZG9uJ3QgYm90aGVyLCBpdCdzIHByb2JhYmx5IGEgcGVhayAuLi5cclxuICAgICAgICAgICAgICAgICAgICAvLyAuLi53aGljaCBzaG91bGQgYmUgZmlsdGVyZWQgb3V0IGJ5IFNlYXJjaENyb3NzaW5nRWRnZXMoKSBhbnl3YXkuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDb29yZHMuQ291bnQgPiAxICYmIHhDb29yZHMuQ291bnQgJSAyID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPaywgdGhpcyBpcyBzaG9ydCwgYnV0IHByb2JhYmx5IGEgbGl0dGxlIGJpdCBjb25mdXNpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcGFydCBzZWFyY2hlcyBmcm9tIGxlZnQgdG8gcmlnaHQgYmV0d2VlbiB0aGUgZWRnZXMgaW5zaWRlIHRoZSBwb2x5Z29uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJvYmxlbTogV2UgYXJlIHVzaW5nIHRoZSBwb2x5Z29uIGRhdGEgdG8gc2VhcmNoIGluIHRoZSB0ZXh0dXJlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyBzaW1wbHkgbm90IGFjY3VyYXRlLCBidXQgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgeENvb3Jkcy5Db3VudDsgaSArPSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFNvbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFRyYW5zcGFyZW50ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2VhcmNoIGJldHdlZW4gdGhlIGVkZ2VzIGluc2lkZSB0aGUgcG9seWdvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IHggPSAoaW50KXhDb29yZHNbaV07IHggPD0gKGludCl4Q29vcmRzW2kgKyAxXTsgeCsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBhc3M6IElzU29saWQgbWlnaHQgcmV0dXJuIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSB0aGUgcG9seWdvbiBlZGdlIGRvZXNuJ3QgbGllIG9uIHRoZSB0ZXh0dXJlJ3Mgc29saWQgcGl4ZWwsIGJlY2F1c2Ugb2YgdGhlIGh1bGwgdG9sZWFyYW5jZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWRnZSBsaWVzIGJlZm9yZSB0aGUgZmlyc3Qgc29saWQgcGl4ZWwgdGhlbiB3ZSBuZWVkIHRvIHNraXAgb3VyIHRyYW5zcGFyZW50IHBpeGVsIGZpbmRzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIHN0YXJ0cyB0byBzZWFyY2ggZm9yIGEgcmVsZXZhbnQgdHJhbnNwYXJlbnQgcGl4ZWwgKHdoaWNoIGluZGljYXRlcyBhIHBvc3NpYmxlIGhvbGUpIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIGl0IGhhcyBmb3VuZCBhIHNvbGlkIHBpeGVsLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciB3ZSd2ZSBmb3VuZCBhIHNvbGlkIGFuZCBhIHRyYW5zcGFyZW50IHBpeGVsIChhIGhvbGUncyBsZWZ0IGVkZ2UpIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNlYXJjaCBmb3IgYSBzb2xpZCBwaXhlbCBhZ2FpbiAoYSBob2xlJ3MgcmlnaHQgZWRnZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBmb3VuZCB0aGUgZGlzdGFuY2Ugb2YgdGhhdCBjb29kcmluYXRlIGhhcyB0byBiZSBncmVhdGVyIHRoZW4gdGhlIGh1bGwgdG9sZXJhbmNlLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoSXNTb2xpZChyZWYgeCwgcmVmIHkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZFRyYW5zcGFyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFNvbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTb2xpZCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFNvbGlkICYmIGZvdW5kVHJhbnNwYXJlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJhbmNlID0gbmV3IFZlY3RvcjIobGFzdFNvbGlkLCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRGlzdGFuY2VUb0h1bGxBY2NlcHRhYmxlKHBvbHlnb24sIGVudHJhbmNlLlZhbHVlLCB0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cmFuY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kU29saWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhDb29yZHMuQ291bnQgJSAyID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJTZWFyY2hDcm9zc2luZ0VkZ2VzKCkgJSAyICE9IDBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBEaXN0YW5jZVRvSHVsbEFjY2VwdGFibGUoRGV0ZWN0ZWRWZXJ0aWNlcyBwb2x5Z29uLCBWZWN0b3IyIHBvaW50LCBib29sIGhpZ2hlckRldGFpbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicG9seWdvblwiLCBcIidwb2x5Z29uJyBjYW4ndCBiZSBudWxsLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uLkNvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIidwb2x5Z29uLk1haW5Qb2x5Z29uLkNvdW50JyBjYW4ndCBiZSBsZXNzIHRoZW4gMy5cIik7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgZGlzdGFuY2UgdG8gbWFpbiBwb2x5Z29uLlxyXG4gICAgICAgICAgICBpZiAoRGlzdGFuY2VUb0h1bGxBY2NlcHRhYmxlKChWZXJ0aWNlcylwb2x5Z29uLCBwb2ludCwgaGlnaGVyRGV0YWlsKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb24uSG9sZXMgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHlnb24uSG9sZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9uZSBkaXN0YW5jZSBub3QgYWNjZXB0YWJsZSB0aGVuIHJldHVybiBmYWxzZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFEaXN0YW5jZVRvSHVsbEFjY2VwdGFibGUocG9seWdvbi5Ib2xlc1tpXSwgcG9pbnQsIGhpZ2hlckRldGFpbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFsbCBkaXN0YW5jZXMgYXJlIGxhcmdlciB0aGVuIF9odWxsVG9sZXJhbmNlLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gZmFsc2UuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBEaXN0YW5jZVRvSHVsbEFjY2VwdGFibGUoVmVydGljZXMgcG9seWdvbiwgVmVjdG9yMiBwb2ludCwgYm9vbCBoaWdoZXJEZXRhaWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInBvbHlnb25cIiwgXCIncG9seWdvbicgY2FuJ3QgYmUgbnVsbC5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCIncG9seWdvbi5Db3VudCcgY2FuJ3QgYmUgbGVzcyB0aGVuIDMuXCIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZWRnZVZlcnRleDIgPSBwb2x5Z29uW3BvbHlnb24uQ291bnQgLSAxXTtcclxuICAgICAgICAgICAgVmVjdG9yMiBlZGdlVmVydGV4MTtcclxuXHJcbiAgICAgICAgICAgIGlmIChoaWdoZXJEZXRhaWwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcG9seWdvbi5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VWZXJ0ZXgxID0gcG9seWdvbltpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpbmVUb29scy5EaXN0YW5jZUJldHdlZW5Qb2ludEFuZExpbmVTZWdtZW50KHJlZiBwb2ludCwgcmVmIGVkZ2VWZXJ0ZXgxLCByZWYgZWRnZVZlcnRleDIpIDw9IF9odWxsVG9sZXJhbmNlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExpbmVUb29scy5EaXN0YW5jZUJldHdlZW5Qb2ludEFuZFBvaW50KHJlZiBwb2ludCwgcmVmIGVkZ2VWZXJ0ZXgxKSA8PSBfaHVsbFRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VWZXJ0ZXgyID0gcG9seWdvbltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcG9seWdvbi5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VWZXJ0ZXgxID0gcG9seWdvbltpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpbmVUb29scy5EaXN0YW5jZUJldHdlZW5Qb2ludEFuZExpbmVTZWdtZW50KHJlZiBwb2ludCwgcmVmIGVkZ2VWZXJ0ZXgxLCByZWYgZWRnZVZlcnRleDIpIDw9IF9odWxsVG9sZXJhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZVZlcnRleDIgPSBwb2x5Z29uW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgSW5Qb2x5Z29uKERldGVjdGVkVmVydGljZXMgcG9seWdvbiwgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJvb2wgaW5Qb2x5Z29uID0gIURpc3RhbmNlVG9IdWxsQWNjZXB0YWJsZShwb2x5Z29uLCBwb2ludCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWluUG9seWdvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTGlzdDxmbG9hdD4geENvb3JkcyA9IFNlYXJjaENyb3NzaW5nRWRnZXMocG9seWdvbiwgKGludClwb2ludC5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoeENvb3Jkcy5Db3VudCA+IDAgJiYgeENvb3Jkcy5Db3VudCAlIDIgPT0gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHhDb29yZHMuQ291bnQ7IGkgKz0gMilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4Q29vcmRzW2ldIDw9IHBvaW50LlggJiYgeENvb3Jkc1tpICsgMV0gPj0gcG9pbnQuWClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyPyBHZXRUb3BNb3N0VmVydGV4KFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgdG9wTW9zdFZhbHVlID0gZmxvYXQuTWF4VmFsdWU7XHJcbiAgICAgICAgICAgIFZlY3RvcjI/IHRvcE1vc3QgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9wTW9zdFZhbHVlID4gdmVydGljZXNbaV0uWSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BNb3N0VmFsdWUgPSB2ZXJ0aWNlc1tpXS5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE1vc3QgPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRvcE1vc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IEdldFRvcE1vc3RDb29yZChWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IHJldHVyblZhbHVlID0gZmxvYXQuTWF4VmFsdWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSA+IHZlcnRpY2VzW2ldLlkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB2ZXJ0aWNlc1tpXS5ZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IEdldEJvdHRvbU1vc3RDb29yZChWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IHJldHVyblZhbHVlID0gZmxvYXQuTWluVmFsdWU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSA8IHZlcnRpY2VzW2ldLlkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB2ZXJ0aWNlc1tpXS5ZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIExpc3Q8ZmxvYXQ+IFNlYXJjaENyb3NzaW5nRWRnZXMoRGV0ZWN0ZWRWZXJ0aWNlcyBwb2x5Z29uLCBpbnQgeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnROdWxsRXhjZXB0aW9uKFwicG9seWdvblwiLCBcIidwb2x5Z29uJyBjYW4ndCBiZSBudWxsLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uLkNvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIidwb2x5Z29uLk1haW5Qb2x5Z29uLkNvdW50JyBjYW4ndCBiZSBsZXNzIHRoZW4gMy5cIik7XHJcblxyXG4gICAgICAgICAgICBMaXN0PGZsb2F0PiByZXN1bHQgPSBTZWFyY2hDcm9zc2luZ0VkZ2VzKChWZXJ0aWNlcylwb2x5Z29uLCB5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uLkhvbGVzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcG9seWdvbi5Ib2xlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5BZGRSYW5nZShTZWFyY2hDcm9zc2luZ0VkZ2VzKHBvbHlnb24uSG9sZXNbaV0sIHkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0LlNvcnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2VhcmNoZXMgdGhlIHBvbHlnb24gZm9yIHRoZSB4IGNvb3JkaW5hdGVzIG9mIHRoZSBlZGdlcyB0aGF0IGNyb3NzIHRoZSBzcGVjaWZpZWQgeSBjb29yZGluYXRlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9seWdvblwiPlBvbHlnb24gdG8gc2VhcmNoIGluLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieVwiPlkgY29vcmRpbmF0ZSB0byBjaGVjayBmb3IgZWRnZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+RGVzY2VuZGluZyBzb3J0ZWQgbGlzdCBvZiB4IGNvb3JkaW5hdGVzIG9mIGVkZ2VzIHRoYXQgY3Jvc3MgdGhlIHNwZWNpZmllZCB5IGNvb3JkaW5hdGUuPC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgTGlzdDxmbG9hdD4gU2VhcmNoQ3Jvc3NpbmdFZGdlcyhWZXJ0aWNlcyBwb2x5Z29uLCBpbnQgeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHNpY2stby1ub3RlOlxyXG4gICAgICAgICAgICAvLyBVc2VkIHRvIHNlYXJjaCB0aGUgeCBjb29yZGluYXRlcyBvZiBlZGdlcyBpbiB0aGUgcG9seWdvbiBmb3IgYSBzcGVjaWZpYyB5IGNvb3JkaW5hdGUuXHJcbiAgICAgICAgICAgIC8vIChVc3VhbHkgY29tbWluZyBmcm9tIHRoZSB0ZXh0dXJlIGRhdGEsIHRoYXQncyB3aHkgaXQncyBhbiBpbnQgYW5kIG5vdCBhIGZsb2F0LilcclxuXHJcbiAgICAgICAgICAgIExpc3Q8ZmxvYXQ+IGVkZ2VzID0gbmV3IExpc3Q8ZmxvYXQ+KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBjdXJyZW50IGVkZ2VcclxuICAgICAgICAgICAgVmVjdG9yMiBzbG9wZTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2ZXJ0ZXgxOyAgICAvLyBpXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdmVydGV4MjsgICAgLy8gaSAtIDFcclxuXHJcbiAgICAgICAgICAgIC8vIG5leHQgZWRnZVxyXG4gICAgICAgICAgICBWZWN0b3IyIG5leHRTbG9wZTtcclxuICAgICAgICAgICAgVmVjdG9yMiBuZXh0VmVydGV4OyAvLyBpICsgMVxyXG5cclxuICAgICAgICAgICAgYm9vbCBhZGRGaW5kO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBvbHlnb24uQ291bnQgPiAyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGdhcCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgdmVydGV4IGluIHRoZSB2ZXJ0ZXggbGlzdC5cclxuICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgYnJpZGdlIHRoYXQgYnkgc2V0dGluZyB0aGUgbGFzdCB2ZXJ0ZXggKHZlcnRleDIpIHRvIHRoZSBsYXN0IFxyXG4gICAgICAgICAgICAgICAgLy8gdmVydGV4IGluIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgICAgdmVydGV4MiA9IHBvbHlnb25bcG9seWdvbi5Db3VudCAtIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBtb3ZpbmcgYWxvbmcgdGhlIHBvbHlnb24gZWRnZXMuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHlnb24uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgxID0gcG9seWdvbltpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwcm94LiBjaGVjayBpZiB0aGUgZWRnZSBjcm9zc2VzIG91ciB5IGNvb3JkLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodmVydGV4MS5ZID49IHkgJiYgdmVydGV4Mi5ZIDw9IHkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh2ZXJ0ZXgxLlkgPD0geSAmJiB2ZXJ0ZXgyLlkgPj0geSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZWRnZXMgdGhhdCBhcmUgcGFyYWxsZWwgdG8geS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleDEuWSAhPSB2ZXJ0ZXgyLlkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZpbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvcGUgPSB2ZXJ0ZXgyIC0gdmVydGV4MTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIHRocmVhdG1lbnQgZm9yIGVkZ2VzIHRoYXQgZW5kIGF0IHRoZSB5IGNvb3JkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleDEuWSA9PSB5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwcmV2aWV3IG9mIHRoZSBuZXh0IGVkZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFZlcnRleCA9IHBvbHlnb25bKGkgKyAxKSAlIHBvbHlnb24uQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTbG9wZSA9IHZlcnRleDEgLSBuZXh0VmVydGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcGVha3MuIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRod28gZWRnZXMgYXJlIGFsaWduZWQgbGlrZSB0aGlzOiAvXFwgYW5kIHRoZSB5IGNvb3JkaW5hdGUgbGllcyBvbiB0aGUgdG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgZ2V0IHRoZSBzYW1lIHggY29vcmQgdHdpY2UgYW5kIHdlIGRvbid0IG5lZWQgdGhhdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvcGUuWSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZpbmQgPSAobmV4dFNsb3BlLlkgPD0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGaW5kID0gKG5leHRTbG9wZS5ZID49IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRGaW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzLkFkZCgoeSAtIHZlcnRleDEuWSkgLyBzbG9wZS5ZICogc2xvcGUuWCArIHZlcnRleDEuWCk7IC8vIENhbGN1bGF0ZSBhbmQgYWRkIHRoZSB4IGNvb3JkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB2ZXJ0ZXgxIGJlY29tZXMgdmVydGV4MiA6KS5cclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgyID0gdmVydGV4MTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWRnZXMuU29ydCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWRnZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgU3BsaXRQb2x5Z29uRWRnZShWZXJ0aWNlcyBwb2x5Z29uLCBWZWN0b3IyIGNvb3JkSW5zaWRlVGhlUG9seWdvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IGludCB2ZXJ0ZXgxSW5kZXgsIG91dCBpbnQgdmVydGV4MkluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBzbG9wZTtcclxuICAgICAgICAgICAgaW50IG5lYXJlc3RFZGdlVmVydGV4MUluZGV4ID0gMDtcclxuICAgICAgICAgICAgaW50IG5lYXJlc3RFZGdlVmVydGV4MkluZGV4ID0gMDtcclxuICAgICAgICAgICAgYm9vbCBlZGdlRm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHNob3J0ZXN0RGlzdGFuY2UgPSBmbG9hdC5NYXhWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGJvb2wgZWRnZUNvb3JkRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgVmVjdG9yMiBmb3VuZEVkZ2VDb29yZCA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgIExpc3Q8ZmxvYXQ+IHhDb29yZHMgPSBTZWFyY2hDcm9zc2luZ0VkZ2VzKHBvbHlnb24sIChpbnQpY29vcmRJbnNpZGVUaGVQb2x5Z29uLlkpO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4MUluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmVydGV4MkluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvdW5kRWRnZUNvb3JkLlkgPSBjb29yZEluc2lkZVRoZVBvbHlnb24uWTtcclxuXHJcbiAgICAgICAgICAgIGlmICh4Q29vcmRzICE9IG51bGwgJiYgeENvb3Jkcy5Db3VudCA+IDEgJiYgeENvb3Jkcy5Db3VudCAlIDIgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHhDb29yZHMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeENvb3Jkc1tpXSA8IGNvb3JkSW5zaWRlVGhlUG9seWdvbi5YKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBjb29yZEluc2lkZVRoZVBvbHlnb24uWCAtIHhDb29yZHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBzaG9ydGVzdERpc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydGVzdERpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEVkZ2VDb29yZC5YID0geENvb3Jkc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlQ29vcmRGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VDb29yZEZvdW5kKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3J0ZXN0RGlzdGFuY2UgPSBmbG9hdC5NYXhWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGVkZ2VWZXJ0ZXgySW5kZXggPSBwb2x5Z29uLkNvdW50IC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGVkZ2VWZXJ0ZXgxSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChlZGdlVmVydGV4MUluZGV4ID0gMDsgZWRnZVZlcnRleDFJbmRleCA8IHBvbHlnb24uQ291bnQ7IGVkZ2VWZXJ0ZXgxSW5kZXgrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdGVtcFZlY3RvcjEgPSBwb2x5Z29uW2VkZ2VWZXJ0ZXgxSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRlbXBWZWN0b3IyID0gcG9seWdvbltlZGdlVmVydGV4MkluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBMaW5lVG9vbHMuRGlzdGFuY2VCZXR3ZWVuUG9pbnRBbmRMaW5lU2VnbWVudChyZWYgZm91bmRFZGdlQ29vcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmIHRlbXBWZWN0b3IxLCByZWYgdGVtcFZlY3RvcjIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBzaG9ydGVzdERpc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydGVzdERpc3RhbmNlID0gZGlzdGFuY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVhcmVzdEVkZ2VWZXJ0ZXgxSW5kZXggPSBlZGdlVmVydGV4MUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVhcmVzdEVkZ2VWZXJ0ZXgySW5kZXggPSBlZGdlVmVydGV4MkluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VWZXJ0ZXgySW5kZXggPSBlZGdlVmVydGV4MUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkZ2VGb3VuZClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3BlID0gcG9seWdvbltuZWFyZXN0RWRnZVZlcnRleDJJbmRleF0gLSBwb2x5Z29uW25lYXJlc3RFZGdlVmVydGV4MUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvcGUuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRlbXBWZWN0b3IgPSBwb2x5Z29uW25lYXJlc3RFZGdlVmVydGV4MUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBMaW5lVG9vbHMuRGlzdGFuY2VCZXR3ZWVuUG9pbnRBbmRQb2ludChyZWYgdGVtcFZlY3RvciwgcmVmIGZvdW5kRWRnZUNvb3JkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleDFJbmRleCA9IG5lYXJlc3RFZGdlVmVydGV4MUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgySW5kZXggPSBuZWFyZXN0RWRnZVZlcnRleDFJbmRleCArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLkluc2VydChuZWFyZXN0RWRnZVZlcnRleDFJbmRleCwgZGlzdGFuY2UgKiBzbG9wZSArIHBvbHlnb25bdmVydGV4MUluZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24uSW5zZXJ0KG5lYXJlc3RFZGdlVmVydGV4MUluZGV4LCBkaXN0YW5jZSAqIHNsb3BlICsgcG9seWdvblt2ZXJ0ZXgySW5kZXhdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVudHJhbmNlXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsYXN0XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgVmVydGljZXMgQ3JlYXRlU2ltcGxlUG9seWdvbihWZWN0b3IyIGVudHJhbmNlLCBWZWN0b3IyIGxhc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib29sIGVudHJhbmNlRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgYm9vbCBlbmRPZkh1bGwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHBvbHlnb24gPSBuZXcgVmVydGljZXMoMzIpO1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBodWxsQXJlYSA9IG5ldyBWZXJ0aWNlcygzMik7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIGVuZE9mSHVsbEFyZWEgPSBuZXcgVmVydGljZXMoMzIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBjdXJyZW50ID0gVmVjdG9yMi5aZXJvO1xyXG5cclxuICAgICAgICAgICAgI3JlZ2lvbiBFbnRyYW5jZSBjaGVja1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBlbnRyYW5jZSBwb2ludC4gLy90b2RvOiBhbGxlIG3DtmdsaWNoa2VpdGVuIHRlc3RlblxyXG4gICAgICAgICAgICBpZiAoZW50cmFuY2UgPT0gVmVjdG9yMi5aZXJvIHx8ICFJbkJvdW5kcyhyZWYgZW50cmFuY2UpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBlbnRyYW5jZUZvdW5kID0gU2VhcmNoSHVsbEVudHJhbmNlKG91dCBlbnRyYW5jZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJhbmNlRm91bmQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBWZWN0b3IyKGVudHJhbmNlLlggLSAxZiwgZW50cmFuY2UuWSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXNTb2xpZChyZWYgZW50cmFuY2UpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChJc05lYXJQaXhlbChyZWYgZW50cmFuY2UsIHJlZiBsYXN0KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBsYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyYW5jZUZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU2VhcmNoTmVhclBpeGVscyhmYWxzZSwgcmVmIGVudHJhbmNlLCBvdXQgdGVtcCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmFuY2VGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyYW5jZUZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgICAgIGlmIChlbnRyYW5jZUZvdW5kKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwb2x5Z29uLkFkZChlbnRyYW5jZSk7XHJcbiAgICAgICAgICAgICAgICBodWxsQXJlYS5BZGQoZW50cmFuY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbmV4dCA9IGVudHJhbmNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGluIHRoZSBwcmUgdmlzaW9uIGxpc3QgZm9yIGFuIG91dHN0YW5kaW5nIHBvaW50LlxyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgb3V0c3RhbmRpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNlYXJjaEZvck91dHN0YW5kaW5nVmVydGV4KGh1bGxBcmVhLCBvdXQgb3V0c3RhbmRpbmcpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZE9mSHVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCB0aGUgbmV4dCBwaXhlbCwgYnV0IGlzIGl0IG9uIHRoZSBsYXN0IGJpdCBvZiB0aGUgaHVsbD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRPZkh1bGxBcmVhLkNvbnRhaW5zKG91dHN0YW5kaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmRlZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5BZGQob3V0c3RhbmRpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyBlbm91Z2gsIHF1aXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGl0IGFuZCByZW1vdmUgYWxsIHZlcnRpY2VzIHRoYXQgZG9uJ3QgbWF0dGVyIGFueW1vcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGFsbCB0aGUgdmVydGljZXMgYmVmb3JlIHRoZSBvdXRzdGFuZGluZykuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24uQWRkKG91dHN0YW5kaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHVsbEFyZWEuUmVtb3ZlUmFuZ2UoMCwgaHVsbEFyZWEuSW5kZXhPZihvdXRzdGFuZGluZykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBwb2ludCBnZXRzIGN1cnJlbnQgYW5kIGN1cnJlbnQgZ2V0cyBuZXh0LiBPdXIgbGl0dGxlIHNwaWRlciBpcyBtb3ZpbmcgZm9yd2FyZCBvbiB0aGUgaHVsbCA7KS5cclxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IHBvaW50IG9uIGh1bGwuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEdldE5leHRIdWxsUG9pbnQocmVmIGxhc3QsIHJlZiBjdXJyZW50LCBvdXQgbmV4dCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZlcnRleCB0byBhIGh1bGwgcHJlIHZpc2lvbiBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBodWxsQXJlYS5BZGQobmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1aXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSBlbnRyYW5jZSAmJiAhZW5kT2ZIdWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyB0aGUgbGFzdCBiaXQgb2YgdGhlIGh1bGwsIHNlYXJjaCBvbiBhbmQgZXhpdCBhdCBuZXh0IGZvdW5kIHZlcnRleC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2ZIdWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2ZIdWxsQXJlYS5BZGRSYW5nZShodWxsQXJlYSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRoZSBsYXN0IHZlcnRleCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgZmlyc3Qgb25lLCBiZWNhdXNlIGl0IGNhdXNlcyB0aGUgdHJpYW5ndWxhdGlvbiBjb2RlIHRvIGNyYXNoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kT2ZIdWxsQXJlYS5Db250YWlucyhlbnRyYW5jZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRPZkh1bGxBcmVhLlJlbW92ZShlbnRyYW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBTZWFyY2hOZWFyUGl4ZWxzKGJvb2wgc2VhcmNoaW5nRm9yU29saWRQaXhlbCwgcmVmIFZlY3RvcjIgY3VycmVudCwgb3V0IFZlY3RvcjIgZm91bmRQaXhlbClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX0NMT1NFUElYRUxTX0xFTkdUSDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgeCA9IChpbnQpY3VycmVudC5YICsgQ2xvc2VQaXhlbHNbaSwgMF07XHJcbiAgICAgICAgICAgICAgICBpbnQgeSA9IChpbnQpY3VycmVudC5ZICsgQ2xvc2VQaXhlbHNbaSwgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWFyY2hpbmdGb3JTb2xpZFBpeGVsIF4gSXNTb2xpZChyZWYgeCwgcmVmIHkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kUGl4ZWwgPSBuZXcgVmVjdG9yMih4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm90aGluZyBmb3VuZC5cclxuICAgICAgICAgICAgZm91bmRQaXhlbCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBib29sIElzTmVhclBpeGVsKHJlZiBWZWN0b3IyIGN1cnJlbnQsIHJlZiBWZWN0b3IyIG5lYXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9DTE9TRVBJWEVMU19MRU5HVEg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHggPSAoaW50KWN1cnJlbnQuWCArIENsb3NlUGl4ZWxzW2ksIDBdO1xyXG4gICAgICAgICAgICAgICAgaW50IHkgPSAoaW50KWN1cnJlbnQuWSArIENsb3NlUGl4ZWxzW2ksIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeCA8PSBfd2lkdGggJiYgeSA+PSAwICYmIHkgPD0gX2hlaWdodClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSAoaW50KW5lYXIuWCAmJiB5ID09IChpbnQpbmVhci5ZKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgU2VhcmNoSHVsbEVudHJhbmNlKG91dCBWZWN0b3IyIGVudHJhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBmaXJzdCBzb2xpZCBwaXhlbC5cclxuICAgICAgICAgICAgZm9yIChpbnQgeSA9IDA7IHkgPD0gX2hlaWdodDsgeSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB4ID0gMDsgeCA8PSBfd2lkdGg7IHgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoSXNTb2xpZChyZWYgeCwgcmVmIHkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cmFuY2UgPSBuZXcgVmVjdG9yMih4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc29saWQgcGl4ZWxzLlxyXG4gICAgICAgICAgICBlbnRyYW5jZSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZWFyY2hlcyBmb3IgdGhlIG5leHQgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkZXRlY3RlZFBvbHlnb25zXCI+QWxyZWFkeSBkZXRlY3RlZCBwb2x5Z29ucy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0YXJ0XCI+U2VhcmNoIHN0YXJ0IGNvb3JkaW5hdGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlbnRyYW5jZVwiPlJldHVybnMgdGhlIGZvdW5kIGVudHJhbmNlIGNvb3JkaW5hdGUuIE51bGwgaWYgbm8gb3RoZXIgc2hhcGVzIGZvdW5kLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgYSBuZXcgc2hhcGUgd2FzIGZvdW5kLjwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIGJvb2wgU2VhcmNoTmV4dEh1bGxFbnRyYW5jZShMaXN0PERldGVjdGVkVmVydGljZXM+IGRldGVjdGVkUG9seWdvbnMsIFZlY3RvcjIgc3RhcnQsIG91dCBWZWN0b3IyPyBlbnRyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCB4O1xyXG5cclxuICAgICAgICAgICAgYm9vbCBmb3VuZFRyYW5zcGFyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGJvb2wgaW5Qb2x5Z29uID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gKGludClzdGFydC5YICsgKGludClzdGFydC5ZICogX3dpZHRoOyBpIDw9IF9kYXRhTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChJc1NvbGlkKHJlZiBpKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRUcmFuc3BhcmVudClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBpICUgX3dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyYW5jZSA9IG5ldyBWZWN0b3IyKHgsIChpIC0geCkgLyAoZmxvYXQpX3dpZHRoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUG9seWdvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBwb2x5Z29uSWR4ID0gMDsgcG9seWdvbklkeCA8IGRldGVjdGVkUG9seWdvbnMuQ291bnQ7IHBvbHlnb25JZHgrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEluUG9seWdvbihkZXRlY3RlZFBvbHlnb25zW3BvbHlnb25JZHhdLCBlbnRyYW5jZS5WYWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Qb2x5Z29uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluUG9seWdvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kVHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kVHJhbnNwYXJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlbnRyYW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBHZXROZXh0SHVsbFBvaW50KHJlZiBWZWN0b3IyIGxhc3QsIHJlZiBWZWN0b3IyIGN1cnJlbnQsIG91dCBWZWN0b3IyIG5leHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgeDtcclxuICAgICAgICAgICAgaW50IHk7XHJcblxyXG4gICAgICAgICAgICBpbnQgaW5kZXhPZkZpcnN0UGl4ZWxUb0NoZWNrID0gR2V0SW5kZXhPZkZpcnN0UGl4ZWxUb0NoZWNrKHJlZiBsYXN0LCByZWYgY3VycmVudCk7XHJcbiAgICAgICAgICAgIGludCBpbmRleE9mUGl4ZWxUb0NoZWNrO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfQ0xPU0VQSVhFTFNfTEVOR1RIOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGluZGV4T2ZQaXhlbFRvQ2hlY2sgPSAoaW5kZXhPZkZpcnN0UGl4ZWxUb0NoZWNrICsgaSkgJSBfQ0xPU0VQSVhFTFNfTEVOR1RIO1xyXG5cclxuICAgICAgICAgICAgICAgIHggPSAoaW50KWN1cnJlbnQuWCArIENsb3NlUGl4ZWxzW2luZGV4T2ZQaXhlbFRvQ2hlY2ssIDBdO1xyXG4gICAgICAgICAgICAgICAgeSA9IChpbnQpY3VycmVudC5ZICsgQ2xvc2VQaXhlbHNbaW5kZXhPZlBpeGVsVG9DaGVjaywgMV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB4IDwgX3dpZHRoICYmIHkgPj0gMCAmJiB5IDw9IF9oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKElzU29saWQocmVmIHgsIHJlZiB5KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXcgVmVjdG9yMih4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBuZXh0ID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgU2VhcmNoRm9yT3V0c3RhbmRpbmdWZXJ0ZXgoVmVydGljZXMgaHVsbEFyZWEsIG91dCBWZWN0b3IyIG91dHN0YW5kaW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBvdXRzdGFuZGluZ1Jlc3VsdCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgYm9vbCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGh1bGxBcmVhLkNvdW50ID4gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGh1bGxBcmVhTGFzdFBvaW50ID0gaHVsbEFyZWEuQ291bnQgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdGVtcFZlY3RvcjE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHRlbXBWZWN0b3IyID0gaHVsbEFyZWFbMF07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHRlbXBWZWN0b3IzID0gaHVsbEFyZWFbaHVsbEFyZWFMYXN0UG9pbnRdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBodWxsIHBvaW50LlxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBodWxsQXJlYUxhc3RQb2ludDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBWZWN0b3IxID0gaHVsbEFyZWFbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBkaXN0YW5jZSBpcyBvdmVyIHRoZSBvbmUgdGhhdCdzIHRvbGVyYWJsZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoTGluZVRvb2xzLkRpc3RhbmNlQmV0d2VlblBvaW50QW5kTGluZVNlZ21lbnQocmVmIHRlbXBWZWN0b3IxLCByZWYgdGVtcFZlY3RvcjIsIHJlZiB0ZW1wVmVjdG9yMykgPj0gX2h1bGxUb2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Jlc3VsdCA9IGh1bGxBcmVhW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3V0c3RhbmRpbmcgPSBvdXRzdGFuZGluZ1Jlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgR2V0SW5kZXhPZkZpcnN0UGl4ZWxUb0NoZWNrKHJlZiBWZWN0b3IyIGxhc3QsIHJlZiBWZWN0b3IyIGN1cnJlbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAuOiBwaXhlbFxyXG4gICAgICAgICAgICAvLyBsOiBsYXN0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIC8vIGM6IGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAgICAgICAgLy8gZjogZmlyc3QgcGl4ZWwgZm9yIG5leHQgc2VhcmNoXHJcblxyXG4gICAgICAgICAgICAvLyBmIC4gLlxyXG4gICAgICAgICAgICAvLyBsIGMgLlxyXG4gICAgICAgICAgICAvLyAuIC4gLlxyXG5cclxuICAgICAgICAgICAgLy9DYWxjdWxhdGUgaW4gd2hpY2ggZGlyZWN0aW9uIHRoZSBsYXN0IG1vdmUgd2VudCBhbmQgZGVjaWRlIG92ZXIgdGhlIG5leHQgcGl4ZWwgdG8gY2hlY2suXHJcbiAgICAgICAgICAgIHN3aXRjaCAoKGludCkoY3VycmVudC5YIC0gbGFzdC5YKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoKGludCkoY3VycmVudC5ZIC0gbGFzdC5ZKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKChpbnQpKGN1cnJlbnQuWSAtIGxhc3QuWSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLTE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAtMTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKChpbnQpKGN1cnJlbnQuWSAtIGxhc3QuWSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db250cm9sbGVyc1xyXG57XHJcbiAgICBbRmxhZ3NdXHJcbiAgICBwdWJsaWMgZW51bSBDb250cm9sbGVyVHlwZVxyXG4gICAge1xyXG4gICAgICAgIEdyYXZpdHlDb250cm9sbGVyID0gKDEgPDwgMCksXHJcbiAgICAgICAgVmVsb2NpdHlMaW1pdENvbnRyb2xsZXIgPSAoMSA8PCAxKSxcclxuICAgICAgICBBYnN0cmFjdEZvcmNlQ29udHJvbGxlciA9ICgxIDw8IDIpLFxyXG4gICAgICAgIEJ1b3lhbmN5Q29udHJvbGxlciA9ICgxIDw8IDMpLFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgQ29udHJvbGxlckZpbHRlclxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBDb250cm9sbGVyVHlwZSBDb250cm9sbGVyRmxhZ3M7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSWdub3JlcyB0aGUgY29udHJvbGxlci4gVGhlIGNvbnRyb2xsZXIgaGFzIG5vIGVmZmVjdCBvbiB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb250cm9sbGVyXCI+VGhlIGNvbnRyb2xsZXIgdHlwZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIElnbm9yZUNvbnRyb2xsZXIoQ29udHJvbGxlclR5cGUgY29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbnRyb2xsZXJGbGFncyB8PSBjb250cm9sbGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXN0b3JlIHRoZSBjb250cm9sbGVyLiBUaGUgY29udHJvbGxlciBhZmZlY3RzIHRoaXMgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbnRyb2xsZXJcIj5UaGUgY29udHJvbGxlciB0eXBlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVzdG9yZUNvbnRyb2xsZXIoQ29udHJvbGxlclR5cGUgY29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbnRyb2xsZXJGbGFncyAmPSB+Y29udHJvbGxlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgYm9keSBpZ25vcmVzIHRoZSB0aGUgc3BlY2lmaWVkIGNvbnRyb2xsZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb250cm9sbGVyXCI+VGhlIGNvbnRyb2xsZXIgdHlwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gXHQ8Yz50cnVlPC9jPiBpZiB0aGUgYm9keSBoYXMgdGhlIHNwZWNpZmllZCBmbGFnOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzQ29udHJvbGxlcklnbm9yZWQoQ29udHJvbGxlclR5cGUgY29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoQ29udHJvbGxlckZsYWdzICYgY29udHJvbGxlcikgPT0gY29udHJvbGxlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIENvbnRyb2xsZXIgOiBGaWx0ZXJEYXRhXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGJvb2wgRW5hYmxlZDtcclxuICAgICAgICBwdWJsaWMgV29ybGQgV29ybGQ7XHJcbiAgICAgICAgcHJpdmF0ZSBDb250cm9sbGVyVHlwZSBfdHlwZTtcclxuXHJcbiAgICAgICAgcHVibGljIENvbnRyb2xsZXIoQ29udHJvbGxlclR5cGUgY29udHJvbGxlclR5cGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfdHlwZSA9IGNvbnRyb2xsZXJUeXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgSXNBY3RpdmVPbihCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoYm9keS5Db250cm9sbGVyRmlsdGVyLklzQ29udHJvbGxlcklnbm9yZWQoX3R5cGUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJhc2UuSXNBY3RpdmVPbihib2R5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIFVwZGF0ZShmbG9hdCBkdCk7XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3Ncclxue1xyXG4gICAgW0ZsYWdzXVxyXG4gICAgcHVibGljIGVudW0gRGVidWdWaWV3RmxhZ3NcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXcgc2hhcGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgU2hhcGUgPSAoMSA8PCAwKSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGpvaW50IGNvbm5lY3Rpb25zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgSm9pbnQgPSAoMSA8PCAxKSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3hlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIEFBQkIgPSAoMSA8PCAyKSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGJyb2FkLXBoYXNlIHBhaXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgUGFpciA9ICgxIDw8IDMpLFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXcgY2VudGVyIG9mIG1hc3MgZnJhbWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBDZW50ZXJPZk1hc3MgPSAoMSA8PCA0KSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IHVzZWZ1bCBkZWJ1ZyBkYXRhIHN1Y2ggYXMgdGltaW5ncyBhbmQgbnVtYmVyIG9mIGJvZGllcywgam9pbnRzLCBjb250YWN0cyBhbmQgbW9yZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIERlYnVnUGFuZWwgPSAoMSA8PCA1KSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGNvbnRhY3QgcG9pbnRzIGJldHdlZW4gY29sbGlkaW5nIGJvZGllcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIENvbnRhY3RQb2ludHMgPSAoMSA8PCA2KSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGNvbnRhY3Qgbm9ybWFscy4gTmVlZCBDb250YWN0UG9pbnRzIHRvIGJlIGVuYWJsZWQgZmlyc3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBDb250YWN0Tm9ybWFscyA9ICgxIDw8IDcpLFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXdzIHRoZSB2ZXJ0aWNlcyBvZiBwb2x5Z29ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFBvbHlnb25Qb2ludHMgPSAoMSA8PCA4KSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3cyB0aGUgcGVyZm9ybWFuY2UgZ3JhcGguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBQZXJmb3JtYW5jZUdyYXBoID0gKDEgPDwgOSksXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhd3MgY29udHJvbGxlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBDb250cm9sbGVycyA9ICgxIDw8IDEwKVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyBJbXBsZW1lbnQgYW5kIHJlZ2lzdGVyIHRoaXMgY2xhc3Mgd2l0aCBhIFdvcmxkIHRvIHByb3ZpZGUgZGVidWcgZHJhd2luZyBvZiBwaHlzaWNzXHJcbiAgICAvLy8gZW50aXRpZXMgaW4geW91ciBnYW1lLlxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIERlYnVnVmlld1xyXG4gICAge1xyXG4gICAgICAgIHByb3RlY3RlZCBEZWJ1Z1ZpZXcoV29ybGQgd29ybGQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBXb3JsZCA9IHdvcmxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIFdvcmxkIFdvcmxkIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgZGVidWcgdmlldyBmbGFncy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGZsYWdzLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIERlYnVnVmlld0ZsYWdzIEZsYWdzIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBlbmQgZmxhZ3MgdG8gdGhlIGN1cnJlbnQgZmxhZ3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmbGFnc1wiPlRoZSBmbGFncy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGVuZEZsYWdzKERlYnVnVmlld0ZsYWdzIGZsYWdzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRmxhZ3MgfD0gZmxhZ3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlbW92ZSBmbGFncyBmcm9tIHRoZSBjdXJyZW50IGZsYWdzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZmxhZ3NcIj5UaGUgZmxhZ3MuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVGbGFncyhEZWJ1Z1ZpZXdGbGFncyBmbGFncylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZsYWdzICY9IH5mbGFncztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBhIGNsb3NlZCBwb2x5Z29uIHByb3ZpZGVkIGluIENDVyBvcmRlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY291bnRcIj5UaGUgdmVydGV4IGNvdW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVkXCI+VGhlIHJlZCB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJsdWVcIj5UaGUgYmx1ZSB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImdyZWVuXCI+VGhlIGdyZWVuIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgRHJhd1BvbHlnb24oVmVjdG9yMltdIHZlcnRpY2VzLCBpbnQgY291bnQsIGZsb2F0IHJlZCwgZmxvYXQgYmx1ZSwgZmxvYXQgZ3JlZW4pO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXcgYSBzb2xpZCBjbG9zZWQgcG9seWdvbiBwcm92aWRlZCBpbiBDQ1cgb3JkZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvdW50XCI+VGhlIHZlcnRleCBjb3VudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlZFwiPlRoZSByZWQgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJibHVlXCI+VGhlIGJsdWUgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJncmVlblwiPlRoZSBncmVlbiB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIERyYXdTb2xpZFBvbHlnb24oVmVjdG9yMltdIHZlcnRpY2VzLCBpbnQgY291bnQsIGZsb2F0IHJlZCwgZmxvYXQgYmx1ZSwgZmxvYXQgZ3JlZW4pO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXcgYSBjaXJjbGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjZW50ZXJcIj5UaGUgY2VudGVyLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmFkaXVzXCI+VGhlIHJhZGl1cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlZFwiPlRoZSByZWQgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJibHVlXCI+VGhlIGJsdWUgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJncmVlblwiPlRoZSBncmVlbiB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIERyYXdDaXJjbGUoVmVjdG9yMiBjZW50ZXIsIGZsb2F0IHJhZGl1cywgZmxvYXQgcmVkLCBmbG9hdCBibHVlLCBmbG9hdCBncmVlbik7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBhIHNvbGlkIGNpcmNsZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNlbnRlclwiPlRoZSBjZW50ZXIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyYWRpdXNcIj5UaGUgcmFkaXVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYXhpc1wiPlRoZSBheGlzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVkXCI+VGhlIHJlZCB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJsdWVcIj5UaGUgYmx1ZSB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImdyZWVuXCI+VGhlIGdyZWVuIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgRHJhd1NvbGlkQ2lyY2xlKFZlY3RvcjIgY2VudGVyLCBmbG9hdCByYWRpdXMsIFZlY3RvcjIgYXhpcywgZmxvYXQgcmVkLCBmbG9hdCBibHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBncmVlbik7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBhIGxpbmUgc2VnbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0YXJ0XCI+VGhlIHN0YXJ0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZW5kXCI+VGhlIGVuZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlZFwiPlRoZSByZWQgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJibHVlXCI+VGhlIGJsdWUgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJncmVlblwiPlRoZSBncmVlbiB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIERyYXdTZWdtZW50KFZlY3RvcjIgc3RhcnQsIFZlY3RvcjIgZW5kLCBmbG9hdCByZWQsIGZsb2F0IGJsdWUsIGZsb2F0IGdyZWVuKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGEgdHJhbnNmb3JtLiBDaG9vc2UgeW91ciBvd24gbGVuZ3RoIHNjYWxlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHRyYW5zZm9ybS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIERyYXdUcmFuc2Zvcm0ocmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0pO1xyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db250cm9sbGVycztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuQ29udGFjdHM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50cztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3Ncclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoZSBib2R5IHR5cGUuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGVudW0gQm9keVR5cGVcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFplcm8gdmVsb2NpdHksIG1heSBiZSBtYW51YWxseSBtb3ZlZC4gTm90ZTogZXZlbiBzdGF0aWMgYm9kaWVzIGhhdmUgbWFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFN0YXRpYyxcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFplcm8gbWFzcywgbm9uLXplcm8gdmVsb2NpdHkgc2V0IGJ5IHVzZXIsIG1vdmVkIGJ5IHNvbHZlclxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgS2luZW1hdGljLFxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9zaXRpdmUgbWFzcywgbm9uLXplcm8gdmVsb2NpdHkgZGV0ZXJtaW5lZCBieSBmb3JjZXMsIG1vdmVkIGJ5IHNvbHZlclxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgRHluYW1pYyxcclxuICAgIH1cclxuXHJcbiAgICBbRmxhZ3NdXHJcbiAgICBwdWJsaWMgZW51bSBCb2R5RmxhZ3NcclxuICAgIHtcclxuICAgICAgICBOb25lID0gMCxcclxuICAgICAgICBJc2xhbmQgPSAoMSA8PCAwKSxcclxuICAgICAgICBBd2FrZSA9ICgxIDw8IDEpLFxyXG4gICAgICAgIEF1dG9TbGVlcCA9ICgxIDw8IDIpLFxyXG4gICAgICAgIEJ1bGxldCA9ICgxIDw8IDMpLFxyXG4gICAgICAgIEZpeGVkUm90YXRpb24gPSAoMSA8PCA0KSxcclxuICAgICAgICBFbmFibGVkID0gKDEgPDwgNSksXHJcbiAgICAgICAgSWdub3JlR3Jhdml0eSA9ICgxIDw8IDYpLFxyXG4gICAgICAgIElnbm9yZUNDRCA9ICgxIDw8IDcpLFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGFzcyBCb2R5IDogSURpc3Bvc2FibGVcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBpbnQgX2JvZHlJZENvdW50ZXI7XHJcbiAgICAgICAgaW50ZXJuYWwgZmxvYXQgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgcHVibGljIGludCBCb2R5SWQ7XHJcbiAgICAgICAgcHVibGljIENvbnRyb2xsZXJGaWx0ZXIgQ29udHJvbGxlckZpbHRlcjtcclxuICAgICAgICBpbnRlcm5hbCBCb2R5RmxhZ3MgRmxhZ3M7XHJcbiAgICAgICAgaW50ZXJuYWwgVmVjdG9yMiBGb3JjZTtcclxuICAgICAgICBpbnRlcm5hbCBmbG9hdCBJbnZJO1xyXG4gICAgICAgIGludGVybmFsIGZsb2F0IEludk1hc3M7XHJcbiAgICAgICAgaW50ZXJuYWwgVmVjdG9yMiBMaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgIHB1YmxpYyBQaHlzaWNzTG9naWNGaWx0ZXIgUGh5c2ljc0xvZ2ljRmlsdGVyO1xyXG4gICAgICAgIGludGVybmFsIGZsb2F0IFNsZWVwVGltZTtcclxuICAgICAgICBpbnRlcm5hbCBTd2VlcCBTd2VlcDsgLy8gdGhlIHN3ZXB0IG1vdGlvbiBmb3IgQ0NEXHJcbiAgICAgICAgaW50ZXJuYWwgZmxvYXQgVG9ycXVlO1xyXG4gICAgICAgIGludGVybmFsIFdvcmxkIFdvcmxkO1xyXG4gICAgICAgIGludGVybmFsIFRyYW5zZm9ybSBYZjsgLy8gdGhlIGJvZHkgb3JpZ2luIHRyYW5zZm9ybVxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2FuZ3VsYXJEYW1waW5nO1xyXG4gICAgICAgIHByaXZhdGUgQm9keVR5cGUgX2JvZHlUeXBlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2luZXJ0aWE7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbGluZWFyRGFtcGluZztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXNzO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBCb2R5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeHR1cmVMaXN0ID0gbmV3IExpc3Q8Rml4dHVyZT4oMzIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEJvZHkoV29ybGQgd29ybGQpXHJcbiAgICAgICAgICAgIDogdGhpcyh3b3JsZCwgbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgQm9keShXb3JsZCB3b3JsZCwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRml4dHVyZUxpc3QgPSBuZXcgTGlzdDxGaXh0dXJlPigzMik7XHJcbiAgICAgICAgICAgIEJvZHlJZCA9IF9ib2R5SWRDb3VudGVyKys7XHJcblxyXG4gICAgICAgICAgICBXb3JsZCA9IHdvcmxkO1xyXG4gICAgICAgICAgICBVc2VyRGF0YSA9IHVzZXJEYXRhO1xyXG5cclxuICAgICAgICAgICAgRml4ZWRSb3RhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBJc0J1bGxldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBTbGVlcGluZ0FsbG93ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBBd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgIEJvZHlUeXBlID0gQm9keVR5cGUuU3RhdGljO1xyXG4gICAgICAgICAgICBFbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIFhmLlIuU2V0KDApO1xyXG5cclxuICAgICAgICAgICAgd29ybGQuQWRkQm9keSh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IG9yIHNldCB0aGlzIGJvZHkgaXMgcGVuZXRyYWJsZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgUGVuZXRyYWJsZSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgdG90YWwgbnVtYmVyIHJldm9sdXRpb25zIHRoZSBib2R5IGhhcyBtYWRlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgcmV2b2x1dGlvbnMuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmV2b2x1dGlvbnNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBSb3RhdGlvbiAvIChmbG9hdClNYXRoLlBJOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgYm9keSB0eXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgdHlwZSBvZiBib2R5LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIEJvZHlUeXBlIEJvZHlUeXBlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2JvZHlUeXBlOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2JvZHlUeXBlID09IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBfYm9keVR5cGUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBSZXNldE1hc3NEYXRhKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgICAgICBBbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgQXdha2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIEZvcmNlID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgVG9ycXVlID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgYm9keSB0eXBlIGNoYW5nZWQsIHdlIG5lZWQgdG8gZmxhZyBjb250YWN0cyBmb3IgZmlsdGVyaW5nLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IEZpeHR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGYuUmVmaWx0ZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgb3Igc2V0cyB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGxpbmVhciB2ZWxvY2l0eS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExpbmVhclZlbG9jaXR5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTih2YWx1ZS5YKSAmJiAhZmxvYXQuSXNOYU4odmFsdWUuWSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfYm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoVmVjdG9yMi5Eb3QodmFsdWUsIHZhbHVlKSA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgQXdha2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIExpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gTGluZWFyVmVsb2NpdHlJbnRlcm5hbDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuIFJhZGlhbnMvc2Vjb25kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgYW5ndWxhciB2ZWxvY2l0eS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBBbmd1bGFyVmVsb2NpdHlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIWZsb2F0LklzTmFOKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAqIHZhbHVlID4gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICBBd2FrZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIHRoZSBsaW5lYXIgZGFtcGluZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGxpbmVhciBkYW1waW5nLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExpbmVhckRhbXBpbmdcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbGluZWFyRGFtcGluZzsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTih2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9saW5lYXJEYW1waW5nID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIHRoZSBhbmd1bGFyIGRhbXBpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBhbmd1bGFyIGRhbXBpbmcuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQW5ndWxhckRhbXBpbmdcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfYW5ndWxhckRhbXBpbmc7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4odmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfYW5ndWxhckRhbXBpbmcgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBib2R5IHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgQ0NEIHNvbHZlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgdGhpcyBpbnN0YW5jZSBpcyBpbmNsdWRlZCBpbiBDQ0Q7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNCdWxsZXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgfD0gQm9keUZsYWdzLkJ1bGxldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyAmPSB+Qm9keUZsYWdzLkJ1bGxldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKEZsYWdzICYgQm9keUZsYWdzLkJ1bGxldCkgPT0gQm9keUZsYWdzLkJ1bGxldDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBZb3UgY2FuIGRpc2FibGUgc2xlZXBpbmcgb24gdGhpcyBib2R5LiBJZiB5b3UgZGlzYWJsZSBzbGVlcGluZywgdGhlXHJcbiAgICAgICAgLy8vIGJvZHkgd2lsbCBiZSB3b2tlbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgc2xlZXBpbmcgaXMgYWxsb3dlZDsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBTbGVlcGluZ0FsbG93ZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgfD0gQm9keUZsYWdzLkF1dG9TbGVlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyAmPSB+Qm9keUZsYWdzLkF1dG9TbGVlcDtcclxuICAgICAgICAgICAgICAgICAgICBBd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChGbGFncyAmIEJvZHlGbGFncy5BdXRvU2xlZXApID09IEJvZHlGbGFncy5BdXRvU2xlZXA7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSBzbGVlcCBzdGF0ZSBvZiB0aGUgYm9keS4gQSBzbGVlcGluZyBib2R5IGhhcyB2ZXJ5XHJcbiAgICAgICAgLy8vIGxvdyBDUFUgY29zdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgYXdha2U7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgQXdha2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChGbGFncyAmIEJvZHlGbGFncy5Bd2FrZSkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZsYWdzIHw9IEJvZHlGbGFncy5Bd2FrZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2xlZXBUaW1lID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgJj0gfkJvZHlGbGFncy5Bd2FrZTtcclxuICAgICAgICAgICAgICAgICAgICBTbGVlcFRpbWUgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIExpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIEZvcmNlID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgIFRvcnF1ZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChGbGFncyAmIEJvZHlGbGFncy5Bd2FrZSkgPT0gQm9keUZsYWdzLkF3YWtlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBib2R5LiBBbiBpbmFjdGl2ZSBib2R5IGlzIG5vdFxyXG4gICAgICAgIC8vLyBzaW11bGF0ZWQgYW5kIGNhbm5vdCBiZSBjb2xsaWRlZCB3aXRoIG9yIHdva2VuIHVwLlxyXG4gICAgICAgIC8vLyBJZiB5b3UgcGFzcyBhIGZsYWcgb2YgdHJ1ZSwgYWxsIGZpeHR1cmVzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXHJcbiAgICAgICAgLy8vIGJyb2FkLXBoYXNlLlxyXG4gICAgICAgIC8vLyBJZiB5b3UgcGFzcyBhIGZsYWcgb2YgZmFsc2UsIGFsbCBmaXh0dXJlcyB3aWxsIGJlIHJlbW92ZWQgZnJvbVxyXG4gICAgICAgIC8vLyB0aGUgYnJvYWQtcGhhc2UgYW5kIGFsbCBjb250YWN0cyB3aWxsIGJlIGRlc3Ryb3llZC5cclxuICAgICAgICAvLy8gRml4dHVyZXMgYW5kIGpvaW50cyBhcmUgb3RoZXJ3aXNlIHVuYWZmZWN0ZWQuIFlvdSBtYXkgY29udGludWVcclxuICAgICAgICAvLy8gdG8gY3JlYXRlL2Rlc3Ryb3kgZml4dHVyZXMgYW5kIGpvaW50cyBvbiBpbmFjdGl2ZSBib2RpZXMuXHJcbiAgICAgICAgLy8vIEZpeHR1cmVzIG9uIGFuIGluYWN0aXZlIGJvZHkgYXJlIGltcGxpY2l0bHkgaW5hY3RpdmUgYW5kIHdpbGxcclxuICAgICAgICAvLy8gbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMsIHJheS1jYXN0cywgb3IgcXVlcmllcy5cclxuICAgICAgICAvLy8gSm9pbnRzIGNvbm5lY3RlZCB0byBhbiBpbmFjdGl2ZSBib2R5IGFyZSBpbXBsaWNpdGx5IGluYWN0aXZlLlxyXG4gICAgICAgIC8vLyBBbiBpbmFjdGl2ZSBib2R5IGlzIHN0aWxsIG93bmVkIGJ5IGEgYjJXb3JsZCBvYmplY3QgYW5kIHJlbWFpbnNcclxuICAgICAgICAvLy8gaW4gdGhlIGJvZHkgbGlzdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgYWN0aXZlOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gRW5hYmxlZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzIHw9IEJvZHlGbGFncy5FbmFibGVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYWxsIHByb3hpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSA9IFdvcmxkLkNvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRml4dHVyZUxpc3RbaV0uQ3JlYXRlUHJveGllcyhicm9hZFBoYXNlLCByZWYgWGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGFjdHMgYXJlIGNyZWF0ZWQgdGhlIG5leHQgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzICY9IH5Cb2R5RmxhZ3MuRW5hYmxlZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVzdHJveSBhbGwgcHJveGllcy5cclxuICAgICAgICAgICAgICAgICAgICBJQnJvYWRQaGFzZSBicm9hZFBoYXNlID0gV29ybGQuQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRml4dHVyZUxpc3RbaV0uRGVzdHJveVByb3hpZXMoYnJvYWRQaGFzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEZXN0cm95IHRoZSBhdHRhY2hlZCBjb250YWN0cy5cclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0RWRnZSBjZSA9IENvbnRhY3RMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdEVkZ2UgY2UwID0gY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlID0gY2UuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgV29ybGQuQ29udGFjdE1hbmFnZXIuRGVzdHJveShjZTAuQ29udGFjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RMaXN0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKEZsYWdzICYgQm9keUZsYWdzLkVuYWJsZWQpID09IEJvZHlGbGFncy5FbmFibGVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGlzIGJvZHkgdG8gaGF2ZSBmaXhlZCByb3RhdGlvbi4gVGhpcyBjYXVzZXMgdGhlIG1hc3NcclxuICAgICAgICAvLy8gdG8gYmUgcmVzZXQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIGl0IGhhcyBmaXhlZCByb3RhdGlvbjsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBGaXhlZFJvdGF0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzIHw9IEJvZHlGbGFncy5GaXhlZFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzICY9IH5Cb2R5RmxhZ3MuRml4ZWRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBSZXNldE1hc3NEYXRhKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChGbGFncyAmIEJvZHlGbGFncy5GaXhlZFJvdGF0aW9uKSA9PSBCb2R5RmxhZ3MuRml4ZWRSb3RhdGlvbjsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGFsbCB0aGUgZml4dHVyZXMgYXR0YWNoZWQgdG8gdGhpcyBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgZml4dHVyZSBsaXN0LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIExpc3Q8Rml4dHVyZT4gRml4dHVyZUxpc3QgeyBnZXQ7IGludGVybmFsIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgbGlzdCBvZiBhbGwgam9pbnRzIGF0dGFjaGVkIHRvIHRoaXMgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGpvaW50IGxpc3QuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgSm9pbnRFZGdlIEpvaW50TGlzdCB7IGdldDsgaW50ZXJuYWwgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBsaXN0IG9mIGFsbCBjb250YWN0cyBhdHRhY2hlZCB0byB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIFdhcm5pbmc6IHRoaXMgbGlzdCBjaGFuZ2VzIGR1cmluZyB0aGUgdGltZSBzdGVwIGFuZCB5b3UgbWF5XHJcbiAgICAgICAgLy8vIG1pc3Mgc29tZSBjb2xsaXNpb25zIGlmIHlvdSBkb24ndCB1c2UgQ29udGFjdExpc3RlbmVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgY29udGFjdCBsaXN0LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIENvbnRhY3RFZGdlIENvbnRhY3RMaXN0IHsgZ2V0OyBpbnRlcm5hbCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIHVzZXIgZGF0YS4gVXNlIHRoaXMgdG8gc3RvcmUgeW91ciBhcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgdXNlciBkYXRhLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIG9iamVjdCBVc2VyRGF0YSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCBib2R5IG9yaWdpbiBwb3NpdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5SZXR1cm4gdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBib2R5J3Mgb3JpZ2luLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBQb3NpdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIFhmLlBvc2l0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIWZsb2F0LklzTmFOKHZhbHVlLlgpICYmICFmbG9hdC5Jc05hTih2YWx1ZS5ZKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgU2V0VHJhbnNmb3JtKHJlZiB2YWx1ZSwgUm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgYW5nbGUgaW4gcmFkaWFucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5SZXR1cm4gdGhlIGN1cnJlbnQgd29ybGQgcm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJvdGF0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gU3dlZXAuQTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTih2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIFNldFRyYW5zZm9ybShyZWYgWGYuUG9zaXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBib2R5IGlzIHN0YXRpYy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgdGhpcyBpbnN0YW5jZSBpcyBzdGF0aWM7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNTdGF0aWNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfYm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgQm9keVR5cGUgPSBCb2R5VHlwZS5TdGF0aWM7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgQm9keVR5cGUgPSBCb2R5VHlwZS5EeW5hbWljO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGJvZHkgaWdub3JlcyBncmF2aXR5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiAgaXQgaWdub3JlcyBncmF2aXR5OyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElnbm9yZUdyYXZpdHlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoRmxhZ3MgJiBCb2R5RmxhZ3MuSWdub3JlR3Jhdml0eSkgPT0gQm9keUZsYWdzLklnbm9yZUdyYXZpdHk7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyB8PSBCb2R5RmxhZ3MuSWdub3JlR3Jhdml0eTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyAmPSB+Qm9keUZsYWdzLklnbm9yZUdyYXZpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSB3b3JsZCBwb3NpdGlvbi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFdvcmxkQ2VudGVyXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gU3dlZXAuQzsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGxvY2FsIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGxvY2FsIHBvc2l0aW9uLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxDZW50ZXJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBTd2VlcC5Mb2NhbENlbnRlcjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSAhPSBCb2R5VHlwZS5EeW5hbWljKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBvbGRDZW50ZXIgPSBTd2VlcC5DO1xyXG4gICAgICAgICAgICAgICAgU3dlZXAuTG9jYWxDZW50ZXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIFN3ZWVwLkMwID0gU3dlZXAuQyA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgWGYsIHJlZiBTd2VlcC5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNlbnRlciBvZiBtYXNzIHZlbG9jaXR5LlxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBhID0gU3dlZXAuQyAtIG9sZENlbnRlcjtcclxuICAgICAgICAgICAgICAgIExpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gbmV3IFZlY3RvcjIoLUFuZ3VsYXJWZWxvY2l0eUludGVybmFsICogYS5ZLCBBbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAqIGEuWCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIHRoZSBtYXNzLiBVc3VhbGx5IGluIGtpbG9ncmFtcyAoa2cpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgbWFzcy48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXNzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21hc3M7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4odmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2JvZHlUeXBlICE9IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIF9tYXNzID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9tYXNzIDw9IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgX21hc3MgPSAxLjBmO1xyXG5cclxuICAgICAgICAgICAgICAgIEludk1hc3MgPSAxLjBmIC8gX21hc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IG9yIHNldCB0aGUgcm90YXRpb25hbCBpbmVydGlhIG9mIHRoZSBib2R5IGFib3V0IHRoZSBsb2NhbCBvcmlnaW4uIHVzdWFsbHkgaW4ga2ctbV4yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgaW5lcnRpYS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBJbmVydGlhXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2luZXJ0aWEgKyBNYXNzICogVmVjdG9yMi5Eb3QoU3dlZXAuTG9jYWxDZW50ZXIsIFN3ZWVwLkxvY2FsQ2VudGVyKTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTih2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfYm9keVR5cGUgIT0gQm9keVR5cGUuRHluYW1pYylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMC4wZiAmJiAoRmxhZ3MgJiBCb2R5RmxhZ3MuRml4ZWRSb3RhdGlvbikgPT0gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfaW5lcnRpYSA9IHZhbHVlIC0gTWFzcyAqIFZlY3RvcjIuRG90KExvY2FsQ2VudGVyLCBMb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KF9pbmVydGlhID4gMC4wZik7XHJcbiAgICAgICAgICAgICAgICAgICAgSW52SSA9IDEuMGYgLyBfaW5lcnRpYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJlc3RpdHV0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgcmVzID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmID0gRml4dHVyZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGYuUmVzdGl0dXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyAvIEZpeHR1cmVMaXN0LkNvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmID0gRml4dHVyZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZi5SZXN0aXR1dGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRnJpY3Rpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByZXMgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBGaXh0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gZi5GcmljdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzIC8gRml4dHVyZUxpc3QuQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBGaXh0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBmLkZyaWN0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBDYXRlZ29yeSBDb2xsaXNpb25DYXRlZ29yaWVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IEZpeHR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGYuQ29sbGlzaW9uQ2F0ZWdvcmllcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgQ2F0ZWdvcnkgQ29sbGlkZXNXaXRoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IEZpeHR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGYuQ29sbGlkZXNXaXRoID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzaG9ydCBDb2xsaXNpb25Hcm91cFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBGaXh0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBmLkNvbGxpc2lvbkdyb3VwID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzU2Vuc29yXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IEZpeHR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGYuSXNTZW5zb3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSWdub3JlQ0NEXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKEZsYWdzICYgQm9keUZsYWdzLklnbm9yZUNDRCkgPT0gQm9keUZsYWdzLklnbm9yZUNDRDsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzIHw9IEJvZHlGbGFncy5JZ25vcmVDQ0Q7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgJj0gfkJvZHlGbGFncy5JZ25vcmVDQ0Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gSURpc3Bvc2FibGUgTWVtYmVyc1xyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0Rpc3Bvc2VkIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgRGlzcG9zZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIUlzRGlzcG9zZWQpXHJcbiAgICAgICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgICAgICBXb3JsZC5SZW1vdmVCb2R5KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgSXNEaXNwb3NlZCA9IHRydWU7XHJcbiNpZiAhSHRtbDVcclxuICAgICAgICAgICAgICAgIEdDLlN1cHByZXNzRmluYWxpemUodGhpcyk7XHJcbiNlbmRpZlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVzZXRzIHRoZSBkeW5hbWljcyBvZiB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIFNldHMgdG9ycXVlLCBmb3JjZSBhbmQgbGluZWFyL2FuZ3VsYXIgdmVsb2NpdHkgdG8gMFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVzZXREeW5hbWljcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUb3JxdWUgPSAwO1xyXG4gICAgICAgICAgICBBbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IDA7XHJcbiAgICAgICAgICAgIEZvcmNlID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBMaW5lYXJWZWxvY2l0eUludGVybmFsID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgZml4dHVyZSBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgYm9keS5cclxuICAgICAgICAvLy8gSWYgdGhlIGRlbnNpdHkgaXMgbm9uLXplcm8sIHRoaXMgZnVuY3Rpb24gYXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBtYXNzIG9mIHRoZSBib2R5LlxyXG4gICAgICAgIC8vLyBDb250YWN0cyBhcmUgbm90IGNyZWF0ZWQgdW50aWwgdGhlIG5leHQgdGltZSBzdGVwLlxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2hhcGVcIj5UaGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlIENyZWF0ZUZpeHR1cmUoU2hhcGUgc2hhcGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeHR1cmUodGhpcywgc2hhcGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgZml4dHVyZSBhbmQgYXR0YWNoIGl0IHRvIHRoaXMgYm9keS5cclxuICAgICAgICAvLy8gSWYgdGhlIGRlbnNpdHkgaXMgbm9uLXplcm8sIHRoaXMgZnVuY3Rpb24gYXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBtYXNzIG9mIHRoZSBib2R5LlxyXG4gICAgICAgIC8vLyBDb250YWN0cyBhcmUgbm90IGNyZWF0ZWQgdW50aWwgdGhlIG5leHQgdGltZSBzdGVwLlxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2hhcGVcIj5UaGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ1c2VyRGF0YVwiPkFwcGxpY2F0aW9uIHNwZWNpZmljIGRhdGE8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIEZpeHR1cmUgQ3JlYXRlRml4dHVyZShTaGFwZSBzaGFwZSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXh0dXJlKHRoaXMsIHNoYXBlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlc3Ryb3kgYSBmaXh0dXJlLiBUaGlzIHJlbW92ZXMgdGhlIGZpeHR1cmUgZnJvbSB0aGUgYnJvYWQtcGhhc2UgYW5kXHJcbiAgICAgICAgLy8vIGRlc3Ryb3lzIGFsbCBjb250YWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaXh0dXJlLiBUaGlzIHdpbGxcclxuICAgICAgICAvLy8gYXV0b21hdGljYWxseSBhZGp1c3QgdGhlIG1hc3Mgb2YgdGhlIGJvZHkgaWYgdGhlIGJvZHkgaXMgZHluYW1pYyBhbmQgdGhlXHJcbiAgICAgICAgLy8vIGZpeHR1cmUgaGFzIHBvc2l0aXZlIGRlbnNpdHkuXHJcbiAgICAgICAgLy8vIEFsbCBmaXh0dXJlcyBhdHRhY2hlZCB0byBhIGJvZHkgYXJlIGltcGxpY2l0bHkgZGVzdHJveWVkIHdoZW4gdGhlIGJvZHkgaXMgZGVzdHJveWVkLlxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBUaGlzIGZ1bmN0aW9uIGlzIGxvY2tlZCBkdXJpbmcgY2FsbGJhY2tzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZml4dHVyZVwiPlRoZSBmaXh0dXJlIHRvIGJlIHJlbW92ZWQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBEZXN0cm95Rml4dHVyZShGaXh0dXJlIGZpeHR1cmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZml4dHVyZS5Cb2R5ID09IHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaXh0dXJlIGZyb20gdGhpcyBib2R5J3Mgc2luZ2x5IGxpbmtlZCBsaXN0LlxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoRml4dHVyZUxpc3QuQ291bnQgPiAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFlvdSB0cmllZCB0byByZW1vdmUgYSBmaXh0dXJlIHRoYXQgbm90IHByZXNlbnQgaW4gdGhlIGZpeHR1cmVsaXN0LlxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoRml4dHVyZUxpc3QuQ29udGFpbnMoZml4dHVyZSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVzdHJveSBhbnkgY29udGFjdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBmaXh0dXJlLlxyXG4gICAgICAgICAgICBDb250YWN0RWRnZSBlZGdlID0gQ29udGFjdExpc3Q7XHJcbiAgICAgICAgICAgIHdoaWxlIChlZGdlICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbnRhY3QgYyA9IGVkZ2UuQ29udGFjdDtcclxuICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlLk5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQSA9IGMuRml4dHVyZUE7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmVCID0gYy5GaXh0dXJlQjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZml4dHVyZSA9PSBmaXh0dXJlQSB8fCBmaXh0dXJlID09IGZpeHR1cmVCKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZGVzdHJveXMgdGhlIGNvbnRhY3QgYW5kIHJlbW92ZXMgaXQgZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYm9keSdzIGNvbnRhY3QgbGlzdC5cclxuICAgICAgICAgICAgICAgICAgICBXb3JsZC5Db250YWN0TWFuYWdlci5EZXN0cm95KGMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoKEZsYWdzICYgQm9keUZsYWdzLkVuYWJsZWQpID09IEJvZHlGbGFncy5FbmFibGVkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBJQnJvYWRQaGFzZSBicm9hZFBoYXNlID0gV29ybGQuQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZTtcclxuICAgICAgICAgICAgICAgIGZpeHR1cmUuRGVzdHJveVByb3hpZXMoYnJvYWRQaGFzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEZpeHR1cmVMaXN0LlJlbW92ZShmaXh0dXJlKTtcclxuICAgICAgICAgICAgZml4dHVyZS5EZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGZpeHR1cmUuQm9keSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBSZXNldE1hc3NEYXRhKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkncyBvcmlnaW4gYW5kIHJvdGF0aW9uLlxyXG4gICAgICAgIC8vLyBUaGlzIGJyZWFrcyBhbnkgY29udGFjdHMgYW5kIHdha2VzIHRoZSBvdGhlciBib2RpZXMuXHJcbiAgICAgICAgLy8vIE1hbmlwdWxhdGluZyBhIGJvZHkncyB0cmFuc2Zvcm0gbWF5IGNhdXNlIG5vbi1waHlzaWNhbCBiZWhhdmlvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvc2l0aW9uXCI+VGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBib2R5J3MgbG9jYWwgb3JpZ2luLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm90YXRpb25cIj5UaGUgd29ybGQgcm90YXRpb24gaW4gcmFkaWFucy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldFRyYW5zZm9ybShyZWYgVmVjdG9yMiBwb3NpdGlvbiwgZmxvYXQgcm90YXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTZXRUcmFuc2Zvcm1JZ25vcmVDb250YWN0cyhyZWYgcG9zaXRpb24sIHJvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIFdvcmxkLkNvbnRhY3RNYW5hZ2VyLkZpbmROZXdDb250YWN0cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5J3Mgb3JpZ2luIGFuZCByb3RhdGlvbi5cclxuICAgICAgICAvLy8gVGhpcyBicmVha3MgYW55IGNvbnRhY3RzIGFuZCB3YWtlcyB0aGUgb3RoZXIgYm9kaWVzLlxyXG4gICAgICAgIC8vLyBNYW5pcHVsYXRpbmcgYSBib2R5J3MgdHJhbnNmb3JtIG1heSBjYXVzZSBub24tcGh5c2ljYWwgYmVoYXZpb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb3NpdGlvblwiPlRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgYm9keSdzIGxvY2FsIG9yaWdpbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvdGF0aW9uXCI+VGhlIHdvcmxkIHJvdGF0aW9uIGluIHJhZGlhbnMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRUcmFuc2Zvcm0oVmVjdG9yMiBwb3NpdGlvbiwgZmxvYXQgcm90YXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTZXRUcmFuc2Zvcm0ocmVmIHBvc2l0aW9uLCByb3RhdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZvciB0ZWxlcG9ydGluZyBhIGJvZHkgd2l0aG91dCBjb25zaWRlcmluZyBuZXcgY29udGFjdHMgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb3NpdGlvblwiPlRoZSBwb3NpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFuZ2xlXCI+VGhlIGFuZ2xlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0VHJhbnNmb3JtSWdub3JlQ29udGFjdHMocmVmIFZlY3RvcjIgcG9zaXRpb24sIGZsb2F0IGFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgWGYuUi5TZXQoYW5nbGUpO1xyXG4gICAgICAgICAgICBYZi5Qb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgU3dlZXAuQzAgPVxyXG4gICAgICAgICAgICAgICAgU3dlZXAuQyA9XHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMihYZi5Qb3NpdGlvbi5YICsgWGYuUi5Db2wxLlggKiBTd2VlcC5Mb2NhbENlbnRlci5YICsgWGYuUi5Db2wyLlggKiBTd2VlcC5Mb2NhbENlbnRlci5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWGYuUG9zaXRpb24uWSArIFhmLlIuQ29sMS5ZICogU3dlZXAuTG9jYWxDZW50ZXIuWCArIFhmLlIuQ29sMi5ZICogU3dlZXAuTG9jYWxDZW50ZXIuWSk7XHJcbiAgICAgICAgICAgIFN3ZWVwLkEwID0gU3dlZXAuQSA9IGFuZ2xlO1xyXG5cclxuICAgICAgICAgICAgSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSA9IFdvcmxkLkNvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2U7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZUxpc3RbaV0uU3luY2hyb25pemUoYnJvYWRQaGFzZSwgcmVmIFhmLCByZWYgWGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgYm9keSB0cmFuc2Zvcm0gZm9yIHRoZSBib2R5J3Mgb3JpZ2luLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHRyYW5zZm9ybSBvZiB0aGUgYm9keSdzIG9yaWdpbi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEdldFRyYW5zZm9ybShvdXQgVHJhbnNmb3JtIHRyYW5zZm9ybSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IFhmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSBhIGZvcmNlIGF0IGEgd29ybGQgcG9pbnQuIElmIHRoZSBmb3JjZSBpcyBub3RcclxuICAgICAgICAvLy8gYXBwbGllZCBhdCB0aGUgY2VudGVyIG9mIG1hc3MsIGl0IHdpbGwgZ2VuZXJhdGUgYSB0b3JxdWUgYW5kXHJcbiAgICAgICAgLy8vIGFmZmVjdCB0aGUgYW5ndWxhciB2ZWxvY2l0eS4gVGhpcyB3YWtlcyB1cCB0aGUgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZvcmNlXCI+VGhlIHdvcmxkIGZvcmNlIHZlY3RvciwgdXN1YWxseSBpbiBOZXd0b25zIChOKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+VGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvZiBhcHBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5Rm9yY2UoVmVjdG9yMiBmb3JjZSwgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFwcGx5Rm9yY2UocmVmIGZvcmNlLCByZWYgcG9pbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBsaWVzIGEgZm9yY2UgYXQgdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZm9yY2VcIj5UaGUgZm9yY2UuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBseUZvcmNlKHJlZiBWZWN0b3IyIGZvcmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQXBwbHlGb3JjZShyZWYgZm9yY2UsIHJlZiBYZi5Qb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGxpZXMgYSBmb3JjZSBhdCB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmb3JjZVwiPlRoZSBmb3JjZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5Rm9yY2UoVmVjdG9yMiBmb3JjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFwcGx5Rm9yY2UocmVmIGZvcmNlLCByZWYgWGYuUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSBhIGZvcmNlIGF0IGEgd29ybGQgcG9pbnQuIElmIHRoZSBmb3JjZSBpcyBub3RcclxuICAgICAgICAvLy8gYXBwbGllZCBhdCB0aGUgY2VudGVyIG9mIG1hc3MsIGl0IHdpbGwgZ2VuZXJhdGUgYSB0b3JxdWUgYW5kXHJcbiAgICAgICAgLy8vIGFmZmVjdCB0aGUgYW5ndWxhciB2ZWxvY2l0eS4gVGhpcyB3YWtlcyB1cCB0aGUgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZvcmNlXCI+VGhlIHdvcmxkIGZvcmNlIHZlY3RvciwgdXN1YWxseSBpbiBOZXd0b25zIChOKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+VGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvZiBhcHBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5Rm9yY2UocmVmIFZlY3RvcjIgZm9yY2UsIHJlZiBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTihmb3JjZS5YKSk7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4oZm9yY2UuWSkpO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIWZsb2F0LklzTmFOKHBvaW50LlgpKTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTihwb2ludC5ZKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2JvZHlUeXBlID09IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChBd2FrZSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBBd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgRm9yY2UgKz0gZm9yY2U7XHJcbiAgICAgICAgICAgICAgICBUb3JxdWUgKz0gKHBvaW50LlggLSBTd2VlcC5DLlgpICogZm9yY2UuWSAtIChwb2ludC5ZIC0gU3dlZXAuQy5ZKSAqIGZvcmNlLlg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbHkgYSB0b3JxdWUuIFRoaXMgYWZmZWN0cyB0aGUgYW5ndWxhciB2ZWxvY2l0eVxyXG4gICAgICAgIC8vLyB3aXRob3V0IGFmZmVjdGluZyB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAgICAvLy8gVGhpcyB3YWtlcyB1cCB0aGUgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRvcnF1ZVwiPlRoZSB0b3JxdWUgYWJvdXQgdGhlIHotYXhpcyAob3V0IG9mIHRoZSBzY3JlZW4pLCB1c3VhbGx5IGluIE4tbS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5VG9ycXVlKGZsb2F0IHRvcnF1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4odG9ycXVlKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2JvZHlUeXBlID09IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChBd2FrZSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBBd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgVG9ycXVlICs9IHRvcnF1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSBhbiBpbXB1bHNlIGF0IGEgcG9pbnQuIFRoaXMgaW1tZWRpYXRlbHkgbW9kaWZpZXMgdGhlIHZlbG9jaXR5LlxyXG4gICAgICAgIC8vLyBUaGlzIHdha2VzIHVwIHRoZSBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW1wdWxzZVwiPlRoZSB3b3JsZCBpbXB1bHNlIHZlY3RvciwgdXN1YWxseSBpbiBOLXNlY29uZHMgb3Iga2ctbS9zLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQXBwbHlMaW5lYXJJbXB1bHNlKFZlY3RvcjIgaW1wdWxzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFwcGx5TGluZWFySW1wdWxzZShyZWYgaW1wdWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGx5IGFuIGltcHVsc2UgYXQgYSBwb2ludC4gVGhpcyBpbW1lZGlhdGVseSBtb2RpZmllcyB0aGUgdmVsb2NpdHkuXHJcbiAgICAgICAgLy8vIEl0IGFsc28gbW9kaWZpZXMgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgaWYgdGhlIHBvaW50IG9mIGFwcGxpY2F0aW9uXHJcbiAgICAgICAgLy8vIGlzIG5vdCBhdCB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgICAgLy8vIFRoaXMgd2FrZXMgdXAgdGhlIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbXB1bHNlXCI+VGhlIHdvcmxkIGltcHVsc2UgdmVjdG9yLCB1c3VhbGx5IGluIE4tc2Vjb25kcyBvciBrZy1tL3MuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPlRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBseUxpbmVhckltcHVsc2UoVmVjdG9yMiBpbXB1bHNlLCBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQXBwbHlMaW5lYXJJbXB1bHNlKHJlZiBpbXB1bHNlLCByZWYgcG9pbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSBhbiBpbXB1bHNlIGF0IGEgcG9pbnQuIFRoaXMgaW1tZWRpYXRlbHkgbW9kaWZpZXMgdGhlIHZlbG9jaXR5LlxyXG4gICAgICAgIC8vLyBUaGlzIHdha2VzIHVwIHRoZSBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW1wdWxzZVwiPlRoZSB3b3JsZCBpbXB1bHNlIHZlY3RvciwgdXN1YWxseSBpbiBOLXNlY29uZHMgb3Iga2ctbS9zLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQXBwbHlMaW5lYXJJbXB1bHNlKHJlZiBWZWN0b3IyIGltcHVsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2JvZHlUeXBlICE9IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoQXdha2UgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMaW5lYXJWZWxvY2l0eUludGVybmFsICs9IEludk1hc3MgKiBpbXB1bHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSBhbiBpbXB1bHNlIGF0IGEgcG9pbnQuIFRoaXMgaW1tZWRpYXRlbHkgbW9kaWZpZXMgdGhlIHZlbG9jaXR5LlxyXG4gICAgICAgIC8vLyBJdCBhbHNvIG1vZGlmaWVzIHRoZSBhbmd1bGFyIHZlbG9jaXR5IGlmIHRoZSBwb2ludCBvZiBhcHBsaWNhdGlvblxyXG4gICAgICAgIC8vLyBpcyBub3QgYXQgdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgIC8vLyBUaGlzIHdha2VzIHVwIHRoZSBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW1wdWxzZVwiPlRoZSB3b3JsZCBpbXB1bHNlIHZlY3RvciwgdXN1YWxseSBpbiBOLXNlY29uZHMgb3Iga2ctbS9zLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRcIj5UaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHBvaW50IG9mIGFwcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQXBwbHlMaW5lYXJJbXB1bHNlKHJlZiBWZWN0b3IyIGltcHVsc2UsIHJlZiBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSAhPSBCb2R5VHlwZS5EeW5hbWljKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKEF3YWtlID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgQXdha2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBJbnZNYXNzICogaW1wdWxzZTtcclxuICAgICAgICAgICAgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52SSAqICgocG9pbnQuWCAtIFN3ZWVwLkMuWCkgKiBpbXB1bHNlLlkgLSAocG9pbnQuWSAtIFN3ZWVwLkMuWSkgKiBpbXB1bHNlLlgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSBhbiBhbmd1bGFyIGltcHVsc2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbXB1bHNlXCI+VGhlIGFuZ3VsYXIgaW1wdWxzZSBpbiB1bml0cyBvZiBrZyptKm0vcy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5QW5ndWxhckltcHVsc2UoZmxvYXQgaW1wdWxzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfYm9keVR5cGUgIT0gQm9keVR5cGUuRHluYW1pYylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoQXdha2UgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52SSAqIGltcHVsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgcmVzZXRzIHRoZSBtYXNzIHByb3BlcnRpZXMgdG8gdGhlIHN1bSBvZiB0aGUgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoZSBmaXh0dXJlcy5cclxuICAgICAgICAvLy8gVGhpcyBub3JtYWxseSBkb2VzIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCB1bmxlc3MgeW91IGNhbGxlZCBTZXRNYXNzRGF0YSB0byBvdmVycmlkZVxyXG4gICAgICAgIC8vLyB0aGUgbWFzcyBhbmQgeW91IGxhdGVyIHdhbnQgdG8gcmVzZXQgdGhlIG1hc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZXNldE1hc3NEYXRhKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbWFzcyBkYXRhIGZyb20gc2hhcGVzLiBFYWNoIHNoYXBlIGhhcyBpdHMgb3duIGRlbnNpdHkuXHJcbiAgICAgICAgICAgIF9tYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgSW52TWFzcyA9IDAuMGY7XHJcbiAgICAgICAgICAgIF9pbmVydGlhID0gMC4wZjtcclxuICAgICAgICAgICAgSW52SSA9IDAuMGY7XHJcbiAgICAgICAgICAgIFN3ZWVwLkxvY2FsQ2VudGVyID0gVmVjdG9yMi5aZXJvO1xyXG5cclxuICAgICAgICAgICAgLy8gS2luZW1hdGljIGJvZGllcyBoYXZlIHplcm8gbWFzcy5cclxuICAgICAgICAgICAgaWYgKEJvZHlUeXBlID09IEJvZHlUeXBlLktpbmVtYXRpYylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU3dlZXAuQzAgPSBTd2VlcC5DID0gWGYuUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChCb2R5VHlwZSA9PSBCb2R5VHlwZS5EeW5hbWljIHx8IEJvZHlUeXBlID09IEJvZHlUeXBlLlN0YXRpYyk7XHJcblxyXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIG1hc3Mgb3ZlciBhbGwgZml4dHVyZXMuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgY2VudGVyID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBmb3JlYWNoIChGaXh0dXJlIGYgaW4gRml4dHVyZUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChmLlNoYXBlLl9kZW5zaXR5ID09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgTWFzc0RhdGEgbWFzc0RhdGEgPSBmLlNoYXBlLk1hc3NEYXRhO1xyXG4gICAgICAgICAgICAgICAgX21hc3MgKz0gbWFzc0RhdGEuTWFzcztcclxuICAgICAgICAgICAgICAgIGNlbnRlciArPSBtYXNzRGF0YS5NYXNzICogbWFzc0RhdGEuQ2VudHJvaWQ7XHJcbiAgICAgICAgICAgICAgICBfaW5lcnRpYSArPSBtYXNzRGF0YS5JbmVydGlhO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1N0YXRpYyBib2RpZXMgb25seSBoYXZlIG1hc3MsIHRoZXkgZG9uJ3QgaGF2ZSBvdGhlciBwcm9wZXJ0aWVzLiBBIGxpdHRsZSBoYWNreSB0aG8uLi5cclxuICAgICAgICAgICAgaWYgKEJvZHlUeXBlID09IEJvZHlUeXBlLlN0YXRpYylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU3dlZXAuQzAgPSBTd2VlcC5DID0gWGYuUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgICAgICAgIGlmIChfbWFzcyA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEludk1hc3MgPSAxLjBmIC8gX21hc3M7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIgKj0gSW52TWFzcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGFsbCBkeW5hbWljIGJvZGllcyB0byBoYXZlIGEgcG9zaXRpdmUgbWFzcy5cclxuICAgICAgICAgICAgICAgIF9tYXNzID0gMS4wZjtcclxuICAgICAgICAgICAgICAgIEludk1hc3MgPSAxLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2luZXJ0aWEgPiAwLjBmICYmIChGbGFncyAmIEJvZHlGbGFncy5GaXhlZFJvdGF0aW9uKSA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIGluZXJ0aWEgYWJvdXQgdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgICAgICAgICAgX2luZXJ0aWEgLT0gX21hc3MgKiBWZWN0b3IyLkRvdChjZW50ZXIsIGNlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KF9pbmVydGlhID4gMC4wZik7XHJcbiAgICAgICAgICAgICAgICBJbnZJID0gMS4wZiAvIF9pbmVydGlhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2luZXJ0aWEgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgSW52SSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1vdmUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgb2xkQ2VudGVyID0gU3dlZXAuQztcclxuICAgICAgICAgICAgU3dlZXAuTG9jYWxDZW50ZXIgPSBjZW50ZXI7XHJcbiAgICAgICAgICAgIFN3ZWVwLkMwID0gU3dlZXAuQyA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgWGYsIHJlZiBTd2VlcC5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2VudGVyIG9mIG1hc3MgdmVsb2NpdHkuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgYSA9IFN3ZWVwLkMgLSBvbGRDZW50ZXI7XHJcbiAgICAgICAgICAgIExpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gbmV3IFZlY3RvcjIoLUFuZ3VsYXJWZWxvY2l0eUludGVybmFsICogYS5ZLCBBbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAqIGEuWCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBnaXZlbiB0aGUgbG9jYWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbFBvaW50XCI+QSBwb2ludCBvbiB0aGUgYm9keSBtZWFzdXJlZCByZWxhdGl2ZSB0aGUgdGhlIGJvZHkncyBvcmlnaW4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHNhbWUgcG9pbnQgZXhwcmVzc2VkIGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRXb3JsZFBvaW50KHJlZiBWZWN0b3IyIGxvY2FsUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoWGYuUG9zaXRpb24uWCArIFhmLlIuQ29sMS5YICogbG9jYWxQb2ludC5YICsgWGYuUi5Db2wyLlggKiBsb2NhbFBvaW50LlksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBYZi5Qb3NpdGlvbi5ZICsgWGYuUi5Db2wxLlkgKiBsb2NhbFBvaW50LlggKyBYZi5SLkNvbDIuWSAqIGxvY2FsUG9pbnQuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBnaXZlbiB0aGUgbG9jYWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbFBvaW50XCI+QSBwb2ludCBvbiB0aGUgYm9keSBtZWFzdXJlZCByZWxhdGl2ZSB0aGUgdGhlIGJvZHkncyBvcmlnaW4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHNhbWUgcG9pbnQgZXhwcmVzc2VkIGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRXb3JsZFBvaW50KFZlY3RvcjIgbG9jYWxQb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBHZXRXb3JsZFBvaW50KHJlZiBsb2NhbFBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCBjb29yZGluYXRlcyBvZiBhIHZlY3RvciBnaXZlbiB0aGUgbG9jYWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy8vIE5vdGUgdGhhdCB0aGUgdmVjdG9yIG9ubHkgdGFrZXMgdGhlIHJvdGF0aW9uIGludG8gYWNjb3VudCwgbm90IHRoZSBwb3NpdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsVmVjdG9yXCI+QSB2ZWN0b3IgZml4ZWQgaW4gdGhlIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHNhbWUgdmVjdG9yIGV4cHJlc3NlZCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0V29ybGRWZWN0b3IocmVmIFZlY3RvcjIgbG9jYWxWZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoWGYuUi5Db2wxLlggKiBsb2NhbFZlY3Rvci5YICsgWGYuUi5Db2wyLlggKiBsb2NhbFZlY3Rvci5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWGYuUi5Db2wxLlkgKiBsb2NhbFZlY3Rvci5YICsgWGYuUi5Db2wyLlkgKiBsb2NhbFZlY3Rvci5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCBjb29yZGluYXRlcyBvZiBhIHZlY3RvciBnaXZlbiB0aGUgbG9jYWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbFZlY3RvclwiPkEgdmVjdG9yIGZpeGVkIGluIHRoZSBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzYW1lIHZlY3RvciBleHByZXNzZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdldFdvcmxkVmVjdG9yKFZlY3RvcjIgbG9jYWxWZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gR2V0V29ybGRWZWN0b3IocmVmIGxvY2FsVmVjdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBhIGxvY2FsIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5J3Mgb3JpZ2luIGdpdmVuIGEgd29ybGQgcG9pbnQuXHJcbiAgICAgICAgLy8vIE5vdGUgdGhhdCB0aGUgdmVjdG9yIG9ubHkgdGFrZXMgdGhlIHJvdGF0aW9uIGludG8gYWNjb3VudCwgbm90IHRoZSBwb3NpdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkUG9pbnRcIj5BIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5J3Mgb3JpZ2luLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRMb2NhbFBvaW50KHJlZiBWZWN0b3IyIHdvcmxkUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKCh3b3JsZFBvaW50LlggLSBYZi5Qb3NpdGlvbi5YKSAqIFhmLlIuQ29sMS5YICsgKHdvcmxkUG9pbnQuWSAtIFhmLlBvc2l0aW9uLlkpICogWGYuUi5Db2wxLlksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAod29ybGRQb2ludC5YIC0gWGYuUG9zaXRpb24uWCkgKiBYZi5SLkNvbDIuWCArICh3b3JsZFBvaW50LlkgLSBYZi5Qb3NpdGlvbi5ZKSAqIFhmLlIuQ29sMi5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBhIGxvY2FsIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5J3Mgb3JpZ2luIGdpdmVuIGEgd29ybGQgcG9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFBvaW50XCI+QSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgY29ycmVzcG9uZGluZyBsb2NhbCBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSdzIG9yaWdpbi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0TG9jYWxQb2ludChWZWN0b3IyIHdvcmxkUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gR2V0TG9jYWxQb2ludChyZWYgd29ybGRQb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgYSBsb2NhbCB2ZWN0b3IgZ2l2ZW4gYSB3b3JsZCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIE5vdGUgdGhhdCB0aGUgdmVjdG9yIG9ubHkgdGFrZXMgdGhlIHJvdGF0aW9uIGludG8gYWNjb3VudCwgbm90IHRoZSBwb3NpdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkVmVjdG9yXCI+QSB2ZWN0b3IgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGNvcnJlc3BvbmRpbmcgbG9jYWwgdmVjdG9yLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRMb2NhbFZlY3RvcihyZWYgVmVjdG9yMiB3b3JsZFZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih3b3JsZFZlY3Rvci5YICogWGYuUi5Db2wxLlggKyB3b3JsZFZlY3Rvci5ZICogWGYuUi5Db2wxLlksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlY3Rvci5YICogWGYuUi5Db2wyLlggKyB3b3JsZFZlY3Rvci5ZICogWGYuUi5Db2wyLlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgbG9jYWwgdmVjdG9yIGdpdmVuIGEgd29ybGQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyBOb3RlIHRoYXQgdGhlIHZlY3RvciBvbmx5IHRha2VzIHRoZSByb3RhdGlvbiBpbnRvIGFjY291bnQsIG5vdCB0aGUgcG9zaXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFZlY3RvclwiPkEgdmVjdG9yIGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHZlY3Rvci48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0TG9jYWxWZWN0b3IoVmVjdG9yMiB3b3JsZFZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBHZXRMb2NhbFZlY3RvcihyZWYgd29ybGRWZWN0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHdvcmxkIGxpbmVhciB2ZWxvY2l0eSBvZiBhIHdvcmxkIHBvaW50IGF0dGFjaGVkIHRvIHRoaXMgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkUG9pbnRcIj5BIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSB3b3JsZCB2ZWxvY2l0eSBvZiBhIHBvaW50LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRMaW5lYXJWZWxvY2l0eUZyb21Xb3JsZFBvaW50KFZlY3RvcjIgd29ybGRQb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBHZXRMaW5lYXJWZWxvY2l0eUZyb21Xb3JsZFBvaW50KHJlZiB3b3JsZFBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCBsaW5lYXIgdmVsb2NpdHkgb2YgYSB3b3JsZCBwb2ludCBhdHRhY2hlZCB0byB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFBvaW50XCI+QSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludChyZWYgVmVjdG9yMiB3b3JsZFBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIExpbmVhclZlbG9jaXR5SW50ZXJuYWwgK1xyXG4gICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoLUFuZ3VsYXJWZWxvY2l0eUludGVybmFsICogKHdvcmxkUG9pbnQuWSAtIFN3ZWVwLkMuWSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAqICh3b3JsZFBvaW50LlggLSBTd2VlcC5DLlgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCB2ZWxvY2l0eSBvZiBhIGxvY2FsIHBvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxQb2ludFwiPkEgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHdvcmxkIHZlbG9jaXR5IG9mIGEgcG9pbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdldExpbmVhclZlbG9jaXR5RnJvbUxvY2FsUG9pbnQoVmVjdG9yMiBsb2NhbFBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEdldExpbmVhclZlbG9jaXR5RnJvbUxvY2FsUG9pbnQocmVmIGxvY2FsUG9pbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHdvcmxkIHZlbG9jaXR5IG9mIGEgbG9jYWwgcG9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbFBvaW50XCI+QSBwb2ludCBpbiBsb2NhbCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0TGluZWFyVmVsb2NpdHlGcm9tTG9jYWxQb2ludChyZWYgVmVjdG9yMiBsb2NhbFBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEdldExpbmVhclZlbG9jaXR5RnJvbVdvcmxkUG9pbnQoR2V0V29ybGRQb2ludChyZWYgbG9jYWxQb2ludCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEJvZHkgRGVlcENsb25lKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keSA9IENsb25lKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmVMaXN0W2ldLkNsb25lKGJvZHkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBCb2R5IENsb25lKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keSA9IG5ldyBCb2R5KCk7XHJcbiAgICAgICAgICAgIGJvZHkuV29ybGQgPSBXb3JsZDtcclxuICAgICAgICAgICAgYm9keS5Vc2VyRGF0YSA9IFVzZXJEYXRhO1xyXG4gICAgICAgICAgICBib2R5LkxpbmVhckRhbXBpbmcgPSBMaW5lYXJEYW1waW5nO1xyXG4gICAgICAgICAgICBib2R5LkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSBMaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBib2R5LkFuZ3VsYXJEYW1waW5nID0gQW5ndWxhckRhbXBpbmc7XHJcbiAgICAgICAgICAgIGJvZHkuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSBBbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgYm9keS5Qb3NpdGlvbiA9IFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBib2R5LlJvdGF0aW9uID0gUm90YXRpb247XHJcbiAgICAgICAgICAgIGJvZHkuX2JvZHlUeXBlID0gX2JvZHlUeXBlO1xyXG4gICAgICAgICAgICBib2R5LkZsYWdzID0gRmxhZ3M7XHJcblxyXG4gICAgICAgICAgICBXb3JsZC5BZGRCb2R5KGJvZHkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIFN5bmNocm9uaXplRml4dHVyZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSA9IG5ldyBUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgZmxvYXQgYyA9IChmbG9hdClNYXRoLkNvcyhTd2VlcC5BMCksIHMgPSAoZmxvYXQpTWF0aC5TaW4oU3dlZXAuQTApO1xyXG4gICAgICAgICAgICB4ZjEuUi5Db2wxLlggPSBjO1xyXG4gICAgICAgICAgICB4ZjEuUi5Db2wyLlggPSAtcztcclxuICAgICAgICAgICAgeGYxLlIuQ29sMS5ZID0gcztcclxuICAgICAgICAgICAgeGYxLlIuQ29sMi5ZID0gYztcclxuXHJcbiAgICAgICAgICAgIHhmMS5Qb3NpdGlvbi5YID0gU3dlZXAuQzAuWCAtICh4ZjEuUi5Db2wxLlggKiBTd2VlcC5Mb2NhbENlbnRlci5YICsgeGYxLlIuQ29sMi5YICogU3dlZXAuTG9jYWxDZW50ZXIuWSk7XHJcbiAgICAgICAgICAgIHhmMS5Qb3NpdGlvbi5ZID0gU3dlZXAuQzAuWSAtICh4ZjEuUi5Db2wxLlkgKiBTd2VlcC5Mb2NhbENlbnRlci5YICsgeGYxLlIuQ29sMi5ZICogU3dlZXAuTG9jYWxDZW50ZXIuWSk7XHJcblxyXG4gICAgICAgICAgICBJQnJvYWRQaGFzZSBicm9hZFBoYXNlID0gV29ybGQuQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlTGlzdFtpXS5TeW5jaHJvbml6ZShicm9hZFBoYXNlLCByZWYgeGYxLCByZWYgWGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIFN5bmNocm9uaXplVHJhbnNmb3JtKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFhmLlIuU2V0KFN3ZWVwLkEpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgdnggPSBYZi5SLkNvbDEuWCAqIFN3ZWVwLkxvY2FsQ2VudGVyLlggKyBYZi5SLkNvbDIuWCAqIFN3ZWVwLkxvY2FsQ2VudGVyLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IHZ5ID0gWGYuUi5Db2wxLlkgKiBTd2VlcC5Mb2NhbENlbnRlci5YICsgWGYuUi5Db2wyLlkgKiBTd2VlcC5Mb2NhbENlbnRlci5ZO1xyXG5cclxuICAgICAgICAgICAgWGYuUG9zaXRpb24uWCA9IFN3ZWVwLkMuWCAtIHZ4O1xyXG4gICAgICAgICAgICBYZi5Qb3NpdGlvbi5ZID0gU3dlZXAuQy5ZIC0gdnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IGNvbm5lY3RlZCBib2RpZXMgZnJvbSBjb2xsaWRpbmcuXHJcbiAgICAgICAgLy8vIEl0IG1heSBsaWUsIGRlcGVuZGluZyBvbiB0aGUgY29sbGlkZUNvbm5lY3RlZCBmbGFnLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3RoZXJcIj5UaGUgb3RoZXIgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgaW50ZXJuYWwgYm9vbCBTaG91bGRDb2xsaWRlKEJvZHkgb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBBdCBsZWFzdCBvbmUgYm9keSBzaG91bGQgYmUgZHluYW1pYy5cclxuICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSAhPSBCb2R5VHlwZS5EeW5hbWljICYmIG90aGVyLl9ib2R5VHlwZSAhPSBCb2R5VHlwZS5EeW5hbWljKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERvZXMgYSBqb2ludCBwcmV2ZW50IGNvbGxpc2lvbj9cclxuICAgICAgICAgICAgZm9yIChKb2ludEVkZ2Ugam4gPSBKb2ludExpc3Q7IGpuICE9IG51bGw7IGpuID0gam4uTmV4dClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGpuLk90aGVyID09IG90aGVyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqbi5Kb2ludC5Db2xsaWRlQ29ubmVjdGVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIEFkdmFuY2UoZmxvYXQgYWxwaGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXcgc2FmZSB0aW1lLlxyXG4gICAgICAgICAgICBTd2VlcC5BZHZhbmNlKGFscGhhKTtcclxuICAgICAgICAgICAgU3dlZXAuQyA9IFN3ZWVwLkMwO1xyXG4gICAgICAgICAgICBTd2VlcC5BID0gU3dlZXAuQTA7XHJcbiAgICAgICAgICAgIFN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZXZlbnQgT25Db2xsaXNpb25FdmVudEhhbmRsZXIgT25Db2xsaXNpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFkZFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZUxpc3RbaV0uT25Db2xsaXNpb24gKz0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVtb3ZlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlTGlzdFtpXS5PbkNvbGxpc2lvbiAtPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGV2ZW50IE9uU2VwYXJhdGlvbkV2ZW50SGFuZGxlciBPblNlcGFyYXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGFkZFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZUxpc3RbaV0uT25TZXBhcmF0aW9uICs9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbW92ZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZUxpc3RbaV0uT25TZXBhcmF0aW9uIC09IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBJZ25vcmVDb2xsaXNpb25XaXRoKEJvZHkgb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IEZpeHR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBvdGhlci5GaXh0dXJlTGlzdC5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZjIgPSBvdGhlci5GaXh0dXJlTGlzdFtqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZi5JZ25vcmVDb2xsaXNpb25XaXRoKGYyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVzdG9yZUNvbGxpc2lvbldpdGgoQm9keSBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmID0gRml4dHVyZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IG90aGVyLkZpeHR1cmVMaXN0LkNvdW50OyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmMiA9IG90aGVyLkZpeHR1cmVMaXN0W2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmLlJlc3RvcmVDb2xsaXNpb25XaXRoKGYyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuQ29udGFjdHM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkZhY3RvcmllcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3Ncclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgdHlwZSBvZiBib2R5IHRoYXQgc3VwcG9ydHMgbXVsdGlwbGUgZml4dHVyZXMgdGhhdCBjYW4gYnJlYWsgYXBhcnQuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIEJyZWFrYWJsZUJvZHlcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgYm9vbCBCcm9rZW47XHJcbiAgICAgICAgcHVibGljIEJvZHkgTWFpbkJvZHk7XHJcbiAgICAgICAgcHVibGljIExpc3Q8Rml4dHVyZT4gUGFydHMgPSBuZXcgTGlzdDxGaXh0dXJlPig4KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZm9yY2UgbmVlZGVkIHRvIGJyZWFrIHRoZSBib2R5IGFwYXJ0LlxyXG4gICAgICAgIC8vLyBEZWZhdWx0OiA1MDBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBTdHJlbmd0aCA9IDUwMC4wZjtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdFtdIF9hbmd1bGFyVmVsb2NpdGllc0NhY2hlID0gbmV3IGZsb2F0WzhdO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfYnJlYWs7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyW10gX3ZlbG9jaXRpZXNDYWNoZSA9IG5ldyBWZWN0b3IyWzhdO1xyXG4gICAgICAgIHByaXZhdGUgV29ybGQgX3dvcmxkO1xyXG5cclxuICAgICAgICBwdWJsaWMgQnJlYWthYmxlQm9keShJRW51bWVyYWJsZTxWZXJ0aWNlcz4gdmVydGljZXMsIFdvcmxkIHdvcmxkLCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgICAgICA6IHRoaXModmVydGljZXMsIHdvcmxkLCBkZW5zaXR5LCBudWxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBCcmVha2FibGVCb2R5KElFbnVtZXJhYmxlPFZlcnRpY2VzPiB2ZXJ0aWNlcywgV29ybGQgd29ybGQsIGZsb2F0IGRlbnNpdHksIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF93b3JsZCA9IHdvcmxkO1xyXG4gICAgICAgICAgICBfd29ybGQuQ29udGFjdE1hbmFnZXIuUG9zdFNvbHZlICs9IFBvc3RTb2x2ZTtcclxuICAgICAgICAgICAgTWFpbkJvZHkgPSBuZXcgQm9keShfd29ybGQpO1xyXG4gICAgICAgICAgICBNYWluQm9keS5Cb2R5VHlwZSA9IEJvZHlUeXBlLkR5bmFtaWM7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChWZXJ0aWNlcyBwYXJ0IGluIHZlcnRpY2VzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seWdvblNoYXBlID0gbmV3IFBvbHlnb25TaGFwZShwYXJ0LCBkZW5zaXR5KTtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZSA9IE1haW5Cb2R5LkNyZWF0ZUZpeHR1cmUocG9seWdvblNoYXBlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBQYXJ0cy5BZGQoZml4dHVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBQb3N0U29sdmUoQ29udGFjdCBjb250YWN0LCBDb250YWN0Q29uc3RyYWludCBpbXB1bHNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFCcm9rZW4pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChQYXJ0cy5Db250YWlucyhjb250YWN0LkZpeHR1cmVBKSB8fCBQYXJ0cy5Db250YWlucyhjb250YWN0LkZpeHR1cmVCKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBtYXhJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgY291bnQgPSBjb250YWN0Lk1hbmlmb2xkLlBvaW50Q291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgY291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEltcHVsc2UgPSBNYXRoLk1heChtYXhJbXB1bHNlLCBpbXB1bHNlLlBvaW50c1tpXS5Ob3JtYWxJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhJbXB1bHNlID4gU3RyZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIHRoZSBib2R5IGZvciBicmVha2luZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2JyZWFrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFVwZGF0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2JyZWFrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWNvbXBvc2UoKTtcclxuICAgICAgICAgICAgICAgIEJyb2tlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfYnJlYWsgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FjaGUgdmVsb2NpdGllcyB0byBpbXByb3ZlIG1vdmVtZW50IG9uIGJyZWFrYWdlLlxyXG4gICAgICAgICAgICBpZiAoQnJva2VuID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL0VubGFyZ2UgdGhlIGNhY2hlIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKFBhcnRzLkNvdW50ID4gX2FuZ3VsYXJWZWxvY2l0aWVzQ2FjaGUuTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF92ZWxvY2l0aWVzQ2FjaGUgPSBuZXcgVmVjdG9yMltQYXJ0cy5Db3VudF07XHJcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJWZWxvY2l0aWVzQ2FjaGUgPSBuZXcgZmxvYXRbUGFydHMuQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vQ2FjaGUgdGhlIGxpbmVhciBhbmQgYW5ndWxhciB2ZWxvY2l0aWVzLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBQYXJ0cy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF92ZWxvY2l0aWVzQ2FjaGVbaV0gPSBQYXJ0c1tpXS5Cb2R5LkxpbmVhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyVmVsb2NpdGllc0NhY2hlW2ldID0gUGFydHNbaV0uQm9keS5Bbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBEZWNvbXBvc2UoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9VbnN1YnNyaWJlIGZyb20gdGhlIFBvc3RTb2x2ZSBkZWxlZ2F0ZVxyXG4gICAgICAgICAgICBfd29ybGQuQ29udGFjdE1hbmFnZXIuUG9zdFNvbHZlIC09IFBvc3RTb2x2ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUGFydHMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlID0gUGFydHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgU2hhcGUgc2hhcGUgPSBmaXh0dXJlLlNoYXBlLkNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJkYXRhID0gZml4dHVyZS5Vc2VyRGF0YTtcclxuICAgICAgICAgICAgICAgIE1haW5Cb2R5LkRlc3Ryb3lGaXh0dXJlKGZpeHR1cmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keSA9IEJvZHlGYWN0b3J5LkNyZWF0ZUJvZHkoX3dvcmxkKTtcclxuICAgICAgICAgICAgICAgIGJvZHkuQm9keVR5cGUgPSBCb2R5VHlwZS5EeW5hbWljO1xyXG4gICAgICAgICAgICAgICAgYm9keS5Qb3NpdGlvbiA9IE1haW5Cb2R5LlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgYm9keS5Sb3RhdGlvbiA9IE1haW5Cb2R5LlJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgYm9keS5Vc2VyRGF0YSA9IE1haW5Cb2R5LlVzZXJEYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvZHkuQ3JlYXRlRml4dHVyZShzaGFwZSwgdXNlcmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvZHkuQW5ndWxhclZlbG9jaXR5ID0gX2FuZ3VsYXJWZWxvY2l0aWVzQ2FjaGVbaV07XHJcbiAgICAgICAgICAgICAgICBib2R5LkxpbmVhclZlbG9jaXR5ID0gX3ZlbG9jaXRpZXNDYWNoZVtpXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3dvcmxkLlJlbW92ZUJvZHkoTWFpbkJvZHkpO1xyXG4gICAgICAgICAgICBfd29ybGQuUmVtb3ZlQnJlYWthYmxlQm9keSh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEJyZWFrKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9icmVhayA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Db250YWN0cztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3Ncclxue1xyXG4gICAgW0ZsYWdzXVxyXG4gICAgcHVibGljIGVudW0gQ2F0ZWdvcnlcclxuICAgIHtcclxuICAgICAgICBOb25lID0gMCxcclxuICAgICAgICBBbGwgPSBpbnQuTWF4VmFsdWUsXHJcbiAgICAgICAgQ2F0MSA9IDEsXHJcbiAgICAgICAgQ2F0MiA9IDIsXHJcbiAgICAgICAgQ2F0MyA9IDQsXHJcbiAgICAgICAgQ2F0NCA9IDgsXHJcbiAgICAgICAgQ2F0NSA9IDE2LFxyXG4gICAgICAgIENhdDYgPSAzMixcclxuICAgICAgICBDYXQ3ID0gNjQsXHJcbiAgICAgICAgQ2F0OCA9IDEyOCxcclxuICAgICAgICBDYXQ5ID0gMjU2LFxyXG4gICAgICAgIENhdDEwID0gNTEyLFxyXG4gICAgICAgIENhdDExID0gMTAyNCxcclxuICAgICAgICBDYXQxMiA9IDIwNDgsXHJcbiAgICAgICAgQ2F0MTMgPSA0MDk2LFxyXG4gICAgICAgIENhdDE0ID0gODE5MixcclxuICAgICAgICBDYXQxNSA9IDE2Mzg0LFxyXG4gICAgICAgIENhdDE2ID0gMzI3NjgsXHJcbiAgICAgICAgQ2F0MTcgPSA2NTUzNixcclxuICAgICAgICBDYXQxOCA9IDEzMTA3MixcclxuICAgICAgICBDYXQxOSA9IDI2MjE0NCxcclxuICAgICAgICBDYXQyMCA9IDUyNDI4OCxcclxuICAgICAgICBDYXQyMSA9IDEwNDg1NzYsXHJcbiAgICAgICAgQ2F0MjIgPSAyMDk3MTUyLFxyXG4gICAgICAgIENhdDIzID0gNDE5NDMwNCxcclxuICAgICAgICBDYXQyNCA9IDgzODg2MDgsXHJcbiAgICAgICAgQ2F0MjUgPSAxNjc3NzIxNixcclxuICAgICAgICBDYXQyNiA9IDMzNTU0NDMyLFxyXG4gICAgICAgIENhdDI3ID0gNjcxMDg4NjQsXHJcbiAgICAgICAgQ2F0MjggPSAxMzQyMTc3MjgsXHJcbiAgICAgICAgQ2F0MjkgPSAyNjg0MzU0NTYsXHJcbiAgICAgICAgQ2F0MzAgPSA1MzY4NzA5MTIsXHJcbiAgICAgICAgQ2F0MzEgPSAxMDczNzQxODI0XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgcHJveHkgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGNvbm5lY3QgZml4dHVyZXMgdG8gdGhlIGJyb2FkLXBoYXNlLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgRml4dHVyZVByb3h5XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIEFBQkIgQUFCQjtcclxuICAgICAgICBwdWJsaWMgaW50IENoaWxkSW5kZXg7XHJcbiAgICAgICAgcHVibGljIEZpeHR1cmUgRml4dHVyZTtcclxuICAgICAgICBwdWJsaWMgaW50IFByb3h5SWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgZml4dHVyZSBpcyB1c2VkIHRvIGF0dGFjaCBhIFNoYXBlIHRvIGEgYm9keSBmb3IgY29sbGlzaW9uIGRldGVjdGlvbi4gQSBmaXh0dXJlXHJcbiAgICAvLy8gaW5oZXJpdHMgaXRzIHRyYW5zZm9ybSBmcm9tIGl0cyBwYXJlbnQuIEZpeHR1cmVzIGhvbGQgYWRkaXRpb25hbCBub24tZ2VvbWV0cmljIGRhdGFcclxuICAgIC8vLyBzdWNoIGFzIGZyaWN0aW9uLCBjb2xsaXNpb24gZmlsdGVycywgZXRjLlxyXG4gICAgLy8vIEZpeHR1cmVzIGFyZSBjcmVhdGVkIHZpYSBCb2R5LkNyZWF0ZUZpeHR1cmUuXHJcbiAgICAvLy8gV2FybmluZzogWW91IGNhbm5vdCByZXVzZSBmaXh0dXJlcy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRml4dHVyZSA6IElEaXNwb3NhYmxlXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgaW50IF9maXh0dXJlSWRDb3VudGVyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIGFmdGVyIHR3byBzaGFwZXMgaGFzIGNvbGxpZGVkIGFuZCBhcmUgc29sdmVkLiBUaGlzIGdpdmVzIHlvdSBhIGNoYW5jZSB0byBnZXQgdGhlIGltcGFjdCBmb3JjZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBBZnRlckNvbGxpc2lvbkV2ZW50SGFuZGxlciBBZnRlckNvbGxpc2lvbjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuIHR3byBmaXh0dXJlcyBhcmUgY2xvc2UgdG8gZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gRHVlIHRvIGhvdyB0aGUgYnJvYWRwaGFzZSB3b3JrcywgdGhpcyBjYW4gYmUgcXVpdGUgaW5hY2N1cmF0ZSBhcyBzaGFwZXMgYXJlIGFwcHJveGltYXRlZCB1c2luZyBBQUJCcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBCZWZvcmVDb2xsaXNpb25FdmVudEhhbmRsZXIgQmVmb3JlQ29sbGlzaW9uO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIHdoZW4gdHdvIHNoYXBlcyBjb2xsaWRlIGFuZCBhIGNvbnRhY3QgaXMgY3JlYXRlZCBiZXR3ZWVuIHRoZW0uXHJcbiAgICAgICAgLy8vIE5vdGUgdGhhdCB0aGUgZmlyc3QgZml4dHVyZSBhcmd1bWVudCBpcyBhbHdheXMgdGhlIGZpeHR1cmUgdGhhdCB0aGUgZGVsZWdhdGUgaXMgc3Vic2NyaWJlZCB0by5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBPbkNvbGxpc2lvbkV2ZW50SGFuZGxlciBPbkNvbGxpc2lvbjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuIHR3byBzaGFwZXMgc2VwYXJhdGUgYW5kIGEgY29udGFjdCBpcyByZW1vdmVkIGJldHdlZW4gdGhlbS5cclxuICAgICAgICAvLy8gTm90ZSB0aGF0IHRoZSBmaXJzdCBmaXh0dXJlIGFyZ3VtZW50IGlzIGFsd2F5cyB0aGUgZml4dHVyZSB0aGF0IHRoZSBkZWxlZ2F0ZSBpcyBzdWJzY3JpYmVkIHRvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE9uU2VwYXJhdGlvbkV2ZW50SGFuZGxlciBPblNlcGFyYXRpb247XHJcblxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlUHJveHlbXSBQcm94aWVzO1xyXG4gICAgICAgIHB1YmxpYyBpbnQgUHJveHlDb3VudDtcclxuICAgICAgICBpbnRlcm5hbCBDYXRlZ29yeSBfY29sbGlkZXNXaXRoO1xyXG4gICAgICAgIGludGVybmFsIENhdGVnb3J5IF9jb2xsaXNpb25DYXRlZ29yaWVzO1xyXG4gICAgICAgIGludGVybmFsIHNob3J0IF9jb2xsaXNpb25Hcm91cDtcclxuICAgICAgICBpbnRlcm5hbCBEaWN0aW9uYXJ5PGludCwgYm9vbD4gX2NvbGxpc2lvbklnbm9yZXM7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfZnJpY3Rpb247XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfcmVzdGl0dXRpb247XHJcblxyXG4gICAgICAgIGludGVybmFsIEZpeHR1cmUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlKEJvZHkgYm9keSwgU2hhcGUgc2hhcGUpXHJcbiAgICAgICAgICAgIDogdGhpcyhib2R5LCBzaGFwZSwgbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgRml4dHVyZShCb2R5IGJvZHksIFNoYXBlIHNoYXBlLCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuVXNlRlBFQ29sbGlzaW9uQ2F0ZWdvcmllcylcclxuICAgICAgICAgICAgICAgIF9jb2xsaXNpb25DYXRlZ29yaWVzID0gQ2F0ZWdvcnkuQWxsO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBfY29sbGlzaW9uQ2F0ZWdvcmllcyA9IENhdGVnb3J5LkNhdDE7XHJcblxyXG4gICAgICAgICAgICBfY29sbGlkZXNXaXRoID0gQ2F0ZWdvcnkuQWxsO1xyXG4gICAgICAgICAgICBfY29sbGlzaW9uR3JvdXAgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy9GaXh0dXJlIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIEZyaWN0aW9uID0gMC4yZjtcclxuICAgICAgICAgICAgUmVzdGl0dXRpb24gPSAwO1xyXG5cclxuICAgICAgICAgICAgSXNTZW5zb3IgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIEJvZHkgPSBib2R5O1xyXG4gICAgICAgICAgICBVc2VyRGF0YSA9IHVzZXJEYXRhO1xyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkNvbnNlcnZlTWVtb3J5KVxyXG4gICAgICAgICAgICAgICAgU2hhcGUgPSBzaGFwZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgU2hhcGUgPSBzaGFwZS5DbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgUmVnaXN0ZXJGaXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlZmF1bHRzIHRvIDBcclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIElmIFNldHRpbmdzLlVzZUZQRUNvbGxpc2lvbkNhdGVnb3JpZXMgaXMgc2V0IHRvIGZhbHNlOlxyXG4gICAgICAgIC8vLyBDb2xsaXNpb24gZ3JvdXBzIGFsbG93IGEgY2VydGFpbiBncm91cCBvZiBvYmplY3RzIHRvIG5ldmVyIGNvbGxpZGUgKG5lZ2F0aXZlKVxyXG4gICAgICAgIC8vLyBvciBhbHdheXMgY29sbGlkZSAocG9zaXRpdmUpLiBaZXJvIG1lYW5zIG5vIGNvbGxpc2lvbiBncm91cC4gTm9uLXplcm8gZ3JvdXBcclxuICAgICAgICAvLy8gZmlsdGVyaW5nIGFsd2F5cyB3aW5zIGFnYWluc3QgdGhlIG1hc2sgYml0cy5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIElmIFNldHRpbmdzLlVzZUZQRUNvbGxpc2lvbkNhdGVnb3JpZXMgaXMgc2V0IHRvIHRydWU6XHJcbiAgICAgICAgLy8vIElmIDIgZml4dHVyZXMgYXJlIGluIHRoZSBzYW1lIGNvbGxpc2lvbiBncm91cCwgdGhleSB3aWxsIG5vdCBjb2xsaWRlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHNob3J0IENvbGxpc2lvbkdyb3VwXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jb2xsaXNpb25Hcm91cCA9PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgX2NvbGxpc2lvbkdyb3VwID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBSZWZpbHRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfY29sbGlzaW9uR3JvdXA7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVmYXVsdHMgdG8gQ2F0ZWdvcnkuQWxsXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBUaGUgY29sbGlzaW9uIG1hc2sgYml0cy4gVGhpcyBzdGF0ZXMgdGhlIGNhdGVnb3JpZXMgdGhhdCB0aGlzXHJcbiAgICAgICAgLy8vIGZpeHR1cmUgd291bGQgYWNjZXB0IGZvciBjb2xsaXNpb24uXHJcbiAgICAgICAgLy8vIFVzZSBTZXR0aW5ncy5Vc2VGUEVDb2xsaXNpb25DYXRlZ29yaWVzIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQ2F0ZWdvcnkgQ29sbGlkZXNXaXRoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2NvbGxpZGVzV2l0aDsgfVxyXG5cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChfY29sbGlkZXNXaXRoID09IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBfY29sbGlkZXNXaXRoID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBSZWZpbHRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBjb2xsaXNpb24gY2F0ZWdvcmllcyB0aGlzIGZpeHR1cmUgaXMgYSBwYXJ0IG9mLlxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gSWYgU2V0dGluZ3MuVXNlRlBFQ29sbGlzaW9uQ2F0ZWdvcmllcyBpcyBzZXQgdG8gZmFsc2U6XHJcbiAgICAgICAgLy8vIERlZmF1bHRzIHRvIENhdGVnb3J5LkNhdDFcclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIElmIFNldHRpbmdzLlVzZUZQRUNvbGxpc2lvbkNhdGVnb3JpZXMgaXMgc2V0IHRvIHRydWU6XHJcbiAgICAgICAgLy8vIERlZmF1bHRzIHRvIENhdGVnb3J5LkFsbFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIENhdGVnb3J5IENvbGxpc2lvbkNhdGVnb3JpZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfY29sbGlzaW9uQ2F0ZWdvcmllczsgfVxyXG5cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChfY29sbGlzaW9uQ2F0ZWdvcmllcyA9PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgX2NvbGxpc2lvbkNhdGVnb3JpZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIFJlZmlsdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB0eXBlIG9mIHRoZSBjaGlsZCBTaGFwZS4gWW91IGNhbiB1c2UgdGhpcyB0byBkb3duIGNhc3QgdG8gdGhlIGNvbmNyZXRlIFNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgdHlwZSBvZiB0aGUgc2hhcGUuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgU2hhcGVUeXBlIFNoYXBlVHlwZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIFNoYXBlLlNoYXBlVHlwZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGNoaWxkIFNoYXBlLiBZb3UgY2FuIG1vZGlmeSB0aGUgY2hpbGQgU2hhcGUsIGhvd2V2ZXIgeW91IHNob3VsZCBub3QgY2hhbmdlIHRoZVxyXG4gICAgICAgIC8vLyBudW1iZXIgb2YgdmVydGljZXMgYmVjYXVzZSB0aGlzIHdpbGwgY3Jhc2ggc29tZSBjb2xsaXNpb24gY2FjaGluZyBtZWNoYW5pc21zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgc2hhcGUuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgU2hhcGUgU2hhcGUgeyBnZXQ7IGludGVybmFsIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGZpeHR1cmUgaXMgYSBzZW5zb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIHRoaXMgaW5zdGFuY2UgaXMgYSBzZW5zb3I7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNTZW5zb3IgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgcGFyZW50IGJvZHkgb2YgdGhpcyBmaXh0dXJlLiBUaGlzIGlzIG51bGwgaWYgdGhlIGZpeHR1cmUgaXMgbm90IGF0dGFjaGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgYm9keS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBCb2R5IEJvZHkgeyBnZXQ7IGludGVybmFsIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGUgdXNlciBkYXRhLiBVc2UgdGhpcyB0byBzdG9yZSB5b3VyIGFwcGxpY2F0aW9uIHNwZWNpZmljIGRhdGEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSB1c2VyIGRhdGEuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgb2JqZWN0IFVzZXJEYXRhIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgb3Igc2V0IHRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGZyaWN0aW9uLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyaWN0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2ZyaWN0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIWZsb2F0LklzTmFOKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2ZyaWN0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IG9yIHNldCB0aGUgY29lZmZpY2llbnQgb2YgcmVzdGl0dXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSByZXN0aXR1dGlvbi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSZXN0aXR1dGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9yZXN0aXR1dGlvbjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTih2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9yZXN0aXR1dGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgYSB1bmlxdWUgSUQgZm9yIHRoaXMgZml4dHVyZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGZpeHR1cmUgaWQuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgaW50IEZpeHR1cmVJZCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBJRGlzcG9zYWJsZSBNZW1iZXJzXHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzRGlzcG9zZWQgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBEaXNwb3NlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghSXNEaXNwb3NlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keS5EZXN0cm95Rml4dHVyZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIElzRGlzcG9zZWQgPSB0cnVlO1xyXG4jaWYgIUh0bWw1XHJcbiAgICAgICAgICAgICAgICBHQy5TdXBwcmVzc0ZpbmFsaXplKHRoaXMpO1xyXG4jZW5kaWZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXN0b3JlcyBjb2xsaXNpb25zIGJldHdlZW4gdGhpcyBmaXh0dXJlIGFuZCB0aGUgcHJvdmlkZWQgZml4dHVyZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZpeHR1cmVcIj5UaGUgZml4dHVyZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlc3RvcmVDb2xsaXNpb25XaXRoKEZpeHR1cmUgZml4dHVyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfY29sbGlzaW9uSWdub3JlcyA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9jb2xsaXNpb25JZ25vcmVzLkNvbnRhaW5zS2V5KGZpeHR1cmUuRml4dHVyZUlkKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2NvbGxpc2lvbklnbm9yZXNbZml4dHVyZS5GaXh0dXJlSWRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBSZWZpbHRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElnbm9yZXMgY29sbGlzaW9ucyBiZXR3ZWVuIHRoaXMgZml4dHVyZSBhbmQgdGhlIHByb3ZpZGVkIGZpeHR1cmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmaXh0dXJlXCI+VGhlIGZpeHR1cmUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBJZ25vcmVDb2xsaXNpb25XaXRoKEZpeHR1cmUgZml4dHVyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfY29sbGlzaW9uSWdub3JlcyA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgX2NvbGxpc2lvbklnbm9yZXMgPSBuZXcgRGljdGlvbmFyeTxpbnQsIGJvb2w+KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2NvbGxpc2lvbklnbm9yZXMuQ29udGFpbnNLZXkoZml4dHVyZS5GaXh0dXJlSWQpKVxyXG4gICAgICAgICAgICAgICAgX2NvbGxpc2lvbklnbm9yZXNbZml4dHVyZS5GaXh0dXJlSWRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgX2NvbGxpc2lvbklnbm9yZXMuQWRkKGZpeHR1cmUuRml4dHVyZUlkLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIFJlZmlsdGVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciBjb2xsaXNpb25zIGFyZSBpZ25vcmVkIGJldHdlZW4gdGhpcyBmaXh0dXJlIGFuZCB0aGUgcHJvdmlkZWQgZml4dHVyZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZpeHR1cmVcIj5UaGUgZml4dHVyZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gXHQ8Yz50cnVlPC9jPiBpZiB0aGUgZml4dHVyZSBpcyBpZ25vcmVkOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzRml4dHVyZUlnbm9yZWQoRml4dHVyZSBmaXh0dXJlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9jb2xsaXNpb25JZ25vcmVzID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2NvbGxpc2lvbklnbm9yZXMuQ29udGFpbnNLZXkoZml4dHVyZS5GaXh0dXJlSWQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb2xsaXNpb25JZ25vcmVzW2ZpeHR1cmUuRml4dHVyZUlkXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29udGFjdHMgYXJlIHBlcnNpc3RhbnQgYW5kIHdpbGwga2VlcCBiZWluZyBwZXJzaXN0YW50IHVubGVzcyB0aGV5IGFyZVxyXG4gICAgICAgIC8vLyBmbGFnZ2VkIGZvciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgLy8vIFRoaXMgbWV0aG9kcyBmbGFncyBhbGwgY29udGFjdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBib2R5IGZvciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIFJlZmlsdGVyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIEZsYWcgYXNzb2NpYXRlZCBjb250YWN0cyBmb3IgZmlsdGVyaW5nLlxyXG4gICAgICAgICAgICBDb250YWN0RWRnZSBlZGdlID0gQm9keS5Db250YWN0TGlzdDtcclxuICAgICAgICAgICAgd2hpbGUgKGVkZ2UgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdCBjb250YWN0ID0gZWRnZS5Db250YWN0O1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQSA9IGNvbnRhY3QuRml4dHVyZUE7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmVCID0gY29udGFjdC5GaXh0dXJlQjtcclxuICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlQSA9PSB0aGlzIHx8IGZpeHR1cmVCID09IHRoaXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5GbGFnRm9yRmlsdGVyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgV29ybGQgd29ybGQgPSBCb2R5LldvcmxkO1xyXG5cclxuICAgICAgICAgICAgaWYgKHdvcmxkID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVG91Y2ggZWFjaCBwcm94eSBzbyB0aGF0IG5ldyBwYWlycyBtYXkgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICBJQnJvYWRQaGFzZSBicm9hZFBoYXNlID0gd29ybGQuQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBQcm94eUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJyb2FkUGhhc2UuVG91Y2hQcm94eShQcm94aWVzW2ldLlByb3h5SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUmVnaXN0ZXJGaXh0dXJlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFJlc2VydmUgcHJveHkgc3BhY2VcclxuICAgICAgICAgICAgUHJveGllcyA9IG5ldyBGaXh0dXJlUHJveHlbU2hhcGUuQ2hpbGRDb3VudF07XHJcbiAgICAgICAgICAgIFByb3h5Q291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgRml4dHVyZUlkID0gX2ZpeHR1cmVJZENvdW50ZXIrKztcclxuXHJcbiAgICAgICAgICAgIGlmICgoQm9keS5GbGFncyAmIEJvZHlGbGFncy5FbmFibGVkKSA9PSBCb2R5RmxhZ3MuRW5hYmxlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSA9IEJvZHkuV29ybGQuQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZTtcclxuICAgICAgICAgICAgICAgIENyZWF0ZVByb3hpZXMoYnJvYWRQaGFzZSwgcmVmIEJvZHkuWGYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBCb2R5LkZpeHR1cmVMaXN0LkFkZCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkanVzdCBtYXNzIHByb3BlcnRpZXMgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICBpZiAoU2hhcGUuX2RlbnNpdHkgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5LlJlc2V0TWFzc0RhdGEoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGV0IHRoZSB3b3JsZCBrbm93IHdlIGhhdmUgYSBuZXcgZml4dHVyZS4gVGhpcyB3aWxsIGNhdXNlIG5ldyBjb250YWN0c1xyXG4gICAgICAgICAgICAvLyB0byBiZSBjcmVhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICBCb2R5LldvcmxkLkZsYWdzIHw9IFdvcmxkRmxhZ3MuTmV3Rml4dHVyZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChCb2R5LldvcmxkLkZpeHR1cmVBZGRlZCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5LldvcmxkLkZpeHR1cmVBZGRlZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUZXN0IGEgcG9pbnQgZm9yIGNvbnRhaW5tZW50IGluIHRoaXMgZml4dHVyZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+QSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgVGVzdFBvaW50KHJlZiBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNoYXBlLlRlc3RQb2ludChyZWYgQm9keS5YZiwgcmVmIHBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FzdCBhIHJheSBhZ2FpbnN0IHRoaXMgU2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdXRwdXRcIj5UaGUgcmF5LWNhc3QgcmVzdWx0cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJheS1jYXN0IGlucHV0IHBhcmFtZXRlcnMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaGlsZEluZGV4XCI+SW5kZXggb2YgdGhlIGNoaWxkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBSYXlDYXN0KG91dCBSYXlDYXN0T3V0cHV0IG91dHB1dCwgcmVmIFJheUNhc3RJbnB1dCBpbnB1dCwgaW50IGNoaWxkSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gU2hhcGUuUmF5Q2FzdChvdXQgb3V0cHV0LCByZWYgaW5wdXQsIHJlZiBCb2R5LlhmLCBjaGlsZEluZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBmaXh0dXJlJ3MgQUFCQi4gVGhpcyBBQUJCIG1heSBiZSBlbmxhcmdlIGFuZC9vciBzdGFsZS5cclxuICAgICAgICAvLy8gSWYgeW91IG5lZWQgYSBtb3JlIGFjY3VyYXRlIEFBQkIsIGNvbXB1dGUgaXQgdXNpbmcgdGhlIFNoYXBlIGFuZFxyXG4gICAgICAgIC8vLyB0aGUgYm9keSB0cmFuc2Zvcm0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaGlsZEluZGV4XCI+SW5kZXggb2YgdGhlIGNoaWxkLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgR2V0QUFCQihvdXQgQUFCQiBhYWJiLCBpbnQgY2hpbGRJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDw9IGNoaWxkSW5kZXggJiYgY2hpbGRJbmRleCA8IFByb3h5Q291bnQpO1xyXG4gICAgICAgICAgICBhYWJiID0gUHJveGllc1tjaGlsZEluZGV4XS5BQUJCO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEZpeHR1cmUgQ2xvbmUoQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlID0gbmV3IEZpeHR1cmUoKTtcclxuICAgICAgICAgICAgZml4dHVyZS5Cb2R5ID0gYm9keTtcclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5Db25zZXJ2ZU1lbW9yeSlcclxuICAgICAgICAgICAgICAgIGZpeHR1cmUuU2hhcGUgPSBTaGFwZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZml4dHVyZS5TaGFwZSA9IFNoYXBlLkNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICBmaXh0dXJlLlVzZXJEYXRhID0gVXNlckRhdGE7XHJcbiAgICAgICAgICAgIGZpeHR1cmUuUmVzdGl0dXRpb24gPSBSZXN0aXR1dGlvbjtcclxuICAgICAgICAgICAgZml4dHVyZS5GcmljdGlvbiA9IEZyaWN0aW9uO1xyXG4gICAgICAgICAgICBmaXh0dXJlLklzU2Vuc29yID0gSXNTZW5zb3I7XHJcbiAgICAgICAgICAgIGZpeHR1cmUuX2NvbGxpc2lvbkdyb3VwID0gQ29sbGlzaW9uR3JvdXA7XHJcbiAgICAgICAgICAgIGZpeHR1cmUuX2NvbGxpc2lvbkNhdGVnb3JpZXMgPSBDb2xsaXNpb25DYXRlZ29yaWVzO1xyXG4gICAgICAgICAgICBmaXh0dXJlLl9jb2xsaWRlc1dpdGggPSBDb2xsaWRlc1dpdGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2NvbGxpc2lvbklnbm9yZXMgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZml4dHVyZS5fY29sbGlzaW9uSWdub3JlcyA9IG5ldyBEaWN0aW9uYXJ5PGludCwgYm9vbD4oKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChLZXlWYWx1ZVBhaXI8aW50LCBib29sPiBwYWlyIGluIF9jb2xsaXNpb25JZ25vcmVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpeHR1cmUuX2NvbGxpc2lvbklnbm9yZXMuQWRkKHBhaXIuS2V5LCBwYWlyLlZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZml4dHVyZS5SZWdpc3RlckZpeHR1cmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpeHR1cmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgRml4dHVyZSBEZWVwQ2xvbmUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRml4dHVyZSBmaXggPSBDbG9uZShCb2R5LkNsb25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZml4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBEZXN0cm95KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBwcm94aWVzIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSBjYWxsaW5nIHRoaXMuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChQcm94eUNvdW50ID09IDApO1xyXG5cclxuICAgICAgICAgICAgLy8gRnJlZSB0aGUgcHJveHkgYXJyYXkuXHJcbiAgICAgICAgICAgIFByb3hpZXMgPSBudWxsO1xyXG4gICAgICAgICAgICBTaGFwZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBCZWZvcmVDb2xsaXNpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBPbkNvbGxpc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIE9uU2VwYXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIEFmdGVyQ29sbGlzaW9uID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGlmIChCb2R5LldvcmxkLkZpeHR1cmVSZW1vdmVkICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkuV29ybGQuRml4dHVyZVJlbW92ZWQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEJvZHkuV29ybGQuRml4dHVyZUFkZGVkID0gbnVsbDtcclxuICAgICAgICAgICAgQm9keS5Xb3JsZC5GaXh0dXJlUmVtb3ZlZCA9IG51bGw7XHJcbiAgICAgICAgICAgIE9uU2VwYXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIE9uQ29sbGlzaW9uID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZXNlIHN1cHBvcnQgYm9keSBhY3RpdmF0aW9uL2RlYWN0aXZhdGlvbi5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIENyZWF0ZVByb3hpZXMoSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSwgcmVmIFRyYW5zZm9ybSB4ZilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChQcm94eUNvdW50ID09IDApO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHByb3hpZXMgaW4gdGhlIGJyb2FkLXBoYXNlLlxyXG4gICAgICAgICAgICBQcm94eUNvdW50ID0gU2hhcGUuQ2hpbGRDb3VudDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUHJveHlDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlUHJveHkgcHJveHkgPSBuZXcgRml4dHVyZVByb3h5KCk7XHJcbiAgICAgICAgICAgICAgICBTaGFwZS5Db21wdXRlQUFCQihvdXQgcHJveHkuQUFCQiwgcmVmIHhmLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwcm94eS5GaXh0dXJlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHByb3h5LkNoaWxkSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgcHJveHkuUHJveHlJZCA9IGJyb2FkUGhhc2UuQWRkUHJveHkocmVmIHByb3h5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBQcm94aWVzW2ldID0gcHJveHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgRGVzdHJveVByb3hpZXMoSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIERlc3Ryb3kgcHJveGllcyBpbiB0aGUgYnJvYWQtcGhhc2UuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUHJveHlDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicm9hZFBoYXNlLlJlbW92ZVByb3h5KFByb3hpZXNbaV0uUHJveHlJZCk7XHJcbiAgICAgICAgICAgICAgICBQcm94aWVzW2ldLlByb3h5SWQgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgUHJveHlDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIFN5bmNocm9uaXplKElCcm9hZFBoYXNlIGJyb2FkUGhhc2UsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtMSwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFByb3h5Q291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFByb3h5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZVByb3h5IHByb3h5ID0gUHJveGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGFuIEFBQkIgdGhhdCBjb3ZlcnMgdGhlIHN3ZXB0IFNoYXBlIChtYXkgbWlzcyBzb21lIHJvdGF0aW9uIGVmZmVjdCkuXHJcbiAgICAgICAgICAgICAgICBBQUJCIGFhYmIxLCBhYWJiMjtcclxuICAgICAgICAgICAgICAgIFNoYXBlLkNvbXB1dGVBQUJCKG91dCBhYWJiMSwgcmVmIHRyYW5zZm9ybTEsIHByb3h5LkNoaWxkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgU2hhcGUuQ29tcHV0ZUFBQkIob3V0IGFhYmIyLCByZWYgdHJhbnNmb3JtMiwgcHJveHkuQ2hpbGRJbmRleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJveHkuQUFCQi5Db21iaW5lKHJlZiBhYWJiMSwgcmVmIGFhYmIyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGRpc3BsYWNlbWVudCA9IHRyYW5zZm9ybTIuUG9zaXRpb24gLSB0cmFuc2Zvcm0xLlBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyb2FkUGhhc2UuTW92ZVByb3h5KHByb3h5LlByb3h5SWQsIHJlZiBwcm94eS5BQUJCLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBib29sIENvbXBhcmVUbyhGaXh0dXJlIGZpeHR1cmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgIENvbGxpZGVzV2l0aCA9PSBmaXh0dXJlLkNvbGxpZGVzV2l0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIENvbGxpc2lvbkNhdGVnb3JpZXMgPT0gZml4dHVyZS5Db2xsaXNpb25DYXRlZ29yaWVzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgQ29sbGlzaW9uR3JvdXAgPT0gZml4dHVyZS5Db2xsaXNpb25Hcm91cCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIEZyaWN0aW9uID09IGZpeHR1cmUuRnJpY3Rpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBJc1NlbnNvciA9PSBmaXh0dXJlLklzU2Vuc29yICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgUmVzdGl0dXRpb24gPT0gZml4dHVyZS5SZXN0aXR1dGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIFNoYXBlLkNvbXBhcmVUbyhmaXh0dXJlLlNoYXBlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIFVzZXJEYXRhID09IGZpeHR1cmUuVXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuQ29udGFjdHM7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3Ncclxue1xyXG4gICAgcHVibGljIGNsYXNzIENvbnRhY3RNYW5hZ2VyXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuIGEgY29udGFjdCBpcyBjcmVhdGVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQmVnaW5Db250YWN0RGVsZWdhdGUgQmVnaW5Db250YWN0O1xyXG5cclxuICAgICAgICBwdWJsaWMgSUJyb2FkUGhhc2UgQnJvYWRQaGFzZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZmlsdGVyIHVzZWQgYnkgdGhlIGNvbnRhY3QgbWFuYWdlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBDb2xsaXNpb25GaWx0ZXJEZWxlZ2F0ZSBDb250YWN0RmlsdGVyO1xyXG5cclxuICAgICAgICBwdWJsaWMgTGlzdDxDb250YWN0PiBDb250YWN0TGlzdCA9IG5ldyBMaXN0PENvbnRhY3Q+KDEyOCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbiBhIGNvbnRhY3QgaXMgZGVsZXRlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEVuZENvbnRhY3REZWxlZ2F0ZSBFbmRDb250YWN0O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIHdoZW4gdGhlIGJyb2FkcGhhc2UgZGV0ZWN0cyB0aGF0IHR3byBGaXh0dXJlcyBhcmUgY2xvc2UgdG8gZWFjaCBvdGhlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBCcm9hZHBoYXNlRGVsZWdhdGUgT25Ccm9hZHBoYXNlQ29sbGlzaW9uO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIGFmdGVyIHRoZSBzb2x2ZXIgaGFzIHJ1blxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFBvc3RTb2x2ZURlbGVnYXRlIFBvc3RTb2x2ZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyBiZWZvcmUgdGhlIHNvbHZlciBydW5zXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgUHJlU29sdmVEZWxlZ2F0ZSBQcmVTb2x2ZTtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgQ29udGFjdE1hbmFnZXIoSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJyb2FkUGhhc2UgPSBicm9hZFBoYXNlO1xyXG4gICAgICAgICAgICBPbkJyb2FkcGhhc2VDb2xsaXNpb24gPSBBZGRQYWlyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQnJvYWQtcGhhc2UgY2FsbGJhY2suXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIEFkZFBhaXIocmVmIEZpeHR1cmVQcm94eSBwcm94eUEsIHJlZiBGaXh0dXJlUHJveHkgcHJveHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQSA9IHByb3h5QS5GaXh0dXJlO1xyXG4gICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmVCID0gcHJveHlCLkZpeHR1cmU7XHJcblxyXG4gICAgICAgICAgICBpbnQgaW5kZXhBID0gcHJveHlBLkNoaWxkSW5kZXg7XHJcbiAgICAgICAgICAgIGludCBpbmRleEIgPSBwcm94eUIuQ2hpbGRJbmRleDtcclxuXHJcbiAgICAgICAgICAgIEJvZHkgYm9keUEgPSBmaXh0dXJlQS5Cb2R5O1xyXG4gICAgICAgICAgICBCb2R5IGJvZHlCID0gZml4dHVyZUIuQm9keTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFyZSB0aGUgZml4dHVyZXMgb24gdGhlIHNhbWUgYm9keT9cclxuICAgICAgICAgICAgaWYgKGJvZHlBID09IGJvZHlCKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERvZXMgYSBjb250YWN0IGFscmVhZHkgZXhpc3Q/XHJcbiAgICAgICAgICAgIENvbnRhY3RFZGdlIGVkZ2UgPSBib2R5Qi5Db250YWN0TGlzdDtcclxuICAgICAgICAgICAgd2hpbGUgKGVkZ2UgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuT3RoZXIgPT0gYm9keUEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmQSA9IGVkZ2UuQ29udGFjdC5GaXh0dXJlQTtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGZCID0gZWRnZS5Db250YWN0LkZpeHR1cmVCO1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBpQSA9IGVkZ2UuQ29udGFjdC5DaGlsZEluZGV4QTtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgaUIgPSBlZGdlLkNvbnRhY3QuQ2hpbGRJbmRleEI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmQSA9PSBmaXh0dXJlQSAmJiBmQiA9PSBmaXh0dXJlQiAmJiBpQSA9PSBpbmRleEEgJiYgaUIgPT0gaW5kZXhCKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBjb250YWN0IGFscmVhZHkgZXhpc3RzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZkEgPT0gZml4dHVyZUIgJiYgZkIgPT0gZml4dHVyZUEgJiYgaUEgPT0gaW5kZXhCICYmIGlCID09IGluZGV4QSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY29udGFjdCBhbHJlYWR5IGV4aXN0cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlZGdlID0gZWRnZS5OZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEb2VzIGEgam9pbnQgb3ZlcnJpZGUgY29sbGlzaW9uPyBJcyBhdCBsZWFzdCBvbmUgYm9keSBkeW5hbWljP1xyXG4gICAgICAgICAgICBpZiAoYm9keUIuU2hvdWxkQ29sbGlkZShib2R5QSkgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvL0NoZWNrIGRlZmF1bHQgZmlsdGVyXHJcbiAgICAgICAgICAgIGlmIChTaG91bGRDb2xsaWRlKGZpeHR1cmVBLCBmaXh0dXJlQikgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB1c2VyIGZpbHRlcmluZy5cclxuICAgICAgICAgICAgaWYgKENvbnRhY3RGaWx0ZXIgIT0gbnVsbCAmJiBDb250YWN0RmlsdGVyKGZpeHR1cmVBLCBmaXh0dXJlQikgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoZml4dHVyZUEuQmVmb3JlQ29sbGlzaW9uICE9IG51bGwgJiYgZml4dHVyZUEuQmVmb3JlQ29sbGlzaW9uKGZpeHR1cmVBLCBmaXh0dXJlQikgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoZml4dHVyZUIuQmVmb3JlQ29sbGlzaW9uICE9IG51bGwgJiYgZml4dHVyZUIuQmVmb3JlQ29sbGlzaW9uKGZpeHR1cmVCLCBmaXh0dXJlQSkgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBmYWN0b3J5LlxyXG4gICAgICAgICAgICBDb250YWN0IGMgPSBDb250YWN0LkNyZWF0ZShmaXh0dXJlQSwgaW5kZXhBLCBmaXh0dXJlQiwgaW5kZXhCKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnRhY3QgY3JlYXRpb24gbWF5IHN3YXAgZml4dHVyZXMuXHJcbiAgICAgICAgICAgIGZpeHR1cmVBID0gYy5GaXh0dXJlQTtcclxuICAgICAgICAgICAgZml4dHVyZUIgPSBjLkZpeHR1cmVCO1xyXG4gICAgICAgICAgICBib2R5QSA9IGZpeHR1cmVBLkJvZHk7XHJcbiAgICAgICAgICAgIGJvZHlCID0gZml4dHVyZUIuQm9keTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSB3b3JsZC5cclxuICAgICAgICAgICAgQ29udGFjdExpc3QuQWRkKGMpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29ubmVjdCB0byBpc2xhbmQgZ3JhcGguXHJcblxyXG4gICAgICAgICAgICAvLyBDb25uZWN0IHRvIGJvZHkgQVxyXG4gICAgICAgICAgICBjLk5vZGVBLkNvbnRhY3QgPSBjO1xyXG4gICAgICAgICAgICBjLk5vZGVBLk90aGVyID0gYm9keUI7XHJcblxyXG4gICAgICAgICAgICBjLk5vZGVBLlByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICBjLk5vZGVBLk5leHQgPSBib2R5QS5Db250YWN0TGlzdDtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLkNvbnRhY3RMaXN0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJvZHlBLkNvbnRhY3RMaXN0LlByZXYgPSBjLk5vZGVBO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvZHlBLkNvbnRhY3RMaXN0ID0gYy5Ob2RlQTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gYm9keSBCXHJcbiAgICAgICAgICAgIGMuTm9kZUIuQ29udGFjdCA9IGM7XHJcbiAgICAgICAgICAgIGMuTm9kZUIuT3RoZXIgPSBib2R5QTtcclxuXHJcbiAgICAgICAgICAgIGMuTm9kZUIuUHJldiA9IG51bGw7XHJcbiAgICAgICAgICAgIGMuTm9kZUIuTmV4dCA9IGJvZHlCLkNvbnRhY3RMaXN0O1xyXG4gICAgICAgICAgICBpZiAoYm9keUIuQ29udGFjdExpc3QgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYm9keUIuQ29udGFjdExpc3QuUHJldiA9IGMuTm9kZUI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYm9keUIuQ29udGFjdExpc3QgPSBjLk5vZGVCO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBGaW5kTmV3Q29udGFjdHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQnJvYWRQaGFzZS5VcGRhdGVQYWlycygoZ2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Ccm9hZHBoYXNlRGVsZWdhdGUpT25Ccm9hZHBoYXNlQ29sbGlzaW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgRGVzdHJveShDb250YWN0IGNvbnRhY3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmVBID0gY29udGFjdC5GaXh0dXJlQTtcclxuICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQiA9IGNvbnRhY3QuRml4dHVyZUI7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keUEgPSBmaXh0dXJlQS5Cb2R5O1xyXG4gICAgICAgICAgICBCb2R5IGJvZHlCID0gZml4dHVyZUIuQm9keTtcclxuXHJcbiAgICAgICAgICAgIGlmIChFbmRDb250YWN0ICE9IG51bGwgJiYgY29udGFjdC5Jc1RvdWNoaW5nKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEVuZENvbnRhY3QoY29udGFjdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSB3b3JsZC5cclxuICAgICAgICAgICAgQ29udGFjdExpc3QuUmVtb3ZlKGNvbnRhY3QpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYm9keSAxXHJcbiAgICAgICAgICAgIGlmIChjb250YWN0Lk5vZGVBLlByZXYgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGFjdC5Ob2RlQS5QcmV2Lk5leHQgPSBjb250YWN0Lk5vZGVBLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb250YWN0Lk5vZGVBLk5leHQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGFjdC5Ob2RlQS5OZXh0LlByZXYgPSBjb250YWN0Lk5vZGVBLlByZXY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb250YWN0Lk5vZGVBID09IGJvZHlBLkNvbnRhY3RMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib2R5QS5Db250YWN0TGlzdCA9IGNvbnRhY3QuTm9kZUEuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYm9keSAyXHJcbiAgICAgICAgICAgIGlmIChjb250YWN0Lk5vZGVCLlByZXYgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGFjdC5Ob2RlQi5QcmV2Lk5leHQgPSBjb250YWN0Lk5vZGVCLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb250YWN0Lk5vZGVCLk5leHQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29udGFjdC5Ob2RlQi5OZXh0LlByZXYgPSBjb250YWN0Lk5vZGVCLlByZXY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjb250YWN0Lk5vZGVCID09IGJvZHlCLkNvbnRhY3RMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib2R5Qi5Db250YWN0TGlzdCA9IGNvbnRhY3QuTm9kZUIuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29udGFjdC5EZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIENvbGxpZGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGF3YWtlIGNvbnRhY3RzLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvbnRhY3RMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbnRhY3QgYyA9IENvbnRhY3RMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQSA9IGMuRml4dHVyZUE7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmVCID0gYy5GaXh0dXJlQjtcclxuICAgICAgICAgICAgICAgIGludCBpbmRleEEgPSBjLkNoaWxkSW5kZXhBO1xyXG4gICAgICAgICAgICAgICAgaW50IGluZGV4QiA9IGMuQ2hpbGRJbmRleEI7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHlBID0gZml4dHVyZUEuQm9keTtcclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keUIgPSBmaXh0dXJlQi5Cb2R5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5Bd2FrZSA9PSBmYWxzZSAmJiBib2R5Qi5Bd2FrZSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGNvbnRhY3QgZmxhZ2dlZCBmb3IgZmlsdGVyaW5nP1xyXG4gICAgICAgICAgICAgICAgaWYgKChjLkZsYWdzICYgQ29udGFjdEZsYWdzLkZpbHRlcikgPT0gQ29udGFjdEZsYWdzLkZpbHRlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgdGhlc2UgYm9kaWVzIGNvbGxpZGU/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlCLlNob3VsZENvbGxpZGUoYm9keUEpID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdCBjTnVrZSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlc3Ryb3koY051a2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGRlZmF1bHQgZmlsdGVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNob3VsZENvbGxpZGUoZml4dHVyZUEsIGZpeHR1cmVCKSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3QgY051a2UgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZXN0cm95KGNOdWtlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB1c2VyIGZpbHRlcmluZy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ29udGFjdEZpbHRlciAhPSBudWxsICYmIENvbnRhY3RGaWx0ZXIoZml4dHVyZUEsIGZpeHR1cmVCKSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3QgY051a2UgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZXN0cm95KGNOdWtlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgZmlsdGVyaW5nIGZsYWcuXHJcbiAgICAgICAgICAgICAgICAgICAgYy5GbGFncyAmPSB+Q29udGFjdEZsYWdzLkZpbHRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpbnQgcHJveHlJZEEgPSBmaXh0dXJlQS5Qcm94aWVzW2luZGV4QV0uUHJveHlJZDtcclxuICAgICAgICAgICAgICAgIGludCBwcm94eUlkQiA9IGZpeHR1cmVCLlByb3hpZXNbaW5kZXhCXS5Qcm94eUlkO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvb2wgb3ZlcmxhcCA9IEJyb2FkUGhhc2UuVGVzdE92ZXJsYXAocHJveHlJZEEsIHByb3h5SWRCKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIZXJlIHdlIGRlc3Ryb3kgY29udGFjdHMgdGhhdCBjZWFzZSB0byBvdmVybGFwIGluIHRoZSBicm9hZC1waGFzZS5cclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3QgY051a2UgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgIERlc3Ryb3koY051a2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb250YWN0IHBlcnNpc3RzLlxyXG4gICAgICAgICAgICAgICAgYy5VcGRhdGUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgU2hvdWxkQ29sbGlkZShGaXh0dXJlIGZpeHR1cmVBLCBGaXh0dXJlIGZpeHR1cmVCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLlVzZUZQRUNvbGxpc2lvbkNhdGVnb3JpZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICgoZml4dHVyZUEuQ29sbGlzaW9uR3JvdXAgPT0gZml4dHVyZUIuQ29sbGlzaW9uR3JvdXApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZml4dHVyZUEuQ29sbGlzaW9uR3JvdXAgIT0gMCAmJiBmaXh0dXJlQi5Db2xsaXNpb25Hcm91cCAhPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKChmaXh0dXJlQS5Db2xsaXNpb25DYXRlZ29yaWVzICYgZml4dHVyZUIuQ29sbGlkZXNXaXRoKSA9PVxyXG4gICAgICAgICAgICAgICAgICAgICBDYXRlZ29yeS5Ob25lKSAmXHJcbiAgICAgICAgICAgICAgICAgICAgKChmaXh0dXJlQi5Db2xsaXNpb25DYXRlZ29yaWVzICYgZml4dHVyZUEuQ29sbGlkZXNXaXRoKSA9PVxyXG4gICAgICAgICAgICAgICAgICAgICBDYXRlZ29yeS5Ob25lKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpeHR1cmVBLklzRml4dHVyZUlnbm9yZWQoZml4dHVyZUIpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZml4dHVyZUIuSXNGaXh0dXJlSWdub3JlZChmaXh0dXJlQSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZml4dHVyZUEuQ29sbGlzaW9uR3JvdXAgPT0gZml4dHVyZUIuQ29sbGlzaW9uR3JvdXAgJiZcclxuICAgICAgICAgICAgICAgIGZpeHR1cmVBLkNvbGxpc2lvbkdyb3VwICE9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaXh0dXJlQS5Db2xsaXNpb25Hcm91cCA+IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJvb2wgY29sbGlkZSA9IChmaXh0dXJlQS5Db2xsaWRlc1dpdGggJiBmaXh0dXJlQi5Db2xsaXNpb25DYXRlZ29yaWVzKSAhPSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaXh0dXJlQS5Db2xsaXNpb25DYXRlZ29yaWVzICYgZml4dHVyZUIuQ29sbGlkZXNXaXRoKSAhPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbGxpZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlQS5Jc0ZpeHR1cmVJZ25vcmVkKGZpeHR1cmVCKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpeHR1cmVCLklzRml4dHVyZUlnbm9yZWQoZml4dHVyZUEpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxpZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Db250YWN0c1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBjb250YWN0IGVkZ2UgaXMgdXNlZCB0byBjb25uZWN0IGJvZGllcyBhbmQgY29udGFjdHMgdG9nZXRoZXJcclxuICAgIC8vLyBpbiBhIGNvbnRhY3QgZ3JhcGggd2hlcmUgZWFjaCBib2R5IGlzIGEgbm9kZSBhbmQgZWFjaCBjb250YWN0XHJcbiAgICAvLy8gaXMgYW4gZWRnZS4gQSBjb250YWN0IGVkZ2UgYmVsb25ncyB0byBhIGRvdWJseSBsaW5rZWQgbGlzdFxyXG4gICAgLy8vIG1haW50YWluZWQgaW4gZWFjaCBhdHRhY2hlZCBib2R5LiBFYWNoIGNvbnRhY3QgaGFzIHR3byBjb250YWN0XHJcbiAgICAvLy8gbm9kZXMsIG9uZSBmb3IgZWFjaCBhdHRhY2hlZCBib2R5LlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzZWFsZWQgY2xhc3MgQ29udGFjdEVkZ2VcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBjb250YWN0XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQ29udGFjdCBDb250YWN0O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBuZXh0IGNvbnRhY3QgZWRnZSBpbiB0aGUgYm9keSdzIGNvbnRhY3QgbGlzdFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIENvbnRhY3RFZGdlIE5leHQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUHJvdmlkZXMgcXVpY2sgYWNjZXNzIHRvIHRoZSBvdGhlciBib2R5IGF0dGFjaGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEJvZHkgT3RoZXI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIHByZXZpb3VzIGNvbnRhY3QgZWRnZSBpbiB0aGUgYm9keSdzIGNvbnRhY3QgbGlzdFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIENvbnRhY3RFZGdlIFByZXY7XHJcbiAgICB9XHJcblxyXG4gICAgW0ZsYWdzXVxyXG4gICAgcHVibGljIGVudW0gQ29udGFjdEZsYWdzXHJcbiAgICB7XHJcbiAgICAgICAgTm9uZSA9IDAsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVXNlZCB3aGVuIGNyYXdsaW5nIGNvbnRhY3QgZ3JhcGggd2hlbiBmb3JtaW5nIGlzbGFuZHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBJc2xhbmQgPSAweDAwMDEsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHdoZW4gdGhlIHNoYXBlcyBhcmUgdG91Y2hpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBUb3VjaGluZyA9IDB4MDAwMixcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGNvbnRhY3QgY2FuIGJlIGRpc2FibGVkIChieSB1c2VyKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgRW5hYmxlZCA9IDB4MDAwNCxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGNvbnRhY3QgbmVlZHMgZmlsdGVyaW5nIGJlY2F1c2UgYSBmaXh0dXJlIGZpbHRlciB3YXMgY2hhbmdlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIEZpbHRlciA9IDB4MDAwOCxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGJ1bGxldCBjb250YWN0IGhhZCBhIFRPSSBldmVudFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgQnVsbGV0SGl0ID0gMHgwMDEwLFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgY29udGFjdCBoYXMgYSB2YWxpZCBUT0kgaSB0aGUgZmllbGQgVE9JXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBUT0kgPSAweDAwMjBcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhlIGNsYXNzIG1hbmFnZXMgY29udGFjdCBiZXR3ZWVuIHR3byBzaGFwZXMuIEEgY29udGFjdCBleGlzdHMgZm9yIGVhY2ggb3ZlcmxhcHBpbmdcclxuICAgIC8vLyBBQUJCIGluIHRoZSBicm9hZC1waGFzZSAoZXhjZXB0IGlmIGZpbHRlcmVkKS4gVGhlcmVmb3JlIGEgY29udGFjdCBvYmplY3QgbWF5IGV4aXN0XHJcbiAgICAvLy8gdGhhdCBoYXMgbm8gY29udGFjdCBwb2ludHMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIENvbnRhY3RcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBFZGdlU2hhcGUgX2VkZ2UgPSBuZXcgRWRnZVNoYXBlKCk7XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIENvbnRhY3RUeXBlWyxdIF9yZWdpc3RlcnMgPSBuZXdbLF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLkNpcmNsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuRWRnZUFuZENpcmNsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuUG9seWdvbkFuZENpcmNsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuTG9vcEFuZENpcmNsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuRWRnZUFuZENpcmNsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuTm90U3VwcG9ydGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLDEgaXMgaW52YWxpZCAobm8gQ29udGFjdFR5cGUuRWRnZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuRWRnZUFuZFBvbHlnb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLk5vdFN1cHBvcnRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSwzIGlzIGludmFsaWQgKG5vIENvbnRhY3RUeXBlLkVkZ2VBbmRMb29wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0VHlwZS5Qb2x5Z29uQW5kQ2lyY2xlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0VHlwZS5FZGdlQW5kUG9seWdvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuUG9seWdvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuTG9vcEFuZFBvbHlnb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLkxvb3BBbmRDaXJjbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLk5vdFN1cHBvcnRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMywxIGlzIGludmFsaWQgKG5vIENvbnRhY3RUeXBlLkVkZ2VBbmRMb29wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0VHlwZS5Mb29wQW5kUG9seWdvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuTm90U3VwcG9ydGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzLDMgaXMgaW52YWxpZCAobm8gQ29udGFjdFR5cGUuTG9vcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcHVibGljIEZpeHR1cmUgRml4dHVyZUE7XHJcbiAgICAgICAgcHVibGljIEZpeHR1cmUgRml4dHVyZUI7XHJcbiAgICAgICAgaW50ZXJuYWwgQ29udGFjdEZsYWdzIEZsYWdzO1xyXG5cclxuICAgICAgICBwdWJsaWMgTWFuaWZvbGQgTWFuaWZvbGQ7XHJcblxyXG4gICAgICAgIC8vIE5vZGVzIGZvciBjb25uZWN0aW5nIGJvZGllcy5cclxuICAgICAgICBpbnRlcm5hbCBDb250YWN0RWRnZSBOb2RlQSA9IG5ldyBDb250YWN0RWRnZSgpO1xyXG4gICAgICAgIGludGVybmFsIENvbnRhY3RFZGdlIE5vZGVCID0gbmV3IENvbnRhY3RFZGdlKCk7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFRPSTtcclxuICAgICAgICBpbnRlcm5hbCBpbnQgVE9JQ291bnQ7XHJcbiAgICAgICAgcHJpdmF0ZSBDb250YWN0VHlwZSBfdHlwZTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBDb250YWN0KEZpeHR1cmUgZkEsIGludCBpbmRleEEsIEZpeHR1cmUgZkIsIGludCBpbmRleEIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBSZXNldChmQSwgaW5kZXhBLCBmQiwgaW5kZXhCKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyBFbmFibGUvZGlzYWJsZSB0aGlzIGNvbnRhY3QuIFRoaXMgY2FuIGJlIHVzZWQgaW5zaWRlIHRoZSBwcmUtc29sdmVcclxuICAgICAgICAvLy8gY29udGFjdCBsaXN0ZW5lci4gVGhlIGNvbnRhY3QgaXMgb25seSBkaXNhYmxlZCBmb3IgdGhlIGN1cnJlbnRcclxuICAgICAgICAvLy8gdGltZSBzdGVwIChvciBzdWItc3RlcCBpbiBjb250aW51b3VzIGNvbGxpc2lvbnMpLlxyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgfD0gQ29udGFjdEZsYWdzLkVuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgJj0gfkNvbnRhY3RGbGFncy5FbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKEZsYWdzICYgQ29udGFjdEZsYWdzLkVuYWJsZWQpID09IENvbnRhY3RGbGFncy5FbmFibGVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY2hpbGQgcHJpbWl0aXZlIGluZGV4IGZvciBmaXh0dXJlIEEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBjaGlsZCBpbmRleCBBLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGludCBDaGlsZEluZGV4QSB7IGdldDsgaW50ZXJuYWwgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjaGlsZCBwcmltaXRpdmUgaW5kZXggZm9yIGZpeHR1cmUgQi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGNoaWxkIGluZGV4IEIuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgaW50IENoaWxkSW5kZXhCIHsgZ2V0OyBpbnRlcm5hbCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGNvbnRhY3QgbWFuaWZvbGQuIERvIG5vdCBtb2RpZnkgdGhlIG1hbmlmb2xkIHVubGVzcyB5b3UgdW5kZXJzdGFuZCB0aGVcclxuICAgICAgICAvLy8gaW50ZXJuYWxzIG9mIEJveDJELlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWFuaWZvbGRcIj5UaGUgbWFuaWZvbGQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBHZXRNYW5pZm9sZChvdXQgTWFuaWZvbGQgbWFuaWZvbGQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtYW5pZm9sZCA9IE1hbmlmb2xkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSB3b3JsZCBtYW5pZm9sZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEdldFdvcmxkTWFuaWZvbGQob3V0IFZlY3RvcjIgbm9ybWFsLCBvdXQgRml4ZWRBcnJheTI8VmVjdG9yMj4gcG9pbnRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5QSA9IEZpeHR1cmVBLkJvZHk7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keUIgPSBGaXh0dXJlQi5Cb2R5O1xyXG4gICAgICAgICAgICBTaGFwZSBzaGFwZUEgPSBGaXh0dXJlQS5TaGFwZTtcclxuICAgICAgICAgICAgU2hhcGUgc2hhcGVCID0gRml4dHVyZUIuU2hhcGU7XHJcblxyXG4gICAgICAgICAgICBDb2xsaXNpb24uQ29sbGlzaW9uLkdldFdvcmxkTWFuaWZvbGQocmVmIE1hbmlmb2xkLCByZWYgYm9keUEuWGYsIHNoYXBlQS5SYWRpdXMsIHJlZiBib2R5Qi5YZiwgc2hhcGVCLlJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBub3JtYWwsIG91dCBwb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBjb250YWN0IGlzIHRvdWNoaW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBcdDxjPnRydWU8L2M+IGlmIHRoaXMgaW5zdGFuY2UgaXMgdG91Y2hpbmc7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNUb3VjaGluZygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKEZsYWdzICYgQ29udGFjdEZsYWdzLlRvdWNoaW5nKSA9PSBDb250YWN0RmxhZ3MuVG91Y2hpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZsYWcgdGhpcyBjb250YWN0IGZvciBmaWx0ZXJpbmcuIEZpbHRlcmluZyB3aWxsIG9jY3VyIHRoZSBuZXh0IHRpbWUgc3RlcC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEZsYWdGb3JGaWx0ZXJpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRmxhZ3MgfD0gQ29udGFjdEZsYWdzLkZpbHRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBSZXNldChGaXh0dXJlIGZBLCBpbnQgaW5kZXhBLCBGaXh0dXJlIGZCLCBpbnQgaW5kZXhCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRmxhZ3MgPSBDb250YWN0RmxhZ3MuRW5hYmxlZDtcclxuXHJcbiAgICAgICAgICAgIEZpeHR1cmVBID0gZkE7XHJcbiAgICAgICAgICAgIEZpeHR1cmVCID0gZkI7XHJcblxyXG4gICAgICAgICAgICBDaGlsZEluZGV4QSA9IGluZGV4QTtcclxuICAgICAgICAgICAgQ2hpbGRJbmRleEIgPSBpbmRleEI7XHJcblxyXG4gICAgICAgICAgICBNYW5pZm9sZC5Qb2ludENvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIE5vZGVBLkNvbnRhY3QgPSBudWxsO1xyXG4gICAgICAgICAgICBOb2RlQS5QcmV2ID0gbnVsbDtcclxuICAgICAgICAgICAgTm9kZUEuTmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIE5vZGVBLk90aGVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIE5vZGVCLkNvbnRhY3QgPSBudWxsO1xyXG4gICAgICAgICAgICBOb2RlQi5QcmV2ID0gbnVsbDtcclxuICAgICAgICAgICAgTm9kZUIuTmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIE5vZGVCLk90aGVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIFRPSUNvdW50ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVXBkYXRlIHRoZSBjb250YWN0IG1hbmlmb2xkIGFuZCB0b3VjaGluZyBzdGF0dXMuXHJcbiAgICAgICAgLy8vIE5vdGU6IGRvIG5vdCBhc3N1bWUgdGhlIGZpeHR1cmUgQUFCQnMgYXJlIG92ZXJsYXBwaW5nIG9yIGFyZSB2YWxpZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbnRhY3RNYW5hZ2VyXCI+VGhlIGNvbnRhY3QgbWFuYWdlci48L3BhcmFtPlxyXG4gICAgICAgIGludGVybmFsIHZvaWQgVXBkYXRlKENvbnRhY3RNYW5hZ2VyIGNvbnRhY3RNYW5hZ2VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFuaWZvbGQgb2xkTWFuaWZvbGQgPSBNYW5pZm9sZDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlLWVuYWJsZSB0aGlzIGNvbnRhY3QuXHJcbiAgICAgICAgICAgIEZsYWdzIHw9IENvbnRhY3RGbGFncy5FbmFibGVkO1xyXG5cclxuICAgICAgICAgICAgYm9vbCB0b3VjaGluZztcclxuICAgICAgICAgICAgYm9vbCB3YXNUb3VjaGluZyA9IChGbGFncyAmIENvbnRhY3RGbGFncy5Ub3VjaGluZykgPT0gQ29udGFjdEZsYWdzLlRvdWNoaW5nO1xyXG5cclxuICAgICAgICAgICAgYm9vbCBzZW5zb3IgPSBGaXh0dXJlQS5Jc1NlbnNvciB8fCBGaXh0dXJlQi5Jc1NlbnNvcjtcclxuXHJcbiAgICAgICAgICAgIEJvZHkgYm9keUEgPSBGaXh0dXJlQS5Cb2R5O1xyXG4gICAgICAgICAgICBCb2R5IGJvZHlCID0gRml4dHVyZUIuQm9keTtcclxuXHJcbiAgICAgICAgICAgIC8vIElzIHRoaXMgY29udGFjdCBhIHNlbnNvcj9cclxuICAgICAgICAgICAgaWYgKHNlbnNvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU2hhcGUgc2hhcGVBID0gRml4dHVyZUEuU2hhcGU7XHJcbiAgICAgICAgICAgICAgICBTaGFwZSBzaGFwZUIgPSBGaXh0dXJlQi5TaGFwZTtcclxuICAgICAgICAgICAgICAgIHRvdWNoaW5nID0gQUFCQi5UZXN0T3ZlcmxhcChzaGFwZUEsIENoaWxkSW5kZXhBLCBzaGFwZUIsIENoaWxkSW5kZXhCLCByZWYgYm9keUEuWGYsIHJlZiBib2R5Qi5YZik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2Vuc29ycyBkb24ndCBnZW5lcmF0ZSBtYW5pZm9sZHMuXHJcbiAgICAgICAgICAgICAgICBNYW5pZm9sZC5Qb2ludENvdW50ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEV2YWx1YXRlKHJlZiBNYW5pZm9sZCwgcmVmIGJvZHlBLlhmLCByZWYgYm9keUIuWGYpO1xyXG4gICAgICAgICAgICAgICAgdG91Y2hpbmcgPSBNYW5pZm9sZC5Qb2ludENvdW50ID4gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCBvbGQgY29udGFjdCBpZHMgdG8gbmV3IGNvbnRhY3QgaWRzIGFuZCBjb3B5IHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gc3RvcmVkIGltcHVsc2VzIHRvIHdhcm0gc3RhcnQgdGhlIHNvbHZlci5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTWFuaWZvbGQuUG9pbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgbXAyID0gTWFuaWZvbGQuUG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG1wMi5Ob3JtYWxJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBtcDIuVGFuZ2VudEltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RJRCBpZDIgPSBtcDIuSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IG9sZE1hbmlmb2xkLlBvaW50Q291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgbXAxID0gb2xkTWFuaWZvbGQuUG9pbnRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1wMS5JZC5LZXkgPT0gaWQyLktleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXAyLk5vcm1hbEltcHVsc2UgPSBtcDEuTm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wMi5UYW5nZW50SW1wdWxzZSA9IG1wMS5UYW5nZW50SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1wMi5Ob3JtYWxJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXAyLlRhbmdlbnRJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIE1hbmlmb2xkLlBvaW50c1tpXSA9IG1wMjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodG91Y2hpbmcgIT0gd2FzVG91Y2hpbmcpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRvdWNoaW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGbGFncyB8PSBDb250YWN0RmxhZ3MuVG91Y2hpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGbGFncyAmPSB+Q29udGFjdEZsYWdzLlRvdWNoaW5nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAod2FzVG91Y2hpbmcgPT0gZmFsc2UgJiYgdG91Y2hpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vUmVwb3J0IHRoZSBjb2xsaXNpb24gdG8gYm90aCBwYXJ0aWNpcGFudHM6XHJcbiAgICAgICAgICAgICAgICBpZiAoRml4dHVyZUEuT25Db2xsaXNpb24gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBFbmFibGVkID0gRml4dHVyZUEuT25Db2xsaXNpb24oRml4dHVyZUEsIEZpeHR1cmVCLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1JldmVyc2UgdGhlIG9yZGVyIG9mIHRoZSByZXBvcnRlZCBmaXh0dXJlcy4gVGhlIGZpcnN0IGZpeHR1cmUgaXMgYWx3YXlzIHRoZSBvbmUgdGhhdCB0aGVcclxuICAgICAgICAgICAgICAgIC8vdXNlciBzdWJzY3JpYmVkIHRvLlxyXG4gICAgICAgICAgICAgICAgaWYgKEZpeHR1cmVCLk9uQ29sbGlzaW9uICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgRW5hYmxlZCA9IEZpeHR1cmVCLk9uQ29sbGlzaW9uKEZpeHR1cmVCLCBGaXh0dXJlQSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9CZWdpbkNvbnRhY3QgY2FuIGFsc28gcmV0dXJuIGZhbHNlIGFuZCBkaXNhYmxlIHRoZSBjb250YWN0XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdE1hbmFnZXIuQmVnaW5Db250YWN0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgRW5hYmxlZCA9IGNvbnRhY3RNYW5hZ2VyLkJlZ2luQ29udGFjdCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSB1c2VyIGRpc2FibGVkIHRoZSBjb250YWN0IChuZWVkZWQgdG8gZXhjbHVkZSBpdCBpbiBUT0kgc29sdmVyKSwgd2UgYWxzbyBuZWVkIHRvIG1hcmtcclxuICAgICAgICAgICAgICAgIC8vaXQgYXMgbm90IHRvdWNoaW5nLlxyXG4gICAgICAgICAgICAgICAgaWYgKEVuYWJsZWQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgJj0gfkNvbnRhY3RGbGFncy5Ub3VjaGluZztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHdhc1RvdWNoaW5nICYmIHRvdWNoaW5nID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL1JlcG9ydCB0aGUgc2VwYXJhdGlvbiB0byBib3RoIHBhcnRpY2lwYW50czpcclxuICAgICAgICAgICAgICAgIGlmIChGaXh0dXJlQSAhPSBudWxsICYmIEZpeHR1cmVBLk9uU2VwYXJhdGlvbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmVBLk9uU2VwYXJhdGlvbihGaXh0dXJlQSwgRml4dHVyZUIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vUmV2ZXJzZSB0aGUgb3JkZXIgb2YgdGhlIHJlcG9ydGVkIGZpeHR1cmVzLiBUaGUgZmlyc3QgZml4dHVyZSBpcyBhbHdheXMgdGhlIG9uZSB0aGF0IHRoZVxyXG4gICAgICAgICAgICAgICAgLy91c2VyIHN1YnNjcmliZWQgdG8uXHJcbiAgICAgICAgICAgICAgICBpZiAoRml4dHVyZUIgIT0gbnVsbCAmJiBGaXh0dXJlQi5PblNlcGFyYXRpb24gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlQi5PblNlcGFyYXRpb24oRml4dHVyZUIsIEZpeHR1cmVBKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdE1hbmFnZXIuRW5kQ29udGFjdCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RNYW5hZ2VyLkVuZENvbnRhY3QodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZW5zb3IpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGFjdE1hbmFnZXIuUHJlU29sdmUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGNvbnRhY3RNYW5hZ2VyLlByZVNvbHZlKHRoaXMsIHJlZiBvbGRNYW5pZm9sZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEV2YWx1YXRlIHRoaXMgY29udGFjdCB3aXRoIHlvdXIgb3duIG1hbmlmb2xkIGFuZCB0cmFuc2Zvcm1zLiAgIFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWFuaWZvbGRcIj5UaGUgbWFuaWZvbGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1BXCI+VGhlIGZpcnN0IHRyYW5zZm9ybS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybUJcIj5UaGUgc2Vjb25kIHRyYW5zZm9ybS48L3BhcmFtPlxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBFdmFsdWF0ZShyZWYgTWFuaWZvbGQgbWFuaWZvbGQsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtQSwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1CKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfdHlwZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb250YWN0VHlwZS5Qb2x5Z29uOlxyXG4gICAgICAgICAgICAgICAgICAgIENvbGxpc2lvbi5Db2xsaXNpb24uQ29sbGlkZVBvbHlnb25zKHJlZiBtYW5pZm9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoUG9seWdvblNoYXBlKUZpeHR1cmVBLlNoYXBlLCByZWYgdHJhbnNmb3JtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoUG9seWdvblNoYXBlKUZpeHR1cmVCLlNoYXBlLCByZWYgdHJhbnNmb3JtQik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRhY3RUeXBlLlBvbHlnb25BbmRDaXJjbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgQ29sbGlzaW9uLkNvbGxpc2lvbi5Db2xsaWRlUG9seWdvbkFuZENpcmNsZShyZWYgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoUG9seWdvblNoYXBlKUZpeHR1cmVBLlNoYXBlLCByZWYgdHJhbnNmb3JtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChDaXJjbGVTaGFwZSlGaXh0dXJlQi5TaGFwZSwgcmVmIHRyYW5zZm9ybUIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb250YWN0VHlwZS5FZGdlQW5kQ2lyY2xlOlxyXG4gICAgICAgICAgICAgICAgICAgIENvbGxpc2lvbi5Db2xsaXNpb24uQ29sbGlkZUVkZ2VBbmRDaXJjbGUocmVmIG1hbmlmb2xkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEVkZ2VTaGFwZSlGaXh0dXJlQS5TaGFwZSwgcmVmIHRyYW5zZm9ybUEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ2lyY2xlU2hhcGUpRml4dHVyZUIuU2hhcGUsIHJlZiB0cmFuc2Zvcm1CKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29udGFjdFR5cGUuRWRnZUFuZFBvbHlnb246XHJcbiAgICAgICAgICAgICAgICAgICAgQ29sbGlzaW9uLkNvbGxpc2lvbi5Db2xsaWRlRWRnZUFuZFBvbHlnb24ocmVmIG1hbmlmb2xkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChFZGdlU2hhcGUpRml4dHVyZUEuU2hhcGUsIHJlZiB0cmFuc2Zvcm1BLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChQb2x5Z29uU2hhcGUpRml4dHVyZUIuU2hhcGUsIHJlZiB0cmFuc2Zvcm1CKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29udGFjdFR5cGUuTG9vcEFuZENpcmNsZTpcclxuICAgICAgICAgICAgICAgICAgICBMb29wU2hhcGUgbG9vcCA9IChMb29wU2hhcGUpRml4dHVyZUEuU2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9vcC5HZXRDaGlsZEVkZ2UocmVmIF9lZGdlLCBDaGlsZEluZGV4QSk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29sbGlzaW9uLkNvbGxpc2lvbi5Db2xsaWRlRWRnZUFuZENpcmNsZShyZWYgbWFuaWZvbGQsIF9lZGdlLCByZWYgdHJhbnNmb3JtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChDaXJjbGVTaGFwZSlGaXh0dXJlQi5TaGFwZSwgcmVmIHRyYW5zZm9ybUIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb250YWN0VHlwZS5Mb29wQW5kUG9seWdvbjpcclxuICAgICAgICAgICAgICAgICAgICBMb29wU2hhcGUgbG9vcDIgPSAoTG9vcFNoYXBlKUZpeHR1cmVBLlNoYXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvb3AyLkdldENoaWxkRWRnZShyZWYgX2VkZ2UsIENoaWxkSW5kZXhBKTtcclxuICAgICAgICAgICAgICAgICAgICBDb2xsaXNpb24uQ29sbGlzaW9uLkNvbGxpZGVFZGdlQW5kUG9seWdvbihyZWYgbWFuaWZvbGQsIF9lZGdlLCByZWYgdHJhbnNmb3JtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoUG9seWdvblNoYXBlKUZpeHR1cmVCLlNoYXBlLCByZWYgdHJhbnNmb3JtQik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRhY3RUeXBlLkNpcmNsZTpcclxuICAgICAgICAgICAgICAgICAgICBDb2xsaXNpb24uQ29sbGlzaW9uLkNvbGxpZGVDaXJjbGVzKHJlZiBtYW5pZm9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChDaXJjbGVTaGFwZSlGaXh0dXJlQS5TaGFwZSwgcmVmIHRyYW5zZm9ybUEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ2lyY2xlU2hhcGUpRml4dHVyZUIuU2hhcGUsIHJlZiB0cmFuc2Zvcm1CKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgc3RhdGljIENvbnRhY3QgQ3JlYXRlKEZpeHR1cmUgZml4dHVyZUEsIGludCBpbmRleEEsIEZpeHR1cmUgZml4dHVyZUIsIGludCBpbmRleEIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgdHlwZTEgPSBmaXh0dXJlQS5TaGFwZVR5cGU7XHJcbiAgICAgICAgICAgIFNoYXBlVHlwZSB0eXBlMiA9IGZpeHR1cmVCLlNoYXBlVHlwZTtcclxuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChTaGFwZVR5cGUuVW5rbm93biA8IHR5cGUxICYmIHR5cGUxIDwgU2hhcGVUeXBlLlR5cGVDb3VudCk7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChTaGFwZVR5cGUuVW5rbm93biA8IHR5cGUyICYmIHR5cGUyIDwgU2hhcGVUeXBlLlR5cGVDb3VudCk7XHJcblxyXG4gICAgICAgICAgICBDb250YWN0IGM7XHJcbiAgICAgICAgICAgIFF1ZXVlPENvbnRhY3Q+IHBvb2wgPSBmaXh0dXJlQS5Cb2R5LldvcmxkLkNvbnRhY3RQb29sO1xyXG4gICAgICAgICAgICBpZiAocG9vbC5Db3VudCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGMgPSBwb29sLkRlcXVldWUoKTtcclxuICAgICAgICAgICAgICAgIGlmICgodHlwZTEgPj0gdHlwZTIgfHwgKHR5cGUxID09IFNoYXBlVHlwZS5FZGdlICYmIHR5cGUyID09IFNoYXBlVHlwZS5Qb2x5Z29uKSlcclxuICAgICAgICAgICAgICAgICAgICAmJlxyXG4gICAgICAgICAgICAgICAgICAgICEodHlwZTIgPT0gU2hhcGVUeXBlLkVkZ2UgJiYgdHlwZTEgPT0gU2hhcGVUeXBlLlBvbHlnb24pKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGMuUmVzZXQoZml4dHVyZUEsIGluZGV4QSwgZml4dHVyZUIsIGluZGV4Qik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5SZXNldChmaXh0dXJlQiwgaW5kZXhCLCBmaXh0dXJlQSwgaW5kZXhBKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEVkZ2UrUG9seWdvbiBpcyBub24tc3ltZXRyaWNhbCBkdWUgdG8gdGhlIHdheSBFcmluIGhhbmRsZXMgY29sbGlzaW9uIHR5cGUgcmVnaXN0cmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlMSA+PSB0eXBlMiB8fCAodHlwZTEgPT0gU2hhcGVUeXBlLkVkZ2UgJiYgdHlwZTIgPT0gU2hhcGVUeXBlLlBvbHlnb24pKVxyXG4gICAgICAgICAgICAgICAgICAgICYmXHJcbiAgICAgICAgICAgICAgICAgICAgISh0eXBlMiA9PSBTaGFwZVR5cGUuRWRnZSAmJiB0eXBlMSA9PSBTaGFwZVR5cGUuUG9seWdvbikpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBDb250YWN0KGZpeHR1cmVBLCBpbmRleEEsIGZpeHR1cmVCLCBpbmRleEIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBuZXcgQ29udGFjdChmaXh0dXJlQiwgaW5kZXhCLCBmaXh0dXJlQSwgaW5kZXhBKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYy5fdHlwZSA9IF9yZWdpc3RlcnNbKGludCl0eXBlMSwgKGludCl0eXBlMl07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgRGVzdHJveSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGaXh0dXJlQS5Cb2R5LldvcmxkLkNvbnRhY3RQb29sLkVucXVldWUodGhpcyk7XHJcbiAgICAgICAgICAgIFJlc2V0KG51bGwsIDAsIG51bGwsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBOZXN0ZWQgdHlwZTogQ29udGFjdFR5cGVcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBlbnVtIENvbnRhY3RUeXBlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBOb3RTdXBwb3J0ZWQsXHJcbiAgICAgICAgICAgIFBvbHlnb24sXHJcbiAgICAgICAgICAgIFBvbHlnb25BbmRDaXJjbGUsXHJcbiAgICAgICAgICAgIENpcmNsZSxcclxuICAgICAgICAgICAgRWRnZUFuZFBvbHlnb24sXHJcbiAgICAgICAgICAgIEVkZ2VBbmRDaXJjbGUsXHJcbiAgICAgICAgICAgIExvb3BBbmRQb2x5Z29uLFxyXG4gICAgICAgICAgICBMb29wQW5kQ2lyY2xlLFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Db250YWN0c1xyXG57XHJcbiAgICBwdWJsaWMgc2VhbGVkIGNsYXNzIENvbnRhY3RDb25zdHJhaW50UG9pbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbFBvaW50O1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBOb3JtYWxJbXB1bHNlO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBOb3JtYWxNYXNzO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBUYW5nZW50SW1wdWxzZTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgVGFuZ2VudE1hc3M7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFZlbG9jaXR5QmlhcztcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiByQTtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiByQjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VhbGVkIGNsYXNzIENvbnRhY3RDb25zdHJhaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIEJvZHkgQm9keUE7XHJcbiAgICAgICAgcHVibGljIEJvZHkgQm9keUI7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyaWN0aW9uO1xyXG4gICAgICAgIHB1YmxpYyBNYXQyMiBLO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsTm9ybWFsO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsUG9pbnQ7XHJcbiAgICAgICAgcHVibGljIE1hbmlmb2xkIE1hbmlmb2xkO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIE5vcm1hbDtcclxuICAgICAgICBwdWJsaWMgTWF0MjIgTm9ybWFsTWFzcztcclxuICAgICAgICBwdWJsaWMgaW50IFBvaW50Q291bnQ7XHJcbiAgICAgICAgcHVibGljIENvbnRhY3RDb25zdHJhaW50UG9pbnRbXSBQb2ludHMgPSBuZXcgQ29udGFjdENvbnN0cmFpbnRQb2ludFtTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXNdO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSYWRpdXNBO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSYWRpdXNCO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSZXN0aXR1dGlvbjtcclxuICAgICAgICBwdWJsaWMgTWFuaWZvbGRUeXBlIFR5cGU7XHJcblxyXG4gICAgICAgIHB1YmxpYyBDb250YWN0Q29uc3RyYWludCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFNldHRpbmdzLk1heE1hbmlmb2xkUG9pbnRzOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBvaW50c1tpXSA9IG5ldyBDb250YWN0Q29uc3RyYWludFBvaW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNsYXNzIENvbnRhY3RTb2x2ZXJcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgQ29udGFjdENvbnN0cmFpbnRbXSBDb25zdHJhaW50cztcclxuICAgICAgICBwcml2YXRlIGludCBfY29uc3RyYWludENvdW50OyAvLyBjb2xsZWN0aW9uIGNhbiBiZSBiaWdnZXIuXHJcbiAgICAgICAgcHJpdmF0ZSBDb250YWN0W10gX2NvbnRhY3RzO1xyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZXNldChDb250YWN0W10gY29udGFjdHMsIGludCBjb250YWN0Q291bnQsIGZsb2F0IGltcHVsc2VSYXRpbywgYm9vbCB3YXJtc3RhcnRpbmcpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfY29udGFjdHMgPSBjb250YWN0cztcclxuICAgICAgICAgICAgX2NvbnN0cmFpbnRDb3VudCA9IGNvbnRhY3RDb3VudDtcclxuXHJcbiAgICAgICAgICAgIC8vIGdyb3cgdGhlIGFycmF5XHJcbiAgICAgICAgICAgIGlmIChDb25zdHJhaW50cyA9PSBudWxsIHx8IENvbnN0cmFpbnRzLkxlbmd0aCA8IF9jb25zdHJhaW50Q291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbnN0cmFpbnRzID0gbmV3IENvbnRhY3RDb25zdHJhaW50W2NvbnRhY3RDb3VudCAqIDJdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb25zdHJhaW50cy5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29uc3RyYWludHNbaV0gPSBuZXcgQ29udGFjdENvbnN0cmFpbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBwb3NpdGlvbiBpbmRlcGVuZGVudCBwb3J0aW9ucyBvZiB0aGUgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX2NvbnN0cmFpbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0IGNvbnRhY3QgPSBfY29udGFjdHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQSA9IGNvbnRhY3QuRml4dHVyZUE7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmVCID0gY29udGFjdC5GaXh0dXJlQjtcclxuICAgICAgICAgICAgICAgIFNoYXBlIHNoYXBlQSA9IGZpeHR1cmVBLlNoYXBlO1xyXG4gICAgICAgICAgICAgICAgU2hhcGUgc2hhcGVCID0gZml4dHVyZUIuU2hhcGU7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByYWRpdXNBID0gc2hhcGVBLlJhZGl1cztcclxuICAgICAgICAgICAgICAgIGZsb2F0IHJhZGl1c0IgPSBzaGFwZUIuUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QSA9IGZpeHR1cmVBLkJvZHk7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHlCID0gZml4dHVyZUIuQm9keTtcclxuICAgICAgICAgICAgICAgIE1hbmlmb2xkIG1hbmlmb2xkID0gY29udGFjdC5NYW5pZm9sZDtcclxuXHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQobWFuaWZvbGQuUG9pbnRDb3VudCA+IDApO1xyXG5cclxuICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50IGNjID0gQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICBjYy5GcmljdGlvbiA9IFNldHRpbmdzLk1peEZyaWN0aW9uKGZpeHR1cmVBLkZyaWN0aW9uLCBmaXh0dXJlQi5GcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjYy5SZXN0aXR1dGlvbiA9IFNldHRpbmdzLk1peFJlc3RpdHV0aW9uKGZpeHR1cmVBLlJlc3RpdHV0aW9uLCBmaXh0dXJlQi5SZXN0aXR1dGlvbik7XHJcbiAgICAgICAgICAgICAgICBjYy5Cb2R5QSA9IGJvZHlBO1xyXG4gICAgICAgICAgICAgICAgY2MuQm9keUIgPSBib2R5QjtcclxuICAgICAgICAgICAgICAgIGNjLk1hbmlmb2xkID0gbWFuaWZvbGQ7XHJcbiAgICAgICAgICAgICAgICBjYy5Ob3JtYWwgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBjYy5Qb2ludENvdW50ID0gbWFuaWZvbGQuUG9pbnRDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICBjYy5Mb2NhbE5vcm1hbCA9IG1hbmlmb2xkLkxvY2FsTm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgY2MuTG9jYWxQb2ludCA9IG1hbmlmb2xkLkxvY2FsUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBjYy5SYWRpdXNBID0gcmFkaXVzQTtcclxuICAgICAgICAgICAgICAgIGNjLlJhZGl1c0IgPSByYWRpdXNCO1xyXG4gICAgICAgICAgICAgICAgY2MuVHlwZSA9IG1hbmlmb2xkLlR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjYy5Qb2ludENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBjcCA9IG1hbmlmb2xkLlBvaW50c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludFBvaW50IGNjcCA9IGNjLlBvaW50c1tqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhcm1zdGFydGluZylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjcC5Ob3JtYWxJbXB1bHNlID0gaW1wdWxzZVJhdGlvICogY3AuTm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2NwLlRhbmdlbnRJbXB1bHNlID0gaW1wdWxzZVJhdGlvICogY3AuVGFuZ2VudEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjcC5Ob3JtYWxJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2NwLlRhbmdlbnRJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5Mb2NhbFBvaW50ID0gY3AuTG9jYWxQb2ludDtcclxuICAgICAgICAgICAgICAgICAgICBjY3AuckEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgY2NwLnJCID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5Ob3JtYWxNYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBjY3AuVGFuZ2VudE1hc3MgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5WZWxvY2l0eUJpYXMgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNjLksuU2V0WmVybygpO1xyXG4gICAgICAgICAgICAgICAgY2MuTm9ybWFsTWFzcy5TZXRaZXJvKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEluaXRpYWxpemVWZWxvY2l0eUNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX2NvbnN0cmFpbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludCBjYyA9IENvbnN0cmFpbnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHJhZGl1c0EgPSBjYy5SYWRpdXNBO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgcmFkaXVzQiA9IGNjLlJhZGl1c0I7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHlBID0gY2MuQm9keUE7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHlCID0gY2MuQm9keUI7XHJcbiAgICAgICAgICAgICAgICBNYW5pZm9sZCBtYW5pZm9sZCA9IGNjLk1hbmlmb2xkO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdkEgPSBib2R5QS5MaW5lYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdkIgPSBib2R5Qi5MaW5lYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHdBID0gYm9keUEuQW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgd0IgPSBib2R5Qi5Bbmd1bGFyVmVsb2NpdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1hbmlmb2xkLlBvaW50Q291bnQgPiAwKTtcclxuICAgICAgICAgICAgICAgIEZpeGVkQXJyYXkyPFZlY3RvcjI+IHBvaW50cztcclxuXHJcbiAgICAgICAgICAgICAgICBDb2xsaXNpb24uQ29sbGlzaW9uLkdldFdvcmxkTWFuaWZvbGQocmVmIG1hbmlmb2xkLCByZWYgYm9keUEuWGYsIHJhZGl1c0EsIHJlZiBib2R5Qi5YZiwgcmFkaXVzQixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgY2MuTm9ybWFsLCBvdXQgcG9pbnRzKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdGFuZ2VudCA9IG5ldyBWZWN0b3IyKGNjLk5vcm1hbC5ZLCAtY2MuTm9ybWFsLlgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY2MuUG9pbnRDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50UG9pbnQgY2NwID0gY2MuUG9pbnRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjY3AuckEgPSBwb2ludHNbal0gLSBib2R5QS5Td2VlcC5DO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5yQiA9IHBvaW50c1tqXSAtIGJvZHlCLlN3ZWVwLkM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJuQSA9IGNjcC5yQS5YICogY2MuTm9ybWFsLlkgLSBjY3AuckEuWSAqIGNjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJuQiA9IGNjcC5yQi5YICogY2MuTm9ybWFsLlkgLSBjY3AuckIuWSAqIGNjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIHJuQSAqPSBybkE7XHJcbiAgICAgICAgICAgICAgICAgICAgcm5CICo9IHJuQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQga05vcm1hbCA9IGJvZHlBLkludk1hc3MgKyBib2R5Qi5JbnZNYXNzICsgYm9keUEuSW52SSAqIHJuQSArIGJvZHlCLkludkkgKiBybkI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChrTm9ybWFsID4gU2V0dGluZ3MuRXBzaWxvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2NwLk5vcm1hbE1hc3MgPSAxLjBmIC8ga05vcm1hbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcnRBID0gY2NwLnJBLlggKiB0YW5nZW50LlkgLSBjY3AuckEuWSAqIHRhbmdlbnQuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBydEIgPSBjY3AuckIuWCAqIHRhbmdlbnQuWSAtIGNjcC5yQi5ZICogdGFuZ2VudC5YO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBydEEgKj0gcnRBO1xyXG4gICAgICAgICAgICAgICAgICAgIHJ0QiAqPSBydEI7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQga1RhbmdlbnQgPSBib2R5QS5JbnZNYXNzICsgYm9keUIuSW52TWFzcyArIGJvZHlBLkludkkgKiBydEEgKyBib2R5Qi5JbnZJICogcnRCO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoa1RhbmdlbnQgPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgICAgICAgICBjY3AuVGFuZ2VudE1hc3MgPSAxLjBmIC8ga1RhbmdlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldHVwIGEgdmVsb2NpdHkgYmlhcyBmb3IgcmVzdGl0dXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgY2NwLlZlbG9jaXR5QmlhcyA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdlJlbCA9IGNjLk5vcm1hbC5YICogKHZCLlggKyAtd0IgKiBjY3AuckIuWSAtIHZBLlggLSAtd0EgKiBjY3AuckEuWSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5Ob3JtYWwuWSAqICh2Qi5ZICsgd0IgKiBjY3AuckIuWCAtIHZBLlkgLSB3QSAqIGNjcC5yQS5YKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodlJlbCA8IC1TZXR0aW5ncy5WZWxvY2l0eVRocmVzaG9sZClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjcC5WZWxvY2l0eUJpYXMgPSAtY2MuUmVzdGl0dXRpb24gKiB2UmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHR3byBwb2ludHMsIHRoZW4gcHJlcGFyZSB0aGUgYmxvY2sgc29sdmVyLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNjLlBvaW50Q291bnQgPT0gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludFBvaW50IGNjcDEgPSBjYy5Qb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjY3AyID0gY2MuUG9pbnRzWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBpbnZNYXNzQSA9IGJvZHlBLkludk1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgaW52SUEgPSBib2R5QS5JbnZJO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGludk1hc3NCID0gYm9keUIuSW52TWFzcztcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBpbnZJQiA9IGJvZHlCLkludkk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJuMUEgPSBjY3AxLnJBLlggKiBjYy5Ob3JtYWwuWSAtIGNjcDEuckEuWSAqIGNjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJuMUIgPSBjY3AxLnJCLlggKiBjYy5Ob3JtYWwuWSAtIGNjcDEuckIuWSAqIGNjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJuMkEgPSBjY3AyLnJBLlggKiBjYy5Ob3JtYWwuWSAtIGNjcDIuckEuWSAqIGNjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJuMkIgPSBjY3AyLnJCLlggKiBjYy5Ob3JtYWwuWSAtIGNjcDIuckIuWSAqIGNjLk5vcm1hbC5YO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBrMTEgPSBpbnZNYXNzQSArIGludk1hc3NCICsgaW52SUEgKiBybjFBICogcm4xQSArIGludklCICogcm4xQiAqIHJuMUI7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgazIyID0gaW52TWFzc0EgKyBpbnZNYXNzQiArIGludklBICogcm4yQSAqIHJuMkEgKyBpbnZJQiAqIHJuMkIgKiBybjJCO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGsxMiA9IGludk1hc3NBICsgaW52TWFzc0IgKyBpbnZJQSAqIHJuMUEgKiBybjJBICsgaW52SUIgKiBybjFCICogcm4yQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGEgcmVhc29uYWJsZSBjb25kaXRpb24gbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IGtfbWF4Q29uZGl0aW9uTnVtYmVyID0gMTAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrMTEgKiBrMTEgPCBrX21heENvbmRpdGlvbk51bWJlciAqIChrMTEgKiBrMjIgLSBrMTIgKiBrMTIpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSyBpcyBzYWZlIHRvIGludmVydC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuSy5Db2wxLlggPSBrMTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLksuQ29sMS5ZID0gazEyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5LLkNvbDIuWCA9IGsxMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuSy5Db2wyLlkgPSBrMjI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBhID0gY2MuSy5Db2wxLlgsIGIgPSBjYy5LLkNvbDIuWCwgYyA9IGNjLksuQ29sMS5ZLCBkID0gY2MuSy5Db2wyLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGRldCA9IGEgKiBkIC0gYiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXQgIT0gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ID0gMS4wZiAvIGRldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTm9ybWFsTWFzcy5Db2wxLlggPSBkZXQgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5Ob3JtYWxNYXNzLkNvbDEuWSA9IC1kZXQgKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5Ob3JtYWxNYXNzLkNvbDIuWCA9IC1kZXQgKiBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5Ob3JtYWxNYXNzLkNvbDIuWSA9IGRldCAqIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb25zdHJhaW50cyBhcmUgcmVkdW5kYW50LCBqdXN0IHVzZSBvbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE9fRVJJTiB1c2UgZGVlcGVzdD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuUG9pbnRDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBXYXJtU3RhcnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gV2FybSBzdGFydC5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfY29uc3RyYWludENvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50IGMgPSBDb25zdHJhaW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0YW5nZW50eCA9IGMuTm9ybWFsLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0YW5nZW50eSA9IC1jLk5vcm1hbC5YO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgYy5Qb2ludENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjY3AgPSBjLlBvaW50c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBweCA9IGNjcC5Ob3JtYWxJbXB1bHNlICogYy5Ob3JtYWwuWCArIGNjcC5UYW5nZW50SW1wdWxzZSAqIHRhbmdlbnR4O1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHB5ID0gY2NwLk5vcm1hbEltcHVsc2UgKiBjLk5vcm1hbC5ZICsgY2NwLlRhbmdlbnRJbXB1bHNlICogdGFuZ2VudHk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtPSBjLkJvZHlBLkludkkgKiAoY2NwLnJBLlggKiBweSAtIGNjcC5yQS5ZICogcHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YIC09IGMuQm9keUEuSW52TWFzcyAqIHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC09IGMuQm9keUEuSW52TWFzcyAqIHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYy5Cb2R5Qi5JbnZJICogKGNjcC5yQi5YICogcHkgLSBjY3AuckIuWSAqIHB4KTtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArPSBjLkJvZHlCLkludk1hc3MgKiBweDtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArPSBjLkJvZHlCLkludk1hc3MgKiBweTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX2NvbnN0cmFpbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludCBjID0gQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYy5Cb2R5QS5QZW5ldHJhYmxlIHx8IGMuQm9keUIuUGVuZXRyYWJsZSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHdBID0gYy5Cb2R5QS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHdCID0gYy5Cb2R5Qi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0YW5nZW50eCA9IGMuTm9ybWFsLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0YW5nZW50eSA9IC1jLk5vcm1hbC5YO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGZyaWN0aW9uID0gYy5GcmljdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoYy5Qb2ludENvdW50ID09IDEgfHwgYy5Qb2ludENvdW50ID09IDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIHRhbmdlbnQgY29uc3RyYWludHNcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgYy5Qb2ludENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjY3AgPSBjLlBvaW50c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBsYW1iZGEgPSBjY3AuVGFuZ2VudE1hc3MgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0oKGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICsgKC13QiAqIGNjcC5yQi5ZKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggLSAoLXdBICogY2NwLnJBLlkpKSAqIHRhbmdlbnR4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArICh3QiAqIGNjcC5yQi5YKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgLSAod0EgKiBjY3AuckEuWCkpICogdGFuZ2VudHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRoVXRpbHMuQ2xhbXAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWF4RnJpY3Rpb24gPSBmcmljdGlvbiAqIGNjcC5Ob3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ld0ltcHVsc2UgPSBNYXRoLk1heCgtbWF4RnJpY3Rpb24sIE1hdGguTWluKGNjcC5UYW5nZW50SW1wdWxzZSArIGxhbWJkYSwgbWF4RnJpY3Rpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICBsYW1iZGEgPSBuZXdJbXB1bHNlIC0gY2NwLlRhbmdlbnRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjb250YWN0IGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBweCA9IGxhbWJkYSAqIHRhbmdlbnR4O1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHB5ID0gbGFtYmRhICogdGFuZ2VudHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YIC09IGMuQm9keUEuSW52TWFzcyAqIHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC09IGMuQm9keUEuSW52TWFzcyAqIHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHdBIC09IGMuQm9keUEuSW52SSAqIChjY3AuckEuWCAqIHB5IC0gY2NwLnJBLlkgKiBweCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICs9IGMuQm9keUIuSW52TWFzcyAqIHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICs9IGMuQm9keUIuSW52TWFzcyAqIHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHdCICs9IGMuQm9keUIuSW52SSAqIChjY3AuckIuWCAqIHB5IC0gY2NwLnJCLlkgKiBweCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5UYW5nZW50SW1wdWxzZSA9IG5ld0ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU29sdmUgbm9ybWFsIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoYy5Qb2ludENvdW50ID09IDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjY3AgPSBjLlBvaW50c1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVsYXRpdmUgdmVsb2NpdHkgYXQgY29udGFjdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBsYW1iZGEgPSAtY2NwLk5vcm1hbE1hc3MgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggKyAoLXdCICogY2NwLnJCLlkpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YIC0gKC13QSAqIGNjcC5yQS5ZKSkgKiBjLk5vcm1hbC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICsgKHdCICogY2NwLnJCLlgpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3QSAqIGNjcC5yQS5YKSkgKiBjLk5vcm1hbC5ZIC0gY2NwLlZlbG9jaXR5Qmlhcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENsYW1wIHRoZSBhY2N1bXVsYXRlZCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3SW1wdWxzZSA9IE1hdGguTWF4KGNjcC5Ob3JtYWxJbXB1bHNlICsgbGFtYmRhLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgICAgICBsYW1iZGEgPSBuZXdJbXB1bHNlIC0gY2NwLk5vcm1hbEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNvbnRhY3QgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHB4ID0gbGFtYmRhICogYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBweSA9IGxhbWJkYSAqIGMuTm9ybWFsLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YIC09IGMuQm9keUEuSW52TWFzcyAqIHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC09IGMuQm9keUEuSW52TWFzcyAqIHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHdBIC09IGMuQm9keUEuSW52SSAqIChjY3AuckEuWCAqIHB5IC0gY2NwLnJBLlkgKiBweCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICs9IGMuQm9keUIuSW52TWFzcyAqIHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICs9IGMuQm9keUIuSW52TWFzcyAqIHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHdCICs9IGMuQm9keUIuSW52SSAqIChjY3AuckIuWCAqIHB5IC0gY2NwLnJCLlkgKiBweCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5Ob3JtYWxJbXB1bHNlID0gbmV3SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCbG9jayBzb2x2ZXIgZGV2ZWxvcGVkIGluIGNvbGxhYm9yYXRpb24gd2l0aCBEaXJrIEdyZWdvcml1cyAoYmFjayBpbiAwMS8wNyBvbiBCb3gyRF9MaXRlKS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgbWluaSBMQ1AgZm9yIHRoaXMgY29udGFjdCBwYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm4gPSBBICogeCArIGIsIHZuID49IDAsICwgdm4gPj0gMCwgeCA+PSAwIGFuZCB2bl9pICogeF9pID0gMCB3aXRoIGkgPSAxLi4yXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBBID0gSiAqIFcgKiBKVCBhbmQgSiA9ICggLW4sIC1yMSB4IG4sIG4sIHIyIHggbiApXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYiA9IHZuXzAgLSB2ZWxvY2l0eUJpYXNcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzeXN0ZW0gaXMgc29sdmVkIHVzaW5nIHRoZSBcIlRvdGFsIGVudW1lcmF0aW9uIG1ldGhvZFwiIChzLiBNdXJ0eSkuIFRoZSBjb21wbGVtZW50YXJ5IGNvbnN0cmFpbnQgdm5faSAqIHhfaVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGltcGxpZXMgdGhhdCB3ZSBtdXN0IGhhdmUgaW4gYW55IHNvbHV0aW9uIGVpdGhlciB2bl9pID0gMCBvciB4X2kgPSAwLiBTbyBmb3IgdGhlIDJEIGNvbnRhY3QgcHJvYmxlbSB0aGUgY2FzZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bjEgPSAwIGFuZCB2bjIgPSAwLCB4MSA9IDAgYW5kIHgyID0gMCwgeDEgPSAwIGFuZCB2bjIgPSAwLCB4MiA9IDAgYW5kIHZuMSA9IDAgbmVlZCB0byBiZSB0ZXN0ZWQuIFRoZSBmaXJzdCB2YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbHV0aW9uIHRoYXQgc2F0aXNmaWVzIHRoZSBwcm9ibGVtIGlzIGNob3Nlbi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byBhY2NvdW50IG9mIHRoZSBhY2N1bXVsYXRlZCBpbXB1bHNlICdhJyAoYmVjYXVzZSBvZiB0aGUgaXRlcmF0aXZlIG5hdHVyZSBvZiB0aGUgc29sdmVyIHdoaWNoIG9ubHkgcmVxdWlyZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZSBhY2N1bXVsYXRlZCBpbXB1bHNlIGlzIGNsYW1wZWQgYW5kIG5vdCB0aGUgaW5jcmVtZW50YWwgaW1wdWxzZSkgd2UgY2hhbmdlIHRoZSBpbXB1bHNlIHZhcmlhYmxlICh4X2kpLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Vic3RpdHV0ZTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBcclxuICAgICAgICAgICAgICAgICAgICAvLyB4ID0geCcgLSBhXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGx1ZyBpbnRvIGFib3ZlIGVxdWF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm4gPSBBICogeCArIGJcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICA9IEEgKiAoeCcgLSBhKSArIGJcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICA9IEEgKiB4JyArIGIgLSBBICogYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgID0gQSAqIHgnICsgYidcclxuICAgICAgICAgICAgICAgICAgICAvLyBiJyA9IGIgLSBBICogYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjcDEgPSBjLlBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludFBvaW50IGNwMiA9IGMuUG9pbnRzWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBheCA9IGNwMS5Ob3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGF5ID0gY3AyLk5vcm1hbEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGF4ID49IDAuMGYgJiYgYXkgPj0gMC4wZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbGF0aXZlIHZlbG9jaXR5IGF0IGNvbnRhY3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5vcm1hbCB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHZuMSA9IChjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArICgtd0IgKiBjcDEuckIuWSkgLSBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgtd0EgKiBjcDEuckEuWSkpICogYy5Ob3JtYWwuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICsgKHdCICogY3AxLnJCLlgpIC0gYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod0EgKiBjcDEuckEuWCkpICogYy5Ob3JtYWwuWTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB2bjIgPSAoYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggKyAoLXdCICogY3AyLnJCLlkpIC0gYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoLXdBICogY3AyLnJBLlkpKSAqIGMuTm9ybWFsLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArICh3QiAqIGNwMi5yQi5YKSAtIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdBICogY3AyLnJBLlgpKSAqIGMuTm9ybWFsLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGJ4ID0gdm4xIC0gY3AxLlZlbG9jaXR5QmlhcyAtIChjLksuQ29sMS5YICogYXggKyBjLksuQ29sMi5YICogYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGJ5ID0gdm4yIC0gY3AyLlZlbG9jaXR5QmlhcyAtIChjLksuQ29sMS5ZICogYXggKyBjLksuQ29sMi5ZICogYXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB4eCA9IC0oYy5Ob3JtYWxNYXNzLkNvbDEuWCAqIGJ4ICsgYy5Ob3JtYWxNYXNzLkNvbDIuWCAqIGJ5KTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB4eSA9IC0oYy5Ob3JtYWxNYXNzLkNvbDEuWSAqIGJ4ICsgYy5Ob3JtYWxNYXNzLkNvbDIuWSAqIGJ5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXNlIDE6IHZuID0gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAwID0gQSAqIHgnICsgYidcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29sdmUgZm9yIHgnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4JyA9IC0gaW52KEEpICogYidcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHh4ID49IDAuMGYgJiYgeHkgPj0gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdWJzdGl0dXRlIGZvciB0aGUgaW5jcmVtZW50YWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZHggPSB4eCAtIGF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZHkgPSB4eSAtIGF5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGluY3JlbWVudGFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxeCA9IGR4ICogYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxeSA9IGR4ICogYy5Ob3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMnggPSBkeSAqIGMuTm9ybWFsLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMnkgPSBkeSAqIGMuTm9ybWFsLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDEyeCA9IHAxeCArIHAyeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxMnkgPSBwMXkgKyBwMnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggLT0gYy5Cb2R5QS5JbnZNYXNzICogcDEyeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC09IGMuQm9keUEuSW52TWFzcyAqIHAxMnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3QSAtPSBjLkJvZHlBLkludkkgKiAoKGNwMS5yQS5YICogcDF5IC0gY3AxLnJBLlkgKiBwMXgpICsgKGNwMi5yQS5YICogcDJ5IC0gY3AyLnJBLlkgKiBwMngpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArPSBjLkJvZHlCLkludk1hc3MgKiBwMTJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgKz0gYy5Cb2R5Qi5JbnZNYXNzICogcDEyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdCICs9IGMuQm9keUIuSW52SSAqICgoY3AxLnJCLlggKiBwMXkgLSBjcDEuckIuWSAqIHAxeCkgKyAoY3AyLnJCLlggKiBwMnkgLSBjcDIuckIuWSAqIHAyeCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMS5Ob3JtYWxJbXB1bHNlID0geHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDIuTm9ybWFsSW1wdWxzZSA9IHh5O1xyXG5cclxuI2lmIEIyX0RFQlVHX1NPTFZFUiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgZmxvYXQga19lcnJvclRvbCA9IDFlLTNmO1xyXG5cclxuXHRcdFx0XHRcdCAgICAgICAgLy8gUG9zdGNvbmRpdGlvbnNcclxuXHRcdFx0XHRcdCAgICAgICAgZHYxID0gdkIgKyBNYXRoVXRpbHMuQ3Jvc3Mod0IsIGNwMS5yQikgLSB2QSAtIE1hdGhVdGlscy5Dcm9zcyh3QSwgY3AxLnJBKTtcclxuXHRcdFx0XHRcdCAgICAgICAgZHYyID0gdkIgKyBNYXRoVXRpbHMuQ3Jvc3Mod0IsIGNwMi5yQikgLSB2QSAtIE1hdGhVdGlscy5Dcm9zcyh3QSwgY3AyLnJBKTtcclxuXHJcblx0XHRcdFx0XHQgICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIHZlbG9jaXR5XHJcblx0XHRcdFx0XHQgICAgICAgIHZuMSA9IFZlY3RvcjIuRG90KGR2MSwgbm9ybWFsKTtcclxuXHRcdFx0XHRcdCAgICAgICAgdm4yID0gVmVjdG9yMi5Eb3QoZHYyLCBub3JtYWwpO1xyXG5cclxuXHRcdFx0XHRcdCAgICAgICAgRGVidWcuQXNzZXJ0KE1hdGhVdGlscy5BYnModm4xIC0gY3AxLnZlbG9jaXR5QmlhcykgPCBrX2Vycm9yVG9sKTtcclxuXHRcdFx0XHRcdCAgICAgICAgRGVidWcuQXNzZXJ0KE1hdGhVdGlscy5BYnModm4yIC0gY3AyLnZlbG9jaXR5QmlhcykgPCBrX2Vycm9yVG9sKTtcclxuI2VuZGlmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAyOiB2bjEgPSAwIGFuZCB4MiA9IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAwID0gYTExICogeDEnICsgYTEyICogMCArIGIxJyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdm4yID0gYTIxICogeDEnICsgYTIyICogMCArIGIyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4eCA9IC1jcDEuTm9ybWFsTWFzcyAqIGJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4eSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZuMSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZuMiA9IGMuSy5Db2wxLlkgKiB4eCArIGJ5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHh4ID49IDAuMGYgJiYgdm4yID49IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3Vic3RpdHV0ZSBmb3IgdGhlIGluY3JlbWVudGFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGR4ID0geHggLSBheDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGR5ID0geHkgLSBheTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBpbmNyZW1lbnRhbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMXggPSBkeCAqIGMuTm9ybWFsLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMXkgPSBkeCAqIGMuTm9ybWFsLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDJ4ID0gZHkgKiBjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDJ5ID0gZHkgKiBjLk5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxMnggPSBwMXggKyBwMng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMTJ5ID0gcDF5ICsgcDJ5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YIC09IGMuQm9keUEuSW52TWFzcyAqIHAxMng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSAtPSBjLkJvZHlBLkludk1hc3MgKiBwMTJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd0EgLT0gYy5Cb2R5QS5JbnZJICogKChjcDEuckEuWCAqIHAxeSAtIGNwMS5yQS5ZICogcDF4KSArIChjcDIuckEuWCAqIHAyeSAtIGNwMi5yQS5ZICogcDJ4KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggKz0gYy5Cb2R5Qi5JbnZNYXNzICogcDEyeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICs9IGMuQm9keUIuSW52TWFzcyAqIHAxMnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3QiArPSBjLkJvZHlCLkludkkgKiAoKGNwMS5yQi5YICogcDF5IC0gY3AxLnJCLlkgKiBwMXgpICsgKGNwMi5yQi5YICogcDJ5IC0gY3AyLnJCLlkgKiBwMngpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDEuTm9ybWFsSW1wdWxzZSA9IHh4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AyLk5vcm1hbEltcHVsc2UgPSB4eTtcclxuXHJcbiNpZiBCMl9ERUJVR19TT0xWRVIgXHJcbiAgICAvLyBQb3N0Y29uZGl0aW9uc1xyXG5cdFx0XHRcdFx0ICAgICAgICBkdjEgPSB2QiArIE1hdGhVdGlscy5Dcm9zcyh3QiwgY3AxLnJCKSAtIHZBIC0gTWF0aFV0aWxzLkNyb3NzKHdBLCBjcDEuckEpO1xyXG5cclxuXHRcdFx0XHRcdCAgICAgICAgLy8gQ29tcHV0ZSBub3JtYWwgdmVsb2NpdHlcclxuXHRcdFx0XHRcdCAgICAgICAgdm4xID0gVmVjdG9yMi5Eb3QoZHYxLCBub3JtYWwpO1xyXG5cclxuXHRcdFx0XHRcdCAgICAgICAgRGVidWcuQXNzZXJ0KE1hdGhVdGlscy5BYnModm4xIC0gY3AxLnZlbG9jaXR5QmlhcykgPCBrX2Vycm9yVG9sKTtcclxuI2VuZGlmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMzogdm4yID0gMCBhbmQgeDEgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZuMSA9IGExMSAqIDAgKyBhMTIgKiB4MicgKyBiMScgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgMCA9IGEyMSAqIDAgKyBhMjIgKiB4MicgKyBiMidcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgeHggPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4eSA9IC1jcDIuTm9ybWFsTWFzcyAqIGJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bjEgPSBjLksuQ29sMi5YICogeHkgKyBieDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm4yID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4eSA+PSAwLjBmICYmIHZuMSA+PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN1YnN0aXR1dGUgZm9yIHRoZSBpbmNyZW1lbnRhbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkeCA9IHh4IC0gYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkeSA9IHh5IC0gYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDF4ID0gZHggKiBjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDF5ID0gZHggKiBjLk5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAyeCA9IGR5ICogYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAyeSA9IGR5ICogYy5Ob3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMTJ4ID0gcDF4ICsgcDJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDEyeSA9IHAxeSArIHAyeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAtPSBjLkJvZHlBLkludk1hc3MgKiBwMTJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgLT0gYy5Cb2R5QS5JbnZNYXNzICogcDEyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdBIC09IGMuQm9keUEuSW52SSAqICgoY3AxLnJBLlggKiBwMXkgLSBjcDEuckEuWSAqIHAxeCkgKyAoY3AyLnJBLlggKiBwMnkgLSBjcDIuckEuWSAqIHAyeCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICs9IGMuQm9keUIuSW52TWFzcyAqIHAxMng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArPSBjLkJvZHlCLkludk1hc3MgKiBwMTJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd0IgKz0gYy5Cb2R5Qi5JbnZJICogKChjcDEuckIuWCAqIHAxeSAtIGNwMS5yQi5ZICogcDF4KSArIChjcDIuckIuWCAqIHAyeSAtIGNwMi5yQi5ZICogcDJ4KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AxLk5vcm1hbEltcHVsc2UgPSB4eDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMi5Ob3JtYWxJbXB1bHNlID0geHk7XHJcblxyXG4jaWYgQjJfREVCVUdfU09MVkVSIFxyXG4gICAgLy8gUG9zdGNvbmRpdGlvbnNcclxuXHRcdFx0XHRcdCAgICAgICAgZHYyID0gdkIgKyBNYXRoVXRpbHMuQ3Jvc3Mod0IsIGNwMi5yQikgLSB2QSAtIE1hdGhVdGlscy5Dcm9zcyh3QSwgY3AyLnJBKTtcclxuXHJcblx0XHRcdFx0XHQgICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIHZlbG9jaXR5XHJcblx0XHRcdFx0XHQgICAgICAgIHZuMiA9IFZlY3RvcjIuRG90KGR2Miwgbm9ybWFsKTtcclxuXHJcblx0XHRcdFx0XHQgICAgICAgIERlYnVnLkFzc2VydChNYXRoVXRpbHMuQWJzKHZuMiAtIGNwMi52ZWxvY2l0eUJpYXMpIDwga19lcnJvclRvbCk7XHJcbiNlbmRpZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgNDogeDEgPSAwIGFuZCB4MiA9IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZuMSA9IGIxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZuMiA9IGIyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4eCA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5ID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm4xID0gYng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZuMiA9IGJ5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZuMSA+PSAwLjBmICYmIHZuMiA+PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN1YnN0aXR1dGUgZm9yIHRoZSBpbmNyZW1lbnRhbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkeCA9IHh4IC0gYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkeSA9IHh5IC0gYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDF4ID0gZHggKiBjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDF5ID0gZHggKiBjLk5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAyeCA9IGR5ICogYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAyeSA9IGR5ICogYy5Ob3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMTJ4ID0gcDF4ICsgcDJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDEyeSA9IHAxeSArIHAyeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAtPSBjLkJvZHlBLkludk1hc3MgKiBwMTJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgLT0gYy5Cb2R5QS5JbnZNYXNzICogcDEyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdBIC09IGMuQm9keUEuSW52SSAqICgoY3AxLnJBLlggKiBwMXkgLSBjcDEuckEuWSAqIHAxeCkgKyAoY3AyLnJBLlggKiBwMnkgLSBjcDIuckEuWSAqIHAyeCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICs9IGMuQm9keUIuSW52TWFzcyAqIHAxMng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArPSBjLkJvZHlCLkludk1hc3MgKiBwMTJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd0IgKz0gYy5Cb2R5Qi5JbnZJICogKChjcDEuckIuWCAqIHAxeSAtIGNwMS5yQi5ZICogcDF4KSArIChjcDIuckIuWCAqIHAyeSAtIGNwMi5yQi5ZICogcDJ4KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AxLk5vcm1hbEltcHVsc2UgPSB4eDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMi5Ob3JtYWxJbXB1bHNlID0geHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHNvbHV0aW9uLCBnaXZlIHVwLiBUaGlzIGlzIGhpdCBzb21ldGltZXMsIGJ1dCBpdCBkb2Vzbid0IHNlZW0gdG8gbWF0dGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYy5Cb2R5QS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdBO1xyXG4gICAgICAgICAgICAgICAgYy5Cb2R5Qi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdCO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTdG9yZUltcHVsc2VzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX2NvbnN0cmFpbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludCBjID0gQ29uc3RyYWludHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYy5Cb2R5QS5QZW5ldHJhYmxlIHx8IGMuQm9keUIuUGVuZXRyYWJsZSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBNYW5pZm9sZCBtID0gYy5NYW5pZm9sZDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGMuUG9pbnRDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgcGogPSBtLlBvaW50c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludFBvaW50IGNwID0gYy5Qb2ludHNbal07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBqLk5vcm1hbEltcHVsc2UgPSBjcC5Ob3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBqLlRhbmdlbnRJbXB1bHNlID0gY3AuVGFuZ2VudEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG0uUG9pbnRzW2pdID0gcGo7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYy5NYW5pZm9sZCA9IG07XHJcbiAgICAgICAgICAgICAgICBfY29udGFjdHNbaV0uTWFuaWZvbGQgPSBtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoZmxvYXQgYmF1bWdhcnRlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgbWluU2VwYXJhdGlvbiA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9jb25zdHJhaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnQgYyA9IENvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMuQm9keUEuUGVuZXRyYWJsZSB8fCBjLkJvZHlCLlBlbmV0cmFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QSA9IGMuQm9keUE7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHlCID0gYy5Cb2R5QjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZNYXNzQSA9IGJvZHlBLk1hc3MgKiBib2R5QS5JbnZNYXNzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52SUEgPSBib2R5QS5NYXNzICogYm9keUEuSW52STtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGludk1hc3NCID0gYm9keUIuTWFzcyAqIGJvZHlCLkludk1hc3M7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZJQiA9IGJvZHlCLk1hc3MgKiBib2R5Qi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIG5vcm1hbCBjb25zdHJhaW50c1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjLlBvaW50Q291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIG5vcm1hbDtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHNlcGFyYXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFNvbHZlKGMsIGosIG91dCBub3JtYWwsIG91dCBwb2ludCwgb3V0IHNlcGFyYXRpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCByYXggPSBwb2ludC5YIC0gYm9keUEuU3dlZXAuQy5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJheSA9IHBvaW50LlkgLSBib2R5QS5Td2VlcC5DLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJieCA9IHBvaW50LlggLSBib2R5Qi5Td2VlcC5DLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcmJ5ID0gcG9pbnQuWSAtIGJvZHlCLlN3ZWVwLkMuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgbWF4IGNvbnN0cmFpbnQgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgbWluU2VwYXJhdGlvbiA9IE1hdGguTWluKG1pblNlcGFyYXRpb24sIHNlcGFyYXRpb24pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzbG9wLlxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBNYXRoLk1heCgtU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5NaW4oYmF1bWdhcnRlICogKHNlcGFyYXRpb24gKyBTZXR0aW5ncy5MaW5lYXJTbG9wKSwgMC4wZikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcy5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBybkEgPSByYXggKiBub3JtYWwuWSAtIHJheSAqIG5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJuQiA9IHJieCAqIG5vcm1hbC5ZIC0gcmJ5ICogbm9ybWFsLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgSyA9IGludk1hc3NBICsgaW52TWFzc0IgKyBpbnZJQSAqIHJuQSAqIHJuQSArIGludklCICogcm5CICogcm5CO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5vcm1hbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IEsgPiAwLjBmID8gLUMgLyBLIDogMC4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcHggPSBpbXB1bHNlICogbm9ybWFsLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcHkgPSBpbXB1bHNlICogbm9ybWFsLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLlN3ZWVwLkMuWCAtPSBpbnZNYXNzQSAqIHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLlN3ZWVwLkMuWSAtPSBpbnZNYXNzQSAqIHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLlN3ZWVwLkEgLT0gaW52SUEgKiAocmF4ICogcHkgLSByYXkgKiBweCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLlN3ZWVwLkMuWCArPSBpbnZNYXNzQiAqIHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLlN3ZWVwLkMuWSArPSBpbnZNYXNzQiAqIHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLlN3ZWVwLkEgKz0gaW52SUIgKiAocmJ4ICogcHkgLSByYnkgKiBweCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZXhwZWN0IG1pblNwZXBhcmF0aW9uID49IC1TZXR0aW5ncy5iMl9saW5lYXJTbG9wIGJlY2F1c2Ugd2UgZG9uJ3RcclxuICAgICAgICAgICAgLy8gcHVzaCB0aGUgc2VwYXJhdGlvbiBhYm92ZSAtU2V0dGluZ3MuYjJfbGluZWFyU2xvcC5cclxuICAgICAgICAgICAgcmV0dXJuIG1pblNlcGFyYXRpb24gPj0gLTEuNWYgKiBTZXR0aW5ncy5MaW5lYXJTbG9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBTb2x2ZShDb250YWN0Q29uc3RyYWludCBjYywgaW50IGluZGV4LCBvdXQgVmVjdG9yMiBub3JtYWwsIG91dCBWZWN0b3IyIHBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IGZsb2F0IHNlcGFyYXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoY2MuUG9pbnRDb3VudCA+IDApO1xyXG5cclxuICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yMi5aZXJvO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChjYy5UeXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hbmlmb2xkVHlwZS5DaXJjbGVzOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEEgPSBjYy5Cb2R5QS5HZXRXb3JsZFBvaW50KHJlZiBjYy5Mb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEIgPSBjYy5Cb2R5Qi5HZXRXb3JsZFBvaW50KHJlZiBjYy5Qb2ludHNbMF0uTG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGEgPSAocG9pbnRBLlggLSBwb2ludEIuWCkgKiAocG9pbnRBLlggLSBwb2ludEIuWCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvaW50QS5ZIC0gcG9pbnRCLlkpICogKHBvaW50QS5ZIC0gcG9pbnRCLlkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA+IFNldHRpbmdzLkVwc2lsb24gKiBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIG5vcm1hbFRtcCA9IHBvaW50QiAtIHBvaW50QTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGZhY3RvciA9IDFmIC8gKGZsb2F0KU1hdGguU3FydChub3JtYWxUbXAuWCAqIG5vcm1hbFRtcC5YICsgbm9ybWFsVG1wLlkgKiBub3JtYWxUbXAuWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWCA9IG5vcm1hbFRtcC5YICogZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlkgPSBub3JtYWxUbXAuWSAqIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5YID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ZID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSAwLjVmICogKHBvaW50QSArIHBvaW50Qik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSAocG9pbnRCLlggLSBwb2ludEEuWCkgKiBub3JtYWwuWCArIChwb2ludEIuWSAtIHBvaW50QS5ZKSAqIG5vcm1hbC5ZIC0gY2MuUmFkaXVzQSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5SYWRpdXNCO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hbmlmb2xkVHlwZS5GYWNlQTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCA9IGNjLkJvZHlBLkdldFdvcmxkVmVjdG9yKHJlZiBjYy5Mb2NhbE5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcGxhbmVQb2ludCA9IGNjLkJvZHlBLkdldFdvcmxkUG9pbnQocmVmIGNjLkxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGNsaXBQb2ludCA9IGNjLkJvZHlCLkdldFdvcmxkUG9pbnQocmVmIGNjLlBvaW50c1tpbmRleF0uTG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb24gPSAoY2xpcFBvaW50LlggLSBwbGFuZVBvaW50LlgpICogbm9ybWFsLlggKyAoY2xpcFBvaW50LlkgLSBwbGFuZVBvaW50LlkpICogbm9ybWFsLlkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MuUmFkaXVzQSAtIGNjLlJhZGl1c0I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gY2xpcFBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hbmlmb2xkVHlwZS5GYWNlQjpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCA9IGNjLkJvZHlCLkdldFdvcmxkVmVjdG9yKHJlZiBjYy5Mb2NhbE5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcGxhbmVQb2ludCA9IGNjLkJvZHlCLkdldFdvcmxkUG9pbnQocmVmIGNjLkxvY2FsUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBjbGlwUG9pbnQgPSBjYy5Cb2R5QS5HZXRXb3JsZFBvaW50KHJlZiBjYy5Qb2ludHNbaW5kZXhdLkxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uID0gKGNsaXBQb2ludC5YIC0gcGxhbmVQb2ludC5YKSAqIG5vcm1hbC5YICsgKGNsaXBQb2ludC5ZIC0gcGxhbmVQb2ludC5ZKSAqIG5vcm1hbC5ZIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLlJhZGl1c0EgLSBjYy5SYWRpdXNCO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGNsaXBQb2ludDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBub3JtYWwgcG9pbnRzIGZyb20gQSB0byBCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCA9IC1ub3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuQ29udGFjdHM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50cztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3Ncclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgaXMgYW4gaW50ZXJuYWwgY2xhc3MuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIElzbGFuZFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBCb2R5W10gQm9kaWVzO1xyXG4gICAgICAgIHB1YmxpYyBpbnQgQm9keUNvdW50O1xyXG4gICAgICAgIHB1YmxpYyBpbnQgQ29udGFjdENvdW50O1xyXG4gICAgICAgIHB1YmxpYyBpbnQgSm9pbnRDb3VudDtcclxuICAgICAgICBwcml2YXRlIGludCBfYm9keUNhcGFjaXR5O1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9jb250YWN0Q2FwYWNpdHk7XHJcbiAgICAgICAgcHJpdmF0ZSBDb250YWN0TWFuYWdlciBfY29udGFjdE1hbmFnZXI7XHJcbiAgICAgICAgcHJpdmF0ZSBDb250YWN0U29sdmVyIF9jb250YWN0U29sdmVyID0gbmV3IENvbnRhY3RTb2x2ZXIoKTtcclxuICAgICAgICBwcml2YXRlIENvbnRhY3RbXSBfY29udGFjdHM7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX2pvaW50Q2FwYWNpdHk7XHJcbiAgICAgICAgcHJpdmF0ZSBKb2ludFtdIF9qb2ludHM7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEpvaW50VXBkYXRlVGltZTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBmbG9hdCBMaW5Ub2xTcXIgPSBTZXR0aW5ncy5MaW5lYXJTbGVlcFRvbGVyYW5jZSAqIFNldHRpbmdzLkxpbmVhclNsZWVwVG9sZXJhbmNlO1xyXG4gICAgICAgIHByaXZhdGUgY29uc3QgZmxvYXQgQW5nVG9sU3FyID0gU2V0dGluZ3MuQW5ndWxhclNsZWVwVG9sZXJhbmNlICogU2V0dGluZ3MuQW5ndWxhclNsZWVwVG9sZXJhbmNlO1xyXG5cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVzZXQoaW50IGJvZHlDYXBhY2l0eSwgaW50IGNvbnRhY3RDYXBhY2l0eSwgaW50IGpvaW50Q2FwYWNpdHksIENvbnRhY3RNYW5hZ2VyIGNvbnRhY3RNYW5hZ2VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2JvZHlDYXBhY2l0eSA9IGJvZHlDYXBhY2l0eTtcclxuICAgICAgICAgICAgX2NvbnRhY3RDYXBhY2l0eSA9IGNvbnRhY3RDYXBhY2l0eTtcclxuICAgICAgICAgICAgX2pvaW50Q2FwYWNpdHkgPSBqb2ludENhcGFjaXR5O1xyXG5cclxuICAgICAgICAgICAgQm9keUNvdW50ID0gMDtcclxuICAgICAgICAgICAgQ29udGFjdENvdW50ID0gMDtcclxuICAgICAgICAgICAgSm9pbnRDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICBfY29udGFjdE1hbmFnZXIgPSBjb250YWN0TWFuYWdlcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChCb2RpZXMgPT0gbnVsbCB8fCBCb2RpZXMuTGVuZ3RoIDwgYm9keUNhcGFjaXR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2RpZXMgPSBuZXcgQm9keVtib2R5Q2FwYWNpdHldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2NvbnRhY3RzID09IG51bGwgfHwgX2NvbnRhY3RzLkxlbmd0aCA8IGNvbnRhY3RDYXBhY2l0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2NvbnRhY3RzID0gbmV3IENvbnRhY3RbY29udGFjdENhcGFjaXR5ICogMl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfam9pbnRzID09IG51bGwgfHwgX2pvaW50cy5MZW5ndGggPCBqb2ludENhcGFjaXR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfam9pbnRzID0gbmV3IEpvaW50W2pvaW50Q2FwYWNpdHkgKiAyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keUNvdW50ID0gMDtcclxuICAgICAgICAgICAgQ29udGFjdENvdW50ID0gMDtcclxuICAgICAgICAgICAgSm9pbnRDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF90bXBUaW1lO1xyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTb2x2ZShyZWYgVGltZVN0ZXAgc3RlcCwgcmVmIFZlY3RvcjIgZ3Jhdml0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIEludGVncmF0ZSB2ZWxvY2l0aWVzIGFuZCBhcHBseSBkYW1waW5nLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEJvZHlDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGIgPSBCb2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGIuQm9keVR5cGUgIT0gQm9keVR5cGUuRHluYW1pYylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnRlZ3JhdGUgdmVsb2NpdGllcy5cclxuICAgICAgICAgICAgICAgIC8vIEZQRSAzIG9ubHkgLSBPbmx5IGFwcGx5IGdyYXZpdHkgaWYgdGhlIGJvZHkgd2FudHMgaXQuXHJcbiAgICAgICAgICAgICAgICBpZiAoYi5JZ25vcmVHcmF2aXR5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICs9IHN0ZXAuZHQgKiAoYi5JbnZNYXNzICogYi5Gb3JjZS5YKTtcclxuICAgICAgICAgICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArPSBzdGVwLmR0ICogKGIuSW52TWFzcyAqIGIuRm9yY2UuWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBzdGVwLmR0ICogYi5JbnZJICogYi5Ub3JxdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggKz0gc3RlcC5kdCAqIChncmF2aXR5LlggKyBiLkludk1hc3MgKiBiLkZvcmNlLlgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICs9IHN0ZXAuZHQgKiAoZ3Jhdml0eS5ZICsgYi5JbnZNYXNzICogYi5Gb3JjZS5ZKTtcclxuICAgICAgICAgICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IHN0ZXAuZHQgKiBiLkludkkgKiBiLlRvcnF1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBkYW1waW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gT0RFOiBkdi9kdCArIGMgKiB2ID0gMFxyXG4gICAgICAgICAgICAgICAgLy8gU29sdXRpb246IHYodCkgPSB2MCAqIGV4cCgtYyAqIHQpXHJcbiAgICAgICAgICAgICAgICAvLyBUaW1lIHN0ZXA6IHYodCArIGR0KSA9IHYwICogZXhwKC1jICogKHQgKyBkdCkpID0gdjAgKiBleHAoLWMgKiB0KSAqIGV4cCgtYyAqIGR0KSA9IHYgKiBleHAoLWMgKiBkdClcclxuICAgICAgICAgICAgICAgIC8vIHYyID0gZXhwKC1jICogZHQpICogdjFcclxuICAgICAgICAgICAgICAgIC8vIFRheWxvciBleHBhbnNpb246XHJcbiAgICAgICAgICAgICAgICAvLyB2MiA9ICgxLjBmIC0gYyAqIGR0KSAqIHYxXHJcbiAgICAgICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKj0gTWF0aFV0aWxzLkNsYW1wKDEuMGYgLSBzdGVwLmR0ICogYi5MaW5lYXJEYW1waW5nLCAwLjBmLCAxLjBmKTtcclxuICAgICAgICAgICAgICAgIGIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKj0gTWF0aFV0aWxzLkNsYW1wKDEuMGYgLSBzdGVwLmR0ICogYi5Bbmd1bGFyRGFtcGluZywgMC4wZiwgMS4wZik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBhcnRpdGlvbiBjb250YWN0cyBzbyB0aGF0IGNvbnRhY3RzIHdpdGggc3RhdGljIGJvZGllcyBhcmUgc29sdmVkIGxhc3QuXHJcbiAgICAgICAgICAgIGludCBpMSA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpMiA9IDA7IGkyIDwgQ29udGFjdENvdW50OyArK2kyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmVBID0gX2NvbnRhY3RzW2kyXS5GaXh0dXJlQTtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZUIgPSBfY29udGFjdHNbaTJdLkZpeHR1cmVCO1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QSA9IGZpeHR1cmVBLkJvZHk7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHlCID0gZml4dHVyZUIuQm9keTtcclxuICAgICAgICAgICAgICAgIGJvb2wgbm9uU3RhdGljID0gYm9keUEuQm9keVR5cGUgIT0gQm9keVR5cGUuU3RhdGljICYmIGJvZHlCLkJvZHlUeXBlICE9IEJvZHlUeXBlLlN0YXRpYztcclxuICAgICAgICAgICAgICAgIGlmIChub25TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBPbmx5IHN3YXAgaWYgdGhleSBhcmUgbm90IHRoZSBzYW1lPyBzZWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2JveDJkL2lzc3Vlcy9kZXRhaWw/aWQ9MTYyXHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdCB0bXAgPSBfY29udGFjdHNbaTFdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jb250YWN0c1tpMV0gPSBfY29udGFjdHNbaTJdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jb250YWN0c1tpMl0gPSB0bXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdmVsb2NpdHkgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgIF9jb250YWN0U29sdmVyLlJlc2V0KF9jb250YWN0cywgQ29udGFjdENvdW50LCBzdGVwLmR0UmF0aW8sIFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZyk7XHJcbiAgICAgICAgICAgIF9jb250YWN0U29sdmVyLkluaXRpYWxpemVWZWxvY2l0eUNvbnN0cmFpbnRzKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfY29udGFjdFNvbHZlci5XYXJtU3RhcnQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgSm9pbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2pvaW50c1tpXS5FbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIF9qb2ludHNbaV0uSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIHN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgdmVsb2NpdHkgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgU2V0dGluZ3MuVmVsb2NpdHlJdGVyYXRpb25zOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgSm9pbnRDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEpvaW50IGpvaW50ID0gX2pvaW50c1tqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2ludC5FbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgam9pbnQuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBzdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICBqb2ludC5WYWxpZGF0ZShzdGVwLmludl9kdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIF9jb250YWN0U29sdmVyLlNvbHZlVmVsb2NpdHlDb25zdHJhaW50cygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQb3N0LXNvbHZlIChzdG9yZSBpbXB1bHNlcyBmb3Igd2FybSBzdGFydGluZykuXHJcbiAgICAgICAgICAgIF9jb250YWN0U29sdmVyLlN0b3JlSW1wdWxzZXMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEludGVncmF0ZSBwb3NpdGlvbnMuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQm9keUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkgYiA9IEJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYi5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGxhcmdlIHZlbG9jaXRpZXMuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0cmFuc2xhdGlvblggPSBzdGVwLmR0ICogYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0cmFuc2xhdGlvblkgPSBzdGVwLmR0ICogYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByZXN1bHQgPSB0cmFuc2xhdGlvblggKiB0cmFuc2xhdGlvblggKyB0cmFuc2xhdGlvblkgKiB0cmFuc2xhdGlvblk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+IFNldHRpbmdzLk1heFRyYW5zbGF0aW9uU3F1YXJlZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzcSA9IChmbG9hdClNYXRoLlNxcnQocmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcmF0aW8gPSBTZXR0aW5ncy5NYXhUcmFuc2xhdGlvbiAvIHNxO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICo9IHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICo9IHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHJvdGF0aW9uID0gc3RlcC5kdCAqIGIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICBpZiAocm90YXRpb24gKiByb3RhdGlvbiA+IFNldHRpbmdzLk1heFJvdGF0aW9uU3F1YXJlZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCByYXRpbyA9IFNldHRpbmdzLk1heFJvdGF0aW9uIC8gKGZsb2F0KU1hdGguQWJzKHJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICo9IHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHBvc2l0aW9ucyBmb3IgY29udGludW91cyBjb2xsaXNpb24uXHJcbiAgICAgICAgICAgICAgICBiLlN3ZWVwLkMwLlggPSBiLlN3ZWVwLkMuWDtcclxuICAgICAgICAgICAgICAgIGIuU3dlZXAuQzAuWSA9IGIuU3dlZXAuQy5ZO1xyXG4gICAgICAgICAgICAgICAgYi5Td2VlcC5BMCA9IGIuU3dlZXAuQTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnRlZ3JhdGVcclxuICAgICAgICAgICAgICAgIGIuU3dlZXAuQy5YICs9IHN0ZXAuZHQgKiBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWDtcclxuICAgICAgICAgICAgICAgIGIuU3dlZXAuQy5ZICs9IHN0ZXAuZHQgKiBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWTtcclxuICAgICAgICAgICAgICAgIGIuU3dlZXAuQSArPSBzdGVwLmR0ICogYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5ldyB0cmFuc2Zvcm1cclxuICAgICAgICAgICAgICAgIGIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBzaGFwZXMgYXJlIHN5bmNocm9uaXplZCBsYXRlci5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFNldHRpbmdzLlBvc2l0aW9uSXRlcmF0aW9uczsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib29sIGNvbnRhY3RzT2theSA9IF9jb250YWN0U29sdmVyLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyhTZXR0aW5ncy5Db250YWN0QmF1bWdhcnRlKTtcclxuICAgICAgICAgICAgICAgIGJvb2wgam9pbnRzT2theSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBKb2ludENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgSm9pbnQgam9pbnQgPSBfam9pbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgham9pbnQuRW5hYmxlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgam9pbnRPa2F5ID0gam9pbnQuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbnRzT2theSA9IGpvaW50c09rYXkgJiYgam9pbnRPa2F5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb250YWN0c09rYXkgJiYgam9pbnRzT2theSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBwb3NpdGlvbiBlcnJvcnMgYXJlIHNtYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgUmVwb3J0KF9jb250YWN0U29sdmVyLkNvbnN0cmFpbnRzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5BbGxvd1NsZWVwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtaW5TbGVlcFRpbWUgPSBTZXR0aW5ncy5NYXhGbG9hdDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEJvZHlDb3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEJvZHkgYiA9IEJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYi5GbGFncyAmIEJvZHlGbGFncy5BdXRvU2xlZXApID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLlNsZWVwVGltZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGIuRmxhZ3MgJiBCb2R5RmxhZ3MuQXV0b1NsZWVwKSA9PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKiBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID4gQW5nVG9sU3FyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIuRG90KGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCwgYi5MaW5lYXJWZWxvY2l0eUludGVybmFsKSA+IExpblRvbFNxcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuU2xlZXBUaW1lID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluU2xlZXBUaW1lID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5TbGVlcFRpbWUgKz0gc3RlcC5kdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluU2xlZXBUaW1lID0gTWF0aC5NaW4obWluU2xlZXBUaW1lLCBiLlNsZWVwVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtaW5TbGVlcFRpbWUgPj0gU2V0dGluZ3MuVGltZVRvU2xlZXApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBCb2R5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEJvZHkgYiA9IEJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5Bd2FrZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBTb2x2ZVRPSShyZWYgVGltZVN0ZXAgc3ViU3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9jb250YWN0U29sdmVyLlJlc2V0KF9jb250YWN0cywgQ29udGFjdENvdW50LCBzdWJTdGVwLmR0UmF0aW8sIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHBvc2l0aW9uIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCBrVE9JQmF1bWdhcnRlID0gMC43NWY7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgU2V0dGluZ3MuVE9JUG9zaXRpb25JdGVyYXRpb25zOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJvb2wgY29udGFjdHNPa2F5ID0gX2NvbnRhY3RTb2x2ZXIuU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKGtUT0lCYXVtZ2FydGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RzT2theSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBTZXR0aW5ncy5UT0lQb3NpdGlvbkl0ZXJhdGlvbnMgLSAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGVhcCBvZiBmYWl0aCB0byBuZXcgc2FmZSBzdGF0ZS5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBCb2R5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5ID0gQm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgYm9keS5Td2VlcC5BMCA9IGJvZHkuU3dlZXAuQTtcclxuICAgICAgICAgICAgICAgIGJvZHkuU3dlZXAuQzAgPSBib2R5LlN3ZWVwLkM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vIHdhcm0gc3RhcnRpbmcgaXMgbmVlZGVkIGZvciBUT0kgZXZlbnRzIGJlY2F1c2Ugd2FybVxyXG4gICAgICAgICAgICAvLyBzdGFydGluZyBpbXB1bHNlcyB3ZXJlIGFwcGxpZWQgaW4gdGhlIGRpc2NyZXRlIHNvbHZlci5cclxuICAgICAgICAgICAgX2NvbnRhY3RTb2x2ZXIuSW5pdGlhbGl6ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHZlbG9jaXR5IGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFNldHRpbmdzLlRPSVZlbG9jaXR5SXRlcmF0aW9uczsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfY29udGFjdFNvbHZlci5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIFRPSSBjb250YWN0IGZvcmNlcyBmb3Igd2FybSBzdGFydGluZ1xyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgY2FuIGJlIHF1aXRlIGxhcmdlLlxyXG5cclxuICAgICAgICAgICAgLy8gSW50ZWdyYXRlIHBvc2l0aW9ucy5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBCb2R5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keSBiID0gQm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiLkJvZHlUeXBlID09IEJvZHlUeXBlLlN0YXRpYylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgbGFyZ2UgdmVsb2NpdGllcy5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHRyYW5zbGF0aW9ueCA9IHN1YlN0ZXAuZHQgKiBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHRyYW5zbGF0aW9ueSA9IHN1YlN0ZXAuZHQgKiBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRvdCA9IHRyYW5zbGF0aW9ueCAqIHRyYW5zbGF0aW9ueCArIHRyYW5zbGF0aW9ueSAqIHRyYW5zbGF0aW9ueTtcclxuICAgICAgICAgICAgICAgIGlmIChkb3QgPiBTZXR0aW5ncy5NYXhUcmFuc2xhdGlvblNxdWFyZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbm9ybSA9IDFmIC8gKGZsb2F0KU1hdGguU3FydChkb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gU2V0dGluZ3MuTWF4VHJhbnNsYXRpb24gKiBzdWJTdGVwLmludl9kdDtcclxuICAgICAgICAgICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCA9IHZhbHVlICogKHRyYW5zbGF0aW9ueCAqIG5vcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZID0gdmFsdWUgKiAodHJhbnNsYXRpb255ICogbm9ybSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgcm90YXRpb24gPSBzdWJTdGVwLmR0ICogYi5Bbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICBpZiAocm90YXRpb24gKiByb3RhdGlvbiA+IFNldHRpbmdzLk1heFJvdGF0aW9uU3F1YXJlZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRpb24gPCAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gLXN1YlN0ZXAuaW52X2R0ICogU2V0dGluZ3MuTWF4Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSBzdWJTdGVwLmludl9kdCAqIFNldHRpbmdzLk1heFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnRlZ3JhdGVcclxuICAgICAgICAgICAgICAgIGIuU3dlZXAuQy5YICs9IHN1YlN0ZXAuZHQgKiBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWDtcclxuICAgICAgICAgICAgICAgIGIuU3dlZXAuQy5ZICs9IHN1YlN0ZXAuZHQgKiBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWTtcclxuICAgICAgICAgICAgICAgIGIuU3dlZXAuQSArPSBzdWJTdGVwLmR0ICogYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5ldyB0cmFuc2Zvcm1cclxuICAgICAgICAgICAgICAgIGIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBzaGFwZXMgYXJlIHN5bmNocm9uaXplZCBsYXRlci5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgUmVwb3J0KF9jb250YWN0U29sdmVyLkNvbnN0cmFpbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZChCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoQm9keUNvdW50IDwgX2JvZHlDYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIEJvZGllc1tCb2R5Q291bnQrK10gPSBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkKENvbnRhY3QgY29udGFjdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChDb250YWN0Q291bnQgPCBfY29udGFjdENhcGFjaXR5KTtcclxuICAgICAgICAgICAgX2NvbnRhY3RzW0NvbnRhY3RDb3VudCsrXSA9IGNvbnRhY3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGQoSm9pbnQgam9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoSm9pbnRDb3VudCA8IF9qb2ludENhcGFjaXR5KTtcclxuICAgICAgICAgICAgX2pvaW50c1tKb2ludENvdW50KytdID0gam9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUmVwb3J0KENvbnRhY3RDb25zdHJhaW50W10gY29uc3RyYWludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2NvbnRhY3RNYW5hZ2VyID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvbnRhY3RDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0IGMgPSBfY29udGFjdHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGMuRml4dHVyZUEuQWZ0ZXJDb2xsaXNpb24gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBjLkZpeHR1cmVBLkFmdGVyQ29sbGlzaW9uKGMuRml4dHVyZUEsIGMuRml4dHVyZUIsIGMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjLkZpeHR1cmVCLkFmdGVyQ29sbGlzaW9uICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYy5GaXh0dXJlQi5BZnRlckNvbGxpc2lvbihjLkZpeHR1cmVCLCBjLkZpeHR1cmVBLCBjKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbnRhY3RNYW5hZ2VyLlBvc3RTb2x2ZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50IGNjID0gY29uc3RyYWludHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9jb250YWN0TWFuYWdlci5Qb3N0U29sdmUoYywgY2MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIHB1YmxpYyBlbnVtIEpvaW50VHlwZVxyXG4gICAge1xyXG4gICAgICAgIFJldm9sdXRlLFxyXG4gICAgICAgIFByaXNtYXRpYyxcclxuICAgICAgICBEaXN0YW5jZSxcclxuICAgICAgICBQdWxsZXksXHJcbiAgICAgICAgR2VhcixcclxuICAgICAgICBMaW5lLFxyXG4gICAgICAgIFdlbGQsXHJcbiAgICAgICAgRnJpY3Rpb24sXHJcbiAgICAgICAgU2xpZGVyLFxyXG4gICAgICAgIEFuZ2xlLFxyXG4gICAgICAgIFJvcGUsXHJcbiAgICAgICAgRml4ZWRNb3VzZSxcclxuICAgICAgICBGaXhlZFJldm9sdXRlLFxyXG4gICAgICAgIEZpeGVkRGlzdGFuY2UsXHJcbiAgICAgICAgRml4ZWRMaW5lLFxyXG4gICAgICAgIEZpeGVkUHJpc21hdGljLFxyXG4gICAgICAgIEZpeGVkQW5nbGUsXHJcbiAgICAgICAgRml4ZWRGcmljdGlvbixcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZW51bSBMaW1pdFN0YXRlXHJcbiAgICB7XHJcbiAgICAgICAgSW5hY3RpdmUsXHJcbiAgICAgICAgQXRMb3dlcixcclxuICAgICAgICBBdFVwcGVyLFxyXG4gICAgICAgIEVxdWFsLFxyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIHN0cnVjdCBKYWNvYmlhblxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBBbmd1bGFyQTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgQW5ndWxhckI7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTGluZWFyQTtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMaW5lYXJCO1xyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRaZXJvKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpbmVhckEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIEFuZ3VsYXJBID0gMC4wZjtcclxuICAgICAgICAgICAgTGluZWFyQiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgQW5ndWxhckIgPSAwLjBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0KFZlY3RvcjIgeDEsIGZsb2F0IGExLCBWZWN0b3IyIHgyLCBmbG9hdCBhMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpbmVhckEgPSB4MTtcclxuICAgICAgICAgICAgQW5ndWxhckEgPSBhMTtcclxuICAgICAgICAgICAgTGluZWFyQiA9IHgyO1xyXG4gICAgICAgICAgICBBbmd1bGFyQiA9IGEyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IENvbXB1dGUoVmVjdG9yMiB4MSwgZmxvYXQgYTEsIFZlY3RvcjIgeDIsIGZsb2F0IGEyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuRG90KExpbmVhckEsIHgxKSArIEFuZ3VsYXJBICogYTEgKyBWZWN0b3IyLkRvdChMaW5lYXJCLCB4MikgKyBBbmd1bGFyQiAqIGEyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBqb2ludCBlZGdlIGlzIHVzZWQgdG8gY29ubmVjdCBib2RpZXMgYW5kIGpvaW50cyB0b2dldGhlclxyXG4gICAgLy8vIGluIGEgam9pbnQgZ3JhcGggd2hlcmUgZWFjaCBib2R5IGlzIGEgbm9kZSBhbmQgZWFjaCBqb2ludFxyXG4gICAgLy8vIGlzIGFuIGVkZ2UuIEEgam9pbnQgZWRnZSBiZWxvbmdzIHRvIGEgZG91Ymx5IGxpbmtlZCBsaXN0XHJcbiAgICAvLy8gbWFpbnRhaW5lZCBpbiBlYWNoIGF0dGFjaGVkIGJvZHkuIEVhY2ggam9pbnQgaGFzIHR3byBqb2ludFxyXG4gICAgLy8vIG5vZGVzLCBvbmUgZm9yIGVhY2ggYXR0YWNoZWQgYm9keS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc2VhbGVkIGNsYXNzIEpvaW50RWRnZVxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGpvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEpvaW50IEpvaW50O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBuZXh0IGpvaW50IGVkZ2UgaW4gdGhlIGJvZHkncyBqb2ludCBsaXN0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEpvaW50RWRnZSBOZXh0O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFByb3ZpZGVzIHF1aWNrIGFjY2VzcyB0byB0aGUgb3RoZXIgYm9keSBhdHRhY2hlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBCb2R5IE90aGVyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBwcmV2aW91cyBqb2ludCBlZGdlIGluIHRoZSBib2R5J3Mgam9pbnQgbGlzdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBKb2ludEVkZ2UgUHJldjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgY2xhc3MgSm9pbnRcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBCcmVha3BvaW50IHNpbXBseSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gVmFsdWUgdGhlIEpvaW50RXJyb3IgY2FuIGJlIGJlZm9yZSBpdCBicmVha3MuXHJcbiAgICAgICAgLy8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGZsb2F0Lk1heFZhbHVlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQnJlYWtwb2ludCA9IGZsb2F0Lk1heFZhbHVlO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBKb2ludEVkZ2UgRWRnZUEgPSBuZXcgSm9pbnRFZGdlKCk7XHJcbiAgICAgICAgaW50ZXJuYWwgSm9pbnRFZGdlIEVkZ2VCID0gbmV3IEpvaW50RWRnZSgpO1xyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHByb3RlY3RlZCBmbG9hdCBJbnZJQTtcclxuICAgICAgICBwcm90ZWN0ZWQgZmxvYXQgSW52SUI7XHJcbiAgICAgICAgcHJvdGVjdGVkIGZsb2F0IEludk1hc3NBO1xyXG4gICAgICAgIHByb3RlY3RlZCBmbG9hdCBJbnZNYXNzQjtcclxuICAgICAgICBpbnRlcm5hbCBib29sIElzbGFuZEZsYWc7XHJcbiAgICAgICAgcHJvdGVjdGVkIFZlY3RvcjIgTG9jYWxDZW50ZXJBLCBMb2NhbENlbnRlckI7XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBKb2ludCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIEpvaW50KEJvZHkgYm9keSwgQm9keSBib2R5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChib2R5ICE9IGJvZHlCKTtcclxuXHJcbiAgICAgICAgICAgIEJvZHlBID0gYm9keTtcclxuICAgICAgICAgICAgQm9keUIgPSBib2R5QjtcclxuXHJcbiAgICAgICAgICAgIC8vQ29ubmVjdGVkIGJvZGllcyBzaG91bGQgbm90IGNvbGxpZGUgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBDb2xsaWRlQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnN0cnVjdG9yIGZvciBmaXhlZCBqb2ludFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJvdGVjdGVkIEpvaW50KEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHlBID0gYm9keTtcclxuXHJcbiAgICAgICAgICAgIC8vQ29ubmVjdGVkIGJvZGllcyBzaG91bGQgbm90IGNvbGxpZGUgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBDb2xsaWRlQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgdHlwZSBvZiB0aGUgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSB0eXBlIG9mIHRoZSBqb2ludC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBKb2ludFR5cGUgSm9pbnRUeXBlIHsgZ2V0OyBwcm90ZWN0ZWQgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBmaXJzdCBib2R5IGF0dGFjaGVkIHRvIHRoaXMgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIEJvZHkgQm9keUEgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgc2Vjb25kIGJvZHkgYXR0YWNoZWQgdG8gdGhpcyBqb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgQm9keSBCb2R5QiB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keTEgaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFZlY3RvcjIgV29ybGRBbmNob3JBIHsgZ2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keTIgaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFZlY3RvcjIgV29ybGRBbmNob3JCIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIHVzZXIgZGF0YSBwb2ludGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgZGF0YS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBvYmplY3QgVXNlckRhdGEgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNob3J0LWN1dCBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgZWl0aGVyIGJvZHkgaXMgaW5hY3RpdmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIGFjdGl2ZTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBBY3RpdmVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5FbmFibGVkICYmIEJvZHlCLkVuYWJsZWQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoaXMgZmxhZyB0byB0cnVlIGlmIHRoZSBhdHRhY2hlZCBib2RpZXMgc2hvdWxkIGNvbGxpZGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBDb2xsaWRlQ29ubmVjdGVkIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuIHRoZSBqb2ludCBpcyBicm9rZW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZXZlbnQgQWN0aW9uPEpvaW50LCBmbG9hdD4gQnJva2U7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSByZWFjdGlvbiBmb3JjZSBvbiBib2R5MiBhdCB0aGUgam9pbnQgYW5jaG9yIGluIE5ld3RvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnZfZHRcIj5UaGUgaW52X2R0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSByZWFjdGlvbiB0b3JxdWUgb24gYm9keTIgaW4gTiptLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW52X2R0XCI+VGhlIGludl9kdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludl9kdCk7XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCB2b2lkIFdha2VCb2RpZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keUEuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoQm9keUIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keUIuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybiB0cnVlIGlmIHRoZSBqb2ludCBpcyBhIGZpeGVkIHR5cGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0ZpeGVkVHlwZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gSm9pbnRUeXBlID09IEpvaW50VHlwZS5GaXhlZFJldm9sdXRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICBKb2ludFR5cGUgPT0gSm9pbnRUeXBlLkZpeGVkRGlzdGFuY2UgfHxcclxuICAgICAgICAgICAgICAgICAgIEpvaW50VHlwZSA9PSBKb2ludFR5cGUuRml4ZWRQcmlzbWF0aWMgfHxcclxuICAgICAgICAgICAgICAgICAgIEpvaW50VHlwZSA9PSBKb2ludFR5cGUuRml4ZWRMaW5lIHx8XHJcbiAgICAgICAgICAgICAgICAgICBKb2ludFR5cGUgPT0gSm9pbnRUeXBlLkZpeGVkTW91c2UgfHxcclxuICAgICAgICAgICAgICAgICAgIEpvaW50VHlwZSA9PSBKb2ludFR5cGUuRml4ZWRBbmdsZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgSm9pbnRUeXBlID09IEpvaW50VHlwZS5GaXhlZEZyaWN0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgYWJzdHJhY3Qgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcCk7XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgVmFsaWRhdGUoZmxvYXQgaW52RFQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIUVuYWJsZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBqb2ludEVycm9yID0gR2V0UmVhY3Rpb25Gb3JjZShpbnZEVCkuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLkFicyhqb2ludEVycm9yKSA8PSBCcmVha3BvaW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKEJyb2tlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBCcm9rZSh0aGlzLCBqb2ludEVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIGFic3RyYWN0IHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTb2x2ZXMgdGhlIHBvc2l0aW9uIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPnJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSB3aXRoaW4gdG9sZXJhbmNlLjwvcmV0dXJucz5cclxuICAgICAgICBpbnRlcm5hbCBhYnN0cmFjdCBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpO1xyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkZhY3Rvcmllc1xyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEJvZHlGYWN0b3J5XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUJvZHkoV29ybGQgd29ybGQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQm9keSh3b3JsZCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQm9keShXb3JsZCB3b3JsZCwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gbmV3IEJvZHkod29ybGQsIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQm9keShXb3JsZCB3b3JsZCwgVmVjdG9yMiBwb3NpdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVCb2R5KHdvcmxkLCBwb3NpdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQm9keShXb3JsZCB3b3JsZCwgVmVjdG9yMiBwb3NpdGlvbiwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQm9keSh3b3JsZCwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICBib2R5LlBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUVkZ2UoV29ybGQgd29ybGQsIFZlY3RvcjIgc3RhcnQsIFZlY3RvcjIgZW5kKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUVkZ2Uod29ybGQsIHN0YXJ0LCBlbmQsIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUVkZ2UoV29ybGQgd29ybGQsIFZlY3RvcjIgc3RhcnQsIFZlY3RvcjIgZW5kLCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJvZHkgPSBDcmVhdGVCb2R5KHdvcmxkKTtcclxuICAgICAgICAgICAgRml4dHVyZUZhY3RvcnkuQXR0YWNoRWRnZShzdGFydCwgZW5kLCBib2R5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUxvb3BTaGFwZShXb3JsZCB3b3JsZCwgVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlTG9vcFNoYXBlKHdvcmxkLCB2ZXJ0aWNlcywgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlTG9vcFNoYXBlKFdvcmxkIHdvcmxkLCBWZXJ0aWNlcyB2ZXJ0aWNlcywgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUxvb3BTaGFwZSh3b3JsZCwgdmVydGljZXMsIFZlY3RvcjIuWmVybywgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUxvb3BTaGFwZShXb3JsZCB3b3JsZCwgVmVydGljZXMgdmVydGljZXMsIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlTG9vcFNoYXBlKHdvcmxkLCB2ZXJ0aWNlcywgcG9zaXRpb24sIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUxvb3BTaGFwZShXb3JsZCB3b3JsZCwgVmVydGljZXMgdmVydGljZXMsIFZlY3RvcjIgcG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJvZHkgPSBDcmVhdGVCb2R5KHdvcmxkLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIEZpeHR1cmVGYWN0b3J5LkF0dGFjaExvb3BTaGFwZSh2ZXJ0aWNlcywgYm9keSwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVSZWN0YW5nbGUoV29ybGQgd29ybGQsIGZsb2F0IHdpZHRoLCBmbG9hdCBoZWlnaHQsIGZsb2F0IGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUmVjdGFuZ2xlKHdvcmxkLCB3aWR0aCwgaGVpZ2h0LCBkZW5zaXR5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVSZWN0YW5nbGUoV29ybGQgd29ybGQsIGZsb2F0IHdpZHRoLCBmbG9hdCBoZWlnaHQsIGZsb2F0IGRlbnNpdHksIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVSZWN0YW5nbGUod29ybGQsIHdpZHRoLCBoZWlnaHQsIGRlbnNpdHksIFZlY3RvcjIuWmVybywgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZVJlY3RhbmdsZShXb3JsZCB3b3JsZCwgZmxvYXQgd2lkdGgsIGZsb2F0IGhlaWdodCwgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVSZWN0YW5nbGUod29ybGQsIHdpZHRoLCBoZWlnaHQsIGRlbnNpdHksIHBvc2l0aW9uLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVSZWN0YW5nbGUoV29ybGQgd29ybGQsIGZsb2F0IHdpZHRoLCBmbG9hdCBoZWlnaHQsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgcG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAod2lkdGggPD0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ3aWR0aFwiLCBcIldpZHRoIG11c3QgYmUgbW9yZSB0aGFuIDAgbWV0ZXJzXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhlaWdodCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImhlaWdodFwiLCBcIkhlaWdodCBtdXN0IGJlIG1vcmUgdGhhbiAwIG1ldGVyc1wiKTtcclxuXHJcbiAgICAgICAgICAgIEJvZHkgbmV3Qm9keSA9IENyZWF0ZUJvZHkod29ybGQsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgVmVydGljZXMgcmVjdGFuZ2xlVmVydGljZXMgPSBQb2x5Z29uVG9vbHMuQ3JlYXRlUmVjdGFuZ2xlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIFBvbHlnb25TaGFwZSByZWN0YW5nbGVTaGFwZSA9IG5ldyBQb2x5Z29uU2hhcGUocmVjdGFuZ2xlVmVydGljZXMsIGRlbnNpdHkpO1xyXG4gICAgICAgICAgICBuZXdCb2R5LkNyZWF0ZUZpeHR1cmUocmVjdGFuZ2xlU2hhcGUsIHVzZXJEYXRhKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXdCb2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUNpcmNsZShXb3JsZCB3b3JsZCwgZmxvYXQgcmFkaXVzLCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUNpcmNsZSh3b3JsZCwgcmFkaXVzLCBkZW5zaXR5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDaXJjbGUoV29ybGQgd29ybGQsIGZsb2F0IHJhZGl1cywgZmxvYXQgZGVuc2l0eSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUNpcmNsZSh3b3JsZCwgcmFkaXVzLCBkZW5zaXR5LCBWZWN0b3IyLlplcm8sIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDaXJjbGUoV29ybGQgd29ybGQsIGZsb2F0IHJhZGl1cywgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDaXJjbGUod29ybGQsIHJhZGl1cywgZGVuc2l0eSwgcG9zaXRpb24sIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUNpcmNsZShXb3JsZCB3b3JsZCwgZmxvYXQgcmFkaXVzLCBmbG9hdCBkZW5zaXR5LCBWZWN0b3IyIHBvc2l0aW9uLCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJvZHkgPSBDcmVhdGVCb2R5KHdvcmxkLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIEZpeHR1cmVGYWN0b3J5LkF0dGFjaENpcmNsZShyYWRpdXMsIGRlbnNpdHksIGJvZHksIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlRWxsaXBzZShXb3JsZCB3b3JsZCwgZmxvYXQgeFJhZGl1cywgZmxvYXQgeVJhZGl1cywgaW50IGVkZ2VzLCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUVsbGlwc2Uod29ybGQsIHhSYWRpdXMsIHlSYWRpdXMsIGVkZ2VzLCBkZW5zaXR5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVFbGxpcHNlKFdvcmxkIHdvcmxkLCBmbG9hdCB4UmFkaXVzLCBmbG9hdCB5UmFkaXVzLCBpbnQgZWRnZXMsIGZsb2F0IGRlbnNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUVsbGlwc2Uod29ybGQsIHhSYWRpdXMsIHlSYWRpdXMsIGVkZ2VzLCBkZW5zaXR5LCBWZWN0b3IyLlplcm8sIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVFbGxpcHNlKFdvcmxkIHdvcmxkLCBmbG9hdCB4UmFkaXVzLCBmbG9hdCB5UmFkaXVzLCBpbnQgZWRnZXMsIGZsb2F0IGRlbnNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb3NpdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVFbGxpcHNlKHdvcmxkLCB4UmFkaXVzLCB5UmFkaXVzLCBlZGdlcywgZGVuc2l0eSwgcG9zaXRpb24sIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUVsbGlwc2UoV29ybGQgd29ybGQsIGZsb2F0IHhSYWRpdXMsIGZsb2F0IHlSYWRpdXMsIGludCBlZGdlcywgZmxvYXQgZGVuc2l0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvc2l0aW9uLCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJvZHkgPSBDcmVhdGVCb2R5KHdvcmxkLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIEZpeHR1cmVGYWN0b3J5LkF0dGFjaEVsbGlwc2UoeFJhZGl1cywgeVJhZGl1cywgZWRnZXMsIGRlbnNpdHksIGJvZHksIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlUG9seWdvbihXb3JsZCB3b3JsZCwgVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUG9seWdvbih3b3JsZCwgdmVydGljZXMsIGRlbnNpdHksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZVBvbHlnb24oV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkZW5zaXR5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUG9seWdvbih3b3JsZCwgdmVydGljZXMsIGRlbnNpdHksIFZlY3RvcjIuWmVybywgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZVBvbHlnb24oV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkZW5zaXR5LCBWZWN0b3IyIHBvc2l0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVBvbHlnb24od29ybGQsIHZlcnRpY2VzLCBkZW5zaXR5LCBwb3NpdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlUG9seWdvbihXb3JsZCB3b3JsZCwgVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgcG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQm9keSh3b3JsZCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBGaXh0dXJlRmFjdG9yeS5BdHRhY2hQb2x5Z29uKHZlcnRpY2VzLCBkZW5zaXR5LCBib2R5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUNvbXBvdW5kUG9seWdvbihXb3JsZCB3b3JsZCwgTGlzdDxWZXJ0aWNlcz4gbGlzdCwgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDb21wb3VuZFBvbHlnb24od29ybGQsIGxpc3QsIGRlbnNpdHksIEJvZHlUeXBlLlN0YXRpYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQ29tcG91bmRQb2x5Z29uKFdvcmxkIHdvcmxkLCBMaXN0PFZlcnRpY2VzPiBsaXN0LCBmbG9hdCBkZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUNvbXBvdW5kUG9seWdvbih3b3JsZCwgbGlzdCwgZGVuc2l0eSwgVmVjdG9yMi5aZXJvLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQ29tcG91bmRQb2x5Z29uKFdvcmxkIHdvcmxkLCBMaXN0PFZlcnRpY2VzPiBsaXN0LCBmbG9hdCBkZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb3NpdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDb21wb3VuZFBvbHlnb24od29ybGQsIGxpc3QsIGRlbnNpdHksIHBvc2l0aW9uLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDb21wb3VuZFBvbHlnb24oV29ybGQgd29ybGQsIExpc3Q8VmVydGljZXM+IGxpc3QsIGZsb2F0IGRlbnNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvc2l0aW9uLCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1dlIGNyZWF0ZSBhIHNpbmdsZSBib2R5XHJcbiAgICAgICAgICAgIEJvZHkgcG9seWdvbkJvZHkgPSBDcmVhdGVCb2R5KHdvcmxkLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIEZpeHR1cmVGYWN0b3J5LkF0dGFjaENvbXBvdW5kUG9seWdvbihsaXN0LCBkZW5zaXR5LCBwb2x5Z29uQm9keSwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbkJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUdlYXIoV29ybGQgd29ybGQsIGZsb2F0IHJhZGl1cywgaW50IG51bWJlck9mVGVldGgsIGZsb2F0IHRpcFBlcmNlbnRhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdG9vdGhIZWlnaHQsIGZsb2F0IGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlR2Vhcih3b3JsZCwgcmFkaXVzLCBudW1iZXJPZlRlZXRoLCB0aXBQZXJjZW50YWdlLCB0b290aEhlaWdodCwgZGVuc2l0eSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlR2VhcihXb3JsZCB3b3JsZCwgZmxvYXQgcmFkaXVzLCBpbnQgbnVtYmVyT2ZUZWV0aCwgZmxvYXQgdGlwUGVyY2VudGFnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB0b290aEhlaWdodCwgZmxvYXQgZGVuc2l0eSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgZ2VhclBvbHlnb24gPSBQb2x5Z29uVG9vbHMuQ3JlYXRlR2VhcihyYWRpdXMsIG51bWJlck9mVGVldGgsIHRpcFBlcmNlbnRhZ2UsIHRvb3RoSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIC8vR2VhcnMgY2FuIGluIHNvbWUgY2FzZXMgYmUgY29udmV4XHJcbiAgICAgICAgICAgIGlmICghZ2VhclBvbHlnb24uSXNDb252ZXgoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9EZWNvbXBvc2UgdGhlIGdlYXI6XHJcbiAgICAgICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiBsaXN0ID0gRWFyY2xpcERlY29tcG9zZXIuQ29udmV4UGFydGl0aW9uKGdlYXJQb2x5Z29uKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlQ29tcG91bmRQb2x5Z29uKHdvcmxkLCBsaXN0LCBkZW5zaXR5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVQb2x5Z29uKHdvcmxkLCBnZWFyUG9seWdvbiwgZGVuc2l0eSwgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgY2Fwc3VsZS5cclxuICAgICAgICAvLy8gTm90ZTogQXV0b21hdGljYWxseSBkZWNvbXBvc2VzIHRoZSBjYXBzdWxlIGlmIGl0IGNvbnRhaW5zIHRvbyBtYW55IHZlcnRpY2VzIChjb250cm9sbGVkIGJ5IFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcylcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkXCI+VGhlIHdvcmxkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaGVpZ2h0XCI+VGhlIGhlaWdodC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRvcFJhZGl1c1wiPlRoZSB0b3AgcmFkaXVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidG9wRWRnZXNcIj5UaGUgdG9wIGVkZ2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm90dG9tUmFkaXVzXCI+VGhlIGJvdHRvbSByYWRpdXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib3R0b21FZGdlc1wiPlRoZSBib3R0b20gZWRnZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkZW5zaXR5XCI+VGhlIGRlbnNpdHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb3NpdGlvblwiPlRoZSBwb3NpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUNhcHN1bGUoV29ybGQgd29ybGQsIGZsb2F0IGhlaWdodCwgZmxvYXQgdG9wUmFkaXVzLCBpbnQgdG9wRWRnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgYm90dG9tUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBib3R0b21FZGdlcywgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbiwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgdmVydHMgPSBQb2x5Z29uVG9vbHMuQ3JlYXRlQ2Fwc3VsZShoZWlnaHQsIHRvcFJhZGl1cywgdG9wRWRnZXMsIGJvdHRvbVJhZGl1cywgYm90dG9tRWRnZXMpO1xyXG5cclxuICAgICAgICAgICAgQm9keSBib2R5O1xyXG5cclxuICAgICAgICAgICAgLy9UaGVyZSBhcmUgdG9vIG1hbnkgdmVydGljZXMgaW4gdGhlIGNhcHN1bGUuIFdlIGRlY29tcG9zZSBpdC5cclxuICAgICAgICAgICAgaWYgKHZlcnRzLkNvdW50ID49IFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gdmVydExpc3QgPSBFYXJjbGlwRGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24odmVydHMpO1xyXG4gICAgICAgICAgICAgICAgYm9keSA9IENyZWF0ZUNvbXBvdW5kUG9seWdvbih3b3JsZCwgdmVydExpc3QsIGRlbnNpdHksIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIGJvZHkuUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYm9keSA9IENyZWF0ZVBvbHlnb24od29ybGQsIHZlcnRzLCBkZW5zaXR5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIGJvZHkuUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUNhcHN1bGUoV29ybGQgd29ybGQsIGZsb2F0IGhlaWdodCwgZmxvYXQgdG9wUmFkaXVzLCBpbnQgdG9wRWRnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgYm90dG9tUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBib3R0b21FZGdlcywgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDYXBzdWxlKHdvcmxkLCBoZWlnaHQsIHRvcFJhZGl1cywgdG9wRWRnZXMsIGJvdHRvbVJhZGl1cywgYm90dG9tRWRnZXMsIGRlbnNpdHksIHBvc2l0aW9uLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDYXBzdWxlKFdvcmxkIHdvcmxkLCBmbG9hdCBoZWlnaHQsIGZsb2F0IGVuZFJhZGl1cywgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDYXBzdWxlKHdvcmxkLCBoZWlnaHQsIGVuZFJhZGl1cywgZGVuc2l0eSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQ2Fwc3VsZShXb3JsZCB3b3JsZCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCBlbmRSYWRpdXMsIGZsb2F0IGRlbnNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9DcmVhdGUgdGhlIG1pZGRsZSByZWN0YW5nbGVcclxuICAgICAgICAgICAgVmVydGljZXMgcmVjdGFuZ2xlID0gUG9seWdvblRvb2xzLkNyZWF0ZVJlY3RhbmdsZShlbmRSYWRpdXMsIGhlaWdodCAvIDIpO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gbGlzdCA9IG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG4gICAgICAgICAgICBsaXN0LkFkZChyZWN0YW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQ29tcG91bmRQb2x5Z29uKHdvcmxkLCBsaXN0LCBkZW5zaXR5LCB1c2VyRGF0YSk7XHJcblxyXG4gICAgICAgICAgICAvL0NyZWF0ZSB0aGUgdHdvIGNpcmNsZXNcclxuICAgICAgICAgICAgQ2lyY2xlU2hhcGUgdG9wQ2lyY2xlID0gbmV3IENpcmNsZVNoYXBlKGVuZFJhZGl1cywgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgIHRvcENpcmNsZS5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IyKDAsIGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICBib2R5LkNyZWF0ZUZpeHR1cmUodG9wQ2lyY2xlLCB1c2VyRGF0YSk7XHJcblxyXG4gICAgICAgICAgICBDaXJjbGVTaGFwZSBib3R0b21DaXJjbGUgPSBuZXcgQ2lyY2xlU2hhcGUoZW5kUmFkaXVzLCBkZW5zaXR5KTtcclxuICAgICAgICAgICAgYm90dG9tQ2lyY2xlLlBvc2l0aW9uID0gbmV3IFZlY3RvcjIoMCwgLShoZWlnaHQgLyAyKSk7XHJcbiAgICAgICAgICAgIGJvZHkuQ3JlYXRlRml4dHVyZShib3R0b21DaXJjbGUsIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSByb3VuZGVkIHJlY3RhbmdsZS5cclxuICAgICAgICAvLy8gTm90ZTogQXV0b21hdGljYWxseSBkZWNvbXBvc2VzIHRoZSBjYXBzdWxlIGlmIGl0IGNvbnRhaW5zIHRvbyBtYW55IHZlcnRpY2VzIChjb250cm9sbGVkIGJ5IFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcylcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkXCI+VGhlIHdvcmxkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid2lkdGhcIj5UaGUgd2lkdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoZWlnaHRcIj5UaGUgaGVpZ2h0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFJhZGl1c1wiPlRoZSB4IHJhZGl1cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInlSYWRpdXNcIj5UaGUgeSByYWRpdXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzZWdtZW50c1wiPlRoZSBzZWdtZW50cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRlbnNpdHlcIj5UaGUgZGVuc2l0eS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvc2l0aW9uXCI+VGhlIHBvc2l0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlUm91bmRlZFJlY3RhbmdsZShXb3JsZCB3b3JsZCwgZmxvYXQgd2lkdGgsIGZsb2F0IGhlaWdodCwgZmxvYXQgeFJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB5UmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBzZWdtZW50cywgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0cyA9IFBvbHlnb25Ub29scy5DcmVhdGVSb3VuZGVkUmVjdGFuZ2xlKHdpZHRoLCBoZWlnaHQsIHhSYWRpdXMsIHlSYWRpdXMsIHNlZ21lbnRzKTtcclxuXHJcbiAgICAgICAgICAgIC8vVGhlcmUgYXJlIHRvbyBtYW55IHZlcnRpY2VzIGluIHRoZSBjYXBzdWxlLiBXZSBkZWNvbXBvc2UgaXQuXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0cy5Db3VudCA+PSBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHZlcnRMaXN0ID0gRWFyY2xpcERlY29tcG9zZXIuQ29udmV4UGFydGl0aW9uKHZlcnRzKTtcclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keSA9IENyZWF0ZUNvbXBvdW5kUG9seWdvbih3b3JsZCwgdmVydExpc3QsIGRlbnNpdHksIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIGJvZHkuUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUG9seWdvbih3b3JsZCwgdmVydHMsIGRlbnNpdHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZVJvdW5kZWRSZWN0YW5nbGUoV29ybGQgd29ybGQsIGZsb2F0IHdpZHRoLCBmbG9hdCBoZWlnaHQsIGZsb2F0IHhSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgeVJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgc2VnbWVudHMsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUm91bmRlZFJlY3RhbmdsZSh3b3JsZCwgd2lkdGgsIGhlaWdodCwgeFJhZGl1cywgeVJhZGl1cywgc2VnbWVudHMsIGRlbnNpdHksIHBvc2l0aW9uLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVSb3VuZGVkUmVjdGFuZ2xlKFdvcmxkIHdvcmxkLCBmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCB4UmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHlSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IHNlZ21lbnRzLCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVJvdW5kZWRSZWN0YW5nbGUod29ybGQsIHdpZHRoLCBoZWlnaHQsIHhSYWRpdXMsIHlSYWRpdXMsIHNlZ21lbnRzLCBkZW5zaXR5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVSb3VuZGVkUmVjdGFuZ2xlKFdvcmxkIHdvcmxkLCBmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCB4UmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHlSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IHNlZ21lbnRzLCBmbG9hdCBkZW5zaXR5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUm91bmRlZFJlY3RhbmdsZSh3b3JsZCwgd2lkdGgsIGhlaWdodCwgeFJhZGl1cywgeVJhZGl1cywgc2VnbWVudHMsIGRlbnNpdHksIFZlY3RvcjIuWmVybyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCcmVha2FibGVCb2R5IENyZWF0ZUJyZWFrYWJsZUJvZHkoV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUJyZWFrYWJsZUJvZHkod29ybGQsIHZlcnRpY2VzLCBkZW5zaXR5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQnJlYWthYmxlQm9keSBDcmVhdGVCcmVha2FibGVCb2R5KFdvcmxkIHdvcmxkLCBWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUJyZWFrYWJsZUJvZHkod29ybGQsIHZlcnRpY2VzLCBkZW5zaXR5LCBWZWN0b3IyLlplcm8sIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGJyZWFrYWJsZSBib2R5LiBZb3Ugd291bGQgd2FudCB0byByZW1vdmUgY29sbGluZWFyIHBvaW50cyBiZWZvcmUgdXNpbmcgdGhpcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkXCI+VGhlIHdvcmxkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgdmVydGljZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkZW5zaXR5XCI+VGhlIGRlbnNpdHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb3NpdGlvblwiPlRoZSBwb3NpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCcmVha2FibGVCb2R5IENyZWF0ZUJyZWFrYWJsZUJvZHkoV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkZW5zaXR5LCBWZWN0b3IyIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHRyaWFuZ2xlcyA9IEVhcmNsaXBEZWNvbXBvc2VyLkNvbnZleFBhcnRpdGlvbih2ZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICBCcmVha2FibGVCb2R5IGJyZWFrYWJsZUJvZHkgPSBuZXcgQnJlYWthYmxlQm9keSh0cmlhbmdsZXMsIHdvcmxkLCBkZW5zaXR5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIGJyZWFrYWJsZUJvZHkuTWFpbkJvZHkuUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgd29ybGQuQWRkQnJlYWthYmxlQm9keShicmVha2FibGVCb2R5KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBicmVha2FibGVCb2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCcmVha2FibGVCb2R5IENyZWF0ZUJyZWFrYWJsZUJvZHkoV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkZW5zaXR5LCBWZWN0b3IyIHBvc2l0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUJyZWFrYWJsZUJvZHkod29ybGQsIHZlcnRpY2VzLCBkZW5zaXR5LCBwb3NpdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlTGluZUFyYyhXb3JsZCB3b3JsZCwgZmxvYXQgcmFkaWFucywgaW50IHNpZGVzLCBmbG9hdCByYWRpdXMsIFZlY3RvcjIgcG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgYW5nbGUsIGJvb2wgY2xvc2VkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQm9keSh3b3JsZCk7XHJcbiAgICAgICAgICAgIEZpeHR1cmVGYWN0b3J5LkF0dGFjaExpbmVBcmMocmFkaWFucywgc2lkZXMsIHJhZGl1cywgcG9zaXRpb24sIGFuZ2xlLCBjbG9zZWQsIGJvZHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVTb2xpZEFyYyhXb3JsZCB3b3JsZCwgZmxvYXQgZGVuc2l0eSwgZmxvYXQgcmFkaWFucywgaW50IHNpZGVzLCBmbG9hdCByYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9zaXRpb24sIGZsb2F0IGFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQm9keSh3b3JsZCk7XHJcbiAgICAgICAgICAgIEZpeHR1cmVGYWN0b3J5LkF0dGFjaFNvbGlkQXJjKGRlbnNpdHksIHJhZGlhbnMsIHNpZGVzLCByYWRpdXMsIHBvc2l0aW9uLCBhbmdsZSwgYm9keSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5GYWN0b3JpZXNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEFuIGVhc3kgdG8gdXNlIGZhY3RvcnkgZm9yIGNyZWF0aW5nIGJvZGllc1xyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgRml4dHVyZUZhY3RvcnlcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoRWRnZShWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZCwgQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEF0dGFjaEVkZ2Uoc3RhcnQsIGVuZCwgYm9keSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoRWRnZShWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZCwgQm9keSBib2R5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFZGdlU2hhcGUgZWRnZVNoYXBlID0gbmV3IEVkZ2VTaGFwZShzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHkuQ3JlYXRlRml4dHVyZShlZGdlU2hhcGUsIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hMb29wU2hhcGUoVmVydGljZXMgdmVydGljZXMsIEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBBdHRhY2hMb29wU2hhcGUodmVydGljZXMsIGJvZHksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaExvb3BTaGFwZShWZXJ0aWNlcyB2ZXJ0aWNlcywgQm9keSBib2R5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMb29wU2hhcGUgc2hhcGUgPSBuZXcgTG9vcFNoYXBlKHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHkuQ3JlYXRlRml4dHVyZShzaGFwZSwgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaFJlY3RhbmdsZShmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCBkZW5zaXR5LCBWZWN0b3IyIG9mZnNldCwgQm9keSBib2R5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgcmVjdGFuZ2xlVmVydGljZXMgPSBQb2x5Z29uVG9vbHMuQ3JlYXRlUmVjdGFuZ2xlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIHJlY3RhbmdsZVZlcnRpY2VzLlRyYW5zbGF0ZShyZWYgb2Zmc2V0KTtcclxuICAgICAgICAgICAgUG9seWdvblNoYXBlIHJlY3RhbmdsZVNoYXBlID0gbmV3IFBvbHlnb25TaGFwZShyZWN0YW5nbGVWZXJ0aWNlcywgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5LkNyZWF0ZUZpeHR1cmUocmVjdGFuZ2xlU2hhcGUsIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hSZWN0YW5nbGUoZmxvYXQgd2lkdGgsIGZsb2F0IGhlaWdodCwgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBvZmZzZXQsIEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBBdHRhY2hSZWN0YW5nbGUod2lkdGgsIGhlaWdodCwgZGVuc2l0eSwgb2Zmc2V0LCBib2R5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hDaXJjbGUoZmxvYXQgcmFkaXVzLCBmbG9hdCBkZW5zaXR5LCBCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNoQ2lyY2xlKHJhZGl1cywgZGVuc2l0eSwgYm9keSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoQ2lyY2xlKGZsb2F0IHJhZGl1cywgZmxvYXQgZGVuc2l0eSwgQm9keSBib2R5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmFkaXVzIDw9IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicmFkaXVzXCIsIFwiUmFkaXVzIG11c3QgYmUgbW9yZSB0aGFuIDAgbWV0ZXJzXCIpO1xyXG5cclxuICAgICAgICAgICAgQ2lyY2xlU2hhcGUgY2lyY2xlU2hhcGUgPSBuZXcgQ2lyY2xlU2hhcGUocmFkaXVzLCBkZW5zaXR5KTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHkuQ3JlYXRlRml4dHVyZShjaXJjbGVTaGFwZSwgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaENpcmNsZShmbG9hdCByYWRpdXMsIGZsb2F0IGRlbnNpdHksIEJvZHkgYm9keSwgVmVjdG9yMiBvZmZzZXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNoQ2lyY2xlKHJhZGl1cywgZGVuc2l0eSwgYm9keSwgb2Zmc2V0LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hDaXJjbGUoZmxvYXQgcmFkaXVzLCBmbG9hdCBkZW5zaXR5LCBCb2R5IGJvZHksIFZlY3RvcjIgb2Zmc2V0LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocmFkaXVzIDw9IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwicmFkaXVzXCIsIFwiUmFkaXVzIG11c3QgYmUgbW9yZSB0aGFuIDAgbWV0ZXJzXCIpO1xyXG5cclxuICAgICAgICAgICAgQ2lyY2xlU2hhcGUgY2lyY2xlU2hhcGUgPSBuZXcgQ2lyY2xlU2hhcGUocmFkaXVzLCBkZW5zaXR5KTtcclxuICAgICAgICAgICAgY2lyY2xlU2hhcGUuUG9zaXRpb24gPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5LkNyZWF0ZUZpeHR1cmUoY2lyY2xlU2hhcGUsIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hQb2x5Z29uKFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkZW5zaXR5LCBCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNoUG9seWdvbih2ZXJ0aWNlcywgZGVuc2l0eSwgYm9keSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoUG9seWdvbihWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSwgQm9keSBib2R5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuQ291bnQgPD0gMSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ2ZXJ0aWNlc1wiLCBcIlRvbyBmZXcgcG9pbnRzIHRvIGJlIGEgcG9seWdvblwiKTtcclxuXHJcbiAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5Z29uID0gbmV3IFBvbHlnb25TaGFwZSh2ZXJ0aWNlcywgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5LkNyZWF0ZUZpeHR1cmUocG9seWdvbiwgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaEVsbGlwc2UoZmxvYXQgeFJhZGl1cywgZmxvYXQgeVJhZGl1cywgaW50IGVkZ2VzLCBmbG9hdCBkZW5zaXR5LCBCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNoRWxsaXBzZSh4UmFkaXVzLCB5UmFkaXVzLCBlZGdlcywgZGVuc2l0eSwgYm9keSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoRWxsaXBzZShmbG9hdCB4UmFkaXVzLCBmbG9hdCB5UmFkaXVzLCBpbnQgZWRnZXMsIGZsb2F0IGRlbnNpdHksIEJvZHkgYm9keSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoeFJhZGl1cyA8PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInhSYWRpdXNcIiwgXCJYLXJhZGl1cyBtdXN0IGJlIG1vcmUgdGhhbiAwXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHlSYWRpdXMgPD0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ5UmFkaXVzXCIsIFwiWS1yYWRpdXMgbXVzdCBiZSBtb3JlIHRoYW4gMFwiKTtcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIGVsbGlwc2VWZXJ0aWNlcyA9IFBvbHlnb25Ub29scy5DcmVhdGVFbGxpcHNlKHhSYWRpdXMsIHlSYWRpdXMsIGVkZ2VzKTtcclxuICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHlnb25TaGFwZSA9IG5ldyBQb2x5Z29uU2hhcGUoZWxsaXBzZVZlcnRpY2VzLCBkZW5zaXR5KTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHkuQ3JlYXRlRml4dHVyZShwb2x5Z29uU2hhcGUsIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxGaXh0dXJlPiBBdHRhY2hDb21wb3VuZFBvbHlnb24oTGlzdDxWZXJ0aWNlcz4gbGlzdCwgZmxvYXQgZGVuc2l0eSwgQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEF0dGFjaENvbXBvdW5kUG9seWdvbihsaXN0LCBkZW5zaXR5LCBib2R5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxGaXh0dXJlPiBBdHRhY2hDb21wb3VuZFBvbHlnb24oTGlzdDxWZXJ0aWNlcz4gbGlzdCwgZmxvYXQgZGVuc2l0eSwgQm9keSBib2R5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaXN0PEZpeHR1cmU+IHJlcyA9IG5ldyBMaXN0PEZpeHR1cmU+KGxpc3QuQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgLy9UaGVuIHdlIGNyZWF0ZSBzZXZlcmFsIGZpeHR1cmVzIHVzaW5nIHRoZSBib2R5XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKFZlcnRpY2VzIHZlcnRpY2VzIGluIGxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA9PSAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEVkZ2VTaGFwZSBzaGFwZSA9IG5ldyBFZGdlU2hhcGUodmVydGljZXNbMF0sIHZlcnRpY2VzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMuQWRkKGJvZHkuQ3JlYXRlRml4dHVyZShzaGFwZSwgdXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgc2hhcGUgPSBuZXcgUG9seWdvblNoYXBlKHZlcnRpY2VzLCBkZW5zaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICByZXMuQWRkKGJvZHkuQ3JlYXRlRml4dHVyZShzaGFwZSwgdXNlckRhdGEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxGaXh0dXJlPiBBdHRhY2hMaW5lQXJjKGZsb2F0IHJhZGlhbnMsIGludCBzaWRlcywgZmxvYXQgcmFkaXVzLCBWZWN0b3IyIHBvc2l0aW9uLCBmbG9hdCBhbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29sIGNsb3NlZCwgQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgYXJjID0gUG9seWdvblRvb2xzLkNyZWF0ZUFyYyhyYWRpYW5zLCBzaWRlcywgcmFkaXVzKTtcclxuICAgICAgICAgICAgYXJjLlJvdGF0ZSgoTWF0aEhlbHBlci5QaSAtIHJhZGlhbnMpIC8gMiArIGFuZ2xlKTtcclxuICAgICAgICAgICAgYXJjLlRyYW5zbGF0ZShyZWYgcG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxGaXh0dXJlPiBmaXh0dXJlcyA9IG5ldyBMaXN0PEZpeHR1cmU+KGFyYy5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2xvc2VkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaXh0dXJlcy5BZGQoQXR0YWNoTG9vcFNoYXBlKGFyYywgYm9keSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IGFyYy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmaXh0dXJlcy5BZGQoQXR0YWNoRWRnZShhcmNbaV0sIGFyY1tpIC0gMV0sIGJvZHkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpeHR1cmVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PEZpeHR1cmU+IEF0dGFjaFNvbGlkQXJjKGZsb2F0IGRlbnNpdHksIGZsb2F0IHJhZGlhbnMsIGludCBzaWRlcywgZmxvYXQgcmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvc2l0aW9uLCBmbG9hdCBhbmdsZSwgQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgYXJjID0gUG9seWdvblRvb2xzLkNyZWF0ZUFyYyhyYWRpYW5zLCBzaWRlcywgcmFkaXVzKTtcclxuICAgICAgICAgICAgYXJjLlJvdGF0ZSgoTWF0aEhlbHBlci5QaSAtIHJhZGlhbnMpIC8gMiArIGFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIGFyYy5UcmFuc2xhdGUocmVmIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vQ2xvc2UgdGhlIGFyY1xyXG4gICAgICAgICAgICBhcmMuQWRkKGFyY1swXSk7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiB0cmlhbmdsZXMgPSBFYXJjbGlwRGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24oYXJjKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBBdHRhY2hDb21wb3VuZFBvbHlnb24odHJpYW5nbGVzLCBkZW5zaXR5LCBib2R5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5GYWN0b3JpZXNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEFuIGVhc3kgdG8gdXNlIGZhY3RvcnkgZm9yIHVzaW5nIGpvaW50cy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEpvaW50RmFjdG9yeVxyXG4gICAge1xyXG4gICAgICAgICNyZWdpb24gUmV2b2x1dGUgSm9pbnRcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgcmV2b2x1dGUgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsQW5jaG9yQlwiPlRoZSBhbmNob3Igb2YgYm9keUIgaW4gbG9jYWwgY29vcmRpbmF0ZXM8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBSZXZvbHV0ZUpvaW50IENyZWF0ZVJldm9sdXRlSm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbEFuY2hvckIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIGxvY2FsYW5jaG9yQSA9IGJvZHlBLkdldExvY2FsUG9pbnQoYm9keUIuR2V0V29ybGRQb2ludChsb2NhbEFuY2hvckIpKTtcclxuICAgICAgICAgICAgUmV2b2x1dGVKb2ludCBqb2ludCA9IG5ldyBSZXZvbHV0ZUpvaW50KGJvZHlBLCBib2R5QiwgbG9jYWxhbmNob3JBLCBsb2NhbEFuY2hvckIpO1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSByZXZvbHV0ZSBqb2ludCBhbmQgYWRkcyBpdCB0byB0aGUgd29ybGRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFuY2hvclwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFJldm9sdXRlSm9pbnQgQ3JlYXRlUmV2b2x1dGVKb2ludChXb3JsZCB3b3JsZCwgQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBhbmNob3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBSZXZvbHV0ZUpvaW50IGpvaW50ID0gQ3JlYXRlUmV2b2x1dGVKb2ludChib2R5QSwgYm9keUIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KGpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIHRoZSBmaXhlZCByZXZvbHV0ZSBqb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkXCI+VGhlIHdvcmxkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keVwiPlRoZSBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFuY2hvclwiPlRoZSBib2R5IGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkQW5jaG9yXCI+VGhlIHdvcmxkIGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXhlZFJldm9sdXRlSm9pbnQgQ3JlYXRlRml4ZWRSZXZvbHV0ZUpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHksIFZlY3RvcjIgYm9keUFuY2hvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB3b3JsZEFuY2hvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeGVkUmV2b2x1dGVKb2ludCBmaXhlZFJldm9sdXRlSm9pbnQgPSBuZXcgRml4ZWRSZXZvbHV0ZUpvaW50KGJvZHksIGJvZHlBbmNob3IsIHdvcmxkQW5jaG9yKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoZml4ZWRSZXZvbHV0ZUpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpeGVkUmV2b2x1dGVKb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBXZWxkIEpvaW50XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIHdlbGQgam9pbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBXZWxkSm9pbnQgQ3JlYXRlV2VsZEpvaW50KEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxBbmNob3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBXZWxkSm9pbnQgam9pbnQgPSBuZXcgV2VsZEpvaW50KGJvZHlBLCBib2R5QiwgYm9keUEuR2V0TG9jYWxQb2ludChsb2NhbEFuY2hvciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuR2V0TG9jYWxQb2ludChsb2NhbEFuY2hvcikpO1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSB3ZWxkIGpvaW50IGFuZCBhZGRzIGl0IHRvIHRoZSB3b3JsZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid29ybGRcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxhbmNob3JCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgV2VsZEpvaW50IENyZWF0ZVdlbGRKb2ludChXb3JsZCB3b3JsZCwgQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbGFuY2hvckIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBXZWxkSm9pbnQgam9pbnQgPSBDcmVhdGVXZWxkSm9pbnQoYm9keUEsIGJvZHlCLCBsb2NhbGFuY2hvckIpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChqb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgV2VsZEpvaW50IENyZWF0ZVdlbGRKb2ludChXb3JsZCB3b3JsZCwgQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbEFuY2hvckEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxBbmNob3JCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgV2VsZEpvaW50IHdlbGRKb2ludCA9IG5ldyBXZWxkSm9pbnQoYm9keUEsIGJvZHlCLCBsb2NhbEFuY2hvckEsIGxvY2FsQW5jaG9yQik7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KHdlbGRKb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWxkSm9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gUHJpc21hdGljIEpvaW50XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIHByc2ltYXRpYyBqb2ludFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbGFuY2hvckJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBQcmlzbWF0aWNKb2ludCBDcmVhdGVQcmlzbWF0aWNKb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGxvY2FsYW5jaG9yQiwgVmVjdG9yMiBheGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBsb2NhbGFuY2hvckEgPSBib2R5QS5HZXRMb2NhbFBvaW50KGJvZHlCLkdldFdvcmxkUG9pbnQobG9jYWxhbmNob3JCKSk7XHJcbiAgICAgICAgICAgIFByaXNtYXRpY0pvaW50IGpvaW50ID0gbmV3IFByaXNtYXRpY0pvaW50KGJvZHlBLCBib2R5QiwgbG9jYWxhbmNob3JBLCBsb2NhbGFuY2hvckIsIGF4aXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBwcmlzbWF0aWMgam9pbnQgYW5kIGFkZHMgaXQgdG8gdGhlIHdvcmxkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbGFuY2hvckJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBQcmlzbWF0aWNKb2ludCBDcmVhdGVQcmlzbWF0aWNKb2ludChXb3JsZCB3b3JsZCwgQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbGFuY2hvckIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQcmlzbWF0aWNKb2ludCBqb2ludCA9IENyZWF0ZVByaXNtYXRpY0pvaW50KGJvZHlBLCBib2R5QiwgbG9jYWxhbmNob3JCLCBheGlzKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoam9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeGVkUHJpc21hdGljSm9pbnQgQ3JlYXRlRml4ZWRQcmlzbWF0aWNKb2ludChXb3JsZCB3b3JsZCwgQm9keSBib2R5LCBWZWN0b3IyIHdvcmxkQW5jaG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeGVkUHJpc21hdGljSm9pbnQgam9pbnQgPSBuZXcgRml4ZWRQcmlzbWF0aWNKb2ludChib2R5LCB3b3JsZEFuY2hvciwgYXhpcyk7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KGpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIExpbmUgSm9pbnRcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgbGluZSBqb2ludFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhbmNob3JcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaW5lSm9pbnQgQ3JlYXRlTGluZUpvaW50KEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgYW5jaG9yLCBWZWN0b3IyIGF4aXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaW5lSm9pbnQgam9pbnQgPSBuZXcgTGluZUpvaW50KGJvZHlBLCBib2R5QiwgYW5jaG9yLCBheGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgbGluZSBqb2ludCBhbmQgYWRkcyBpdCB0byB0aGUgd29ybGRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsYW5jaG9yQlwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYXhpc1wiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpbmVKb2ludCBDcmVhdGVMaW5lSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxhbmNob3JCLCBWZWN0b3IyIGF4aXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaW5lSm9pbnQgam9pbnQgPSBDcmVhdGVMaW5lSm9pbnQoYm9keUEsIGJvZHlCLCBsb2NhbGFuY2hvckIsIGF4aXMpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChqb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBBbmdsZSBKb2ludFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYW4gYW5nbGUgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPlRoZSB3b3JsZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+VGhlIGZpcnN0IGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPlRoZSBzZWNvbmQgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBBbmdsZUpvaW50IENyZWF0ZUFuZ2xlSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBbmdsZUpvaW50IGFuZ2xlSm9pbnQgPSBuZXcgQW5nbGVKb2ludChib2R5QSwgYm9keUIpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChhbmdsZUpvaW50KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhbmdsZUpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgZml4ZWQgYW5nbGUgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPlRoZSB3b3JsZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlcIj5UaGUgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXhlZEFuZ2xlSm9pbnQgQ3JlYXRlRml4ZWRBbmdsZUpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGaXhlZEFuZ2xlSm9pbnQgYW5nbGVKb2ludCA9IG5ldyBGaXhlZEFuZ2xlSm9pbnQoYm9keSk7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KGFuZ2xlSm9pbnQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFuZ2xlSm9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gRGlzdGFuY2UgSm9pbnRcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBEaXN0YW5jZUpvaW50IENyZWF0ZURpc3RhbmNlSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgYW5jaG9yQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGFuY2hvckIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEaXN0YW5jZUpvaW50IGRpc3RhbmNlSm9pbnQgPSBuZXcgRGlzdGFuY2VKb2ludChib2R5QSwgYm9keUIsIGFuY2hvckEsIGFuY2hvckIpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChkaXN0YW5jZUpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlSm9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeGVkRGlzdGFuY2VKb2ludCBDcmVhdGVGaXhlZERpc3RhbmNlSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keSwgVmVjdG9yMiBsb2NhbEFuY2hvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB3b3JsZEFuY2hvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeGVkRGlzdGFuY2VKb2ludCBkaXN0YW5jZUpvaW50ID0gbmV3IEZpeGVkRGlzdGFuY2VKb2ludChib2R5LCBsb2NhbEFuY2hvciwgd29ybGRBbmNob3IpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChkaXN0YW5jZUpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlSm9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gRnJpY3Rpb24gSm9pbnRcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGcmljdGlvbkpvaW50IENyZWF0ZUZyaWN0aW9uSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgYW5jaG9yQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGFuY2hvckIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGcmljdGlvbkpvaW50IGZyaWN0aW9uSm9pbnQgPSBuZXcgRnJpY3Rpb25Kb2ludChib2R5QSwgYm9keUIsIGFuY2hvckEsIGFuY2hvckIpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChmcmljdGlvbkpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZyaWN0aW9uSm9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeGVkRnJpY3Rpb25Kb2ludCBDcmVhdGVGaXhlZEZyaWN0aW9uSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keSwgVmVjdG9yMiBib2R5QW5jaG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRml4ZWRGcmljdGlvbkpvaW50IGZyaWN0aW9uSm9pbnQgPSBuZXcgRml4ZWRGcmljdGlvbkpvaW50KGJvZHksIGJvZHlBbmNob3IpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChmcmljdGlvbkpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZyaWN0aW9uSm9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gR2VhciBKb2ludFxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEdlYXJKb2ludCBDcmVhdGVHZWFySm9pbnQoV29ybGQgd29ybGQsIEpvaW50IGpvaW50QSwgSm9pbnQgam9pbnRCLCBmbG9hdCByYXRpbylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEdlYXJKb2ludCBnZWFySm9pbnQgPSBuZXcgR2VhckpvaW50KGpvaW50QSwgam9pbnRCLCByYXRpbyk7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KGdlYXJKb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBnZWFySm9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gUHVsbGV5IEpvaW50XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUHVsbGV5Sm9pbnQgQ3JlYXRlUHVsbGV5Sm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgZ3JvdW5kQW5jaG9yQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZ3JvdW5kQW5jaG9yQiwgVmVjdG9yMiBhbmNob3JBLCBWZWN0b3IyIGFuY2hvckIsIGZsb2F0IHJhdGlvKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUHVsbGV5Sm9pbnQgcHVsbGV5Sm9pbnQgPSBuZXcgUHVsbGV5Sm9pbnQoYm9keUEsIGJvZHlCLCBncm91bmRBbmNob3JBLCBncm91bmRBbmNob3JCLCBhbmNob3JBLCBhbmNob3JCLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpbyk7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KHB1bGxleUpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHB1bGxleUpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIFNsaWRlciBKb2ludFxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFNsaWRlckpvaW50IENyZWF0ZVNsaWRlckpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGFuY2hvckEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGFuY2hvckIsIGZsb2F0IG1pbkxlbmd0aCwgZmxvYXQgbWF4TGVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2xpZGVySm9pbnQgc2xpZGVySm9pbnQgPSBuZXcgU2xpZGVySm9pbnQoYm9keUEsIGJvZHlCLCBhbmNob3JBLCBhbmNob3JCLCBtaW5MZW5ndGgsIG1heExlbmd0aCk7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KHNsaWRlckpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNsaWRlckpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3Ncclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBTZXR0aW5nc1xyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBNYXhGbG9hdCA9IDMuNDAyODIzNDY2ZSszOGY7XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IEVwc2lsb24gPSAxLjE5MjA5Mjg5NmUtMDdmO1xyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBQaSA9IDMuMTQxNTkyNjUzNTlmO1xyXG5cclxuICAgICAgICAvLyBDb21tb25cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFbmFibGluZyBkaWFnbmlzdGljcyBjYXVzZXMgdGhlIGVuZ2luZSB0byBnYXRoZXIgdGltaW5nIGluZm9ybWF0aW9uLlxyXG4gICAgICAgIC8vLyBZb3UgY2FuIHNlZSBob3cgbXVjaCB0aW1lIGl0IHRvb2sgdG8gc29sdmUgdGhlIGNvbnRhY3RzLCBzb2x2ZSBDQ0RcclxuICAgICAgICAvLy8gYW5kIHVwZGF0ZSB0aGUgY29udHJvbGxlcnMuXHJcbiAgICAgICAgLy8vIE5PVEU6IElmIHlvdSBhcmUgdXNpbmcgYSBkZWJ1ZyB2aWV3IHRoYXQgc2hvd3MgcGVyZm9ybWFuY2UgY291bnRlcnMsXHJcbiAgICAgICAgLy8vIHlvdSBtaWdodCB3YW50IHRvIGVuYWJsZSB0aGlzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIEVuYWJsZURpYWdub3N0aWNzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbnVtYmVyIG9mIHZlbG9jaXR5IGl0ZXJhdGlvbnMgdXNlZCBpbiB0aGUgc29sdmVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgVmVsb2NpdHlJdGVyYXRpb25zID0gODtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbnVtYmVyIG9mIHBvc2l0aW9uIGl0ZXJhdGlvbnMgdXNlZCBpbiB0aGUgc29sdmVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgUG9zaXRpb25JdGVyYXRpb25zID0gMztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFbmFibGUvRGlzYWJsZSBDb250aW51b3VzIENvbGxpc2lvbiBEZXRlY3Rpb24gKENDRClcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBDb250aW51b3VzUGh5c2ljcyA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG51bWJlciBvZiB2ZWxvY2l0eSBpdGVyYXRpb25zIGluIHRoZSBUT0kgc29sdmVyXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGludCBUT0lWZWxvY2l0eUl0ZXJhdGlvbnMgPSA4O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBudW1iZXIgb2YgcG9zaXRpb24gaXRlcmF0aW9ucyBpbiB0aGUgVE9JIHNvbHZlclxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgVE9JUG9zaXRpb25JdGVyYXRpb25zID0gMjA7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTWF4aW11bSBudW1iZXIgb2Ygc3ViLXN0ZXBzIHBlciBjb250YWN0IGluIGNvbnRpbnVvdXMgcGh5c2ljcyBzaW11bGF0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGludCBNYXhTdWJTdGVwcyA9IDg7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRW5hYmxlL0Rpc2FibGUgd2FybXN0YXJ0aW5nXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgRW5hYmxlV2FybXN0YXJ0aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFbmFibGUvRGlzYWJsZSBzbGVlcGluZ1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIEFsbG93U2xlZXAgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcyBvbiBhIGNvbnZleCBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgTWF4UG9seWdvblZlcnRpY2VzID0gMzA7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBoYXMgYSBkaWZmZXJlbnQgd2F5IG9mIGZpbHRlcmluZyBmaXh0dXJlcyB0aGFuIEJveDJkLlxyXG4gICAgICAgIC8vLyBXZSBoYXZlIGJvdGggRlBFIGFuZCBCb3gyRCBmaWx0ZXJpbmcgaW4gdGhlIGVuZ2luZS4gSWYgeW91IGFyZSB1cGdyYWRpbmdcclxuICAgICAgICAvLy8gZnJvbSBlYXJsaWVyIHZlcnNpb25zIG9mIEZQRSwgc2V0IHRoaXMgdG8gdHJ1ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBVc2VGUEVDb2xsaXNpb25DYXRlZ29yaWVzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnNlcnZlIG1lbW9yeSBtYWtlcyBzdXJlIHRoYXQgb2JqZWN0cyBhcmUgdXNlZCBieSByZWZlcmVuY2UgaW5zdGVhZCBvZiBjbG9uZWQuXHJcbiAgICAgICAgLy8vIFdoZW4geW91IGdpdmUgYSB2ZXJ0aWNlcyBjb2xsZWN0aW9uIHRvIGEgUG9seWdvblNoYXBlLCBpdCB3aWxsIGJ5IGRlZmF1bHQgY29weSB0aGUgdmVydGljZXNcclxuICAgICAgICAvLy8gaW5zdGVhZCBvZiB1c2luZyB0aGUgb3JpZ2luYWwgcmVmZXJlbmNlLiBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IG9iamVjdHMgbW9kaWZpZWQgb3V0c2lkZSB0aGUgZW5naW5lXHJcbiAgICAgICAgLy8vIGRvZXMgbm90IGFmZmVjdCB0aGUgZW5naW5lIGl0c2VsZiwgaG93ZXZlciwgdGhpcyB1c2VzIGV4dHJhIG1lbW9yeS4gVGhpcyBiZWhhdmlvclxyXG4gICAgICAgIC8vLyBjYW4gYmUgdHVybmVkIG9mZiBieSBzZXR0aW5nIENvbnNlcnZlTWVtb3J5IHRvIHRydWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgYm9vbCBDb25zZXJ2ZU1lbW9yeSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb250YWN0IHBvaW50cyBiZXR3ZWVuIHR3byBjb252ZXggc2hhcGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGludCBNYXhNYW5pZm9sZFBvaW50cyA9IDI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBpcyB1c2VkIHRvIGZhdHRlbiBBQUJCcyBpbiB0aGUgZHluYW1pYyB0cmVlLiBUaGlzIGFsbG93cyBwcm94aWVzXHJcbiAgICAgICAgLy8vIHRvIG1vdmUgYnkgYSBzbWFsbCBhbW91bnQgd2l0aG91dCB0cmlnZ2VyaW5nIGEgdHJlZSBhZGp1c3RtZW50LlxyXG4gICAgICAgIC8vLyBUaGlzIGlzIGluIG1ldGVycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBBQUJCRXh0ZW5zaW9uID0gMC4xZjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGlzIHVzZWQgdG8gZmF0dGVuIEFBQkJzIGluIHRoZSBkeW5hbWljIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBwcmVkaWN0XHJcbiAgICAgICAgLy8vIHRoZSBmdXR1cmUgcG9zaXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgZGlzcGxhY2VtZW50LlxyXG4gICAgICAgIC8vLyBUaGlzIGlzIGEgZGltZW5zaW9ubGVzcyBtdWx0aXBsaWVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IEFBQkJNdWx0aXBsaWVyID0gMi4wZjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBIHNtYWxsIGxlbmd0aCB1c2VkIGFzIGEgY29sbGlzaW9uIGFuZCBjb25zdHJhaW50IHRvbGVyYW5jZS4gVXN1YWxseSBpdCBpc1xyXG4gICAgICAgIC8vLyBjaG9zZW4gdG8gYmUgbnVtZXJpY2FsbHkgc2lnbmlmaWNhbnQsIGJ1dCB2aXN1YWxseSBpbnNpZ25pZmljYW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IExpbmVhclNsb3AgPSAwLjAwNWY7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQSBzbWFsbCBhbmdsZSB1c2VkIGFzIGEgY29sbGlzaW9uIGFuZCBjb25zdHJhaW50IHRvbGVyYW5jZS4gVXN1YWxseSBpdCBpc1xyXG4gICAgICAgIC8vLyBjaG9zZW4gdG8gYmUgbnVtZXJpY2FsbHkgc2lnbmlmaWNhbnQsIGJ1dCB2aXN1YWxseSBpbnNpZ25pZmljYW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IEFuZ3VsYXJTbG9wID0gKDIuMGYgLyAxODAuMGYgKiBQaSk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbi9lZGdlIHNoYXBlIHNraW4uIFRoaXMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC4gTWFraW5nXHJcbiAgICAgICAgLy8vIHRoaXMgc21hbGxlciBtZWFucyBwb2x5Z29ucyB3aWxsIGhhdmUgYW4gaW5zdWZmaWNpZW50IGJ1ZmZlciBmb3IgY29udGludW91cyBjb2xsaXNpb24uXHJcbiAgICAgICAgLy8vIE1ha2luZyBpdCBsYXJnZXIgbWF5IGNyZWF0ZSBhcnRpZmFjdHMgZm9yIHZlcnRleCBjb2xsaXNpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgUG9seWdvblJhZGl1cyA9ICgyLjBmICogTGluZWFyU2xvcCk7XHJcblxyXG4gICAgICAgIC8vIER5bmFtaWNzXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTWF4aW11bSBudW1iZXIgb2YgY29udGFjdHMgdG8gYmUgaGFuZGxlZCB0byBzb2x2ZSBhIFRPSSBpbXBhY3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgaW50IE1heFRPSUNvbnRhY3RzID0gNTA7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQSB2ZWxvY2l0eSB0aHJlc2hvbGQgZm9yIGVsYXN0aWMgY29sbGlzaW9ucy4gQW55IGNvbGxpc2lvbiB3aXRoIGEgcmVsYXRpdmUgbGluZWFyXHJcbiAgICAgICAgLy8vIHZlbG9jaXR5IGJlbG93IHRoaXMgdGhyZXNob2xkIHdpbGwgYmUgdHJlYXRlZCBhcyBpbmVsYXN0aWMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgVmVsb2NpdHlUaHJlc2hvbGQgPSAxLjBmO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIGxpbmVhciBwb3NpdGlvbiBjb3JyZWN0aW9uIHVzZWQgd2hlbiBzb2x2aW5nIGNvbnN0cmFpbnRzLiBUaGlzIGhlbHBzIHRvXHJcbiAgICAgICAgLy8vIHByZXZlbnQgb3ZlcnNob290LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IE1heExpbmVhckNvcnJlY3Rpb24gPSAwLjJmO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIGFuZ3VsYXIgcG9zaXRpb24gY29ycmVjdGlvbiB1c2VkIHdoZW4gc29sdmluZyBjb25zdHJhaW50cy4gVGhpcyBoZWxwcyB0b1xyXG4gICAgICAgIC8vLyBwcmV2ZW50IG92ZXJzaG9vdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBNYXhBbmd1bGFyQ29ycmVjdGlvbiA9ICg4LjBmIC8gMTgwLjBmICogUGkpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgc2NhbGUgZmFjdG9yIGNvbnRyb2xzIGhvdyBmYXN0IG92ZXJsYXAgaXMgcmVzb2x2ZWQuIElkZWFsbHkgdGhpcyB3b3VsZCBiZSAxIHNvXHJcbiAgICAgICAgLy8vIHRoYXQgb3ZlcmxhcCBpcyByZW1vdmVkIGluIG9uZSB0aW1lIHN0ZXAuIEhvd2V2ZXIgdXNpbmcgdmFsdWVzIGNsb3NlIHRvIDEgb2Z0ZW4gbGVhZFxyXG4gICAgICAgIC8vLyB0byBvdmVyc2hvb3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgQ29udGFjdEJhdW1nYXJ0ZSA9IDAuMmY7XHJcblxyXG4gICAgICAgIC8vIFNsZWVwXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIHRpbWUgdGhhdCBhIGJvZHkgbXVzdCBiZSBzdGlsbCBiZWZvcmUgaXQgd2lsbCBnbyB0byBzbGVlcC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBUaW1lVG9TbGVlcCA9IDAuNWY7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQSBib2R5IGNhbm5vdCBzbGVlcCBpZiBpdHMgbGluZWFyIHZlbG9jaXR5IGlzIGFib3ZlIHRoaXMgdG9sZXJhbmNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IExpbmVhclNsZWVwVG9sZXJhbmNlID0gMC4wMWY7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQSBib2R5IGNhbm5vdCBzbGVlcCBpZiBpdHMgYW5ndWxhciB2ZWxvY2l0eSBpcyBhYm92ZSB0aGlzIHRvbGVyYW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBBbmd1bGFyU2xlZXBUb2xlcmFuY2UgPSAoMi4wZiAvIDE4MC4wZiAqIFBpKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBsaW5lYXIgdmVsb2NpdHkgb2YgYSBib2R5LiBUaGlzIGxpbWl0IGlzIHZlcnkgbGFyZ2UgYW5kIGlzIHVzZWRcclxuICAgICAgICAvLy8gdG8gcHJldmVudCBudW1lcmljYWwgcHJvYmxlbXMuIFlvdSBzaG91bGRuJ3QgbmVlZCB0byBhZGp1c3QgdGhpcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBNYXhUcmFuc2xhdGlvbiA9IDIuMGY7XHJcblxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBNYXhUcmFuc2xhdGlvblNxdWFyZWQgPSAoTWF4VHJhbnNsYXRpb24gKiBNYXhUcmFuc2xhdGlvbik7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG1heGltdW0gYW5ndWxhciB2ZWxvY2l0eSBvZiBhIGJvZHkuIFRoaXMgbGltaXQgaXMgdmVyeSBsYXJnZSBhbmQgaXMgdXNlZFxyXG4gICAgICAgIC8vLyB0byBwcmV2ZW50IG51bWVyaWNhbCBwcm9ibGVtcy4gWW91IHNob3VsZG4ndCBuZWVkIHRvIGFkanVzdCB0aGlzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IE1heFJvdGF0aW9uID0gKDAuNWYgKiBQaSk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBNYXhSb3RhdGlvblNxdWFyZWQgPSAoTWF4Um90YXRpb24gKiBNYXhSb3RhdGlvbik7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRnJpY3Rpb24gbWl4aW5nIGxhdy4gRmVlbCBmcmVlIHRvIGN1c3RvbWl6ZSB0aGlzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZnJpY3Rpb24xXCI+VGhlIGZyaWN0aW9uMS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZyaWN0aW9uMlwiPlRoZSBmcmljdGlvbjIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgTWl4RnJpY3Rpb24oZmxvYXQgZnJpY3Rpb24xLCBmbG9hdCBmcmljdGlvbjIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKGZsb2F0KSBNYXRoLlNxcnQoZnJpY3Rpb24xICogZnJpY3Rpb24yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVzdGl0dXRpb24gbWl4aW5nIGxhdy4gRmVlbCBmcmVlIHRvIGN1c3RvbWl6ZSB0aGlzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzdGl0dXRpb24xXCI+VGhlIHJlc3RpdHV0aW9uMS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3RpdHV0aW9uMlwiPlRoZSByZXN0aXR1dGlvbjIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgTWl4UmVzdGl0dXRpb24oZmxvYXQgcmVzdGl0dXRpb24xLCBmbG9hdCByZXN0aXR1dGlvbjIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdGl0dXRpb24xID4gcmVzdGl0dXRpb24yID8gcmVzdGl0dXRpb24xIDogcmVzdGl0dXRpb24yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5HcmFwaGljcztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5VdGlsaXR5XHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBDYW1lcmEyRFxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgY29uc3QgZmxvYXQgX21pblpvb20gPSAwLjAyZjtcclxuICAgICAgICBwcml2YXRlIGNvbnN0IGZsb2F0IF9tYXhab29tID0gMjBmO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIEdyYXBoaWNzRGV2aWNlIF9ncmFwaGljcztcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBNYXRyaXggX2JhdGNoVmlldztcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9jdXJyZW50UG9zaXRpb247XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2N1cnJlbnRSb3RhdGlvbjtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfY3VycmVudFpvb207XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9tYXhQb3NpdGlvbjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXhSb3RhdGlvbjtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX21pblBvc2l0aW9uO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21pblJvdGF0aW9uO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfcG9zaXRpb25UcmFja2luZztcclxuICAgICAgICBwcml2YXRlIE1hdHJpeCBfcHJvamVjdGlvbjtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX3JvdGF0aW9uVHJhY2tpbmc7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF90YXJnZXRQb3NpdGlvbjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF90YXJnZXRSb3RhdGlvbjtcclxuICAgICAgICBwcml2YXRlIEJvZHkgX3RyYWNraW5nQm9keTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3RyYW5zbGF0ZUNlbnRlcjtcclxuICAgICAgICBwcml2YXRlIE1hdHJpeCBfdmlldztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBDYW1lcmEyRCBjbGFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImdyYXBoaWNzXCI+PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgQ2FtZXJhMkQoR3JhcGhpY3NEZXZpY2UgZ3JhcGhpY3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfZ3JhcGhpY3MgPSBncmFwaGljcztcclxuICAgICAgICAgICAgX3Byb2plY3Rpb24gPSBNYXRyaXguQ3JlYXRlT3J0aG9ncmFwaGljT2ZmQ2VudGVyKDBmLCBDb252ZXJ0VW5pdHMuVG9TaW1Vbml0cyhfZ3JhcGhpY3MuVmlld3BvcnQuV2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVydFVuaXRzLlRvU2ltVW5pdHMoX2dyYXBoaWNzLlZpZXdwb3J0LkhlaWdodCksIDBmLCAwZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFmKTtcclxuICAgICAgICAgICAgX3ZpZXcgPSBNYXRyaXguSWRlbnRpdHk7XHJcbiAgICAgICAgICAgIF9iYXRjaFZpZXcgPSBNYXRyaXguSWRlbnRpdHk7XHJcblxyXG4gICAgICAgICAgICBfdHJhbnNsYXRlQ2VudGVyID0gbmV3IFZlY3RvcjIoQ29udmVydFVuaXRzLlRvU2ltVW5pdHMoX2dyYXBoaWNzLlZpZXdwb3J0LldpZHRoIC8gMmYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVydFVuaXRzLlRvU2ltVW5pdHMoX2dyYXBoaWNzLlZpZXdwb3J0LkhlaWdodCAvIDJmKSk7XHJcblxyXG4gICAgICAgICAgICBSZXNldENhbWVyYSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIE1hdHJpeCBWaWV3XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2JhdGNoVmlldzsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIE1hdHJpeCBTaW1WaWV3XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3ZpZXc7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXggU2ltUHJvamVjdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9wcm9qZWN0aW9uOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBjYW1lcmEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBQb3NpdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIENvbnZlcnRVbml0cy5Ub0Rpc3BsYXlVbml0cyhfY3VycmVudFBvc2l0aW9uKTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3RhcmdldFBvc2l0aW9uID0gQ29udmVydFVuaXRzLlRvU2ltVW5pdHModmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9taW5Qb3NpdGlvbiAhPSBfbWF4UG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMi5DbGFtcChyZWYgX3RhcmdldFBvc2l0aW9uLCByZWYgX21pblBvc2l0aW9uLCByZWYgX21heFBvc2l0aW9uLCBvdXQgX3RhcmdldFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZnVydGhlc3QgdXAsIGFuZCB0aGUgZnVydGhlc3QgbGVmdCB0aGUgY2FtZXJhIGNhbiBnby5cclxuICAgICAgICAvLy8gaWYgdGhpcyB2YWx1ZSBlcXVhbHMgbWF4UG9zaXRpb24sIHRoZW4gbm8gY2xhbXBpbmcgd2lsbCBiZSBcclxuICAgICAgICAvLy8gYXBwbGllZCAodW5sZXNzIHlvdSBvdmVycmlkZSB0aGF0IGZ1bmN0aW9uKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIE1pblBvc2l0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQ29udmVydFVuaXRzLlRvRGlzcGxheVVuaXRzKF9taW5Qb3NpdGlvbik7IH1cclxuICAgICAgICAgICAgc2V0IHsgX21pblBvc2l0aW9uID0gQ29udmVydFVuaXRzLlRvU2ltVW5pdHModmFsdWUpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIHRoZSBmdXJ0aGVzdCBkb3duLCBhbmQgdGhlIGZ1cnRoZXN0IHJpZ2h0IHRoZSBjYW1lcmEgd2lsbCBnby5cclxuICAgICAgICAvLy8gaWYgdGhpcyB2YWx1ZSBlcXVhbHMgbWluUG9zaXRpb24sIHRoZW4gbm8gY2xhbXBpbmcgd2lsbCBiZSBcclxuICAgICAgICAvLy8gYXBwbGllZCAodW5sZXNzIHlvdSBvdmVycmlkZSB0aGF0IGZ1bmN0aW9uKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIE1heFBvc2l0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQ29udmVydFVuaXRzLlRvRGlzcGxheVVuaXRzKF9tYXhQb3NpdGlvbik7IH1cclxuICAgICAgICAgICAgc2V0IHsgX21heFBvc2l0aW9uID0gQ29udmVydFVuaXRzLlRvU2ltVW5pdHModmFsdWUpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBjdXJyZW50IHJvdGF0aW9uIG9mIHRoZSBjYW1lcmEgaW4gcmFkaWFucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSb3RhdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9jdXJyZW50Um90YXRpb247IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90YXJnZXRSb3RhdGlvbiA9IHZhbHVlICUgTWF0aEhlbHBlci5Ud29QaTtcclxuICAgICAgICAgICAgICAgIGlmIChfbWluUm90YXRpb24gIT0gX21heFJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF90YXJnZXRSb3RhdGlvbiA9IE1hdGhIZWxwZXIuQ2xhbXAoX3RhcmdldFJvdGF0aW9uLCBfbWluUm90YXRpb24sIF9tYXhSb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHJvdGF0aW9uIGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBtaW4gcm90YXRpb24uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWluUm90YXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbWluUm90YXRpb247IH1cclxuICAgICAgICAgICAgc2V0IHsgX21pblJvdGF0aW9uID0gTWF0aEhlbHBlci5DbGFtcCh2YWx1ZSwgLU1hdGhIZWxwZXIuUGksIDBmKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gcm90YXRpb24gaW4gcmFkaWFucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIG1heCByb3RhdGlvbi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhSb3RhdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhSb3RhdGlvbjsgfVxyXG4gICAgICAgICAgICBzZXQgeyBfbWF4Um90YXRpb24gPSBNYXRoSGVscGVyLkNsYW1wKHZhbHVlLCAwZiwgTWF0aEhlbHBlci5QaSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGN1cnJlbnQgcm90YXRpb24gb2YgdGhlIGNhbWVyYSBpbiByYWRpYW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFpvb21cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfY3VycmVudFpvb207IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9jdXJyZW50Wm9vbSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgX2N1cnJlbnRab29tID0gTWF0aEhlbHBlci5DbGFtcChfY3VycmVudFpvb20sIF9taW5ab29tLCBfbWF4Wm9vbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gdGhlIGJvZHkgdGhhdCB0aGlzIGNhbWVyYSBpcyBjdXJyZW50bHkgdHJhY2tpbmcuIFxyXG4gICAgICAgIC8vLyBOdWxsIGlmIG5vdCB0cmFja2luZyBhbnkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQm9keSBUcmFja2luZ0JvZHlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdHJhY2tpbmdCb2R5OyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdHJhY2tpbmdCb2R5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RyYWNraW5nQm9keSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9wb3NpdGlvblRyYWNraW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgRW5hYmxlUG9zaXRpb25UcmFja2luZ1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9wb3NpdGlvblRyYWNraW5nOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgX3RyYWNraW5nQm9keSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9wb3NpdGlvblRyYWNraW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfcG9zaXRpb25UcmFja2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBFbmFibGVSb3RhdGlvblRyYWNraW5nXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3JvdGF0aW9uVHJhY2tpbmc7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBfdHJhY2tpbmdCb2R5ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3JvdGF0aW9uVHJhY2tpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9yb3RhdGlvblRyYWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZVRyYWNraW5nXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRW5hYmxlUG9zaXRpb25UcmFja2luZyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgRW5hYmxlUm90YXRpb25UcmFja2luZyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNb3ZlQ2FtZXJhKFZlY3RvcjIgYW1vdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2N1cnJlbnRQb3NpdGlvbiArPSBhbW91bnQ7XHJcbiAgICAgICAgICAgIGlmIChfbWluUG9zaXRpb24gIT0gX21heFBvc2l0aW9uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyLkNsYW1wKHJlZiBfY3VycmVudFBvc2l0aW9uLCByZWYgX21pblBvc2l0aW9uLCByZWYgX21heFBvc2l0aW9uLCBvdXQgX2N1cnJlbnRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RhcmdldFBvc2l0aW9uID0gX2N1cnJlbnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgX3Bvc2l0aW9uVHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3JvdGF0aW9uVHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJvdGF0ZUNhbWVyYShmbG9hdCBhbW91bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfY3VycmVudFJvdGF0aW9uICs9IGFtb3VudDtcclxuICAgICAgICAgICAgaWYgKF9taW5Sb3RhdGlvbiAhPSBfbWF4Um90YXRpb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9jdXJyZW50Um90YXRpb24gPSBNYXRoSGVscGVyLkNsYW1wKF9jdXJyZW50Um90YXRpb24sIF9taW5Sb3RhdGlvbiwgX21heFJvdGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGFyZ2V0Um90YXRpb24gPSBfY3VycmVudFJvdGF0aW9uO1xyXG4gICAgICAgICAgICBfcG9zaXRpb25UcmFja2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfcm90YXRpb25UcmFja2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXNldHMgdGhlIGNhbWVyYSB0byBkZWZhdWx0IHZhbHVlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlc2V0Q2FtZXJhKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9jdXJyZW50UG9zaXRpb24gPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIF90YXJnZXRQb3NpdGlvbiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgX21pblBvc2l0aW9uID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBfbWF4UG9zaXRpb24gPSBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICBfY3VycmVudFJvdGF0aW9uID0gMGY7XHJcbiAgICAgICAgICAgIF90YXJnZXRSb3RhdGlvbiA9IDBmO1xyXG4gICAgICAgICAgICBfbWluUm90YXRpb24gPSAtTWF0aEhlbHBlci5QaTtcclxuICAgICAgICAgICAgX21heFJvdGF0aW9uID0gTWF0aEhlbHBlci5QaTtcclxuXHJcbiAgICAgICAgICAgIF9wb3NpdGlvblRyYWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF9yb3RhdGlvblRyYWNraW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBfY3VycmVudFpvb20gPSAxZjtcclxuXHJcbiAgICAgICAgICAgIFNldFZpZXcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEp1bXAyVGFyZ2V0KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9jdXJyZW50UG9zaXRpb24gPSBfdGFyZ2V0UG9zaXRpb247XHJcbiAgICAgICAgICAgIF9jdXJyZW50Um90YXRpb24gPSBfdGFyZ2V0Um90YXRpb247XHJcblxyXG4gICAgICAgICAgICBTZXRWaWV3KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgU2V0VmlldygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRyaXggbWF0Um90YXRpb24gPSBNYXRyaXguQ3JlYXRlUm90YXRpb25aKF9jdXJyZW50Um90YXRpb24pO1xyXG4gICAgICAgICAgICBNYXRyaXggbWF0Wm9vbSA9IE1hdHJpeC5DcmVhdGVTY2FsZShfY3VycmVudFpvb20pO1xyXG4gICAgICAgICAgICBWZWN0b3IzIHRyYW5zbGF0ZUNlbnRlciA9IG5ldyBWZWN0b3IzKF90cmFuc2xhdGVDZW50ZXIsIDBmKTtcclxuICAgICAgICAgICAgVmVjdG9yMyB0cmFuc2xhdGVCb2R5ID0gbmV3IFZlY3RvcjMoLV9jdXJyZW50UG9zaXRpb24sIDBmKTtcclxuXHJcbiAgICAgICAgICAgIF92aWV3ID0gTWF0cml4LkNyZWF0ZVRyYW5zbGF0aW9uKHRyYW5zbGF0ZUJvZHkpICpcclxuICAgICAgICAgICAgICAgICAgICBtYXRSb3RhdGlvbiAqXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Wm9vbSAqXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0cml4LkNyZWF0ZVRyYW5zbGF0aW9uKHRyYW5zbGF0ZUNlbnRlcik7XHJcblxyXG4gICAgICAgICAgICB0cmFuc2xhdGVDZW50ZXIgPSBDb252ZXJ0VW5pdHMuVG9EaXNwbGF5VW5pdHModHJhbnNsYXRlQ2VudGVyKTtcclxuICAgICAgICAgICAgdHJhbnNsYXRlQm9keSA9IENvbnZlcnRVbml0cy5Ub0Rpc3BsYXlVbml0cyh0cmFuc2xhdGVCb2R5KTtcclxuXHJcbiAgICAgICAgICAgIF9iYXRjaFZpZXcgPSBNYXRyaXguQ3JlYXRlVHJhbnNsYXRpb24odHJhbnNsYXRlQm9keSkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgbWF0Um90YXRpb24gKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgbWF0Wm9vbSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBNYXRyaXguQ3JlYXRlVHJhbnNsYXRpb24odHJhbnNsYXRlQ2VudGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTW92ZXMgdGhlIGNhbWVyYSBmb3J3YXJkIG9uZSB0aW1lc3RlcC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFVwZGF0ZShHYW1lVGltZSBnYW1lVGltZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfdHJhY2tpbmdCb2R5ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChfcG9zaXRpb25UcmFja2luZylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0UG9zaXRpb24gPSBfdHJhY2tpbmdCb2R5LlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbWluUG9zaXRpb24gIT0gX21heFBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMi5DbGFtcChyZWYgX3RhcmdldFBvc2l0aW9uLCByZWYgX21pblBvc2l0aW9uLCByZWYgX21heFBvc2l0aW9uLCBvdXQgX3RhcmdldFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoX3JvdGF0aW9uVHJhY2tpbmcpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RhcmdldFJvdGF0aW9uID0gLV90cmFja2luZ0JvZHkuUm90YXRpb24gJSBNYXRoSGVscGVyLlR3b1BpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbWluUm90YXRpb24gIT0gX21heFJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldFJvdGF0aW9uID0gTWF0aEhlbHBlci5DbGFtcChfdGFyZ2V0Um90YXRpb24sIF9taW5Sb3RhdGlvbiwgX21heFJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVmVjdG9yMiBkZWx0YSA9IF90YXJnZXRQb3NpdGlvbiAtIF9jdXJyZW50UG9zaXRpb247XHJcbiAgICAgICAgICAgIGZsb2F0IGRpc3RhbmNlID0gZGVsdGEuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YSAvPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmbG9hdCBpbmVydGlhO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAxMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGluZXJ0aWEgPSAoZmxvYXQpIE1hdGguUG93KGRpc3RhbmNlIC8gMTAuMCwgMi4wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGluZXJ0aWEgPSAxZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgcm90RGVsdGEgPSBfdGFyZ2V0Um90YXRpb24gLSBfY3VycmVudFJvdGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgcm90SW5lcnRpYTtcclxuICAgICAgICAgICAgaWYgKE1hdGguQWJzKHJvdERlbHRhKSA8IDVmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByb3RJbmVydGlhID0gKGZsb2F0KSBNYXRoLlBvdyhyb3REZWx0YSAvIDUuMCwgMi4wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJvdEluZXJ0aWEgPSAxZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5BYnMocm90RGVsdGEpID4gMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJvdERlbHRhIC89IChmbG9hdClNYXRoLkFicyhyb3REZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9jdXJyZW50UG9zaXRpb24gKz0gMTAwZiAqIGRlbHRhICogaW5lcnRpYSAqIChmbG9hdCkgZ2FtZVRpbWUuRWxhcHNlZEdhbWVUaW1lLlRvdGFsU2Vjb25kcztcclxuICAgICAgICAgICAgX2N1cnJlbnRSb3RhdGlvbiArPSA4MGYgKiByb3REZWx0YSAqIHJvdEluZXJ0aWEgKiAoZmxvYXQpIGdhbWVUaW1lLkVsYXBzZWRHYW1lVGltZS5Ub3RhbFNlY29uZHM7XHJcblxyXG4gICAgICAgICAgICBTZXRWaWV3KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBDb252ZXJ0U2NyZWVuVG9Xb3JsZChWZWN0b3IyIGxvY2F0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMyB0ID0gbmV3IFZlY3RvcjMobG9jYXRpb24sIDApO1xyXG5cclxuICAgICAgICAgICAgdCA9IF9ncmFwaGljcy5WaWV3cG9ydC5VbnByb2plY3QodCwgX3Byb2plY3Rpb24sIF92aWV3LCBNYXRyaXguSWRlbnRpdHkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHQuWCwgdC5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIENvbnZlcnRXb3JsZFRvU2NyZWVuKFZlY3RvcjIgbG9jYXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IzIHQgPSBuZXcgVmVjdG9yMyhsb2NhdGlvbiwgMCk7XHJcblxyXG4gICAgICAgICAgICB0ID0gX2dyYXBoaWNzLlZpZXdwb3J0LlByb2plY3QodCwgX3Byb2plY3Rpb24sIF92aWV3LCBNYXRyaXguSWRlbnRpdHkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHQuWCwgdC5ZKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgU3lzdGVtLlRleHQ7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5Db250ZW50O1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5HcmFwaGljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcmsuSW5wdXQ7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLklucHV0LlRvdWNoO1xyXG5cclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uLlBvbHlnb25NYW5pcHVsYXRpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5GYWN0b3JpZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLlV0aWxpdHk7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuVXRpbGl0eVxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIENvbW1vblxyXG4gICAge1xyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IEdldENvbXBvdW5kUG9seWdvblZlcnRpY2VzKFRleHR1cmUyRCBfcG9seWdvblRleHR1cmUsIGZsb2F0IF9zY2FsZSwgcmVmIFZlY3RvcjIgb3JpZ2luKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdWludFtdIGRhdGEgPSBuZXcgdWludFtfcG9seWdvblRleHR1cmUuV2lkdGggKiBfcG9seWdvblRleHR1cmUuSGVpZ2h0XTtcclxuICAgICAgICAgICAgX3BvbHlnb25UZXh0dXJlLkdldERhdGE8dWludD4oZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyB0ZXh0dXJlVmVydGljZXMgPSBQb2x5Z29uVG9vbHMuQ3JlYXRlUG9seWdvbihkYXRhLCBfcG9seWdvblRleHR1cmUuV2lkdGgsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgY2VudHJvaWQgPSAtdGV4dHVyZVZlcnRpY2VzLkdldENlbnRyb2lkKCk7XHJcbiAgICAgICAgICAgIHRleHR1cmVWZXJ0aWNlcy5UcmFuc2xhdGUocmVmIGNlbnRyb2lkKTtcclxuXHJcbiAgICAgICAgICAgIG9yaWdpbiA9IC1jZW50cm9pZDtcclxuXHJcbiAgICAgICAgICAgIHRleHR1cmVWZXJ0aWNlcyA9IFNpbXBsaWZ5VG9vbHMuUmVkdWNlQnlEaXN0YW5jZSh0ZXh0dXJlVmVydGljZXMsIDRmKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IGxpc3QgPSBCYXlheml0RGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24odGV4dHVyZVZlcnRpY2VzKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdmVydFNjYWxlID0gbmV3IFZlY3RvcjIoQ29udmVydFVuaXRzLlRvU2ltVW5pdHMoMSkpICogX3NjYWxlO1xyXG4gICAgICAgICAgICBmb3JlYWNoIChWZXJ0aWNlcyB2ZXJ0aWNlcyBpbiBsaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5TY2FsZShyZWYgdmVydFNjYWxlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIEdldFBvbHlnb25WZXJ0aWNlcyhUZXh0dXJlMkQgX3BvbHlnb25UZXh0dXJlLCBmbG9hdCBfc2NhbGUsIHJlZiBWZWN0b3IyIG9yaWdpbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHVpbnRbXSBkYXRhID0gbmV3IHVpbnRbX3BvbHlnb25UZXh0dXJlLldpZHRoICogX3BvbHlnb25UZXh0dXJlLkhlaWdodF07XHJcbiAgICAgICAgICAgIF9wb2x5Z29uVGV4dHVyZS5HZXREYXRhPHVpbnQ+KGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgVmVydGljZXMgdGV4dHVyZVZlcnRpY2VzID0gUG9seWdvblRvb2xzLkNyZWF0ZVBvbHlnb24oZGF0YSwgX3BvbHlnb25UZXh0dXJlLldpZHRoLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGNlbnRyb2lkID0gLXRleHR1cmVWZXJ0aWNlcy5HZXRDZW50cm9pZCgpO1xyXG4gICAgICAgICAgICB0ZXh0dXJlVmVydGljZXMuVHJhbnNsYXRlKHJlZiBjZW50cm9pZCk7XHJcblxyXG4gICAgICAgICAgICBvcmlnaW4gPSAtY2VudHJvaWQ7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlVmVydGljZXMgPSBTaW1wbGlmeVRvb2xzLkNvbGxpbmVhclNpbXBsaWZ5KHRleHR1cmVWZXJ0aWNlcywgMTBmKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2ZXJ0U2NhbGUgPSBuZXcgVmVjdG9yMihDb252ZXJ0VW5pdHMuVG9TaW1Vbml0cygxKSkgKiBfc2NhbGU7XHJcbiAgICAgICAgICAgIHRleHR1cmVWZXJ0aWNlcy5TY2FsZShyZWYgdmVydFNjYWxlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlVmVydGljZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIENvbG9yIEdldEFscGhhKGZsb2F0IG9wYWNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKG9wYWNpdHksIG9wYWNpdHksIG9wYWNpdHksIG9wYWNpdHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIElzUmVjdGFuZ2xlVG91Y2goVmVjdG9yMiBwb3NpdGlvbiwgVmVjdG9yMiBvcmlnaW4sIGZsb2F0IHJlY3RXaWR0aCwgZmxvYXQgcmVjdEhlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAocG9zaXRpb24uWCA+PSBvcmlnaW4uWCAtIHJlY3RXaWR0aCAvIDIgJiYgcG9zaXRpb24uWCA8PSBvcmlnaW4uWCArIHJlY3RXaWR0aCAvIDIgJiZcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLlkgPj0gb3JpZ2luLlkgLSByZWN0SGVpZ2h0IC8gMiAmJiBwb3NpdGlvbi5ZIDw9IG9yaWdpbi5ZICsgcmVjdEhlaWdodCAvIDIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJ1c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5VdGlsaXR5XHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBDb252ZXJ0IHVuaXRzIGJldHdlZW4gZGlzcGxheSBhbmQgc2ltdWxhdGlvbiB1bml0cy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIENvbnZlcnRVbml0c1xyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW8gPSAxMDBmO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IF9zaW1Vbml0c1RvRGlzcGxheVVuaXRzUmF0aW8gPSAxIC8gX2Rpc3BsYXlVbml0c1RvU2ltVW5pdHNSYXRpbztcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIFNldERpc3BsYXlVbml0VG9TaW1Vbml0UmF0aW8oZmxvYXQgZGlzcGxheVVuaXRzUGVyU2ltVW5pdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW8gPSBkaXNwbGF5VW5pdHNQZXJTaW1Vbml0O1xyXG4gICAgICAgICAgICBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvID0gMSAvIGRpc3BsYXlVbml0c1BlclNpbVVuaXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IFRvRGlzcGxheVVuaXRzKGZsb2F0IHNpbVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpbVVuaXRzICogX2Rpc3BsYXlVbml0c1RvU2ltVW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgVG9EaXNwbGF5VW5pdHMoaW50IHNpbVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpbVVuaXRzICogX2Rpc3BsYXlVbml0c1RvU2ltVW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBUb0Rpc3BsYXlVbml0cyhWZWN0b3IyIHNpbVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpbVVuaXRzICogX2Rpc3BsYXlVbml0c1RvU2ltVW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBUb0Rpc3BsYXlVbml0cyhyZWYgVmVjdG9yMiBzaW1Vbml0cywgb3V0IFZlY3RvcjIgZGlzcGxheVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMi5NdWx0aXBseShyZWYgc2ltVW5pdHMsIF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW8sIG91dCBkaXNwbGF5VW5pdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IzIFRvRGlzcGxheVVuaXRzKFZlY3RvcjMgc2ltVW5pdHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gc2ltVW5pdHMgKiBfZGlzcGxheVVuaXRzVG9TaW1Vbml0c1JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIFRvRGlzcGxheVVuaXRzKGZsb2F0IHgsIGZsb2F0IHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoeCwgeSkgKiBfZGlzcGxheVVuaXRzVG9TaW1Vbml0c1JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIFRvRGlzcGxheVVuaXRzKGZsb2F0IHgsIGZsb2F0IHksIG91dCBWZWN0b3IyIGRpc3BsYXlVbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlVbml0cyA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgZGlzcGxheVVuaXRzLlggPSB4ICogX2Rpc3BsYXlVbml0c1RvU2ltVW5pdHNSYXRpbztcclxuICAgICAgICAgICAgZGlzcGxheVVuaXRzLlkgPSB5ICogX2Rpc3BsYXlVbml0c1RvU2ltVW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgVG9TaW1Vbml0cyhmbG9hdCBkaXNwbGF5VW5pdHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheVVuaXRzICogX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgVG9TaW1Vbml0cyhkb3VibGUgZGlzcGxheVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChmbG9hdClkaXNwbGF5VW5pdHMgKiBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBUb1NpbVVuaXRzKGludCBkaXNwbGF5VW5pdHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheVVuaXRzICogX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBUb1NpbVVuaXRzKFZlY3RvcjIgZGlzcGxheVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlVbml0cyAqIF9zaW1Vbml0c1RvRGlzcGxheVVuaXRzUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjMgVG9TaW1Vbml0cyhWZWN0b3IzIGRpc3BsYXlVbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5VW5pdHMgKiBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIFRvU2ltVW5pdHMocmVmIFZlY3RvcjIgZGlzcGxheVVuaXRzLCBvdXQgVmVjdG9yMiBzaW1Vbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIuTXVsdGlwbHkocmVmIGRpc3BsYXlVbml0cywgX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbywgb3V0IHNpbVVuaXRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBUb1NpbVVuaXRzKGZsb2F0IHgsIGZsb2F0IHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoeCwgeSkgKiBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIFRvU2ltVW5pdHMoZG91YmxlIHgsIGRvdWJsZSB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKChmbG9hdCl4LCAoZmxvYXQpeSkgKiBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIFRvU2ltVW5pdHMoZmxvYXQgeCwgZmxvYXQgeSwgb3V0IFZlY3RvcjIgc2ltVW5pdHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaW1Vbml0cyA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgc2ltVW5pdHMuWCA9IHggKiBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvO1xyXG4gICAgICAgICAgICBzaW1Vbml0cy5ZID0geSAqIF9zaW1Vbml0c1RvRGlzcGxheVVuaXRzUmF0aW87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiI3JlZ2lvbiBGaWxlIERlc2NyaXB0aW9uXHJcblxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFBsYXllckluZGV4RXZlbnRBcmdzLmNzXHJcbi8vXHJcbi8vIFhOQSBDb21tdW5pdHkgR2FtZSBQbGF0Zm9ybVxyXG4vLyBDb3B5cmlnaHQgKEMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuI2VuZHJlZ2lvblxyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcmsuSW5wdXQuVG91Y2g7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuVXRpbGl0eVxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gRW51bSBkZXNjcmliZXMgdGhlIHNjcmVlbiB0cmFuc2l0aW9uIHN0YXRlLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBlbnVtIFNjcmVlblN0YXRlXHJcbiAgICB7XHJcbiAgICAgICAgVHJhbnNpdGlvbk9uLFxyXG4gICAgICAgIEFjdGl2ZSxcclxuICAgICAgICBUcmFuc2l0aW9uT2ZmLFxyXG4gICAgICAgIEhpZGRlbixcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBzY3JlZW4gaXMgYSBzaW5nbGUgbGF5ZXIgdGhhdCBoYXMgdXBkYXRlIGFuZCBkcmF3IGxvZ2ljLCBhbmQgd2hpY2hcclxuICAgIC8vLyBjYW4gYmUgY29tYmluZWQgd2l0aCBvdGhlciBsYXllcnMgdG8gYnVpbGQgdXAgYSBjb21wbGV4IG1lbnUgc3lzdGVtLlxyXG4gICAgLy8vIEZvciBpbnN0YW5jZSB0aGUgbWFpbiBtZW51LCB0aGUgb3B0aW9ucyBtZW51LCB0aGUgXCJhcmUgeW91IHN1cmUgeW91XHJcbiAgICAvLy8gd2FudCB0byBxdWl0XCIgbWVzc2FnZSBib3gsIGFuZCB0aGUgbWFpbiBnYW1lIGl0c2VsZiBhcmUgYWxsIGltcGxlbWVudGVkXHJcbiAgICAvLy8gYXMgc2NyZWVucy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgY2xhc3MgR2FtZVNjcmVlblxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgR2VzdHVyZVR5cGUgX2VuYWJsZWRHZXN0dXJlcyA9IEdlc3R1cmVUeXBlLk5vbmU7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9vdGhlclNjcmVlbkhhc0ZvY3VzO1xyXG5cclxuICAgICAgICBwdWJsaWMgR2FtZVNjcmVlbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PbjtcclxuICAgICAgICAgICAgVHJhbnNpdGlvblBvc2l0aW9uID0gMTtcclxuICAgICAgICAgICAgVHJhbnNpdGlvbk9mZlRpbWUgPSBUaW1lU3Bhbi5aZXJvO1xyXG4gICAgICAgICAgICBUcmFuc2l0aW9uT25UaW1lID0gVGltZVNwYW4uWmVybztcclxuICAgICAgICAgICAgSGFzQ3Vyc29yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIEhhc1ZpcnR1YWxTdGljayA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSGFzQ3Vyc29yIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSGFzVmlydHVhbFN0aWNrIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOb3JtYWxseSB3aGVuIG9uZSBzY3JlZW4gaXMgYnJvdWdodCB1cCBvdmVyIHRoZSB0b3Agb2YgYW5vdGhlcixcclxuICAgICAgICAvLy8gdGhlIGZpcnN0IHNjcmVlbiB3aWxsIHRyYW5zaXRpb24gb2ZmIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIG5ld1xyXG4gICAgICAgIC8vLyBvbmUuIFRoaXMgcHJvcGVydHkgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNjcmVlbiBpcyBvbmx5IGEgc21hbGxcclxuICAgICAgICAvLy8gcG9wdXAsIGluIHdoaWNoIGNhc2Ugc2NyZWVucyB1bmRlcm5lYXRoIGl0IGRvIG5vdCBuZWVkIHRvIGJvdGhlclxyXG4gICAgICAgIC8vLyB0cmFuc2l0aW9uaW5nIG9mZi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzUG9wdXAgeyBnZXQ7IHByb3RlY3RlZCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbmRpY2F0ZXMgaG93IGxvbmcgdGhlIHNjcmVlbiB0YWtlcyB0b1xyXG4gICAgICAgIC8vLyB0cmFuc2l0aW9uIG9uIHdoZW4gaXQgaXMgYWN0aXZhdGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRpbWVTcGFuIFRyYW5zaXRpb25PblRpbWUgeyBnZXQ7IHByb3RlY3RlZCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbmRpY2F0ZXMgaG93IGxvbmcgdGhlIHNjcmVlbiB0YWtlcyB0b1xyXG4gICAgICAgIC8vLyB0cmFuc2l0aW9uIG9mZiB3aGVuIGl0IGlzIGRlYWN0aXZhdGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRpbWVTcGFuIFRyYW5zaXRpb25PZmZUaW1lIHsgZ2V0OyBwcm90ZWN0ZWQgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgc2NyZWVuIHRyYW5zaXRpb24sIHJhbmdpbmdcclxuICAgICAgICAvLy8gZnJvbSB6ZXJvIChmdWxseSBhY3RpdmUsIG5vIHRyYW5zaXRpb24pIHRvIG9uZSAodHJhbnNpdGlvbmVkXHJcbiAgICAgICAgLy8vIGZ1bGx5IG9mZiB0byBub3RoaW5nKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBUcmFuc2l0aW9uUG9zaXRpb24geyBnZXQ7IHByb3RlY3RlZCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBjdXJyZW50IGFscGhhIG9mIHRoZSBzY3JlZW4gdHJhbnNpdGlvbiwgcmFuZ2luZ1xyXG4gICAgICAgIC8vLyBmcm9tIDEgKGZ1bGx5IGFjdGl2ZSwgbm8gdHJhbnNpdGlvbikgdG8gMCAodHJhbnNpdGlvbmVkXHJcbiAgICAgICAgLy8vIGZ1bGx5IG9mZiB0byBub3RoaW5nKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBUcmFuc2l0aW9uQWxwaGFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAxZiAtIFRyYW5zaXRpb25Qb3NpdGlvbjsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBjdXJyZW50IHNjcmVlbiB0cmFuc2l0aW9uIHN0YXRlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFNjcmVlblN0YXRlIFNjcmVlblN0YXRlIHsgZ2V0OyBwcm90ZWN0ZWQgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlcmUgYXJlIHR3byBwb3NzaWJsZSByZWFzb25zIHdoeSBhIHNjcmVlbiBtaWdodCBiZSB0cmFuc2l0aW9uaW5nXHJcbiAgICAgICAgLy8vIG9mZi4gSXQgY291bGQgYmUgdGVtcG9yYXJpbHkgZ29pbmcgYXdheSB0byBtYWtlIHJvb20gZm9yIGFub3RoZXJcclxuICAgICAgICAvLy8gc2NyZWVuIHRoYXQgaXMgb24gdG9wIG9mIGl0LCBvciBpdCBjb3VsZCBiZSBnb2luZyBhd2F5IGZvciBnb29kLlxyXG4gICAgICAgIC8vLyBUaGlzIHByb3BlcnR5IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzY3JlZW4gaXMgZXhpdGluZyBmb3IgcmVhbDpcclxuICAgICAgICAvLy8gaWYgc2V0LCB0aGUgc2NyZWVuIHdpbGwgYXV0b21hdGljYWxseSByZW1vdmUgaXRzZWxmIGFzIHNvb24gYXMgdGhlXHJcbiAgICAgICAgLy8vIHRyYW5zaXRpb24gZmluaXNoZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0V4aXRpbmcgeyBnZXQ7IHByb3RlY3RlZCBpbnRlcm5hbCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDaGVja3Mgd2hldGhlciB0aGlzIHNjcmVlbiBpcyBhY3RpdmUgYW5kIGNhbiByZXNwb25kIHRvIHVzZXIgaW5wdXQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0FjdGl2ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhX290aGVyU2NyZWVuSGFzRm9jdXMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAoU2NyZWVuU3RhdGUgPT0gU2NyZWVuU3RhdGUuVHJhbnNpdGlvbk9uIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNjcmVlblN0YXRlID09IFNjcmVlblN0YXRlLkFjdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgbWFuYWdlciB0aGF0IHRoaXMgc2NyZWVuIGJlbG9uZ3MgdG8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgU2NyZWVuTWFuYWdlciBTY3JlZW5NYW5hZ2VyIHsgZ2V0OyBpbnRlcm5hbCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBnZXN0dXJlcyB0aGUgc2NyZWVuIGlzIGludGVyZXN0ZWQgaW4uIFNjcmVlbnMgc2hvdWxkIGJlIGFzIHNwZWNpZmljXHJcbiAgICAgICAgLy8vIGFzIHBvc3NpYmxlIHdpdGggZ2VzdHVyZXMgdG8gaW5jcmVhc2UgdGhlIGFjY3VyYWN5IG9mIHRoZSBnZXN0dXJlIGVuZ2luZS5cclxuICAgICAgICAvLy8gRm9yIGV4YW1wbGUsIG1vc3QgbWVudXMgb25seSBuZWVkIFRhcCBvciBwZXJoYXBzIFRhcCBhbmQgVmVydGljYWxEcmFnIHRvIG9wZXJhdGUuXHJcbiAgICAgICAgLy8vIFRoZXNlIGdlc3R1cmVzIGFyZSBoYW5kbGVkIGJ5IHRoZSBTY3JlZW5NYW5hZ2VyIHdoZW4gc2NyZWVucyBjaGFuZ2UgYW5kXHJcbiAgICAgICAgLy8vIGFsbCBnZXN0dXJlcyBhcmUgcGxhY2VkIGluIHRoZSBJbnB1dFN0YXRlIHBhc3NlZCB0byB0aGUgSGFuZGxlSW5wdXQgbWV0aG9kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEdlc3R1cmVUeXBlIEVuYWJsZWRHZXN0dXJlc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVkR2VzdHVyZXM7IH1cclxuICAgICAgICAgICAgcHJvdGVjdGVkIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfZW5hYmxlZEdlc3R1cmVzID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNjcmVlbiBtYW5hZ2VyIGhhbmRsZXMgdGhpcyBkdXJpbmcgc2NyZWVuIGNoYW5nZXMsIGJ1dFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBzY3JlZW4gaXMgYWN0aXZlIGFuZCB0aGUgZ2VzdHVyZSB0eXBlcyBhcmUgY2hhbmdpbmcsXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHVwZGF0ZSB0aGUgVG91Y2hQYW5lbCBvdXJzZWxmLlxyXG4gICAgICAgICAgICAgICAgaWYgKFNjcmVlblN0YXRlID09IFNjcmVlblN0YXRlLkFjdGl2ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBUb3VjaFBhbmVsLkVuYWJsZWRHZXN0dXJlcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIExvYWQgZ3JhcGhpY3MgY29udGVudCBmb3IgdGhlIHNjcmVlbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgTG9hZENvbnRlbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVW5sb2FkIGNvbnRlbnQgZm9yIHRoZSBzY3JlZW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIFVubG9hZENvbnRlbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWxsb3dzIHRoZSBzY3JlZW4gdG8gcnVuIGxvZ2ljLCBzdWNoIGFzIHVwZGF0aW5nIHRoZSB0cmFuc2l0aW9uIHBvc2l0aW9uLlxyXG4gICAgICAgIC8vLyBVbmxpa2UgSGFuZGxlSW5wdXQsIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHNjcmVlblxyXG4gICAgICAgIC8vLyBpcyBhY3RpdmUsIGhpZGRlbiwgb3IgaW4gdGhlIG1pZGRsZSBvZiBhIHRyYW5zaXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIFVwZGF0ZShHYW1lVGltZSBnYW1lVGltZSwgYm9vbCBvdGhlclNjcmVlbkhhc0ZvY3VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgY292ZXJlZEJ5T3RoZXJTY3JlZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfb3RoZXJTY3JlZW5IYXNGb2N1cyA9IG90aGVyU2NyZWVuSGFzRm9jdXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoSXNFeGl0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NyZWVuIGlzIGdvaW5nIGF3YXkgdG8gZGllLCBpdCBzaG91bGQgdHJhbnNpdGlvbiBvZmYuXHJcbiAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFVcGRhdGVUcmFuc2l0aW9uKGdhbWVUaW1lLCBUcmFuc2l0aW9uT2ZmVGltZSwgMSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlcywgcmVtb3ZlIHRoZSBzY3JlZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgU2NyZWVuTWFuYWdlci5SZW1vdmVTY3JlZW4odGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZEJ5T3RoZXJTY3JlZW4pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzY3JlZW4gaXMgY292ZXJlZCBieSBhbm90aGVyLCBpdCBzaG91bGQgdHJhbnNpdGlvbiBvZmYuXHJcbiAgICAgICAgICAgICAgICBpZiAoVXBkYXRlVHJhbnNpdGlvbihnYW1lVGltZSwgVHJhbnNpdGlvbk9mZlRpbWUsIDEpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0aWxsIGJ1c3kgdHJhbnNpdGlvbmluZy5cclxuICAgICAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PZmY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiBmaW5pc2hlZCFcclxuICAgICAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLkhpZGRlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgc2NyZWVuIHNob3VsZCB0cmFuc2l0aW9uIG9uIGFuZCBiZWNvbWUgYWN0aXZlLlxyXG4gICAgICAgICAgICAgICAgaWYgKFVwZGF0ZVRyYW5zaXRpb24oZ2FtZVRpbWUsIFRyYW5zaXRpb25PblRpbWUsIC0xKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdGlsbCBidXN5IHRyYW5zaXRpb25pbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgU2NyZWVuU3RhdGUgPSBTY3JlZW5TdGF0ZS5UcmFuc2l0aW9uT247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiBmaW5pc2hlZCFcclxuICAgICAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLkFjdGl2ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBIZWxwZXIgZm9yIHVwZGF0aW5nIHRoZSBzY3JlZW4gdHJhbnNpdGlvbiBwb3NpdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBVcGRhdGVUcmFuc2l0aW9uKEdhbWVUaW1lIGdhbWVUaW1lLCBUaW1lU3BhbiB0aW1lLCBpbnQgZGlyZWN0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gSG93IG11Y2ggc2hvdWxkIHdlIG1vdmUgYnk/XHJcbiAgICAgICAgICAgIGZsb2F0IHRyYW5zaXRpb25EZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aW1lID09IFRpbWVTcGFuLlplcm8pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25EZWx0YSA9IDFmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbkRlbHRhID0gKGZsb2F0KShnYW1lVGltZS5FbGFwc2VkR2FtZVRpbWUuVG90YWxNaWxsaXNlY29uZHMgL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZS5Ub3RhbE1pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdHJhbnNpdGlvbiBwb3NpdGlvbi5cclxuICAgICAgICAgICAgVHJhbnNpdGlvblBvc2l0aW9uICs9IHRyYW5zaXRpb25EZWx0YSAqIGRpcmVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIERpZCB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uP1xyXG4gICAgICAgICAgICBpZiAoKChkaXJlY3Rpb24gPCAwKSAmJiAoVHJhbnNpdGlvblBvc2l0aW9uIDw9IDApKSB8fFxyXG4gICAgICAgICAgICAgICAgKChkaXJlY3Rpb24gPiAwKSAmJiAoVHJhbnNpdGlvblBvc2l0aW9uID49IDEpKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNpdGlvblBvc2l0aW9uID0gTWF0aEhlbHBlci5DbGFtcChUcmFuc2l0aW9uUG9zaXRpb24sIDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIHN0aWxsIGJ1c3kgdHJhbnNpdGlvbmluZy5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjcmVlbiBzaG91bGQgZHJhdyBpdHNlbGYuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIERyYXcoR2FtZVRpbWUgZ2FtZVRpbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUZWxscyB0aGUgc2NyZWVuIHRvIGdvIGF3YXkuIFVubGlrZSBTY3JlZW5NYW5hZ2VyLlJlbW92ZVNjcmVlbiwgd2hpY2hcclxuICAgICAgICAvLy8gaW5zdGFudGx5IGtpbGxzIHRoZSBzY3JlZW4sIHRoaXMgbWV0aG9kIHJlc3BlY3RzIHRoZSB0cmFuc2l0aW9uIHRpbWluZ3NcclxuICAgICAgICAvLy8gYW5kIHdpbGwgZ2l2ZSB0aGUgc2NyZWVuIGEgY2hhbmNlIHRvIGdyYWR1YWxseSB0cmFuc2l0aW9uIG9mZi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEV4aXRTY3JlZW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFRyYW5zaXRpb25PZmZUaW1lID09IFRpbWVTcGFuLlplcm8pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzY3JlZW4gaGFzIGEgemVybyB0cmFuc2l0aW9uIHRpbWUsIHJlbW92ZSBpdCBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIFNjcmVlbk1hbmFnZXIuUmVtb3ZlU2NyZWVuKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGZsYWcgdGhhdCBpdCBzaG91bGQgdHJhbnNpdGlvbiBvZmYgYW5kIHRoZW4gZXhpdC5cclxuICAgICAgICAgICAgICAgIElzRXhpdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLkNvbnRlbnQ7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLkdyYXBoaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5JbnB1dC5Ub3VjaDtcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5VdGlsaXR5XHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGUgc2NyZWVuIG1hbmFnZXIgaXMgYSBjb21wb25lbnQgd2hpY2ggbWFuYWdlcyBvbmUgb3IgbW9yZSBHYW1lU2NyZWVuXHJcbiAgICAvLy8gaW5zdGFuY2VzLiBJdCBtYWludGFpbnMgYSBzdGFjayBvZiBzY3JlZW5zLCBjYWxscyB0aGVpciBVcGRhdGUgYW5kIERyYXdcclxuICAgIC8vLyBtZXRob2RzIGF0IHRoZSBhcHByb3ByaWF0ZSB0aW1lcywgYW5kIGF1dG9tYXRpY2FsbHkgcm91dGVzIGlucHV0IHRvIHRoZVxyXG4gICAgLy8vIHRvcG1vc3QgYWN0aXZlIHNjcmVlbi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgU2NyZWVuTWFuYWdlciA6IERyYXdhYmxlR2FtZUNvbXBvbmVudFxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgQ29udGVudE1hbmFnZXIgX2NvbnRlbnRNYW5hZ2VyO1xyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgX2lzSW5pdGlhbGl6ZWQ7XHJcblxyXG4gICAgICAgIHByaXZhdGUgTGlzdDxHYW1lU2NyZWVuPiBfc2NyZWVucztcclxuICAgICAgICBwcml2YXRlIExpc3Q8R2FtZVNjcmVlbj4gX3NjcmVlbnNUb1VwZGF0ZTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBTcHJpdGVCYXRjaCBfc3ByaXRlQmF0Y2g7XHJcblxyXG5cclxuICAgICAgICBwcml2YXRlIExpc3Q8UmVuZGVyVGFyZ2V0MkQ+IF90cmFuc2l0aW9ucztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25zdHJ1Y3RzIGEgbmV3IHNjcmVlbiBtYW5hZ2VyIGNvbXBvbmVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBTY3JlZW5NYW5hZ2VyKEdhbWUgZ2FtZSlcclxuICAgICAgICAgICAgOiBiYXNlKGdhbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyB3ZSBtdXN0IHNldCBFbmFibGVkR2VzdHVyZXMgYmVmb3JlIHdlIGNhbiBxdWVyeSBmb3IgdGhlbSwgYnV0XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGFzc3VtZSB0aGUgZ2FtZSB3YW50cyB0byByZWFkIHRoZW0uXHJcbiAgICAgICAgICAgIFRvdWNoUGFuZWwuRW5hYmxlZEdlc3R1cmVzID0gR2VzdHVyZVR5cGUuTm9uZTtcclxuICAgICAgICAgICAgX2NvbnRlbnRNYW5hZ2VyID0gZ2FtZS5Db250ZW50O1xyXG4gICAgICAgICAgICBfY29udGVudE1hbmFnZXIuUm9vdERpcmVjdG9yeSA9IFwiQ29udGVudFwiO1xyXG5cclxuICAgICAgICAgICAgX3NjcmVlbnMgPSBuZXcgTGlzdDxHYW1lU2NyZWVuPigpO1xyXG4gICAgICAgICAgICBfc2NyZWVuc1RvVXBkYXRlID0gbmV3IExpc3Q8R2FtZVNjcmVlbj4oKTtcclxuICAgICAgICAgICAgX3RyYW5zaXRpb25zID0gbmV3IExpc3Q8UmVuZGVyVGFyZ2V0MkQ+KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEEgZGVmYXVsdCBTcHJpdGVCYXRjaCBzaGFyZWQgYnkgYWxsIHRoZSBzY3JlZW5zLiBUaGlzIHNhdmVzXHJcbiAgICAgICAgLy8vIGVhY2ggc2NyZWVuIGhhdmluZyB0byBib3RoZXIgY3JlYXRpbmcgdGhlaXIgb3duIGxvY2FsIGluc3RhbmNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFNwcml0ZUJhdGNoIFNwcml0ZUJhdGNoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3Nwcml0ZUJhdGNoOyB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIENvbnRlbnRNYW5hZ2VyIENvbnRlbnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfY29udGVudE1hbmFnZXI7IH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIHRoZSBzY3JlZW4gbWFuYWdlciBjb21wb25lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBJbml0aWFsaXplKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vX3Nwcml0ZUZvbnRzID0gbmV3IFNwcml0ZUZvbnRzKF9jb250ZW50TWFuYWdlcik7XHJcbiAgICAgICAgICAgIGJhc2UuSW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBMb2FkIHlvdXIgZ3JhcGhpY3MgY29udGVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIExvYWRDb250ZW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9zcHJpdGVCYXRjaCA9IG5ldyBTcHJpdGVCYXRjaChHcmFwaGljc0RldmljZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUZWxsIGVhY2ggb2YgdGhlIHNjcmVlbnMgdG8gbG9hZCB0aGVpciBjb250ZW50LlxyXG4gICAgICAgICAgICBmb3JlYWNoIChHYW1lU2NyZWVuIHNjcmVlbiBpbiBfc2NyZWVucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuLkxvYWRDb250ZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVW5sb2FkIHlvdXIgZ3JhcGhpY3MgY29udGVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIFVubG9hZENvbnRlbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gVGVsbCBlYWNoIG9mIHRoZSBzY3JlZW5zIHRvIHVubG9hZCB0aGVpciBjb250ZW50LlxyXG4gICAgICAgICAgICBmb3JlYWNoIChHYW1lU2NyZWVuIHNjcmVlbiBpbiBfc2NyZWVucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuLlVubG9hZENvbnRlbnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBbGxvd3MgZWFjaCBzY3JlZW4gdG8gcnVuIGxvZ2ljLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgVXBkYXRlKEdhbWVUaW1lIGdhbWVUaW1lKVxyXG4gICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgc2NyZWVuIGxpc3QsIHRvIGF2b2lkIGNvbmZ1c2lvbiBpZlxyXG4gICAgICAgICAgICAvLyB0aGUgcHJvY2VzcyBvZiB1cGRhdGluZyBvbmUgc2NyZWVuIGFkZHMgb3IgcmVtb3ZlcyBvdGhlcnMuXHJcbiAgICAgICAgICAgIF9zY3JlZW5zVG9VcGRhdGUuQ2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEdhbWVTY3JlZW4gc2NyZWVuIGluIF9zY3JlZW5zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfc2NyZWVuc1RvVXBkYXRlLkFkZChzY3JlZW4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBib29sIG90aGVyU2NyZWVuSGFzRm9jdXMgPSAhR2FtZS5Jc0FjdGl2ZTtcclxuICAgICAgICAgICAgYm9vbCBjb3ZlcmVkQnlPdGhlclNjcmVlbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gTG9vcCBhcyBsb25nIGFzIHRoZXJlIGFyZSBzY3JlZW5zIHdhaXRpbmcgdG8gYmUgdXBkYXRlZC5cclxuICAgICAgICAgICAgd2hpbGUgKF9zY3JlZW5zVG9VcGRhdGUuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBQb3AgdGhlIHRvcG1vc3Qgc2NyZWVuIG9mZiB0aGUgd2FpdGluZyBsaXN0LlxyXG4gICAgICAgICAgICAgICAgR2FtZVNjcmVlbiBzY3JlZW4gPSBfc2NyZWVuc1RvVXBkYXRlW19zY3JlZW5zVG9VcGRhdGUuQ291bnQgLSAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBfc2NyZWVuc1RvVXBkYXRlLlJlbW92ZUF0KF9zY3JlZW5zVG9VcGRhdGUuQ291bnQgLSAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNjcmVlbi5cclxuICAgICAgICAgICAgICAgIHNjcmVlbi5VcGRhdGUoZ2FtZVRpbWUsIG90aGVyU2NyZWVuSGFzRm9jdXMsIGNvdmVyZWRCeU90aGVyU2NyZWVuKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2NyZWVuLlNjcmVlblN0YXRlID09IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PbiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlbi5TY3JlZW5TdGF0ZSA9PSBTY3JlZW5TdGF0ZS5BY3RpdmUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgYWN0aXZlIHNjcmVlbiB3ZSBjYW1lIGFjcm9zcyxcclxuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIGl0IGEgY2hhbmNlIHRvIGhhbmRsZSBpbnB1dC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyU2NyZWVuSGFzRm9jdXMpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlclNjcmVlbkhhc0ZvY3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYWN0aXZlIG5vbi1wb3B1cCwgaW5mb3JtIGFueSBzdWJzZXF1ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2NyZWVucyB0aGF0IHRoZXkgYXJlIGNvdmVyZWQgYnkgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JlZW4uSXNQb3B1cClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWRCeU90aGVyU2NyZWVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGVsbHMgZWFjaCBzY3JlZW4gdG8gZHJhdyBpdHNlbGYuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBEcmF3KEdhbWVUaW1lIGdhbWVUaW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgR3JhcGhpY3NEZXZpY2UuQ2xlYXIoQ29sb3IuQmxhY2spO1xyXG4gICAgICAgICAgICBmb3JlYWNoIChHYW1lU2NyZWVuIHNjcmVlbiBpbiBfc2NyZWVucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuLkRyYXcoZ2FtZVRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICBpbnQgdHJhbnNpdGlvbkNvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yZWFjaCAoR2FtZVNjcmVlbiBzY3JlZW4gaW4gX3NjcmVlbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChzY3JlZW4uU2NyZWVuU3RhdGUgPT0gU2NyZWVuU3RhdGUuVHJhbnNpdGlvbk9uIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuLlNjcmVlblN0YXRlID09IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PZmYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgKyt0cmFuc2l0aW9uQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90cmFuc2l0aW9ucy5Db3VudCA8IHRyYW5zaXRpb25Db3VudClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFByZXNlbnRhdGlvblBhcmFtZXRlcnMgX3BwID0gR3JhcGhpY3NEZXZpY2UuUHJlc2VudGF0aW9uUGFyYW1ldGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RyYW5zaXRpb25zLkFkZChuZXcgUmVuZGVyVGFyZ2V0MkQoR3JhcGhpY3NEZXZpY2UsIF9wcC5CYWNrQnVmZmVyV2lkdGgsIF9wcC5CYWNrQnVmZmVySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3VyZmFjZUZvcm1hdC5Db2xvciwgX3BwLkRlcHRoU3RlbmNpbEZvcm1hdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BwLk11bHRpU2FtcGxlQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlbmRlclRhcmdldFVzYWdlLkRpc2NhcmRDb250ZW50cykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0RldmljZS5TZXRSZW5kZXJUYXJnZXQoX3RyYW5zaXRpb25zW3RyYW5zaXRpb25Db3VudCAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0RldmljZS5DbGVhcihDb2xvci5UcmFuc3BhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuLkRyYXcoZ2FtZVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzRGV2aWNlLlNldFJlbmRlclRhcmdldChudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgR3JhcGhpY3NEZXZpY2UuQ2xlYXIoQ29sb3IuQmxhY2spO1xyXG5cclxuICAgICAgICAgICAgdHJhbnNpdGlvbkNvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yZWFjaCAoR2FtZVNjcmVlbiBzY3JlZW4gaW4gX3NjcmVlbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChzY3JlZW4uU2NyZWVuU3RhdGUgPT0gU2NyZWVuU3RhdGUuSGlkZGVuKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzY3JlZW4uU2NyZWVuU3RhdGUgPT0gU2NyZWVuU3RhdGUuVHJhbnNpdGlvbk9uIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuLlNjcmVlblN0YXRlID09IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PZmYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Nwcml0ZUJhdGNoLkJlZ2luKDAsIEJsZW5kU3RhdGUuQWxwaGFCbGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Nwcml0ZUJhdGNoLkRyYXcoX3RyYW5zaXRpb25zW3RyYW5zaXRpb25Db3VudF0sIFZlY3RvcjIuWmVybywgQ29sb3IuV2hpdGUgKiBzY3JlZW4uVHJhbnNpdGlvbkFscGhhKTtcclxuICAgICAgICAgICAgICAgICAgICBfc3ByaXRlQmF0Y2guRW5kKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICsrdHJhbnNpdGlvbkNvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlbi5EcmF3KGdhbWVUaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqKi9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyBhIG5ldyBzY3JlZW4gdG8gdGhlIHNjcmVlbiBtYW5hZ2VyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkU2NyZWVuKEdhbWVTY3JlZW4gc2NyZWVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2NyZWVuLlNjcmVlbk1hbmFnZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICBzY3JlZW4uSXNFeGl0aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgZ3JhcGhpY3MgZGV2aWNlLCB0ZWxsIHRoZSBzY3JlZW4gdG8gbG9hZCBjb250ZW50LlxyXG4gICAgICAgICAgICBpZiAoX2lzSW5pdGlhbGl6ZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNjcmVlbi5Mb2FkQ29udGVudCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfc2NyZWVucy5BZGQoc2NyZWVuKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgVG91Y2hQYW5lbCB0byByZXNwb25kIHRvIGdlc3R1cmVzIHRoaXMgc2NyZWVuIGlzIGludGVyZXN0ZWQgaW5cclxuICAgICAgICAgICAgVG91Y2hQYW5lbC5FbmFibGVkR2VzdHVyZXMgPSBzY3JlZW4uRW5hYmxlZEdlc3R1cmVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZW1vdmVzIGEgc2NyZWVuIGZyb20gdGhlIHNjcmVlbiBtYW5hZ2VyLiBZb3Ugc2hvdWxkIG5vcm1hbGx5XHJcbiAgICAgICAgLy8vIHVzZSBHYW1lU2NyZWVuLkV4aXRTY3JlZW4gaW5zdGVhZCBvZiBjYWxsaW5nIHRoaXMgZGlyZWN0bHksIHNvXHJcbiAgICAgICAgLy8vIHRoZSBzY3JlZW4gY2FuIGdyYWR1YWxseSB0cmFuc2l0aW9uIG9mZiByYXRoZXIgdGhhbiBqdXN0IGJlaW5nXHJcbiAgICAgICAgLy8vIGluc3RhbnRseSByZW1vdmVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlU2NyZWVuKEdhbWVTY3JlZW4gc2NyZWVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGdyYXBoaWNzIGRldmljZSwgdGVsbCB0aGUgc2NyZWVuIHRvIHVubG9hZCBjb250ZW50LlxyXG4gICAgICAgICAgICBpZiAoX2lzSW5pdGlhbGl6ZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNjcmVlbi5VbmxvYWRDb250ZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9zY3JlZW5zLlJlbW92ZShzY3JlZW4pO1xyXG4gICAgICAgICAgICBfc2NyZWVuc1RvVXBkYXRlLlJlbW92ZShzY3JlZW4pO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzY3JlZW4gc3RpbGwgaW4gdGhlIG1hbmFnZXIsIHVwZGF0ZSBUb3VjaFBhbmVsXHJcbiAgICAgICAgICAgIC8vIHRvIHJlc3BvbmQgdG8gZ2VzdHVyZXMgdGhhdCBzY3JlZW4gaXMgaW50ZXJlc3RlZCBpbi5cclxuICAgICAgICAgICAgaWYgKF9zY3JlZW5zLkNvdW50ID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVG91Y2hQYW5lbC5FbmFibGVkR2VzdHVyZXMgPSBfc2NyZWVuc1tfc2NyZWVucy5Db3VudCAtIDFdLkVuYWJsZWRHZXN0dXJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFeHBvc2UgYW4gYXJyYXkgaG9sZGluZyBhbGwgdGhlIHNjcmVlbnMuIFdlIHJldHVybiBhIGNvcHkgcmF0aGVyXHJcbiAgICAgICAgLy8vIHRoYW4gdGhlIHJlYWwgbWFzdGVyIGxpc3QsIGJlY2F1c2Ugc2NyZWVucyBzaG91bGQgb25seSBldmVyIGJlIGFkZGVkXHJcbiAgICAgICAgLy8vIG9yIHJlbW92ZWQgdXNpbmcgdGhlIEFkZFNjcmVlbiBhbmQgUmVtb3ZlU2NyZWVuIG1ldGhvZHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgR2FtZVNjcmVlbltdIEdldFNjcmVlbnMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zY3JlZW5zLlRvQXJyYXkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcmsuR3JhcGhpY3M7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuVXRpbGl0eVxyXG57XHJcbiAgICBwdWJsaWMgc3RydWN0IFNwcml0ZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIE9yaWdpbjtcclxuICAgICAgICBwdWJsaWMgVGV4dHVyZTJEIFRleHR1cmU7XHJcblxyXG4gICAgICAgIHB1YmxpYyBTcHJpdGUoVGV4dHVyZTJEIHRleHR1cmUsIFZlY3RvcjIgb3JpZ2luKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5UZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAgICAgdGhpcy5PcmlnaW4gPSBvcmlnaW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgU3ByaXRlKFRleHR1cmUyRCBzcHJpdGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUZXh0dXJlID0gc3ByaXRlO1xyXG4gICAgICAgICAgICBPcmlnaW4gPSBuZXcgVmVjdG9yMihzcHJpdGUuV2lkdGggLyAyZiwgc3ByaXRlLkhlaWdodCAvIDJmKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxuLy8gQ2hhbmdlcyBmcm9tIHRoZSBKYXZhIHZlcnNpb25cclxuLy8gICBhdHRyaWJ1dGlmaWNhdGlvblxyXG4vLyBGdXR1cmUgcG9zc2liaWxpdGllc1xyXG4vLyAgIEZsYXR0ZW5pbmcgb3V0IHRoZSBudW1iZXIgb2YgaW5kaXJlY3Rpb25zXHJcbi8vICAgICBSZXBsYWNpbmcgYXJyYXlzIG9mIDMgd2l0aCBmaXhlZC1sZW5ndGggYXJyYXlzP1xyXG4vLyAgICAgUmVwbGFjaW5nIGJvb2xbM10gd2l0aCBhIGJpdCBhcnJheSBvZiBzb21lIHNvcnQ/XHJcbi8vICAgICBCdW5kbGluZyBldmVyeXRoaW5nIGludG8gYW4gQW9TIG1lc3M/XHJcbi8vICAgICBIYXJkY29kZSB0aGVtIGFsbCBhcyBBQkMgP1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5LlN3ZWVwO1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLlV0aWw7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heVxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgRGVsYXVuYXlUcmlhbmdsZVxyXG4gICAge1xyXG4gICAgICAgIC8qKiBOZWlnaGJvciBwb2ludGVycyAqL1xyXG5cclxuICAgICAgICAvKiogRmxhZ3MgdG8gZGV0ZXJtaW5lIGlmIGFuIGVkZ2UgaXMgYSBEZWxhdW5leSBlZGdlICovXHJcbiAgICAgICAgcHVibGljIEZpeGVkQml0QXJyYXkzIEVkZ2VJc0NvbnN0cmFpbmVkO1xyXG5cclxuICAgICAgICAvKiogRmxhZ3MgdG8gZGV0ZXJtaW5lIGlmIGFuIGVkZ2UgaXMgYSBDb25zdHJhaW5lZCBlZGdlICovXHJcbiAgICAgICAgcHVibGljIEZpeGVkQml0QXJyYXkzIEVkZ2VJc0RlbGF1bmF5O1xyXG4gICAgICAgIHB1YmxpYyBGaXhlZEFycmF5MzxEZWxhdW5heVRyaWFuZ2xlPiBOZWlnaGJvcnM7XHJcblxyXG4gICAgICAgIC8qKiBIYXMgdGhpcyB0cmlhbmdsZSBiZWVuIG1hcmtlZCBhcyBhbiBpbnRlcmlvciB0cmlhbmdsZT8gKi9cclxuXHJcbiAgICAgICAgcHVibGljIEZpeGVkQXJyYXkzPFRyaWFuZ3VsYXRpb25Qb2ludD4gUG9pbnRzO1xyXG5cclxuICAgICAgICBwdWJsaWMgRGVsYXVuYXlUcmlhbmdsZShUcmlhbmd1bGF0aW9uUG9pbnQgcDEsIFRyaWFuZ3VsYXRpb25Qb2ludCBwMiwgVHJpYW5ndWxhdGlvblBvaW50IHAzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnRzWzBdID0gcDE7XHJcbiAgICAgICAgICAgIFBvaW50c1sxXSA9IHAyO1xyXG4gICAgICAgICAgICBQb2ludHNbMl0gPSBwMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzSW50ZXJpb3IgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgaW50IEluZGV4T2YoVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgaSA9IFBvaW50cy5JbmRleE9mKHApO1xyXG4gICAgICAgICAgICBpZiAoaSA9PSAtMSkgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIkNhbGxpbmcgaW5kZXggd2l0aCBhIHBvaW50IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0cmlhbmdsZVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RPRE86IFBvcnQgbm90ZSAtIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgIHB1YmxpYyBpbnQgSW5kZXhDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IEluZGV4T2YocCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogUG9ydCBub3RlIC0gZGlmZmVyZW50IGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgcHVibGljIGludCBJbmRleENDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IEluZGV4T2YocCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIENvbnRhaW5zKFRyaWFuZ3VsYXRpb25Qb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChwID09IFBvaW50c1swXSB8fCBwID09IFBvaW50c1sxXSB8fCBwID09IFBvaW50c1syXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBDb250YWlucyhEVFN3ZWVwQ29uc3RyYWludCBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChDb250YWlucyhlLlApICYmIENvbnRhaW5zKGUuUSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29udGFpbnMoVHJpYW5ndWxhdGlvblBvaW50IHAsIFRyaWFuZ3VsYXRpb25Qb2ludCBxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChDb250YWlucyhwKSAmJiBDb250YWlucyhxKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFVwZGF0ZSBuZWlnaGJvciBwb2ludGVyc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicDFcIj5Qb2ludCAxIG9mIHRoZSBzaGFyZWQgZWRnZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicDJcIj5Qb2ludCAyIG9mIHRoZSBzaGFyZWQgZWRnZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidFwiPlRoaXMgdHJpYW5nbGUncyBuZXcgbmVpZ2hib3I8L3BhcmFtPlxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBNYXJrTmVpZ2hib3IoVHJpYW5ndWxhdGlvblBvaW50IHAxLCBUcmlhbmd1bGF0aW9uUG9pbnQgcDIsIERlbGF1bmF5VHJpYW5nbGUgdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgocDEgPT0gUG9pbnRzWzJdICYmIHAyID09IFBvaW50c1sxXSkgfHwgKHAxID09IFBvaW50c1sxXSAmJiBwMiA9PSBQb2ludHNbMl0pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBOZWlnaGJvcnNbMF0gPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwMSA9PSBQb2ludHNbMF0gJiYgcDIgPT0gUG9pbnRzWzJdKSB8fCAocDEgPT0gUG9pbnRzWzJdICYmIHAyID09IFBvaW50c1swXSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE5laWdoYm9yc1sxXSA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHAxID09IFBvaW50c1swXSAmJiBwMiA9PSBQb2ludHNbMV0pIHx8IChwMSA9PSBQb2ludHNbMV0gJiYgcDIgPT0gUG9pbnRzWzBdKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTmVpZ2hib3JzWzJdID0gdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShcIk5laWdoYm9yIGVycm9yLCBwbGVhc2UgcmVwb3J0IVwiKTtcclxuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFeGNlcHRpb24oXCJOZWlnaGJvciBlcnJvciwgcGxlYXNlIHJlcG9ydCFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRXhoYXVzdGl2ZSBzZWFyY2ggdG8gdXBkYXRlIG5laWdoYm9yIHBvaW50ZXJzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXJrTmVpZ2hib3IoRGVsYXVuYXlUcmlhbmdsZSB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHQuQ29udGFpbnMoUG9pbnRzWzFdLCBQb2ludHNbMl0pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBOZWlnaGJvcnNbMF0gPSB0O1xyXG4gICAgICAgICAgICAgICAgdC5NYXJrTmVpZ2hib3IoUG9pbnRzWzFdLCBQb2ludHNbMl0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHQuQ29udGFpbnMoUG9pbnRzWzBdLCBQb2ludHNbMl0pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBOZWlnaGJvcnNbMV0gPSB0O1xyXG4gICAgICAgICAgICAgICAgdC5NYXJrTmVpZ2hib3IoUG9pbnRzWzBdLCBQb2ludHNbMl0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHQuQ29udGFpbnMoUG9pbnRzWzBdLCBQb2ludHNbMV0pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBOZWlnaGJvcnNbMl0gPSB0O1xyXG4gICAgICAgICAgICAgICAgdC5NYXJrTmVpZ2hib3IoUG9pbnRzWzBdLCBQb2ludHNbMV0sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwibWFya05laWdoYm9yIGZhaWxlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXJOZWlnaGJvcnMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTmVpZ2hib3JzWzBdID0gTmVpZ2hib3JzWzFdID0gTmVpZ2hib3JzWzJdID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyTmVpZ2hib3IoRGVsYXVuYXlUcmlhbmdsZSB0cmlhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChOZWlnaGJvcnNbMF0gPT0gdHJpYW5nbGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE5laWdoYm9yc1swXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTmVpZ2hib3JzWzFdID09IHRyaWFuZ2xlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBOZWlnaGJvcnNbMV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTmVpZ2hib3JzWzJdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIGFsbCByZWZlcmVuY2VzIHRvIGFsbCBvdGhlciB0cmlhbmdsZXMgYW5kIHBvaW50c1xyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIHQ7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ID0gTmVpZ2hib3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0LkNsZWFyTmVpZ2hib3IodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ2xlYXJOZWlnaGJvcnMoKTtcclxuICAgICAgICAgICAgUG9pbnRzWzBdID0gUG9pbnRzWzFdID0gUG9pbnRzWzJdID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRcIj5PcHBvc2l0ZSB0cmlhbmdsZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlRoZSBwb2ludCBpbiB0IHRoYXQgaXNuJ3Qgc2hhcmVkIGJldHdlZW4gdGhlIHRyaWFuZ2xlczwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRpb25Qb2ludCBPcHBvc2l0ZVBvaW50KERlbGF1bmF5VHJpYW5nbGUgdCwgVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQodCAhPSB0aGlzLCBcInNlbGYtcG9pbnRlciBlcnJvclwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Q1codC5Qb2ludENXKHApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBEZWxhdW5heVRyaWFuZ2xlIE5laWdoYm9yQ1coVHJpYW5ndWxhdGlvblBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5laWdoYm9yc1soUG9pbnRzLkluZGV4T2YocG9pbnQpICsgMSklM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgRGVsYXVuYXlUcmlhbmdsZSBOZWlnaGJvckNDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTmVpZ2hib3JzWyhQb2ludHMuSW5kZXhPZihwb2ludCkgKyAyKSUzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBEZWxhdW5heVRyaWFuZ2xlIE5laWdoYm9yQWNyb3NzKFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBOZWlnaGJvcnNbUG9pbnRzLkluZGV4T2YocG9pbnQpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0aW9uUG9pbnQgUG9pbnRDQ1coVHJpYW5ndWxhdGlvblBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50c1soSW5kZXhPZihwb2ludCkgKyAxKSUzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0aW9uUG9pbnQgUG9pbnRDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnRzWyhJbmRleE9mKHBvaW50KSArIDIpJTNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFJvdGF0ZUNXKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gUG9pbnRzWzJdO1xyXG4gICAgICAgICAgICBQb2ludHNbMl0gPSBQb2ludHNbMV07XHJcbiAgICAgICAgICAgIFBvaW50c1sxXSA9IFBvaW50c1swXTtcclxuICAgICAgICAgICAgUG9pbnRzWzBdID0gdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTGVnYWxpemUgdHJpYW5nbGUgYnkgcm90YXRpbmcgY2xvY2t3aXNlIGFyb3VuZCBvUG9pbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm9Qb2ludFwiPlRoZSBvcmlnaW4gcG9pbnQgdG8gcm90YXRlIGFyb3VuZDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiblBvaW50XCI+Pz8/PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBMZWdhbGl6ZShUcmlhbmd1bGF0aW9uUG9pbnQgb1BvaW50LCBUcmlhbmd1bGF0aW9uUG9pbnQgblBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUm90YXRlQ1coKTtcclxuICAgICAgICAgICAgUG9pbnRzW0luZGV4Q0NXKG9Qb2ludCldID0gblBvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHN0cmluZyBUb1N0cmluZygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnRzWzBdICsgXCIsXCIgKyBQb2ludHNbMV0gKyBcIixcIiArIFBvaW50c1syXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmluYWxpemUgZWRnZSBtYXJraW5nXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXJrTmVpZ2hib3JFZGdlcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKylcclxuICAgICAgICAgICAgICAgIGlmIChFZGdlSXNDb25zdHJhaW5lZFtpXSAmJiBOZWlnaGJvcnNbaV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBOZWlnaGJvcnNbaV0uTWFya0NvbnN0cmFpbmVkRWRnZShQb2ludHNbKGkgKyAxKSUzXSwgUG9pbnRzWyhpICsgMiklM10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFya0VkZ2UoRGVsYXVuYXlUcmlhbmdsZSB0cmlhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKEVkZ2VJc0NvbnN0cmFpbmVkW2ldKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlLk1hcmtDb25zdHJhaW5lZEVkZ2UoUG9pbnRzWyhpICsgMSklM10sIFBvaW50c1soaSArIDIpJTNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcmtFZGdlKExpc3Q8RGVsYXVuYXlUcmlhbmdsZT4gdExpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3JlYWNoIChEZWxhdW5heVRyaWFuZ2xlIHQgaW4gdExpc3QpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC5FZGdlSXNDb25zdHJhaW5lZFtpXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hcmtDb25zdHJhaW5lZEVkZ2UodC5Qb2ludHNbKGkgKyAxKSUzXSwgdC5Qb2ludHNbKGkgKyAyKSUzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFya0NvbnN0cmFpbmVkRWRnZShpbnQgaW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFZGdlSXNDb25zdHJhaW5lZFtpbmRleF0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFya0NvbnN0cmFpbmVkRWRnZShEVFN3ZWVwQ29uc3RyYWludCBlZGdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFya0NvbnN0cmFpbmVkRWRnZShlZGdlLlAsIGVkZ2UuUSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1hcmsgZWRnZSBhcyBjb25zdHJhaW5lZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFya0NvbnN0cmFpbmVkRWRnZShUcmlhbmd1bGF0aW9uUG9pbnQgcCwgVHJpYW5ndWxhdGlvblBvaW50IHEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgaSA9IEVkZ2VJbmRleChwLCBxKTtcclxuICAgICAgICAgICAgaWYgKGkgIT0gLTEpIEVkZ2VJc0NvbnN0cmFpbmVkW2ldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBkb3VibGUgQXJlYSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgYiA9IFBvaW50c1swXS5YIC0gUG9pbnRzWzFdLlg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBoID0gUG9pbnRzWzJdLlkgLSBQb2ludHNbMV0uWTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkFicygoYipoKjAuNWYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0aW9uUG9pbnQgQ2VudHJvaWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIGN4ID0gKFBvaW50c1swXS5YICsgUG9pbnRzWzFdLlggKyBQb2ludHNbMl0uWCkvM2Y7XHJcbiAgICAgICAgICAgIGRvdWJsZSBjeSA9IChQb2ludHNbMF0uWSArIFBvaW50c1sxXS5ZICsgUG9pbnRzWzJdLlkpLzNmO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyaWFuZ3VsYXRpb25Qb2ludChjeCwgY3kpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBuZWlnaGJvciB0aGF0IHNoYXJlcyB0aGlzIGVkZ2UgKG9yIC0xIGlmIGl0IGlzbid0IHNoYXJlZClcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5pbmRleCBvZiB0aGUgc2hhcmVkIGVkZ2Ugb3IgLTEgaWYgZWRnZSBpc24ndCBzaGFyZWQ8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGludCBFZGdlSW5kZXgoVHJpYW5ndWxhdGlvblBvaW50IHAxLCBUcmlhbmd1bGF0aW9uUG9pbnQgcDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgaTEgPSBQb2ludHMuSW5kZXhPZihwMSk7XHJcbiAgICAgICAgICAgIGludCBpMiA9IFBvaW50cy5JbmRleE9mKHAyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBvaW50cyBvZiB0aGlzIHRyaWFuZ2xlIGluIHRoZSBlZGdlIHAxLXAyXHJcbiAgICAgICAgICAgIGJvb2wgYSA9IChpMSA9PSAwIHx8IGkyID09IDApO1xyXG4gICAgICAgICAgICBib29sIGIgPSAoaTEgPT0gMSB8fCBpMiA9PSAxKTtcclxuICAgICAgICAgICAgYm9vbCBjID0gKGkxID09IDIgfHwgaTIgPT0gMik7XHJcblxyXG4gICAgICAgICAgICBpZiAoYiAmJiBjKSByZXR1cm4gMDtcclxuICAgICAgICAgICAgaWYgKGEgJiYgYykgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGlmIChhICYmIGIpIHJldHVybiAyO1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBHZXRDb25zdHJhaW5lZEVkZ2VDQ1coVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRWRnZUlzQ29uc3RyYWluZWRbKEluZGV4T2YocCkgKyAyKSUzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEdldENvbnN0cmFpbmVkRWRnZUNXKFRyaWFuZ3VsYXRpb25Qb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVkZ2VJc0NvbnN0cmFpbmVkWyhJbmRleE9mKHApICsgMSklM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBHZXRDb25zdHJhaW5lZEVkZ2VBY3Jvc3MoVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRWRnZUlzQ29uc3RyYWluZWRbSW5kZXhPZihwKV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRDb25zdHJhaW5lZEVkZ2VDQ1coVHJpYW5ndWxhdGlvblBvaW50IHAsIGJvb2wgY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFZGdlSXNDb25zdHJhaW5lZFsoSW5kZXhPZihwKSArIDIpJTNdID0gY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRDb25zdHJhaW5lZEVkZ2VDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcCwgYm9vbCBjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVkZ2VJc0NvbnN0cmFpbmVkWyhJbmRleE9mKHApICsgMSklM10gPSBjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldENvbnN0cmFpbmVkRWRnZUFjcm9zcyhUcmlhbmd1bGF0aW9uUG9pbnQgcCwgYm9vbCBjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVkZ2VJc0NvbnN0cmFpbmVkW0luZGV4T2YocCldID0gY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBHZXREZWxhdW5heUVkZ2VDQ1coVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRWRnZUlzRGVsYXVuYXlbKEluZGV4T2YocCkgKyAyKSUzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEdldERlbGF1bmF5RWRnZUNXKFRyaWFuZ3VsYXRpb25Qb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVkZ2VJc0RlbGF1bmF5WyhJbmRleE9mKHApICsgMSklM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBHZXREZWxhdW5heUVkZ2VBY3Jvc3MoVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRWRnZUlzRGVsYXVuYXlbSW5kZXhPZihwKV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXREZWxhdW5heUVkZ2VDQ1coVHJpYW5ndWxhdGlvblBvaW50IHAsIGJvb2wgY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFZGdlSXNEZWxhdW5heVsoSW5kZXhPZihwKSArIDIpJTNdID0gY2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXREZWxhdW5heUVkZ2VDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcCwgYm9vbCBjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVkZ2VJc0RlbGF1bmF5WyhJbmRleE9mKHApICsgMSklM10gPSBjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldERlbGF1bmF5RWRnZUFjcm9zcyhUcmlhbmd1bGF0aW9uUG9pbnQgcCwgYm9vbCBjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVkZ2VJc0RlbGF1bmF5W0luZGV4T2YocCldID0gY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbi8vIENoYW5nZXMgZnJvbSB0aGUgSmF2YSB2ZXJzaW9uXHJcbi8vICAgUmVtb3ZlZCBCU1QgY29kZSwgYnV0IG5vdCBhbGwgYXJ0aWZhY3RzIG9mIGl0XHJcbi8vIEZ1dHVyZSBwb3NzaWJpbGl0aWVzXHJcbi8vICAgRWxpbWluYXRlIEFkZC9SZW1vdmVOb2RlID9cclxuLy8gICBDb21tZW50cyBjb21tZW50cyBhbmQgbW9yZSBjb21tZW50cyFcclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLlRleHQ7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heS5Td2VlcFxyXG57XHJcbiAgICAvKipcclxuICAgICAqIEBhdXRob3IgVGhvbWFzIMOFaGxlbiAodGhhaGxlbkBnbWFpbC5jb20pXHJcbiAgICAgKi9cclxuXHJcbiAgICBwdWJsaWMgY2xhc3MgQWR2YW5jaW5nRnJvbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnROb2RlIEhlYWQ7XHJcbiAgICAgICAgcHJvdGVjdGVkIEFkdmFuY2luZ0Zyb250Tm9kZSBTZWFyY2g7XHJcbiAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250Tm9kZSBUYWlsO1xyXG5cclxuICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnQoQWR2YW5jaW5nRnJvbnROb2RlIGhlYWQsIEFkdmFuY2luZ0Zyb250Tm9kZSB0YWlsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSGVhZCA9IGhlYWQ7XHJcbiAgICAgICAgICAgIFRhaWwgPSB0YWlsO1xyXG4gICAgICAgICAgICBTZWFyY2ggPSBoZWFkO1xyXG4gICAgICAgICAgICBBZGROb2RlKGhlYWQpO1xyXG4gICAgICAgICAgICBBZGROb2RlKHRhaWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkTm9kZShBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vX3NlYXJjaFRyZWUucHV0KG5vZGUua2V5LCBub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZU5vZGUoQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL19zZWFyY2hUcmVlLmRlbGV0ZSggbm9kZS5rZXkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBzdHJpbmcgVG9TdHJpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU3RyaW5nQnVpbGRlciBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XHJcbiAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlID0gSGVhZDtcclxuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gVGFpbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKG5vZGUuUG9pbnQuWCkuQXBwZW5kKFwiLT5cIik7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5OZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNiLkFwcGVuZChUYWlsLlBvaW50LlgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2IuVG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTU06ICBUaGlzIHNlZW1zIHRvIGJlIHVzZWQgYnkgTG9jYXRlTm9kZSB0byBndWVzcyBhIHBvc2l0aW9uIGluIHRoZSBpbXBsaWNpdCBsaW5rZWQgbGlzdCBvZiBBZHZhbmNpbmdGcm9udE5vZGVzIG5lYXIgeFxyXG4gICAgICAgIC8vLyAgICAgIFJlbW92ZWQgYW4gb3ZlcmxvYWQgdGhhdCBkZXBlbmRlZCBvbiB0aGlzIGJlaW5nIGV4YWN0XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIEFkdmFuY2luZ0Zyb250Tm9kZSBGaW5kU2VhcmNoTm9kZShkb3VibGUgeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBCU1QgaW5kZXggXHJcbiAgICAgICAgICAgIHJldHVybiBTZWFyY2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFdlIHVzZSBhIGJhbGFuY2luZyB0cmVlIHRvIGxvY2F0ZSBhIG5vZGUgc21hbGxlciBvciBlcXVhbCB0byBnaXZlbiBrZXkgdmFsdWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBBZHZhbmNpbmdGcm9udE5vZGUgTG9jYXRlTm9kZShUcmlhbmd1bGF0aW9uUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTG9jYXRlTm9kZShwb2ludC5YKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgQWR2YW5jaW5nRnJvbnROb2RlIExvY2F0ZU5vZGUoZG91YmxlIHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSA9IEZpbmRTZWFyY2hOb2RlKHgpO1xyXG4gICAgICAgICAgICBpZiAoeCA8IG5vZGUuVmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUuUHJldikgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA+PSBub2RlLlZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2VhcmNoID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5OZXh0KSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgbm9kZS5WYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNlYXJjaCA9IG5vZGUuUHJldjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuUHJldjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgaW1wbGVtZW50YXRpb24gd2lsbCB1c2Ugc2ltcGxlIG5vZGUgdHJhdmVyc2FsIGFsZ29yaXRobSB0byBmaW5kIGEgcG9pbnQgb24gdGhlIGZyb250XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnROb2RlIExvY2F0ZVBvaW50KFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBweCA9IHBvaW50Llg7XHJcbiAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlID0gRmluZFNlYXJjaE5vZGUocHgpO1xyXG4gICAgICAgICAgICBkb3VibGUgbnggPSBub2RlLlBvaW50Llg7XHJcblxyXG4gICAgICAgICAgICBpZiAocHggPT0gbngpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludCAhPSBub2RlLlBvaW50KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgdHdvIG5vZGVzIHdpdGggc2FtZSB4IHZhbHVlIGZvciBhIHNob3J0IHRpbWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQgPT0gbm9kZS5QcmV2LlBvaW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuUHJldjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9pbnQgPT0gbm9kZS5OZXh0LlBvaW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIkZhaWxlZCB0byBmaW5kIE5vZGUgZm9yIGdpdmVuIGFmcm9udCBwb2ludFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocHggPCBueClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5QcmV2KSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCA9PSBub2RlLlBvaW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5OZXh0KSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCA9PSBub2RlLlBvaW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNlYXJjaCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG4vLyBDaGFuZ2VzIGZyb20gdGhlIEphdmEgdmVyc2lvblxyXG4vLyAgIFJlbW92ZWQgZ2V0dGVyc1xyXG4vLyAgIEhhcyogdHVybmVkIGludG8gYXR0cmlidXRlc1xyXG4vLyBGdXR1cmUgcG9zc2liaWxpdGllc1xyXG4vLyAgIENvbW1lbnRzIVxyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXkuU3dlZXBcclxue1xyXG4gICAgcHVibGljIGNsYXNzIEFkdmFuY2luZ0Zyb250Tm9kZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBBZHZhbmNpbmdGcm9udE5vZGUgTmV4dDtcclxuICAgICAgICBwdWJsaWMgVHJpYW5ndWxhdGlvblBvaW50IFBvaW50O1xyXG4gICAgICAgIHB1YmxpYyBBZHZhbmNpbmdGcm9udE5vZGUgUHJldjtcclxuICAgICAgICBwdWJsaWMgRGVsYXVuYXlUcmlhbmdsZSBUcmlhbmdsZTtcclxuICAgICAgICBwdWJsaWMgZG91YmxlIFZhbHVlO1xyXG5cclxuICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnROb2RlKFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgICAgIFZhbHVlID0gcG9pbnQuWDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEhhc05leHRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBOZXh0ICE9IG51bGw7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEhhc1ByZXZcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBQcmV2ICE9IG51bGw7IH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxuLypcclxuICogU3dlZXAtbGluZSwgQ29uc3RyYWluZWQgRGVsYXVuZXkgVHJpYW5ndWxhdGlvbiAoQ0RUKSBTZWU6IERvbWl0ZXIsIFYuIGFuZFxyXG4gKiBaYWxpaywgQi4oMjAwOCknU3dlZXAtbGluZSBhbGdvcml0aG0gZm9yIGNvbnN0cmFpbmVkIERlbGF1bmF5IHRyaWFuZ3VsYXRpb24nLFxyXG4gKiBJbnRlcm5hdGlvbmFsIEpvdXJuYWwgb2YgR2VvZ3JhcGhpY2FsIEluZm9ybWF0aW9uIFNjaWVuY2VcclxuICogXHJcbiAqIFwiRmxpcFNjYW5cIiBDb25zdHJhaW5lZCBFZGdlIEFsZ29yaXRobSBpbnZlbnRlZCBieSBhdXRob3Igb2YgdGhpcyBjb2RlLlxyXG4gKiBcclxuICogQXV0aG9yOiBUaG9tYXMgw4VobMOpbiwgdGhhaGxlbkBnbWFpbC5jb20gXHJcbiAqL1xyXG5cclxuLy8gQ2hhbmdlcyBmcm9tIHRoZSBKYXZhIHZlcnNpb25cclxuLy8gICBUdXJuZWQgRFRTd2VlcCBpbnRvIGEgc3RhdGljIGNsYXNzXHJcbi8vICAgTG90cyBvZiBkZWluZGVudGF0aW9uIHZpYSBlYXJseSBiYWlsb3V0XHJcbi8vIEZ1dHVyZSBwb3NzaWJpbGl0aWVzXHJcbi8vICAgQ29tbWVudHMhXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5EZWNvbXBvc2l0aW9uLkNEVDtcclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5LlN3ZWVwXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgRFRTd2VlcFxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgY29uc3QgZG91YmxlIFBJX2RpdjIgPSBNYXRoLlBJLzI7XHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBkb3VibGUgUElfM2RpdjQgPSAzKk1hdGguUEkvNDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUcmlhbmd1bGF0ZSBzaW1wbGUgcG9seWdvbiB3aXRoIGhvbGVzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgVHJpYW5ndWxhdGUoRFRTd2VlcENvbnRleHQgdGN4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGN4LkNyZWF0ZUFkdmFuY2luZ0Zyb250KCk7XHJcblxyXG4gICAgICAgICAgICBTd2VlcCh0Y3gpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluYWxpemUgdHJpYW5ndWxhdGlvblxyXG4gICAgICAgICAgICBpZiAodGN4LlRyaWFuZ3VsYXRpb25Nb2RlID09IFRyaWFuZ3VsYXRpb25Nb2RlLlBvbHlnb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpbmFsaXphdGlvblBvbHlnb24odGN4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpbmFsaXphdGlvbkNvbnZleEh1bGwodGN4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGN4LkRvbmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3RhcnQgc3dlZXBpbmcgdGhlIFktc29ydGVkIHBvaW50IHNldCBmcm9tIGJvdHRvbSB0byB0b3BcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgU3dlZXAoRFRTd2VlcENvbnRleHQgdGN4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IHBvaW50cyA9IHRjeC5Qb2ludHM7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludDtcclxuICAgICAgICAgICAgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IHBvaW50cy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBub2RlID0gUG9pbnRFdmVudCh0Y3gsIHBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnQuSGFzRWRnZXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yZWFjaCAoRFRTd2VlcENvbnN0cmFpbnQgZSBpbiBwb2ludC5FZGdlcylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEVkZ2VFdmVudCh0Y3gsIGUsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRjeC5VcGRhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSWYgdGhpcyBpcyBhIERlbGF1bmF5IFRyaWFuZ3VsYXRpb24gb2YgYSBwb2ludHNldCB3ZSBuZWVkIHRvIGZpbGwgc28gdGhlIHRyaWFuZ2xlIG1lc2ggZ2V0cyBhIENvbnZleEh1bGwgXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbmFsaXphdGlvbkNvbnZleEh1bGwoRFRTd2VlcENvbnRleHQgdGN4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQWR2YW5jaW5nRnJvbnROb2RlIG4xLCBuMjtcclxuICAgICAgICAgICAgRGVsYXVuYXlUcmlhbmdsZSB0MSwgdDI7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBmaXJzdCwgcDE7XHJcblxyXG4gICAgICAgICAgICBuMSA9IHRjeC5hRnJvbnQuSGVhZC5OZXh0O1xyXG4gICAgICAgICAgICBuMiA9IG4xLk5leHQ7XHJcbiAgICAgICAgICAgIGZpcnN0ID0gbjEuUG9pbnQ7XHJcblxyXG4gICAgICAgICAgICBUdXJuQWR2YW5jaW5nRnJvbnRDb252ZXgodGN4LCBuMSwgbjIpO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IENvbnZleEh1bGwgZm9yIGxvd2VyIHJpZ2h0IGFuZCBsZWZ0IGJvdW5kYXJ5XHJcblxyXG4gICAgICAgICAgICAvLyBMZXRzIHJlbW92ZSB0cmlhbmdsZXMgY29ubmVjdGVkIHRvIHRoZSB0d28gXCJhbGdvcml0aG1cIiBwb2ludHNcclxuXHJcbiAgICAgICAgICAgIC8vIFhYWDogV2hlbiB0aGUgZmlyc3QgdGhlIG5vZGVzIGFyZSBwb2ludHMgaW4gYSB0cmlhbmdsZSB3ZSBuZWVkIHRvIGRvIGEgZmxpcCBiZWZvcmUgXHJcbiAgICAgICAgICAgIC8vICAgICAgcmVtb3ZpbmcgdHJpYW5nbGVzIG9yIHdlIHdpbGwgbG9zZSBhIHZhbGlkIHRyaWFuZ2xlLlxyXG4gICAgICAgICAgICAvLyAgICAgIFNhbWUgZm9yIGxhc3QgdGhyZWUgbm9kZXMhXHJcbiAgICAgICAgICAgIC8vICEhISBJZiBJIGltcGxlbWVudCBDb252ZXhIdWxsIGZvciBsb3dlciByaWdodCBhbmQgbGVmdCBib3VuZGFyeSB0aGlzIGZpeCBzaG91bGQgbm90IGJlIFxyXG4gICAgICAgICAgICAvLyAgICAgbmVlZGVkIGFuZCB0aGUgcmVtb3ZlZCB0cmlhbmdsZXMgd2lsbCBiZSBhZGRlZCBhZ2FpbiBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgIG4xID0gdGN4LmFGcm9udC5UYWlsLlByZXY7XHJcbiAgICAgICAgICAgIGlmIChuMS5UcmlhbmdsZS5Db250YWlucyhuMS5OZXh0LlBvaW50KSAmJiBuMS5UcmlhbmdsZS5Db250YWlucyhuMS5QcmV2LlBvaW50KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdDEgPSBuMS5UcmlhbmdsZS5OZWlnaGJvckFjcm9zcyhuMS5Qb2ludCk7XHJcbiAgICAgICAgICAgICAgICBSb3RhdGVUcmlhbmdsZVBhaXIobjEuVHJpYW5nbGUsIG4xLlBvaW50LCB0MSwgdDEuT3Bwb3NpdGVQb2ludChuMS5UcmlhbmdsZSwgbjEuUG9pbnQpKTtcclxuICAgICAgICAgICAgICAgIHRjeC5NYXBUcmlhbmdsZVRvTm9kZXMobjEuVHJpYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgdGN4Lk1hcFRyaWFuZ2xlVG9Ob2Rlcyh0MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbjEgPSB0Y3guYUZyb250LkhlYWQuTmV4dDtcclxuICAgICAgICAgICAgaWYgKG4xLlRyaWFuZ2xlLkNvbnRhaW5zKG4xLlByZXYuUG9pbnQpICYmIG4xLlRyaWFuZ2xlLkNvbnRhaW5zKG4xLk5leHQuUG9pbnQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0MSA9IG4xLlRyaWFuZ2xlLk5laWdoYm9yQWNyb3NzKG4xLlBvaW50KTtcclxuICAgICAgICAgICAgICAgIFJvdGF0ZVRyaWFuZ2xlUGFpcihuMS5UcmlhbmdsZSwgbjEuUG9pbnQsIHQxLCB0MS5PcHBvc2l0ZVBvaW50KG4xLlRyaWFuZ2xlLCBuMS5Qb2ludCkpO1xyXG4gICAgICAgICAgICAgICAgdGN4Lk1hcFRyaWFuZ2xlVG9Ob2RlcyhuMS5UcmlhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB0Y3guTWFwVHJpYW5nbGVUb05vZGVzKHQxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTG93ZXIgcmlnaHQgYm91bmRhcnkgXHJcbiAgICAgICAgICAgIGZpcnN0ID0gdGN4LmFGcm9udC5IZWFkLlBvaW50O1xyXG4gICAgICAgICAgICBuMiA9IHRjeC5hRnJvbnQuVGFpbC5QcmV2O1xyXG4gICAgICAgICAgICB0MSA9IG4yLlRyaWFuZ2xlO1xyXG4gICAgICAgICAgICBwMSA9IG4yLlBvaW50O1xyXG4gICAgICAgICAgICBuMi5UcmlhbmdsZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRjeC5SZW1vdmVGcm9tTGlzdCh0MSk7XHJcbiAgICAgICAgICAgICAgICBwMSA9IHQxLlBvaW50Q0NXKHAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChwMSA9PSBmaXJzdCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB0MiA9IHQxLk5laWdoYm9yQ0NXKHAxKTtcclxuICAgICAgICAgICAgICAgIHQxLkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICB0MSA9IHQyO1xyXG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExvd2VyIGxlZnQgYm91bmRhcnlcclxuICAgICAgICAgICAgZmlyc3QgPSB0Y3guYUZyb250LkhlYWQuTmV4dC5Qb2ludDtcclxuICAgICAgICAgICAgcDEgPSB0MS5Qb2ludENXKHRjeC5hRnJvbnQuSGVhZC5Qb2ludCk7XHJcbiAgICAgICAgICAgIHQyID0gdDEuTmVpZ2hib3JDVyh0Y3guYUZyb250LkhlYWQuUG9pbnQpO1xyXG4gICAgICAgICAgICB0MS5DbGVhcigpO1xyXG4gICAgICAgICAgICB0MSA9IHQyO1xyXG4gICAgICAgICAgICB3aGlsZSAocDEgIT0gZmlyc3QpIC8vVE9ETzogUG9ydCBub3RlLiBUaGlzIHdhcyBkbyB3aGlsZSBiZWZvcmUuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRjeC5SZW1vdmVGcm9tTGlzdCh0MSk7XHJcbiAgICAgICAgICAgICAgICBwMSA9IHQxLlBvaW50Q0NXKHAxKTtcclxuICAgICAgICAgICAgICAgIHQyID0gdDEuTmVpZ2hib3JDQ1cocDEpO1xyXG4gICAgICAgICAgICAgICAgdDEuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHQxID0gdDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJyZW50IGhlYWQgYW5kIHRhaWwgbm9kZSBub3cgdGhhdCB3ZSBoYXZlIHJlbW92ZWQgYWxsIHRyaWFuZ2xlcyBhdHRhY2hlZFxyXG4gICAgICAgICAgICAvLyB0byB0aGVtLiBUaGVuIHNldCBuZXcgaGVhZCBhbmQgdGFpbCBub2RlIHBvaW50c1xyXG4gICAgICAgICAgICB0Y3guYUZyb250LkhlYWQgPSB0Y3guYUZyb250LkhlYWQuTmV4dDtcclxuICAgICAgICAgICAgdGN4LmFGcm9udC5IZWFkLlByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICB0Y3guYUZyb250LlRhaWwgPSB0Y3guYUZyb250LlRhaWwuUHJldjtcclxuICAgICAgICAgICAgdGN4LmFGcm9udC5UYWlsLk5leHQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgdGN4LkZpbmFsaXplVHJpYW5ndWxhdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBXZSB3aWxsIHRyYXZlcnNlIHRoZSBlbnRpcmUgYWR2YW5jaW5nIGZyb250IGFuZCBmaWxsIGl0IHRvIGZvcm0gYSBjb252ZXggaHVsbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgVHVybkFkdmFuY2luZ0Zyb250Q29udmV4KERUU3dlZXBDb250ZXh0IHRjeCwgQWR2YW5jaW5nRnJvbnROb2RlIGIsIEFkdmFuY2luZ0Zyb250Tm9kZSBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQWR2YW5jaW5nRnJvbnROb2RlIGZpcnN0ID0gYjtcclxuICAgICAgICAgICAgd2hpbGUgKGMgIT0gdGN4LmFGcm9udC5UYWlsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoYi5Qb2ludCwgYy5Qb2ludCwgYy5OZXh0LlBvaW50KSA9PSBPcmllbnRhdGlvbi5DQ1cpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gW2IsYyxkXSBDb25jYXZlIC0gZmlsbCBhcm91bmQgY1xyXG4gICAgICAgICAgICAgICAgICAgIEZpbGwodGN4LCBjKTtcclxuICAgICAgICAgICAgICAgICAgICBjID0gYy5OZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFtiLGMsZF0gQ29udmV4XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIgIT0gZmlyc3QgJiYgVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoYi5QcmV2LlBvaW50LCBiLlBvaW50LCBjLlBvaW50KSA9PSBPcmllbnRhdGlvbi5DQ1cpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBbYSxiLGNdIENvbmNhdmUgLSBmaWxsIGFyb3VuZCBiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZpbGwodGN4LCBiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGIuUHJldjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gW2EsYixjXSBDb252ZXggLSBub3RoaW5nIHRvIGZpbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBjLk5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbmFsaXphdGlvblBvbHlnb24oRFRTd2VlcENvbnRleHQgdGN4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gR2V0IGFuIEludGVybmFsIHRyaWFuZ2xlIHRvIHN0YXJ0IHdpdGhcclxuICAgICAgICAgICAgRGVsYXVuYXlUcmlhbmdsZSB0ID0gdGN4LmFGcm9udC5IZWFkLk5leHQuVHJpYW5nbGU7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBwID0gdGN4LmFGcm9udC5IZWFkLk5leHQuUG9pbnQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghdC5HZXRDb25zdHJhaW5lZEVkZ2VDVyhwKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdCA9IHQuTmVpZ2hib3JDQ1cocCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbGxlY3QgaW50ZXJpb3IgdHJpYW5nbGVzIGNvbnN0cmFpbmVkIGJ5IGVkZ2VzXHJcbiAgICAgICAgICAgIHRjeC5NZXNoQ2xlYW4odCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbmQgY2xvc2VzIG5vZGUgdG8gdGhlIGxlZnQgb2YgdGhlIG5ldyBwb2ludCBhbmRcclxuICAgICAgICAvLy8gY3JlYXRlIGEgbmV3IHRyaWFuZ2xlLiBJZiBuZWVkZWQgbmV3IGhvbGVzIGFuZCBiYXNpbnNcclxuICAgICAgICAvLy8gd2lsbCBiZSBmaWxsZWQgdG8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBBZHZhbmNpbmdGcm9udE5vZGUgUG9pbnRFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlLCBuZXdOb2RlO1xyXG5cclxuICAgICAgICAgICAgbm9kZSA9IHRjeC5Mb2NhdGVOb2RlKHBvaW50KTtcclxuICAgICAgICAgICAgbmV3Tm9kZSA9IE5ld0Zyb250VHJpYW5nbGUodGN4LCBwb2ludCwgbm9kZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IG5lZWQgdG8gY2hlY2sgK2Vwc2lsb24gc2luY2UgcG9pbnQgbmV2ZXIgaGF2ZSBzbWFsbGVyIFxyXG4gICAgICAgICAgICAvLyB4IHZhbHVlIHRoYW4gbm9kZSBkdWUgdG8gaG93IHdlIGZldGNoIG5vZGVzIGZyb20gdGhlIGZyb250XHJcbiAgICAgICAgICAgIGlmIChwb2ludC5YIDw9IG5vZGUuUG9pbnQuWCArIFRyaWFuZ3VsYXRpb25VdGlsLkVQU0lMT04pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpbGwodGN4LCBub2RlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGN4LkFkZE5vZGUobmV3Tm9kZSk7XHJcblxyXG4gICAgICAgICAgICBGaWxsQWR2YW5jaW5nRnJvbnQodGN4LCBuZXdOb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBuZXcgZnJvbnQgdHJpYW5nbGUgYW5kIGxlZ2FsaXplIGl0XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBBZHZhbmNpbmdGcm9udE5vZGUgTmV3RnJvbnRUcmlhbmdsZShEVFN3ZWVwQ29udGV4dCB0Y3gsIFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBuZXdOb2RlO1xyXG4gICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlO1xyXG5cclxuICAgICAgICAgICAgdHJpYW5nbGUgPSBuZXcgRGVsYXVuYXlUcmlhbmdsZShwb2ludCwgbm9kZS5Qb2ludCwgbm9kZS5OZXh0LlBvaW50KTtcclxuICAgICAgICAgICAgdHJpYW5nbGUuTWFya05laWdoYm9yKG5vZGUuVHJpYW5nbGUpO1xyXG4gICAgICAgICAgICB0Y3guVHJpYW5nbGVzLkFkZCh0cmlhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3IEFkdmFuY2luZ0Zyb250Tm9kZShwb2ludCk7XHJcbiAgICAgICAgICAgIG5ld05vZGUuTmV4dCA9IG5vZGUuTmV4dDtcclxuICAgICAgICAgICAgbmV3Tm9kZS5QcmV2ID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZS5OZXh0LlByZXYgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICBub2RlLk5leHQgPSBuZXdOb2RlO1xyXG5cclxuICAgICAgICAgICAgdGN4LkFkZE5vZGUobmV3Tm9kZSk7IC8vIFhYWDogQlNUXHJcblxyXG4gICAgICAgICAgICBpZiAoIUxlZ2FsaXplKHRjeCwgdHJpYW5nbGUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0Y3guTWFwVHJpYW5nbGVUb05vZGVzKHRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIERUU3dlZXBDb25zdHJhaW50IGVkZ2UsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHJ5XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRjeC5FZGdlRXZlbnQuQ29uc3RyYWluZWRFZGdlID0gZWRnZTtcclxuICAgICAgICAgICAgICAgIHRjeC5FZGdlRXZlbnQuUmlnaHQgPSBlZGdlLlAuWCA+IGVkZ2UuUS5YO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChJc0VkZ2VTaWRlT2ZUcmlhbmdsZShub2RlLlRyaWFuZ2xlLCBlZGdlLlAsIGVkZ2UuUSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvciBub3cgd2Ugd2lsbCBkbyBhbGwgbmVlZGVkIGZpbGxpbmdcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGludGVncmF0ZSB3aXRoIGZsaXAgcHJvY2VzcyBtaWdodCBnaXZlIHNvbWUgYmV0dGVyIHBlcmZvcm1hbmNlIFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgYnV0IGZvciBub3cgdGhpcyBhdm9pZCB0aGUgaXNzdWUgd2l0aCBjYXNlcyB0aGF0IG5lZWRzIGJvdGggZmxpcHMgYW5kIGZpbGxzXHJcbiAgICAgICAgICAgICAgICBGaWxsRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgRWRnZUV2ZW50KHRjeCwgZWRnZS5QLCBlZGdlLlEsIG5vZGUuVHJpYW5nbGUsIGVkZ2UuUSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKFBvaW50T25FZGdlRXhjZXB0aW9uIGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShTdHJpbmcuRm9ybWF0KFwiU2tpcHBpbmcgRWRnZTogezB9XCIsIGUuTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxFZGdlRXZlbnQoRFRTd2VlcENvbnRleHQgdGN4LCBEVFN3ZWVwQ29uc3RyYWludCBlZGdlLCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0Y3guRWRnZUV2ZW50LlJpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaWxsUmlnaHRBYm92ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRmlsbExlZnRBYm92ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxSaWdodENvbmNhdmVFZGdlRXZlbnQoRFRTd2VlcENvbnRleHQgdGN4LCBEVFN3ZWVwQ29uc3RyYWludCBlZGdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpbGwodGN4LCBub2RlLk5leHQpO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5OZXh0LlBvaW50ICE9IGVkZ2UuUClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gTmV4dCBhYm92ZSBvciBiZWxvdyBlZGdlP1xyXG4gICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKGVkZ2UuUSwgbm9kZS5OZXh0LlBvaW50LCBlZGdlLlApID09IE9yaWVudGF0aW9uLkNDVylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCZWxvd1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChub2RlLlBvaW50LCBub2RlLk5leHQuUG9pbnQsIG5vZGUuTmV4dC5OZXh0LlBvaW50KSA9PSBPcmllbnRhdGlvbi5DQ1cpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IGlzIGNvbmNhdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgRmlsbFJpZ2h0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IGlzIGNvbnZleFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsUmlnaHRDb252ZXhFZGdlRXZlbnQoRFRTd2VlcENvbnRleHQgdGN4LCBEVFN3ZWVwQ29uc3RyYWludCBlZGdlLCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIE5leHQgY29uY2F2ZSBvciBjb252ZXg/XHJcbiAgICAgICAgICAgIGlmIChUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChub2RlLk5leHQuUG9pbnQsIG5vZGUuTmV4dC5OZXh0LlBvaW50LCBub2RlLk5leHQuTmV4dC5OZXh0LlBvaW50KSA9PVxyXG4gICAgICAgICAgICAgICAgT3JpZW50YXRpb24uQ0NXKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb25jYXZlXHJcbiAgICAgICAgICAgICAgICBGaWxsUmlnaHRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZS5OZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbnZleFxyXG4gICAgICAgICAgICAgICAgLy8gTmV4dCBhYm92ZSBvciBiZWxvdyBlZGdlP1xyXG4gICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKGVkZ2UuUSwgbm9kZS5OZXh0Lk5leHQuUG9pbnQsIGVkZ2UuUCkgPT0gT3JpZW50YXRpb24uQ0NXKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlbG93XHJcbiAgICAgICAgICAgICAgICAgICAgRmlsbFJpZ2h0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZS5OZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBYm92ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxSaWdodEJlbG93RWRnZUV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgRFRTd2VlcENvbnN0cmFpbnQgZWRnZSwgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5Qb2ludC5YIDwgZWRnZS5QLlgpIC8vIG5lZWRlZD9cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuUG9pbnQsIG5vZGUuTmV4dC5Qb2ludCwgbm9kZS5OZXh0Lk5leHQuUG9pbnQpID09IE9yaWVudGF0aW9uLkNDVylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25jYXZlIFxyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxSaWdodENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXhcclxuICAgICAgICAgICAgICAgICAgICBGaWxsUmlnaHRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxSaWdodEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmlsbFJpZ2h0QWJvdmVFZGdlRXZlbnQoRFRTd2VlcENvbnRleHQgdGN4LCBEVFN3ZWVwQ29uc3RyYWludCBlZGdlLCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHdoaWxlIChub2RlLk5leHQuUG9pbnQuWCA8IGVkZ2UuUC5YKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBuZXh0IG5vZGUgaXMgYmVsb3cgdGhlIGVkZ2VcclxuICAgICAgICAgICAgICAgIE9yaWVudGF0aW9uIG8xID0gVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoZWRnZS5RLCBub2RlLk5leHQuUG9pbnQsIGVkZ2UuUCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobzEgPT0gT3JpZW50YXRpb24uQ0NXKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxSaWdodEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuTmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsTGVmdENvbnZleEVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIERUU3dlZXBDb25zdHJhaW50IGVkZ2UsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gTmV4dCBjb25jYXZlIG9yIGNvbnZleD9cclxuICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuUHJldi5Qb2ludCwgbm9kZS5QcmV2LlByZXYuUG9pbnQsIG5vZGUuUHJldi5QcmV2LlByZXYuUG9pbnQpID09XHJcbiAgICAgICAgICAgICAgICBPcmllbnRhdGlvbi5DVylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29uY2F2ZVxyXG4gICAgICAgICAgICAgICAgRmlsbExlZnRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZS5QcmV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbnZleFxyXG4gICAgICAgICAgICAgICAgLy8gTmV4dCBhYm92ZSBvciBiZWxvdyBlZGdlP1xyXG4gICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKGVkZ2UuUSwgbm9kZS5QcmV2LlByZXYuUG9pbnQsIGVkZ2UuUCkgPT0gT3JpZW50YXRpb24uQ1cpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVsb3dcclxuICAgICAgICAgICAgICAgICAgICBGaWxsTGVmdENvbnZleEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUuUHJldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWJvdmVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsTGVmdENvbmNhdmVFZGdlRXZlbnQoRFRTd2VlcENvbnRleHQgdGN4LCBEVFN3ZWVwQ29uc3RyYWludCBlZGdlLCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpbGwodGN4LCBub2RlLlByZXYpO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5QcmV2LlBvaW50ICE9IGVkZ2UuUClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gTmV4dCBhYm92ZSBvciBiZWxvdyBlZGdlP1xyXG4gICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKGVkZ2UuUSwgbm9kZS5QcmV2LlBvaW50LCBlZGdlLlApID09IE9yaWVudGF0aW9uLkNXKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlbG93XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuUG9pbnQsIG5vZGUuUHJldi5Qb2ludCwgbm9kZS5QcmV2LlByZXYuUG9pbnQpID09IE9yaWVudGF0aW9uLkNXKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV4dCBpcyBjb25jYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZpbGxMZWZ0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IGlzIGNvbnZleFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsTGVmdEJlbG93RWRnZUV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgRFRTd2VlcENvbnN0cmFpbnQgZWRnZSwgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5Qb2ludC5YID4gZWRnZS5QLlgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChub2RlLlBvaW50LCBub2RlLlByZXYuUG9pbnQsIG5vZGUuUHJldi5QcmV2LlBvaW50KSA9PSBPcmllbnRhdGlvbi5DVylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25jYXZlIFxyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxMZWZ0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZleFxyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxMZWZ0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0cnkgdGhpcyBvbmVcclxuICAgICAgICAgICAgICAgICAgICBGaWxsTGVmdEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmlsbExlZnRBYm92ZUVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIERUU3dlZXBDb25zdHJhaW50IGVkZ2UsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgd2hpbGUgKG5vZGUuUHJldi5Qb2ludC5YID4gZWRnZS5QLlgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG5leHQgbm9kZSBpcyBiZWxvdyB0aGUgZWRnZVxyXG4gICAgICAgICAgICAgICAgT3JpZW50YXRpb24gbzEgPSBUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChlZGdlLlEsIG5vZGUuUHJldi5Qb2ludCwgZWRnZS5QKTtcclxuICAgICAgICAgICAgICAgIGlmIChvMSA9PSBPcmllbnRhdGlvbi5DVylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaWxsTGVmdEJlbG93RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuUHJldjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPOiBQb3J0IG5vdGU6IFRoZXJlIHdlcmUgc29tZSBzdHJ1Y3R1cmFsIGRpZmZlcmVuY2VzIGhlcmUuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBJc0VkZ2VTaWRlT2ZUcmlhbmdsZShEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlLCBUcmlhbmd1bGF0aW9uUG9pbnQgZXAsIFRyaWFuZ3VsYXRpb25Qb2ludCBlcSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBpbmRleDtcclxuICAgICAgICAgICAgaW5kZXggPSB0cmlhbmdsZS5FZGdlSW5kZXgoZXAsIGVxKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZS5NYXJrQ29uc3RyYWluZWRFZGdlKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlID0gdHJpYW5nbGUuTmVpZ2hib3JzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICh0cmlhbmdsZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlLk1hcmtDb25zdHJhaW5lZEVkZ2UoZXAsIGVxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRWRnZUV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgVHJpYW5ndWxhdGlvblBvaW50IGVwLCBUcmlhbmd1bGF0aW9uUG9pbnQgZXEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsYXVuYXlUcmlhbmdsZSB0cmlhbmdsZSwgVHJpYW5ndWxhdGlvblBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IHAxLCBwMjtcclxuXHJcbiAgICAgICAgICAgIGlmIChJc0VkZ2VTaWRlT2ZUcmlhbmdsZSh0cmlhbmdsZSwgZXAsIGVxKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwMSA9IHRyaWFuZ2xlLlBvaW50Q0NXKHBvaW50KTtcclxuICAgICAgICAgICAgT3JpZW50YXRpb24gbzEgPSBUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChlcSwgcDEsIGVwKTtcclxuICAgICAgICAgICAgaWYgKG8xID09IE9yaWVudGF0aW9uLkNvbGxpbmVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyaWFuZ2xlLkNvbnRhaW5zKGVxLCBwMSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUuTWFya0NvbnN0cmFpbmVkRWRnZShlcSwgcDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBtb2RpZnlpbmcgdGhlIGNvbnN0cmFpbnQgbWF5YmUgaXQgd291bGQgYmUgYmV0dGVyIHRvIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjaGFuZ2UgdGhlIGdpdmVuIGNvbnN0cmFpbnQgYW5kIGp1c3Qga2VlcCBhIHZhcmlhYmxlIGZvciB0aGUgbmV3IGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgICAgICB0Y3guRWRnZUV2ZW50LkNvbnN0cmFpbmVkRWRnZS5RID0gcDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZS5OZWlnaGJvckFjcm9zcyhwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgRWRnZUV2ZW50KHRjeCwgZXAsIHAxLCB0cmlhbmdsZSwgcDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQb2ludE9uRWRnZUV4Y2VwdGlvbihcIkVkZ2VFdmVudCAtIFBvaW50IG9uIGNvbnN0cmFpbmVkIGVkZ2Ugbm90IHN1cHBvcnRlZCB5ZXRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGN4LklzRGVidWdFbmFibGVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShcIkVkZ2VFdmVudCAtIFBvaW50IG9uIGNvbnN0cmFpbmVkIGVkZ2VcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHAyID0gdHJpYW5nbGUuUG9pbnRDVyhwb2ludCk7XHJcbiAgICAgICAgICAgIE9yaWVudGF0aW9uIG8yID0gVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoZXEsIHAyLCBlcCk7XHJcbiAgICAgICAgICAgIGlmIChvMiA9PSBPcmllbnRhdGlvbi5Db2xsaW5lYXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmlhbmdsZS5Db250YWlucyhlcSwgcDIpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlLk1hcmtDb25zdHJhaW5lZEVkZ2UoZXEsIHAyKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgbW9kaWZ5aW5nIHRoZSBjb25zdHJhaW50IG1heWJlIGl0IHdvdWxkIGJlIGJldHRlciB0byBcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgY2hhbmdlIHRoZSBnaXZlbiBjb25zdHJhaW50IGFuZCBqdXN0IGtlZXAgYSB2YXJpYWJsZSBmb3IgdGhlIG5ldyBjb25zdHJhaW50XHJcbiAgICAgICAgICAgICAgICAgICAgdGN4LkVkZ2VFdmVudC5Db25zdHJhaW5lZEVkZ2UuUSA9IHAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlID0gdHJpYW5nbGUuTmVpZ2hib3JBY3Jvc3MocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIEVkZ2VFdmVudCh0Y3gsIGVwLCBwMiwgdHJpYW5nbGUsIHAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUG9pbnRPbkVkZ2VFeGNlcHRpb24oXCJFZGdlRXZlbnQgLSBQb2ludCBvbiBjb25zdHJhaW5lZCBlZGdlIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRjeC5Jc0RlYnVnRW5hYmxlZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJFZGdlRXZlbnQgLSBQb2ludCBvbiBjb25zdHJhaW5lZCBlZGdlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobzEgPT0gbzIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gZGVjaWRlIGlmIHdlIGFyZSByb3RhdGluZyBDVyBvciBDQ1cgdG8gZ2V0IHRvIGEgdHJpYW5nbGVcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2lsbCBjcm9zcyBlZGdlXHJcbiAgICAgICAgICAgICAgICBpZiAobzEgPT0gT3JpZW50YXRpb24uQ1cpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZS5OZWlnaGJvckNDVyhwb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZS5OZWlnaGJvckNXKHBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgdHJpYW5nbGUsIHBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgdHJpYW5nbGUgY3Jvc3NlcyBjb25zdHJhaW50IHNvIGxldHMgZmxpcHBpbiBzdGFydCFcclxuICAgICAgICAgICAgICAgIEZsaXBFZGdlRXZlbnQodGN4LCBlcCwgZXEsIHRyaWFuZ2xlLCBwb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmxpcEVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIFRyaWFuZ3VsYXRpb25Qb2ludCBlcCwgVHJpYW5ndWxhdGlvblBvaW50IGVxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIHQsIFRyaWFuZ3VsYXRpb25Qb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IG9wLCBuZXdQO1xyXG4gICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIG90O1xyXG4gICAgICAgICAgICBib29sIGluU2NhbkFyZWE7XHJcblxyXG4gICAgICAgICAgICBvdCA9IHQuTmVpZ2hib3JBY3Jvc3MocCk7XHJcbiAgICAgICAgICAgIG9wID0gb3QuT3Bwb3NpdGVQb2ludCh0LCBwKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvdCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3YW50IHRvIGludGVncmF0ZSB0aGUgZmlsbEVkZ2VFdmVudCBkbyBpdCBoZXJlXHJcbiAgICAgICAgICAgICAgICAvLyBXaXRoIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gd2Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9wZXJhdGlvbkV4Y2VwdGlvbihcIltCVUc6RklYTUVdIEZMSVAgZmFpbGVkIGR1ZSB0byBtaXNzaW5nIHRyaWFuZ2xlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpblNjYW5BcmVhID0gVHJpYW5ndWxhdGlvblV0aWwuSW5TY2FuQXJlYShwLCB0LlBvaW50Q0NXKHApLCB0LlBvaW50Q1cocCksIG9wKTtcclxuICAgICAgICAgICAgaWYgKGluU2NhbkFyZWEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIExldHMgcm90YXRlIHNoYXJlZCBlZGdlIG9uZSB2ZXJ0ZXggQ1dcclxuICAgICAgICAgICAgICAgIFJvdGF0ZVRyaWFuZ2xlUGFpcih0LCBwLCBvdCwgb3ApO1xyXG4gICAgICAgICAgICAgICAgdGN4Lk1hcFRyaWFuZ2xlVG9Ob2Rlcyh0KTtcclxuICAgICAgICAgICAgICAgIHRjeC5NYXBUcmlhbmdsZVRvTm9kZXMob3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwID09IGVxICYmIG9wID09IGVwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcSA9PSB0Y3guRWRnZUV2ZW50LkNvbnN0cmFpbmVkRWRnZS5RXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGVwID09IHRjeC5FZGdlRXZlbnQuQ29uc3RyYWluZWRFZGdlLlApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4jaWYgIU5FVEZYX0NPUkVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRjeC5Jc0RlYnVnRW5hYmxlZCkgQ29uc29sZS5Xcml0ZUxpbmUoXCJbRkxJUF0gLSBjb25zdHJhaW5lZCBlZGdlIGRvbmVcIik7IC8vIFRPRE86IHJlbW92ZVxyXG4jZW5kaWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5NYXJrQ29uc3RyYWluZWRFZGdlKGVwLCBlcSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90Lk1hcmtDb25zdHJhaW5lZEVkZ2UoZXAsIGVxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTGVnYWxpemUodGN4LCB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTGVnYWxpemUodGN4LCBvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiNpZiAhTkVURlhfQ09SRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGN4LklzRGVidWdFbmFibGVkKSBDb25zb2xlLldyaXRlTGluZShcIltGTElQXSAtIHN1YmVkZ2UgZG9uZVwiKTsgLy8gVE9ETzogcmVtb3ZlXHJcbiNlbmRpZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBYWFg6IEkgdGhpbmsgb25lIG9mIHRoZSB0cmlhbmdsZXMgc2hvdWxkIGJlIGxlZ2FsaXplZCBoZXJlP1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuI2lmICFORVRGWF9DT1JFXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRjeC5Jc0RlYnVnRW5hYmxlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ29uc29sZS5Xcml0ZUxpbmUoXCJbRkxJUF0gLSBmbGlwcGluZyBhbmQgY29udGludWluZyB3aXRoIHRyaWFuZ2xlIHN0aWxsIGNyb3NzaW5nIGVkZ2VcIik7XHJcbiNlbmRpZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgT3JpZW50YXRpb24gbyA9IFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKGVxLCBvcCwgZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBOZXh0RmxpcFRyaWFuZ2xlKHRjeCwgbywgdCwgb3QsIHAsIG9wKTtcclxuICAgICAgICAgICAgICAgICAgICBGbGlwRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCB0LCBwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5ld1AgPSBOZXh0RmxpcFBvaW50KGVwLCBlcSwgb3QsIG9wKTtcclxuICAgICAgICAgICAgICAgIEZsaXBTY2FuRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCB0LCBvdCwgbmV3UCk7XHJcbiAgICAgICAgICAgICAgICBFZGdlRXZlbnQodGN4LCBlcCwgZXEsIHQsIHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFdoZW4gd2UgbmVlZCB0byB0cmF2ZXJzZSBmcm9tIG9uZSB0cmlhbmdsZSB0byB0aGUgbmV4dCB3ZSBuZWVkIFxyXG4gICAgICAgIC8vLyB0aGUgcG9pbnQgaW4gY3VycmVudCB0cmlhbmdsZSB0aGF0IGlzIHRoZSBvcHBvc2l0ZSBwb2ludCB0byB0aGUgbmV4dFxyXG4gICAgICAgIC8vLyB0cmlhbmdsZS4gXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBUcmlhbmd1bGF0aW9uUG9pbnQgTmV4dEZsaXBQb2ludChUcmlhbmd1bGF0aW9uUG9pbnQgZXAsIFRyaWFuZ3VsYXRpb25Qb2ludCBlcSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIG90LCBUcmlhbmd1bGF0aW9uUG9pbnQgb3ApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBPcmllbnRhdGlvbiBvMmQgPSBUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChlcSwgb3AsIGVwKTtcclxuICAgICAgICAgICAgaWYgKG8yZCA9PSBPcmllbnRhdGlvbi5DVylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHRcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdC5Qb2ludENDVyhvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobzJkID09IE9yaWVudGF0aW9uLkNDVylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG90LlBvaW50Q1cob3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHN1cHBvcnQgZm9yIHBvaW50IG9uIGNvbnN0cmFpbnQgZWRnZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBvaW50T25FZGdlRXhjZXB0aW9uKFwiUG9pbnQgb24gY29uc3RyYWluZWQgZWRnZSBub3Qgc3VwcG9ydGVkIHlldFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZnRlciBhIGZsaXAgd2UgaGF2ZSB0d28gdHJpYW5nbGVzIGFuZCBrbm93IHRoYXQgb25seSBvbmUgd2lsbCBzdGlsbCBiZVxyXG4gICAgICAgIC8vLyBpbnRlcnNlY3RpbmcgdGhlIGVkZ2UuIFNvIGRlY2lkZSB3aGljaCB0byBjb250aXVuZSB3aXRoIGFuZCBsZWdhbGl6ZSB0aGUgb3RoZXJcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRjeFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib1wiPnNob3VsZCBiZSB0aGUgcmVzdWx0IG9mIGFuIFRyaWFuZ3VsYXRpb25VdGlsLm9yaWVudDJkKCBlcSwgb3AsIGVwICk8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRcIj50cmlhbmdsZSAxPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdFwiPnRyaWFuZ2xlIDI8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBcIj5hIHBvaW50IHNoYXJlZCBieSBib3RoIHRyaWFuZ2xlczwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3BcIj5hbm90aGVyIHBvaW50IHNoYXJlZCBieSBib3RoIHRyaWFuZ2xlczwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPnJldHVybnMgdGhlIHRyaWFuZ2xlIHN0aWxsIGludGVyc2VjdGluZyB0aGUgZWRnZTwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBEZWxhdW5heVRyaWFuZ2xlIE5leHRGbGlwVHJpYW5nbGUoRFRTd2VlcENvbnRleHQgdGN4LCBPcmllbnRhdGlvbiBvLCBEZWxhdW5heVRyaWFuZ2xlIHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgb3QsIFRyaWFuZ3VsYXRpb25Qb2ludCBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmlhbmd1bGF0aW9uUG9pbnQgb3ApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgZWRnZUluZGV4O1xyXG4gICAgICAgICAgICBpZiAobyA9PSBPcmllbnRhdGlvbi5DQ1cpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIG90IGlzIG5vdCBjcm9zc2luZyBlZGdlIGFmdGVyIGZsaXBcclxuICAgICAgICAgICAgICAgIGVkZ2VJbmRleCA9IG90LkVkZ2VJbmRleChwLCBvcCk7XHJcbiAgICAgICAgICAgICAgICBvdC5FZGdlSXNEZWxhdW5heVtlZGdlSW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIExlZ2FsaXplKHRjeCwgb3QpO1xyXG4gICAgICAgICAgICAgICAgb3QuRWRnZUlzRGVsYXVuYXkuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHQgaXMgbm90IGNyb3NzaW5nIGVkZ2UgYWZ0ZXIgZmxpcFxyXG4gICAgICAgICAgICBlZGdlSW5kZXggPSB0LkVkZ2VJbmRleChwLCBvcCk7XHJcbiAgICAgICAgICAgIHQuRWRnZUlzRGVsYXVuYXlbZWRnZUluZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgIExlZ2FsaXplKHRjeCwgdCk7XHJcbiAgICAgICAgICAgIHQuRWRnZUlzRGVsYXVuYXkuQ2xlYXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG90O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTY2FuIHBhcnQgb2YgdGhlIEZsaXBTY2FuIGFsZ29yaXRobTxicj5cclxuICAgICAgICAvLy8gV2hlbiBhIHRyaWFuZ2xlIHBhaXIgaXNuJ3QgZmxpcHBhYmxlIHdlIHdpbGwgc2NhbiBmb3IgdGhlIG5leHQgXHJcbiAgICAgICAgLy8vIHBvaW50IHRoYXQgaXMgaW5zaWRlIHRoZSBmbGlwIHRyaWFuZ2xlIHNjYW4gYXJlYS4gV2hlbiBmb3VuZCBcclxuICAgICAgICAvLy8gd2UgZ2VuZXJhdGUgYSBuZXcgZmxpcEVkZ2VFdmVudFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGN4XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlcFwiPmxhc3QgcG9pbnQgb24gdGhlIGVkZ2Ugd2UgYXJlIHRyYXZlcnNpbmc8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVxXCI+Zmlyc3QgcG9pbnQgb24gdGhlIGVkZ2Ugd2UgYXJlIHRyYXZlcnNpbmc8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZsaXBUcmlhbmdsZVwiPnRoZSBjdXJyZW50IHRyaWFuZ2xlIHNoYXJpbmcgdGhlIHBvaW50IGVxIHdpdGggZWRnZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPjwvcGFyYW0+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGbGlwU2NhbkVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIFRyaWFuZ3VsYXRpb25Qb2ludCBlcCwgVHJpYW5ndWxhdGlvblBvaW50IGVxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsYXVuYXlUcmlhbmdsZSBmbGlwVHJpYW5nbGUsIERlbGF1bmF5VHJpYW5nbGUgdCwgVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIG90O1xyXG4gICAgICAgICAgICBUcmlhbmd1bGF0aW9uUG9pbnQgb3AsIG5ld1A7XHJcbiAgICAgICAgICAgIGJvb2wgaW5TY2FuQXJlYTtcclxuXHJcbiAgICAgICAgICAgIG90ID0gdC5OZWlnaGJvckFjcm9zcyhwKTtcclxuICAgICAgICAgICAgb3AgPSBvdC5PcHBvc2l0ZVBvaW50KHQsIHApO1xyXG5cclxuICAgICAgICAgICAgaWYgKG90ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHdhbnQgdG8gaW50ZWdyYXRlIHRoZSBmaWxsRWRnZUV2ZW50IGRvIGl0IGhlcmVcclxuICAgICAgICAgICAgICAgIC8vIFdpdGggY3VycmVudCBpbXBsZW1lbnRhdGlvbiB3ZSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmVcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJbQlVHOkZJWE1FXSBGTElQIGZhaWxlZCBkdWUgdG8gbWlzc2luZyB0cmlhbmdsZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW5TY2FuQXJlYSA9IFRyaWFuZ3VsYXRpb25VdGlsLkluU2NhbkFyZWEoZXEsIGZsaXBUcmlhbmdsZS5Qb2ludENDVyhlcSksIGZsaXBUcmlhbmdsZS5Qb2ludENXKGVxKSwgb3ApO1xyXG4gICAgICAgICAgICBpZiAoaW5TY2FuQXJlYSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gZmxpcCB3aXRoIG5ldyBlZGdlIG9wLT5lcVxyXG4gICAgICAgICAgICAgICAgRmxpcEVkZ2VFdmVudCh0Y3gsIGVxLCBvcCwgb3QsIG9wKTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IEkganVzdCBmaWd1cmVkIG91dCB0aGF0IGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byBcclxuICAgICAgICAgICAgICAgIC8vICAgICAgIGltcHJvdmUgdGhpcyBieSBnZXR0aW5nIHRoZSBuZXh0IG90IGFuZCBvcCBiZWZvcmUgdGhlIHRoZSBhYm92ZSBcclxuICAgICAgICAgICAgICAgIC8vICAgICAgIGZsaXAgYW5kIGNvbnRpbnVlIHRoZSBmbGlwU2NhbkVkZ2VFdmVudCBoZXJlXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV3IG90IGFuZCBvcCBoZXJlIGFuZCBsb29wIGJhY2sgdG8gaW5TY2FuQXJlYSB0ZXN0XHJcbiAgICAgICAgICAgICAgICAvLyBhbHNvIG5lZWQgdG8gc2V0IGEgbmV3IGZsaXBUcmlhbmdsZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgLy8gVHVybnMgb3V0IGF0IGZpcnN0IGdsYW5jZSB0aGF0IHRoaXMgaXMgc29tZXdoYXQgY29tcGxpY2F0ZWRcclxuICAgICAgICAgICAgICAgIC8vIHNvIGl0IHdpbGwgaGF2ZSB0byB3YWl0LlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbmV3UCA9IE5leHRGbGlwUG9pbnQoZXAsIGVxLCBvdCwgb3ApO1xyXG4gICAgICAgICAgICAgICAgRmxpcFNjYW5FZGdlRXZlbnQodGN4LCBlcCwgZXEsIGZsaXBUcmlhbmdsZSwgb3QsIG5ld1ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbGxzIGhvbGVzIGluIHRoZSBBZHZhbmNpbmcgRnJvbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmlsbEFkdmFuY2luZ0Zyb250KERUU3dlZXBDb250ZXh0IHRjeCwgQWR2YW5jaW5nRnJvbnROb2RlIG4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZTtcclxuICAgICAgICAgICAgZG91YmxlIGFuZ2xlO1xyXG5cclxuICAgICAgICAgICAgLy8gRmlsbCByaWdodCBob2xlc1xyXG4gICAgICAgICAgICBub2RlID0gbi5OZXh0O1xyXG4gICAgICAgICAgICB3aGlsZSAobm9kZS5IYXNOZXh0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhbmdsZSA9IEhvbGVBbmdsZShub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChhbmdsZSA+IFBJX2RpdjIgfHwgYW5nbGUgPCAtUElfZGl2MilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEZpbGwodGN4LCBub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbGwgbGVmdCBob2xlc1xyXG4gICAgICAgICAgICBub2RlID0gbi5QcmV2O1xyXG4gICAgICAgICAgICB3aGlsZSAobm9kZS5IYXNQcmV2KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhbmdsZSA9IEhvbGVBbmdsZShub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChhbmdsZSA+IFBJX2RpdjIgfHwgYW5nbGUgPCAtUElfZGl2MilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEZpbGwodGN4LCBub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLlByZXY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbGwgcmlnaHQgYmFzaW5zXHJcbiAgICAgICAgICAgIGlmIChuLkhhc05leHQgJiYgbi5OZXh0Lkhhc05leHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFuZ2xlID0gQmFzaW5BbmdsZShuKTtcclxuICAgICAgICAgICAgICAgIGlmIChhbmdsZSA8IFBJXzNkaXY0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxCYXNpbih0Y3gsIG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpbGxzIGEgYmFzaW4gdGhhdCBoYXMgZm9ybWVkIG9uIHRoZSBBZHZhbmNpbmcgRnJvbnQgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgLy8vIG9mIGdpdmVuIG5vZGUuPGJyPlxyXG4gICAgICAgIC8vLyBGaXJzdCB3ZSBkZWNpZGUgYSBsZWZ0LGJvdHRvbSBhbmQgcmlnaHQgbm9kZSB0aGF0IGZvcm1zIHRoZSBcclxuICAgICAgICAvLy8gYm91bmRhcmllcyBvZiB0aGUgYmFzaW4uIFRoZW4gd2UgZG8gYSByZXF1cnNpdmUgZmlsbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRjeFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibm9kZVwiPnN0YXJ0aW5nIG5vZGUsIHRoaXMgb3IgbmV4dCBub2RlIHdpbGwgYmUgbGVmdCBub2RlPC9wYXJhbT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxCYXNpbihEVFN3ZWVwQ29udGV4dCB0Y3gsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuUG9pbnQsIG5vZGUuTmV4dC5Qb2ludCwgbm9kZS5OZXh0Lk5leHQuUG9pbnQpID09IE9yaWVudGF0aW9uLkNDVylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gdGN4LmJhc2luLmxlZnROb2RlID0gbm9kZS5uZXh0Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICB0Y3guQmFzaW4ubGVmdE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGN4LkJhc2luLmxlZnROb2RlID0gbm9kZS5OZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBib3R0b20gYW5kIHJpZ2h0IG5vZGVcclxuICAgICAgICAgICAgdGN4LkJhc2luLmJvdHRvbU5vZGUgPSB0Y3guQmFzaW4ubGVmdE5vZGU7XHJcbiAgICAgICAgICAgIHdoaWxlICh0Y3guQmFzaW4uYm90dG9tTm9kZS5IYXNOZXh0ICYmIHRjeC5CYXNpbi5ib3R0b21Ob2RlLlBvaW50LlkgPj0gdGN4LkJhc2luLmJvdHRvbU5vZGUuTmV4dC5Qb2ludC5ZKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0Y3guQmFzaW4uYm90dG9tTm9kZSA9IHRjeC5CYXNpbi5ib3R0b21Ob2RlLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0Y3guQmFzaW4uYm90dG9tTm9kZSA9PSB0Y3guQmFzaW4ubGVmdE5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIHZhbGlkIGJhc2luc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0Y3guQmFzaW4ucmlnaHROb2RlID0gdGN4LkJhc2luLmJvdHRvbU5vZGU7XHJcbiAgICAgICAgICAgIHdoaWxlICh0Y3guQmFzaW4ucmlnaHROb2RlLkhhc05leHQgJiYgdGN4LkJhc2luLnJpZ2h0Tm9kZS5Qb2ludC5ZIDwgdGN4LkJhc2luLnJpZ2h0Tm9kZS5OZXh0LlBvaW50LlkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRjeC5CYXNpbi5yaWdodE5vZGUgPSB0Y3guQmFzaW4ucmlnaHROb2RlLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0Y3guQmFzaW4ucmlnaHROb2RlID09IHRjeC5CYXNpbi5ib3R0b21Ob2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyB2YWxpZCBiYXNpbnNcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGN4LkJhc2luLndpZHRoID0gdGN4LkJhc2luLnJpZ2h0Tm9kZS5Qb2ludC5YIC0gdGN4LkJhc2luLmxlZnROb2RlLlBvaW50Llg7XHJcbiAgICAgICAgICAgIHRjeC5CYXNpbi5sZWZ0SGlnaGVzdCA9IHRjeC5CYXNpbi5sZWZ0Tm9kZS5Qb2ludC5ZID4gdGN4LkJhc2luLnJpZ2h0Tm9kZS5Qb2ludC5ZO1xyXG5cclxuICAgICAgICAgICAgRmlsbEJhc2luUmVxKHRjeCwgdGN4LkJhc2luLmJvdHRvbU5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZWN1cnNpdmUgYWxnb3JpdGhtIHRvIGZpbGwgYSBCYXNpbiB3aXRoIHRyaWFuZ2xlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsQmFzaW5SZXEoRFRTd2VlcENvbnRleHQgdGN4LCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGlmIHNoYWxsb3cgc3RvcCBmaWxsaW5nXHJcbiAgICAgICAgICAgIGlmIChJc1NoYWxsb3codGN4LCBub2RlKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBGaWxsKHRjeCwgbm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLlByZXYgPT0gdGN4LkJhc2luLmxlZnROb2RlICYmIG5vZGUuTmV4dCA9PSB0Y3guQmFzaW4ucmlnaHROb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5QcmV2ID09IHRjeC5CYXNpbi5sZWZ0Tm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgT3JpZW50YXRpb24gbyA9IFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuUG9pbnQsIG5vZGUuTmV4dC5Qb2ludCwgbm9kZS5OZXh0Lk5leHQuUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gPT0gT3JpZW50YXRpb24uQ1cpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLk5leHQgPT0gdGN4LkJhc2luLnJpZ2h0Tm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgT3JpZW50YXRpb24gbyA9IFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuUG9pbnQsIG5vZGUuUHJldi5Qb2ludCwgbm9kZS5QcmV2LlByZXYuUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gPT0gT3JpZW50YXRpb24uQ0NXKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLlByZXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBuZWlnaGJvciBub2RlIHdpdGggbG93ZXN0IFkgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLlByZXYuUG9pbnQuWSA8IG5vZGUuTmV4dC5Qb2ludC5ZKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLlByZXY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuTmV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBGaWxsQmFzaW5SZXEodGN4LCBub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgSXNTaGFsbG93KERUU3dlZXBDb250ZXh0IHRjeCwgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRjeC5CYXNpbi5sZWZ0SGlnaGVzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGN4LkJhc2luLmxlZnROb2RlLlBvaW50LlkgLSBub2RlLlBvaW50Llk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0Y3guQmFzaW4ucmlnaHROb2RlLlBvaW50LlkgLSBub2RlLlBvaW50Llk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRjeC5CYXNpbi53aWR0aCA+IGhlaWdodClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA/Pz9cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5vZGVcIj5taWRkbGUgbm9kZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPnRoZSBhbmdsZSBiZXR3ZWVuIDMgZnJvbnQgbm9kZXM8L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZG91YmxlIEhvbGVBbmdsZShBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFhYWDogZG8gd2UgcmVhbGx5IG5lZWQgYSBzaWduZWQgYW5nbGUgZm9yIGhvbGVBbmdsZT9cclxuICAgICAgICAgICAgLy8gICAgICBjb3VsZCBwb3NzaWJsZSBzYXZlIHNvbWUgY3ljbGVzIGhlcmVcclxuICAgICAgICAgICAgLyogQ29tcGxleCBwbGFuZVxyXG4gICAgICAgICAgICAgKiBhYiA9IGNvc0EgK2kqc2luQVxyXG4gICAgICAgICAgICAgKiBhYiA9IChheCArIGF5KmkpKGJ4ICsgYnkqaSkgPSAoYXgqYnggKyBheSpieSkgKyBpKGF4KmJ5LWF5KmJ4KVxyXG4gICAgICAgICAgICAgKiBhdGFuMih5LHgpIGNvbXB1dGVzIHRoZSBwcmluY2lwYWwgdmFsdWUgb2YgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAqIGFwcGxpZWQgdG8gdGhlIGNvbXBsZXggbnVtYmVyIHgraXlcclxuICAgICAgICAgICAgICogV2hlcmUgeCA9IGF4KmJ4ICsgYXkqYnlcclxuICAgICAgICAgICAgICogICAgICAgeSA9IGF4KmJ5IC0gYXkqYnhcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGRvdWJsZSBweCA9IG5vZGUuUG9pbnQuWDtcclxuICAgICAgICAgICAgZG91YmxlIHB5ID0gbm9kZS5Qb2ludC5ZO1xyXG4gICAgICAgICAgICBkb3VibGUgYXggPSBub2RlLk5leHQuUG9pbnQuWCAtIHB4O1xyXG4gICAgICAgICAgICBkb3VibGUgYXkgPSBub2RlLk5leHQuUG9pbnQuWSAtIHB5O1xyXG4gICAgICAgICAgICBkb3VibGUgYnggPSBub2RlLlByZXYuUG9pbnQuWCAtIHB4O1xyXG4gICAgICAgICAgICBkb3VibGUgYnkgPSBub2RlLlByZXYuUG9pbnQuWSAtIHB5O1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5BdGFuMihheCpieSAtIGF5KmJ4LCBheCpieCArIGF5KmJ5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGJhc2luIGFuZ2xlIGlzIGRlY2lkZWQgYWdhaW5zdCB0aGUgaG9yaXpvbnRhbCBsaW5lIFsxLDBdXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBkb3VibGUgQmFzaW5BbmdsZShBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBheCA9IG5vZGUuUG9pbnQuWCAtIG5vZGUuTmV4dC5OZXh0LlBvaW50Llg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBheSA9IG5vZGUuUG9pbnQuWSAtIG5vZGUuTmV4dC5OZXh0LlBvaW50Llk7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkF0YW4yKGF5LCBheCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYSB0cmlhbmdsZSB0byB0aGUgYWR2YW5jaW5nIGZyb250IHRvIGZpbGwgYSBob2xlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGN4XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJub2RlXCI+bWlkZGxlIG5vZGUsIHRoYXQgaXMgdGhlIGJvdHRvbSBvZiB0aGUgaG9sZTwvcGFyYW0+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsKERUU3dlZXBDb250ZXh0IHRjeCwgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlID0gbmV3IERlbGF1bmF5VHJpYW5nbGUobm9kZS5QcmV2LlBvaW50LCBub2RlLlBvaW50LCBub2RlLk5leHQuUG9pbnQpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgY29weSB0aGUgY0VkZ2UgdmFsdWUgZnJvbSBuZWlnaGJvciB0cmlhbmdsZXNcclxuICAgICAgICAgICAgLy8gICAgICAgZm9yIG5vdyBjRWRnZSB2YWx1ZXMgYXJlIGNvcGllZCBkdXJpbmcgdGhlIGxlZ2FsaXplIFxyXG4gICAgICAgICAgICB0cmlhbmdsZS5NYXJrTmVpZ2hib3Iobm9kZS5QcmV2LlRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgdHJpYW5nbGUuTWFya05laWdoYm9yKG5vZGUuVHJpYW5nbGUpO1xyXG4gICAgICAgICAgICB0Y3guVHJpYW5nbGVzLkFkZCh0cmlhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGFkdmFuY2luZyBmcm9udFxyXG4gICAgICAgICAgICBub2RlLlByZXYuTmV4dCA9IG5vZGUuTmV4dDtcclxuICAgICAgICAgICAgbm9kZS5OZXh0LlByZXYgPSBub2RlLlByZXY7XHJcbiAgICAgICAgICAgIHRjeC5SZW1vdmVOb2RlKG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgaXQgd2FzIGxlZ2FsaXplZCB0aGUgdHJpYW5nbGUgaGFzIGFscmVhZHkgYmVlbiBtYXBwZWRcclxuICAgICAgICAgICAgaWYgKCFMZWdhbGl6ZSh0Y3gsIHRyaWFuZ2xlKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGN4Lk1hcFRyaWFuZ2xlVG9Ob2Rlcyh0cmlhbmdsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyB0cnVlIGlmIHRyaWFuZ2xlIHdhcyBsZWdhbGl6ZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgTGVnYWxpemUoRFRTd2VlcENvbnRleHQgdGN4LCBEZWxhdW5heVRyaWFuZ2xlIHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgb2k7XHJcbiAgICAgICAgICAgIGJvb2wgaW5zaWRlO1xyXG4gICAgICAgICAgICBUcmlhbmd1bGF0aW9uUG9pbnQgcCwgb3A7XHJcbiAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgb3Q7XHJcblxyXG4gICAgICAgICAgICAvLyBUbyBsZWdhbGl6ZSBhIHRyaWFuZ2xlIHdlIHN0YXJ0IGJ5IGZpbmRpbmcgaWYgYW55IG9mIHRoZSB0aHJlZSBlZGdlc1xyXG4gICAgICAgICAgICAvLyB2aW9sYXRlIHRoZSBEZWxhdW5heSBjb25kaXRpb25cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpeCBzbyB0aGF0IGNFZGdlIGlzIGFsd2F5cyB2YWxpZCB3aGVuIGNyZWF0aW5nIG5ldyB0cmlhbmdsZXMgdGhlbiB3ZSBjYW4gY2hlY2sgaXQgaGVyZVxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgaW5zdGVhZCBvZiBiZWxvdyB3aXRoIG90XHJcbiAgICAgICAgICAgICAgICBpZiAodC5FZGdlSXNEZWxhdW5heVtpXSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBvdCA9IHQuTmVpZ2hib3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG90ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHQuUG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wID0gb3QuT3Bwb3NpdGVQb2ludCh0LCBwKTtcclxuICAgICAgICAgICAgICAgICAgICBvaSA9IG90LkluZGV4T2Yob3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBDb25zdHJhaW5lZCBFZGdlIG9yIGEgRGVsYXVuYXkgRWRnZShvbmx5IGR1cmluZyByZWN1cnNpdmUgbGVnYWxpemF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIG5vdCB0cnkgdG8gbGVnYWxpemVcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3QuRWRnZUlzQ29uc3RyYWluZWRbb2ldIHx8IG90LkVkZ2VJc0RlbGF1bmF5W29pXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuRWRnZUlzQ29uc3RyYWluZWRbaV0gPSBvdC5FZGdlSXNDb25zdHJhaW5lZFtvaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBYWFg6IGhhdmUgbm8gZ29vZCB3YXkgb2Ygc2V0dGluZyB0aGlzIHByb3BlcnR5IHdoZW4gY3JlYXRpbmcgbmV3IHRyaWFuZ2xlcyBzbyBsZXRzIHNldCBpdCBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlID0gVHJpYW5ndWxhdGlvblV0aWwuU21hcnRJbmNpcmNsZShwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5Qb2ludENDVyhwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuUG9pbnRDVyhwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2lkZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgbm90TGVnYWxpemVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV0cyBtYXJrIHRoaXMgc2hhcmVkIGVkZ2UgYXMgRGVsYXVuYXkgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuRWRnZUlzRGVsYXVuYXlbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdC5FZGdlSXNEZWxhdW5heVtvaV0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV0cyByb3RhdGUgc2hhcmVkIGVkZ2Ugb25lIHZlcnRleCBDVyB0byBsZWdhbGl6ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBSb3RhdGVUcmlhbmdsZVBhaXIodCwgcCwgb3QsIG9wKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5vdyBnb3Qgb25lIHZhbGlkIERlbGF1bmF5IEVkZ2Ugc2hhcmVkIGJ5IHR3byB0cmlhbmdsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyB1cyA0IG5ldyBlZGdlcyB0byBjaGVjayBmb3IgRGVsYXVuYXlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRyaWFuZ2xlIHRvIG5vZGUgbWFwcGluZyBpcyBkb25lIG9ubHkgb25lIHRpbWUgZm9yIGEgc3BlY2lmaWMgdHJpYW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm90TGVnYWxpemVkID0gIUxlZ2FsaXplKHRjeCwgdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90TGVnYWxpemVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Y3guTWFwVHJpYW5nbGVUb05vZGVzKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdExlZ2FsaXplZCA9ICFMZWdhbGl6ZSh0Y3gsIG90KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdExlZ2FsaXplZClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGN4Lk1hcFRyaWFuZ2xlVG9Ob2RlcyhvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBEZWxhdW5heSBlZGdlcywgc2luY2UgdGhleSBvbmx5IGFyZSB2YWxpZCBEZWxhdW5heSBlZGdlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnRpbCB3ZSBhZGQgYSBuZXcgdHJpYW5nbGUgb3IgcG9pbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhYWDogbmVlZCB0byB0aGluayBhYm91dCB0aGlzLiBDYW4gdGhlc2UgZWRnZXMgYmUgdHJpZWQgYWZ0ZXIgd2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgcmV0dXJuIHRvIHByZXZpb3VzIHJlY3Vyc2l2ZSBsZXZlbD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5FZGdlSXNEZWxhdW5heVtpXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdC5FZGdlSXNEZWxhdW5heVtvaV0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRyaWFuZ2xlIGhhdmUgYmVlbiBsZWdhbGl6ZWQgbm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgZWRnZXMgc2luY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlY3Vyc2l2ZSBsZWdhbGl6YXRpb24gd2lsbCBoYW5kbGVzIHRob3NlIHNvIHdlIGNhbiBlbmQgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUm90YXRlcyBhIHRyaWFuZ2xlIHBhaXIgb25lIHZlcnRleCBDV1xyXG4gICAgICAgIC8vLyAgICAgICBuMiAgICAgICAgICAgICAgICAgICAgbjJcclxuICAgICAgICAvLy8gIFAgKy0tLS0tKyAgICAgICAgICAgICBQICstLS0tLStcclxuICAgICAgICAvLy8gICAgfCB0ICAvfCAgICAgICAgICAgICAgIHxcXCAgdCB8ICBcclxuICAgICAgICAvLy8gICAgfCAgIC8gfCAgICAgICAgICAgICAgIHwgXFwgICB8XHJcbiAgICAgICAgLy8vICBuMXwgIC8gIHxuMyAgICAgICAgICAgbjF8ICBcXCAgfG4zXHJcbiAgICAgICAgLy8vICAgIHwgLyAgIHwgICAgYWZ0ZXIgQ1cgICB8ICAgXFwgfFxyXG4gICAgICAgIC8vLyAgICB8LyBvVCB8ICAgICAgICAgICAgICAgfCBvVCBcXHxcclxuICAgICAgICAvLy8gICAgKy0tLS0tKyBvUCAgICAgICAgICAgICstLS0tLStcclxuICAgICAgICAvLy8gICAgICAgbjQgICAgICAgICAgICAgICAgICAgIG40XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIFJvdGF0ZVRyaWFuZ2xlUGFpcihEZWxhdW5heVRyaWFuZ2xlIHQsIFRyaWFuZ3VsYXRpb25Qb2ludCBwLCBEZWxhdW5heVRyaWFuZ2xlIG90LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBvcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgbjEsIG4yLCBuMywgbjQ7XHJcbiAgICAgICAgICAgIG4xID0gdC5OZWlnaGJvckNDVyhwKTtcclxuICAgICAgICAgICAgbjIgPSB0Lk5laWdoYm9yQ1cocCk7XHJcbiAgICAgICAgICAgIG4zID0gb3QuTmVpZ2hib3JDQ1cob3ApO1xyXG4gICAgICAgICAgICBuNCA9IG90Lk5laWdoYm9yQ1cob3ApO1xyXG5cclxuICAgICAgICAgICAgYm9vbCBjZTEsIGNlMiwgY2UzLCBjZTQ7XHJcbiAgICAgICAgICAgIGNlMSA9IHQuR2V0Q29uc3RyYWluZWRFZGdlQ0NXKHApO1xyXG4gICAgICAgICAgICBjZTIgPSB0LkdldENvbnN0cmFpbmVkRWRnZUNXKHApO1xyXG4gICAgICAgICAgICBjZTMgPSBvdC5HZXRDb25zdHJhaW5lZEVkZ2VDQ1cob3ApO1xyXG4gICAgICAgICAgICBjZTQgPSBvdC5HZXRDb25zdHJhaW5lZEVkZ2VDVyhvcCk7XHJcblxyXG4gICAgICAgICAgICBib29sIGRlMSwgZGUyLCBkZTMsIGRlNDtcclxuICAgICAgICAgICAgZGUxID0gdC5HZXREZWxhdW5heUVkZ2VDQ1cocCk7XHJcbiAgICAgICAgICAgIGRlMiA9IHQuR2V0RGVsYXVuYXlFZGdlQ1cocCk7XHJcbiAgICAgICAgICAgIGRlMyA9IG90LkdldERlbGF1bmF5RWRnZUNDVyhvcCk7XHJcbiAgICAgICAgICAgIGRlNCA9IG90LkdldERlbGF1bmF5RWRnZUNXKG9wKTtcclxuXHJcbiAgICAgICAgICAgIHQuTGVnYWxpemUocCwgb3ApO1xyXG4gICAgICAgICAgICBvdC5MZWdhbGl6ZShvcCwgcCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1hcCBkRWRnZVxyXG4gICAgICAgICAgICBvdC5TZXREZWxhdW5heUVkZ2VDQ1cocCwgZGUxKTtcclxuICAgICAgICAgICAgdC5TZXREZWxhdW5heUVkZ2VDVyhwLCBkZTIpO1xyXG4gICAgICAgICAgICB0LlNldERlbGF1bmF5RWRnZUNDVyhvcCwgZGUzKTtcclxuICAgICAgICAgICAgb3QuU2V0RGVsYXVuYXlFZGdlQ1cob3AsIGRlNCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1hcCBjRWRnZVxyXG4gICAgICAgICAgICBvdC5TZXRDb25zdHJhaW5lZEVkZ2VDQ1cocCwgY2UxKTtcclxuICAgICAgICAgICAgdC5TZXRDb25zdHJhaW5lZEVkZ2VDVyhwLCBjZTIpO1xyXG4gICAgICAgICAgICB0LlNldENvbnN0cmFpbmVkRWRnZUNDVyhvcCwgY2UzKTtcclxuICAgICAgICAgICAgb3QuU2V0Q29uc3RyYWluZWRFZGdlQ1cob3AsIGNlNCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1hcCBuZWlnaGJvcnNcclxuICAgICAgICAgICAgLy8gWFhYOiBtaWdodCBvcHRpbWl6ZSB0aGUgbWFya05laWdoYm9yIGJ5IGtlZXBpbmcgdHJhY2sgb2ZcclxuICAgICAgICAgICAgLy8gICAgICB3aGF0IHNpZGUgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIHdoYXQgbmVpZ2hib3IgYWZ0ZXIgdGhlIFxyXG4gICAgICAgICAgICAvLyAgICAgIHJvdGF0aW9uLiBOb3cgbWFyayBuZWlnaGJvciBkb2VzIGxvdHMgb2YgdGVzdGluZyB0byBmaW5kIFxyXG4gICAgICAgICAgICAvLyAgICAgIHRoZSByaWdodCBzaWRlLlxyXG4gICAgICAgICAgICB0Lk5laWdoYm9ycy5DbGVhcigpO1xyXG4gICAgICAgICAgICBvdC5OZWlnaGJvcnMuQ2xlYXIoKTtcclxuICAgICAgICAgICAgaWYgKG4xICE9IG51bGwpIG90Lk1hcmtOZWlnaGJvcihuMSk7XHJcbiAgICAgICAgICAgIGlmIChuMiAhPSBudWxsKSB0Lk1hcmtOZWlnaGJvcihuMik7XHJcbiAgICAgICAgICAgIGlmIChuMyAhPSBudWxsKSB0Lk1hcmtOZWlnaGJvcihuMyk7XHJcbiAgICAgICAgICAgIGlmIChuNCAhPSBudWxsKSBvdC5NYXJrTmVpZ2hib3IobjQpO1xyXG4gICAgICAgICAgICB0Lk1hcmtOZWlnaGJvcihvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uUnVudGltZS5Db21waWxlclNlcnZpY2VzO1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5O1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb25cclxue1xyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIFRyaWFuZ3VsYXRpb25Db250ZXh0XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBQb2ludHMgPSBuZXcgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+KDIwMCk7XHJcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IExpc3Q8RGVsYXVuYXlUcmlhbmdsZT4gVHJpYW5nbGVzID0gbmV3IExpc3Q8RGVsYXVuYXlUcmlhbmdsZT4oKTtcclxuICAgICAgICBwcml2YXRlIGludCBfc3RlcFRpbWUgPSAtMTtcclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRpb25Db250ZXh0KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0aW9uTW9kZSBUcmlhbmd1bGF0aW9uTW9kZSB7IGdldDsgcHJvdGVjdGVkIHNldDsgfVxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0YWJsZSBUcmlhbmd1bGF0YWJsZSB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgV2FpdFVudGlsTm90aWZpZWQgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcbiAgICAgICAgcHVibGljIGJvb2wgVGVybWluYXRlZCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBpbnQgU3RlcENvdW50IHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIGJvb2wgSXNEZWJ1Z0VuYWJsZWQgeyBnZXQ7IHByb3RlY3RlZCBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgRG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdGVwQ291bnQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgUHJlcGFyZVRyaWFuZ3VsYXRpb24oVHJpYW5ndWxhdGFibGUgdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRhYmxlID0gdDtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGlvbk1vZGUgPSB0LlRyaWFuZ3VsYXRpb25Nb2RlO1xyXG4gICAgICAgICAgICB0LlByZXBhcmVUcmlhbmd1bGF0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFRyaWFuZ3VsYXRpb25Db25zdHJhaW50IE5ld0NvbnN0cmFpbnQoVHJpYW5ndWxhdGlvblBvaW50IGEsIFRyaWFuZ3VsYXRpb25Qb2ludCBiKTtcclxuXHJcbiNpZiAhTkVURlhfQ09SRVxyXG4gICAgICAgIFtNZXRob2RJbXBsKE1ldGhvZEltcGxPcHRpb25zLlN5bmNocm9uaXplZCldXHJcbiNlbmRpZlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFVwZGF0ZShzdHJpbmcgbWVzc2FnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIENsZWFyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50cy5DbGVhcigpO1xyXG4gICAgICAgICAgICBUZXJtaW5hdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIFN0ZXBDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5LlN3ZWVwO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb25cclxue1xyXG4gICAgcHVibGljIGNsYXNzIFRyaWFuZ3VsYXRpb25Qb2ludFxyXG4gICAge1xyXG4gICAgICAgIC8vIExpc3Qgb2YgZWRnZXMgdGhpcyBwb2ludCBjb25zdGl0dXRlcyBhbiB1cHBlciBlbmRpbmcgcG9pbnQgKENEVClcclxuXHJcbiAgICAgICAgcHVibGljIGRvdWJsZSBYLCBZO1xyXG5cclxuICAgICAgICBwdWJsaWMgVHJpYW5ndWxhdGlvblBvaW50KGRvdWJsZSB4LCBkb3VibGUgeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFggPSB4O1xyXG4gICAgICAgICAgICBZID0geTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBMaXN0PERUU3dlZXBDb25zdHJhaW50PiBFZGdlcyB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IFhmXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKGZsb2F0KSBYOyB9XHJcbiAgICAgICAgICAgIHNldCB7IFggPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IFlmXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKGZsb2F0KSBZOyB9XHJcbiAgICAgICAgICAgIHNldCB7IFkgPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSGFzRWRnZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBFZGdlcyAhPSBudWxsOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgc3RyaW5nIFRvU3RyaW5nKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArIFggKyBcIixcIiArIFkgKyBcIl1cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZEVkZ2UoRFRTd2VlcENvbnN0cmFpbnQgZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChFZGdlcyA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBFZGdlcyA9IG5ldyBMaXN0PERUU3dlZXBDb25zdHJhaW50PigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEVkZ2VzLkFkZChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXkuU3dlZXBcclxue1xyXG4gICAgcHVibGljIGNsYXNzIFBvaW50T25FZGdlRXhjZXB0aW9uIDogTm90SW1wbGVtZW50ZWRFeGNlcHRpb25cclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgUG9pbnRPbkVkZ2VFeGNlcHRpb24oc3RyaW5nIG1lc3NhZ2UpXHJcbiAgICAgICAgICAgIDogYmFzZShtZXNzYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxuLy8gQ2hhbmdlcyBmcm9tIHRoZSBKYXZhIHZlcnNpb25cclxuLy8gICBSZXBsYWNlZCBnZXRQb2x5Z29ucyB3aXRoIGF0dHJpYnV0ZVxyXG4vLyBGdXR1cmUgcG9zc2liaWxpdGllc1xyXG4vLyAgIFJlcGxhY2UgQWRkKFBvbHlnb24pIHdpdGggZXhwb3NlZCBjb250YWluZXI/XHJcbi8vICAgUmVwbGFjZSBlbnRpcmUgY2xhc3Mgd2l0aCBIYXNoU2V0PFBvbHlnb24+ID9cclxuXHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uUG9seWdvblxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgUG9seWdvblNldFxyXG4gICAge1xyXG4gICAgICAgIHByb3RlY3RlZCBMaXN0PFBvbHlnb24+IF9wb2x5Z29ucyA9IG5ldyBMaXN0PFBvbHlnb24+KCk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBQb2x5Z29uU2V0KClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgUG9seWdvblNldChQb2x5Z29uIHBvbHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfcG9seWdvbnMuQWRkKHBvbHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIElFbnVtZXJhYmxlPFBvbHlnb24+IFBvbHlnb25zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3BvbHlnb25zOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGQoUG9seWdvbiBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3BvbHlnb25zLkFkZChwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb24uQ0RUO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb25cclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBAYXV0aG9yIFRob21hcyDDhWhsw6luLCB0aGFobGVuQGdtYWlsLmNvbVxyXG4gICAgICovXHJcblxyXG4gICAgcHVibGljIGNsYXNzIFRyaWFuZ3VsYXRpb25VdGlsXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBkb3VibGUgRVBTSUxPTiA9IDFlLTEyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vICAgUmVxdWlyZW1lbnRzOlxyXG4gICAgICAgIC8vLyAxLiBhLGIgYW5kIGMgZm9ybSBhIHRyaWFuZ2xlLlxyXG4gICAgICAgIC8vLyAyLiBhIGFuZCBkIGlzIGtub3cgdG8gYmUgb24gb3Bwb3NpdGUgc2lkZSBvZiBiY1xyXG4gICAgICAgIC8vLyA8Y29kZT5cclxuICAgICAgICAvLy8gICAgICAgICAgICAgICAgYVxyXG4gICAgICAgIC8vLyAgICAgICAgICAgICAgICArXHJcbiAgICAgICAgLy8vICAgICAgICAgICAgICAgLyBcXFxyXG4gICAgICAgIC8vLyAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgICAgLy8vICAgICAgICAgICAgYi8gICAgIFxcY1xyXG4gICAgICAgIC8vLyAgICAgICAgICAgICstLS0tLS0tKyBcclxuICAgICAgICAvLy8gICAgICAgICAgIC8gICAgQiAgICBcXCAgXHJcbiAgICAgICAgLy8vICAgICAgICAgIC8gICAgICAgICAgIFxcIFxyXG4gICAgICAgIC8vLyA8L2NvZGU+XHJcbiAgICAgICAgLy8vICAgIEZhY3RzOlxyXG4gICAgICAgIC8vLyAgZCBoYXMgdG8gYmUgaW4gYXJlYSBCIHRvIGhhdmUgYSBjaGFuY2UgdG8gYmUgaW5zaWRlIHRoZSBjaXJjbGUgZm9ybWVkIGJ5IGEsYiBhbmQgY1xyXG4gICAgICAgIC8vLyAgZCBpcyBvdXRzaWRlIEIgaWYgb3JpZW50MmQoYSxiLGQpIG9yIG9yaWVudDJkKGMsYSxkKSBpcyBDV1xyXG4gICAgICAgIC8vLyAgVGhpcyBwcmVrbm93bGVkZ2UgZ2l2ZXMgdXMgYSB3YXkgdG8gb3B0aW1pemUgdGhlIGluY2lyY2xlIHRlc3RcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBhXCI+dHJpYW5nbGUgcG9pbnQsIG9wcG9zaXRlIGQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBiXCI+dHJpYW5nbGUgcG9pbnQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBjXCI+dHJpYW5nbGUgcG9pbnQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBkXCI+cG9pbnQgb3Bwb3NpdGUgYTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPnRydWUgaWYgZCBpcyBpbnNpZGUgY2lyY2xlLCBmYWxzZSBpZiBvbiBjaXJjbGUgZWRnZTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgU21hcnRJbmNpcmNsZShUcmlhbmd1bGF0aW9uUG9pbnQgcGEsIFRyaWFuZ3VsYXRpb25Qb2ludCBwYiwgVHJpYW5ndWxhdGlvblBvaW50IHBjLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBwZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBwZHggPSBwZC5YO1xyXG4gICAgICAgICAgICBkb3VibGUgcGR5ID0gcGQuWTtcclxuICAgICAgICAgICAgZG91YmxlIGFkeCA9IHBhLlggLSBwZHg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBhZHkgPSBwYS5ZIC0gcGR5O1xyXG4gICAgICAgICAgICBkb3VibGUgYmR4ID0gcGIuWCAtIHBkeDtcclxuICAgICAgICAgICAgZG91YmxlIGJkeSA9IHBiLlkgLSBwZHk7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgYWR4YmR5ID0gYWR4KmJkeTtcclxuICAgICAgICAgICAgZG91YmxlIGJkeGFkeSA9IGJkeCphZHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBvYWJkID0gYWR4YmR5IC0gYmR4YWR5O1xyXG4gICAgICAgICAgICAvLyAgICAgICAgb2FiZCA9IG9yaWVudDJkKHBhLHBiLHBkKTtcclxuICAgICAgICAgICAgaWYgKG9hYmQgPD0gMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZG91YmxlIGNkeCA9IHBjLlggLSBwZHg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBjZHkgPSBwYy5ZIC0gcGR5O1xyXG5cclxuICAgICAgICAgICAgZG91YmxlIGNkeGFkeSA9IGNkeCphZHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBhZHhjZHkgPSBhZHgqY2R5O1xyXG4gICAgICAgICAgICBkb3VibGUgb2NhZCA9IGNkeGFkeSAtIGFkeGNkeTtcclxuICAgICAgICAgICAgLy8gICAgICBvY2FkID0gb3JpZW50MmQocGMscGEscGQpO1xyXG4gICAgICAgICAgICBpZiAob2NhZCA8PSAwKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgYmR4Y2R5ID0gYmR4KmNkeTtcclxuICAgICAgICAgICAgZG91YmxlIGNkeGJkeSA9IGNkeCpiZHk7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgYWxpZnQgPSBhZHgqYWR4ICsgYWR5KmFkeTtcclxuICAgICAgICAgICAgZG91YmxlIGJsaWZ0ID0gYmR4KmJkeCArIGJkeSpiZHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBjbGlmdCA9IGNkeCpjZHggKyBjZHkqY2R5O1xyXG5cclxuICAgICAgICAgICAgZG91YmxlIGRldCA9IGFsaWZ0KihiZHhjZHkgLSBjZHhiZHkpICsgYmxpZnQqb2NhZCArIGNsaWZ0Km9hYmQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGV0ID4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBJblNjYW5BcmVhKFRyaWFuZ3VsYXRpb25Qb2ludCBwYSwgVHJpYW5ndWxhdGlvblBvaW50IHBiLCBUcmlhbmd1bGF0aW9uUG9pbnQgcGMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IHBkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIHBkeCA9IHBkLlg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBwZHkgPSBwZC5ZO1xyXG4gICAgICAgICAgICBkb3VibGUgYWR4ID0gcGEuWCAtIHBkeDtcclxuICAgICAgICAgICAgZG91YmxlIGFkeSA9IHBhLlkgLSBwZHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBiZHggPSBwYi5YIC0gcGR4O1xyXG4gICAgICAgICAgICBkb3VibGUgYmR5ID0gcGIuWSAtIHBkeTtcclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSBhZHhiZHkgPSBhZHgqYmR5O1xyXG4gICAgICAgICAgICBkb3VibGUgYmR4YWR5ID0gYmR4KmFkeTtcclxuICAgICAgICAgICAgZG91YmxlIG9hYmQgPSBhZHhiZHkgLSBiZHhhZHk7XHJcbiAgICAgICAgICAgIC8vICAgICAgICBvYWJkID0gb3JpZW50MmQocGEscGIscGQpO1xyXG4gICAgICAgICAgICBpZiAob2FiZCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSBjZHggPSBwYy5YIC0gcGR4O1xyXG4gICAgICAgICAgICBkb3VibGUgY2R5ID0gcGMuWSAtIHBkeTtcclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSBjZHhhZHkgPSBjZHgqYWR5O1xyXG4gICAgICAgICAgICBkb3VibGUgYWR4Y2R5ID0gYWR4KmNkeTtcclxuICAgICAgICAgICAgZG91YmxlIG9jYWQgPSBjZHhhZHkgLSBhZHhjZHk7XHJcbiAgICAgICAgICAgIC8vICAgICAgb2NhZCA9IG9yaWVudDJkKHBjLHBhLHBkKTtcclxuICAgICAgICAgICAgaWYgKG9jYWQgPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIEZvcnVtbGEgdG8gY2FsY3VsYXRlIHNpZ25lZCBhcmVhXHJcbiAgICAgICAgLy8vIFBvc2l0aXZlIGlmIENDV1xyXG4gICAgICAgIC8vLyBOZWdhdGl2ZSBpZiBDV1xyXG4gICAgICAgIC8vLyAwIGlmIGNvbGxpbmVhclxyXG4gICAgICAgIC8vLyBBW1AxLFAyLFAzXSAgPSAgKHgxKnkyIC0geTEqeDIpICsgKHgyKnkzIC0geTIqeDMpICsgKHgzKnkxIC0geTMqeDEpXHJcbiAgICAgICAgLy8vICAgICAgICAgICAgICA9ICAoeDEteDMpKih5Mi15MykgLSAoeTEteTMpKih4Mi14MylcclxuICAgICAgICBwdWJsaWMgc3RhdGljIE9yaWVudGF0aW9uIE9yaWVudDJkKFRyaWFuZ3VsYXRpb25Qb2ludCBwYSwgVHJpYW5ndWxhdGlvblBvaW50IHBiLCBUcmlhbmd1bGF0aW9uUG9pbnQgcGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgZGV0bGVmdCA9IChwYS5YIC0gcGMuWCkqKHBiLlkgLSBwYy5ZKTtcclxuICAgICAgICAgICAgZG91YmxlIGRldHJpZ2h0ID0gKHBhLlkgLSBwYy5ZKSoocGIuWCAtIHBjLlgpO1xyXG4gICAgICAgICAgICBkb3VibGUgdmFsID0gZGV0bGVmdCAtIGRldHJpZ2h0O1xyXG4gICAgICAgICAgICBpZiAodmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yaWVudGF0aW9uLkNvbGxpbmVhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JpZW50YXRpb24uQ0NXO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBPcmllbnRhdGlvbi5DVztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnM7XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uVXRpbFxyXG57XHJcbiAgICBwdWJsaWMgc3RydWN0IEZpeGVkQXJyYXkzPFQ+IDogSUVudW1lcmFibGU8VD4gd2hlcmUgVCA6IGNsYXNzXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFQgXzAsIF8xLCBfMjtcclxuXHJcbiAgICAgICAgcHVibGljIFQgdGhpc1tpbnQgaW5kZXhdXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfMDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfMjtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZlJhbmdlRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfMCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8xID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgXzIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIElFbnVtZXJhYmxlPFQ+IE1lbWJlcnNcclxuXHJcbiAgICAgICAgcHVibGljIElFbnVtZXJhdG9yPFQ+IEdldEVudW1lcmF0b3IoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVudW1lcmF0ZSgpLkdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIElFbnVtZXJhdG9yIElFbnVtZXJhYmxlLkdldEVudW1lcmF0b3IoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29udGFpbnMoVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgKytpKSBpZiAodGhpc1tpXSA9PSB2YWx1ZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBpbnQgSW5kZXhPZihUIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyArK2kpIGlmICh0aGlzW2ldID09IHZhbHVlKSByZXR1cm4gaTtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXzAgPSBfMSA9IF8yID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyKFQgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7ICsraSkgaWYgKHRoaXNbaV0gPT0gdmFsdWUpIHRoaXNbaV0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBJRW51bWVyYWJsZTxUPiBFbnVtZXJhdGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyArK2kpIHlpZWxkIHJldHVybiB0aGlzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucztcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5VdGlsXHJcbntcclxuICAgIHB1YmxpYyBzdHJ1Y3QgRml4ZWRCaXRBcnJheTMgOiBJRW51bWVyYWJsZTxib29sPlxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBib29sIF8wLCBfMSwgXzI7XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIHRoaXNbaW50IGluZGV4XVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXzA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXzI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGluZGV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgXzAgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfMSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8yID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBJRW51bWVyYWJsZTxib29sPiBNZW1iZXJzXHJcblxyXG4gICAgICAgIHB1YmxpYyBJRW51bWVyYXRvcjxib29sPiBHZXRFbnVtZXJhdG9yKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbnVtZXJhdGUoKS5HZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBJRW51bWVyYXRvciBJRW51bWVyYWJsZS5HZXRFbnVtZXJhdG9yKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBHZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIENvbnRhaW5zKGJvb2wgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7ICsraSkgaWYgKHRoaXNbaV0gPT0gdmFsdWUpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgaW50IEluZGV4T2YoYm9vbCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgKytpKSBpZiAodGhpc1tpXSA9PSB2YWx1ZSkgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF8wID0gXzEgPSBfMiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXIoYm9vbCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgKytpKSBpZiAodGhpc1tpXSA9PSB2YWx1ZSkgdGhpc1tpXSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBJRW51bWVyYWJsZTxib29sPiBFbnVtZXJhdGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyArK2kpIHlpZWxkIHJldHVybiB0aGlzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5VdGlsXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBQb2ludEdlbmVyYXRvclxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFJhbmRvbSBSTkcgPSBuZXcgUmFuZG9tKCk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IFVuaWZvcm1EaXN0cmlidXRpb24oaW50IG4sIGRvdWJsZSBzY2FsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBwb2ludHMgPSBuZXcgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+KCk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMuQWRkKG5ldyBUcmlhbmd1bGF0aW9uUG9pbnQoc2NhbGUqKDAuNSAtIFJORy5OZXh0RG91YmxlKCkpLCBzY2FsZSooMC41IC0gUk5HLk5leHREb3VibGUoKSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gVW5pZm9ybUdyaWQoaW50IG4sIGRvdWJsZSBzY2FsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSB4ID0gMDtcclxuICAgICAgICAgICAgZG91YmxlIHNpemUgPSBzY2FsZS9uO1xyXG4gICAgICAgICAgICBkb3VibGUgaGFsZlNjYWxlID0gMC41KnNjYWxlO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IHBvaW50cyA9IG5ldyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4oKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuICsgMTsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB4ID0gaGFsZlNjYWxlIC0gaSpzaXplO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBuICsgMTsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5BZGQobmV3IFRyaWFuZ3VsYXRpb25Qb2ludCh4LCBoYWxmU2NhbGUgLSBqKnNpemUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uUG9seWdvbjtcclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLlV0aWxcclxue1xyXG4gICAgcHVibGljIGNsYXNzIFBvbHlnb25HZW5lcmF0b3JcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBSYW5kb20gUk5HID0gbmV3IFJhbmRvbSgpO1xyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBkb3VibGUgUElfMiA9IDIuMCpNYXRoLlBJO1xyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFBvbHlnb24uUG9seWdvbiBSYW5kb21DaXJjbGVTd2VlcChkb3VibGUgc2NhbGUsIGludCB2ZXJ0ZXhDb3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvbHlnb25Qb2ludCBwb2ludDtcclxuICAgICAgICAgICAgUG9seWdvblBvaW50W10gcG9pbnRzO1xyXG4gICAgICAgICAgICBkb3VibGUgcmFkaXVzID0gc2NhbGUvNDtcclxuXHJcbiAgICAgICAgICAgIHBvaW50cyA9IG5ldyBQb2x5Z29uUG9pbnRbdmVydGV4Q291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGklMjUwID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMgKz0gc2NhbGUvMiooMC41IC0gUk5HLk5leHREb3VibGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGklNTAgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1cyArPSBzY2FsZS81KigwLjUgLSBSTkcuTmV4dERvdWJsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzICs9IDI1KnNjYWxlL3ZlcnRleENvdW50KigwLjUgLSBSTkcuTmV4dERvdWJsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzID4gc2NhbGUvMiA/IHNjYWxlLzIgOiByYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzIDwgc2NhbGUvMTAgPyBzY2FsZS8xMCA6IHJhZGl1cztcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHJhZGl1cyA8IHNjYWxlLzEwIHx8IHJhZGl1cyA+IHNjYWxlLzIpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgUG9seWdvblBvaW50KHJhZGl1cypNYXRoLkNvcygoUElfMippKS92ZXJ0ZXhDb3VudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzKk1hdGguU2luKChQSV8yKmkpL3ZlcnRleENvdW50KSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24uUG9seWdvbihwb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBQb2x5Z29uLlBvbHlnb24gUmFuZG9tQ2lyY2xlU3dlZXAyKGRvdWJsZSBzY2FsZSwgaW50IHZlcnRleENvdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9seWdvblBvaW50IHBvaW50O1xyXG4gICAgICAgICAgICBQb2x5Z29uUG9pbnRbXSBwb2ludHM7XHJcbiAgICAgICAgICAgIGRvdWJsZSByYWRpdXMgPSBzY2FsZS80O1xyXG5cclxuICAgICAgICAgICAgcG9pbnRzID0gbmV3IFBvbHlnb25Qb2ludFt2ZXJ0ZXhDb3VudF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXMgKz0gc2NhbGUvNSooMC41IC0gUk5HLk5leHREb3VibGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzID4gc2NhbGUvMiA/IHNjYWxlLzIgOiByYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzIDwgc2NhbGUvMTAgPyBzY2FsZS8xMCA6IHJhZGl1cztcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHJhZGl1cyA8IHNjYWxlLzEwIHx8IHJhZGl1cyA+IHNjYWxlLzIpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgUG9seWdvblBvaW50KHJhZGl1cypNYXRoLkNvcygoUElfMippKS92ZXJ0ZXhDb3VudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzKk1hdGguU2luKChQSV8yKmkpL3ZlcnRleENvdW50KSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24uUG9seWdvbihwb2ludHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXNcclxue1xyXG4gICAgcHVibGljIGNsYXNzIENpcmNsZVNoYXBlIDogU2hhcGVcclxuICAgIHtcclxuICAgICAgICBpbnRlcm5hbCBWZWN0b3IyIF9wb3NpdGlvbjtcclxuXHJcbiAgICAgICAgcHVibGljIENpcmNsZVNoYXBlKGZsb2F0IHJhZGl1cywgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICAgICAgOiBiYXNlKGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgPSBTaGFwZVR5cGUuQ2lyY2xlO1xyXG4gICAgICAgICAgICBfcmFkaXVzID0gcmFkaXVzO1xyXG4gICAgICAgICAgICBfcG9zaXRpb24gPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIENvbXB1dGVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBDaXJjbGVTaGFwZSgpXHJcbiAgICAgICAgICAgIDogYmFzZSgwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2hhcGVUeXBlID0gU2hhcGVUeXBlLkNpcmNsZTtcclxuICAgICAgICAgICAgX3JhZGl1cyA9IDAuMGY7XHJcbiAgICAgICAgICAgIF9wb3NpdGlvbiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgQ2hpbGRDb3VudFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIDE7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFBvc2l0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3Bvc2l0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIENvbXB1dGVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBTaGFwZSBDbG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDaXJjbGVTaGFwZSBzaGFwZSA9IG5ldyBDaXJjbGVTaGFwZSgpO1xyXG4gICAgICAgICAgICBzaGFwZS5fcmFkaXVzID0gUmFkaXVzO1xyXG4gICAgICAgICAgICBzaGFwZS5fZGVuc2l0eSA9IF9kZW5zaXR5O1xyXG4gICAgICAgICAgICBzaGFwZS5fcG9zaXRpb24gPSBfcG9zaXRpb247XHJcbiAgICAgICAgICAgIHNoYXBlLlNoYXBlVHlwZSA9IFNoYXBlVHlwZTtcclxuICAgICAgICAgICAgc2hhcGUuTWFzc0RhdGEgPSBNYXNzRGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUZXN0IGEgcG9pbnQgZm9yIGNvbnRhaW5tZW50IGluIHRoaXMgc2hhcGUuIFRoaXMgb25seSB3b3JrcyBmb3IgY29udmV4IHNoYXBlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSBzaGFwZSB3b3JsZCB0cmFuc2Zvcm0uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPmEgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBzaGFwZTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBUZXN0UG9pbnQocmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0sIHJlZiBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBjZW50ZXIgPSB0cmFuc2Zvcm0uUG9zaXRpb24gKyBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybS5SLCBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IHBvaW50IC0gY2VudGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yMi5Eb3QoZCwgZCkgPD0gUmFkaXVzICogUmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYXN0IGEgcmF5IGFnYWluc3QgYSBjaGlsZCBzaGFwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm91dHB1dFwiPlRoZSByYXktY2FzdCByZXN1bHRzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmF5LWNhc3QgaW5wdXQgcGFyYW1ldGVycy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaGlsZEluZGV4XCI+VGhlIGNoaWxkIHNoYXBlIGluZGV4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIHJheS1jYXN0IGhpdHMgdGhlIHNoYXBlPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIFJheUNhc3Qob3V0IFJheUNhc3RPdXRwdXQgb3V0cHV0LCByZWYgUmF5Q2FzdElucHV0IGlucHV0LCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBjaGlsZEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gQ29sbGlzaW9uIERldGVjdGlvbiBpbiBJbnRlcmFjdGl2ZSAzRCBFbnZpcm9ubWVudHMgYnkgR2lubyB2YW4gZGVuIEJlcmdlblxyXG4gICAgICAgICAgICAvLyBGcm9tIFNlY3Rpb24gMy4xLjJcclxuICAgICAgICAgICAgLy8geCA9IHMgKyBhICogclxyXG4gICAgICAgICAgICAvLyBub3JtKHgpID0gcmFkaXVzXHJcblxyXG4gICAgICAgICAgICBvdXRwdXQgPSBuZXcgUmF5Q2FzdE91dHB1dCgpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBwb3NpdGlvbiA9IHRyYW5zZm9ybS5Qb3NpdGlvbiArIE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtLlIsIFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBzID0gaW5wdXQuUG9pbnQxIC0gcG9zaXRpb247XHJcbiAgICAgICAgICAgIGZsb2F0IGIgPSBWZWN0b3IyLkRvdChzLCBzKSAtIFJhZGl1cyAqIFJhZGl1cztcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHF1YWRyYXRpYyBlcXVhdGlvbi5cclxuICAgICAgICAgICAgVmVjdG9yMiByID0gaW5wdXQuUG9pbnQyIC0gaW5wdXQuUG9pbnQxO1xyXG4gICAgICAgICAgICBmbG9hdCBjID0gVmVjdG9yMi5Eb3Qocywgcik7XHJcbiAgICAgICAgICAgIGZsb2F0IHJyID0gVmVjdG9yMi5Eb3Qociwgcik7XHJcbiAgICAgICAgICAgIGZsb2F0IHNpZ21hID0gYyAqIGMgLSByciAqIGI7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgZGlzY3JpbWluYW50IGFuZCBzaG9ydCBzZWdtZW50LlxyXG4gICAgICAgICAgICBpZiAoc2lnbWEgPCAwLjBmIHx8IHJyIDwgU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gb2YgdGhlIGxpbmUgd2l0aCB0aGUgY2lyY2xlLlxyXG4gICAgICAgICAgICBmbG9hdCBhID0gLShjICsgKGZsb2F0KU1hdGguU3FydChzaWdtYSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gSXMgdGhlIGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgc2VnbWVudD9cclxuICAgICAgICAgICAgaWYgKDAuMGYgPD0gYSAmJiBhIDw9IGlucHV0Lk1heEZyYWN0aW9uICogcnIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGEgLz0gcnI7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuRnJhY3Rpb24gPSBhO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBub3JtID0gKHMgKyBhICogcik7XHJcbiAgICAgICAgICAgICAgICBub3JtLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0Lk5vcm1hbCA9IG5vcm07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHaXZlbiBhIHRyYW5zZm9ybSwgY29tcHV0ZSB0aGUgYXNzb2NpYXRlZCBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhIGNoaWxkIHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiIHJlc3VsdHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNoaWxkSW5kZXhcIj5UaGUgY2hpbGQgc2hhcGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDb21wdXRlQUFCQihvdXQgQUFCQiBhYWJiLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgaW50IGNoaWxkSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIHAgPSB0cmFuc2Zvcm0uUG9zaXRpb24gKyBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybS5SLCBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGFhYmIuTG93ZXJCb3VuZCA9IG5ldyBWZWN0b3IyKHAuWCAtIFJhZGl1cywgcC5ZIC0gUmFkaXVzKTtcclxuICAgICAgICAgICAgYWFiYi5VcHBlckJvdW5kID0gbmV3IFZlY3RvcjIocC5YICsgUmFkaXVzLCBwLlkgKyBSYWRpdXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhpcyBzaGFwZSB1c2luZyBpdHMgZGltZW5zaW9ucyBhbmQgZGVuc2l0eS5cclxuICAgICAgICAvLy8gVGhlIGluZXJ0aWEgdGVuc29yIGlzIGNvbXB1dGVkIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4sIG5vdCB0aGUgY2VudHJvaWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgc2VhbGVkIHZvaWQgQ29tcHV0ZVByb3BlcnRpZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgYXJlYSA9IFNldHRpbmdzLlBpICogUmFkaXVzICogUmFkaXVzO1xyXG4gICAgICAgICAgICBNYXNzRGF0YS5BcmVhID0gYXJlYTtcclxuICAgICAgICAgICAgTWFzc0RhdGEuTWFzcyA9IERlbnNpdHkgKiBhcmVhO1xyXG4gICAgICAgICAgICBNYXNzRGF0YS5DZW50cm9pZCA9IFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgLy8gaW5lcnRpYSBhYm91dCB0aGUgbG9jYWwgb3JpZ2luXHJcbiAgICAgICAgICAgIE1hc3NEYXRhLkluZXJ0aWEgPSBNYXNzRGF0YS5NYXNzICogKDAuNWYgKiBSYWRpdXMgKiBSYWRpdXMgKyBWZWN0b3IyLkRvdChQb3NpdGlvbiwgUG9zaXRpb24pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIENvbXBhcmVUbyhDaXJjbGVTaGFwZSBzaGFwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoUmFkaXVzID09IHNoYXBlLlJhZGl1cyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIFBvc2l0aW9uID09IHNoYXBlLlBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBDb21wdXRlU3VibWVyZ2VkQXJlYShWZWN0b3IyIG5vcm1hbCwgZmxvYXQgb2Zmc2V0LCBUcmFuc2Zvcm0geGYsIG91dCBWZWN0b3IyIHNjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2MgPSBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHAgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmLCBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGZsb2F0IGwgPSAtKFZlY3RvcjIuRG90KG5vcm1hbCwgcCkgLSBvZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAobCA8IC1SYWRpdXMgKyBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL0NvbXBsZXRlbHkgZHJ5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobCA+IFJhZGl1cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9Db21wbGV0ZWx5IHdldFxyXG4gICAgICAgICAgICAgICAgc2MgPSBwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldHRpbmdzLlBpICogUmFkaXVzICogUmFkaXVzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL01hZ2ljXHJcbiAgICAgICAgICAgIGZsb2F0IHIyID0gUmFkaXVzICogUmFkaXVzO1xyXG4gICAgICAgICAgICBmbG9hdCBsMiA9IGwgKiBsO1xyXG4gICAgICAgICAgICBmbG9hdCBhcmVhID0gcjIgKiAoZmxvYXQpKChNYXRoLkFzaW4obCAvIFJhZGl1cykgKyBTZXR0aW5ncy5QaSAvIDIpICsgbCAqIE1hdGguU3FydChyMiAtIGwyKSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGNvbSA9IC0yLjBmIC8gMy4wZiAqIChmbG9hdClNYXRoLlBvdyhyMiAtIGwyLCAxLjVmKSAvIGFyZWE7XHJcblxyXG4gICAgICAgICAgICBzYy5YID0gcC5YICsgbm9ybWFsLlggKiBjb207XHJcbiAgICAgICAgICAgIHNjLlkgPSBwLlkgKyBub3JtYWwuWSAqIGNvbTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIGxpbmUgc2VnbWVudCAoZWRnZSkgU2hhcGUuIFRoZXNlIGNhbiBiZSBjb25uZWN0ZWQgaW4gY2hhaW5zIG9yIGxvb3BzXHJcbiAgICAvLy8gdG8gb3RoZXIgZWRnZSBTaGFwZXMuIFRoZSBjb25uZWN0aXZpdHkgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBlbnN1cmVcclxuICAgIC8vLyBjb3JyZWN0IGNvbnRhY3Qgbm9ybWFscy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRWRnZVNoYXBlIDogU2hhcGVcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgYm9vbCBIYXNWZXJ0ZXgwLCBIYXNWZXJ0ZXgzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE9wdGlvbmFsIGFkamFjZW50IHZlcnRpY2VzLiBUaGVzZSBhcmUgdXNlZCBmb3Igc21vb3RoIGNvbGxpc2lvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFZlcnRleDA7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gT3B0aW9uYWwgYWRqYWNlbnQgdmVydGljZXMuIFRoZXNlIGFyZSB1c2VkIGZvciBzbW9vdGggY29sbGlzaW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgVmVydGV4MztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFZGdlIHN0YXJ0IHZlcnRleFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF92ZXJ0ZXgxO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEVkZ2UgZW5kIHZlcnRleFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF92ZXJ0ZXgyO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBFZGdlU2hhcGUoKVxyXG4gICAgICAgICAgICA6IGJhc2UoMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNoYXBlVHlwZSA9IFNoYXBlVHlwZS5FZGdlO1xyXG4gICAgICAgICAgICBfcmFkaXVzID0gU2V0dGluZ3MuUG9seWdvblJhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBFZGdlU2hhcGUoVmVjdG9yMiBzdGFydCwgVmVjdG9yMiBlbmQpXHJcbiAgICAgICAgICAgIDogYmFzZSgwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2hhcGVUeXBlID0gU2hhcGVUeXBlLkVkZ2U7XHJcbiAgICAgICAgICAgIF9yYWRpdXMgPSBTZXR0aW5ncy5Qb2x5Z29uUmFkaXVzO1xyXG4gICAgICAgICAgICBTZXQoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IENoaWxkQ291bnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAxOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZXNlIGFyZSB0aGUgZWRnZSB2ZXJ0aWNlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgVmVydGV4MVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF92ZXJ0ZXgxOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdmVydGV4MSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgQ29tcHV0ZVByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGVzZSBhcmUgdGhlIGVkZ2UgdmVydGljZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFZlcnRleDJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdmVydGV4MjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3ZlcnRleDIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIENvbXB1dGVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoaXMgYXMgYW4gaXNvbGF0ZWQgZWRnZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0YXJ0XCI+VGhlIHN0YXJ0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZW5kXCI+VGhlIGVuZC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldChWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF92ZXJ0ZXgxID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIF92ZXJ0ZXgyID0gZW5kO1xyXG4gICAgICAgICAgICBIYXNWZXJ0ZXgwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIEhhc1ZlcnRleDMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIENvbXB1dGVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgU2hhcGUgQ2xvbmUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRWRnZVNoYXBlIGVkZ2UgPSBuZXcgRWRnZVNoYXBlKCk7XHJcbiAgICAgICAgICAgIGVkZ2UuX3JhZGl1cyA9IF9yYWRpdXM7XHJcbiAgICAgICAgICAgIGVkZ2UuX2RlbnNpdHkgPSBfZGVuc2l0eTtcclxuICAgICAgICAgICAgZWRnZS5IYXNWZXJ0ZXgwID0gSGFzVmVydGV4MDtcclxuICAgICAgICAgICAgZWRnZS5IYXNWZXJ0ZXgzID0gSGFzVmVydGV4MztcclxuICAgICAgICAgICAgZWRnZS5WZXJ0ZXgwID0gVmVydGV4MDtcclxuICAgICAgICAgICAgZWRnZS5fdmVydGV4MSA9IF92ZXJ0ZXgxO1xyXG4gICAgICAgICAgICBlZGdlLl92ZXJ0ZXgyID0gX3ZlcnRleDI7XHJcbiAgICAgICAgICAgIGVkZ2UuVmVydGV4MyA9IFZlcnRleDM7XHJcbiAgICAgICAgICAgIGVkZ2UuTWFzc0RhdGEgPSBNYXNzRGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIGVkZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRlc3QgYSBwb2ludCBmb3IgY29udGFpbm1lbnQgaW4gdGhpcyBzaGFwZS4gVGhpcyBvbmx5IHdvcmtzIGZvciBjb252ZXggc2hhcGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHNoYXBlIHdvcmxkIHRyYW5zZm9ybS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+YSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHNoYXBlPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIFRlc3RQb2ludChyZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgcmVmIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhc3QgYSByYXkgYWdhaW5zdCBhIGNoaWxkIHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3V0cHV0XCI+VGhlIHJheS1jYXN0IHJlc3VsdHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByYXktY2FzdCBpbnB1dCBwYXJhbWV0ZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzaGFwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNoaWxkSW5kZXhcIj5UaGUgY2hpbGQgc2hhcGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgcmF5LWNhc3QgaGl0cyB0aGUgc2hhcGU8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgUmF5Q2FzdChvdXQgUmF5Q2FzdE91dHB1dCBvdXRwdXQsIHJlZiBSYXlDYXN0SW5wdXQgaW5wdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgaW50IGNoaWxkSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBwID0gcDEgKyB0ICogZFxyXG4gICAgICAgICAgICAvLyB2ID0gdjEgKyBzICogZVxyXG4gICAgICAgICAgICAvLyBwMSArIHQgKiBkID0gdjEgKyBzICogZVxyXG4gICAgICAgICAgICAvLyBzICogZSAtIHQgKiBkID0gcDEgLSB2MVxyXG5cclxuICAgICAgICAgICAgb3V0cHV0ID0gbmV3IFJheUNhc3RPdXRwdXQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgcmF5IGludG8gdGhlIGVkZ2UncyBmcmFtZSBvZiByZWZlcmVuY2UuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB0cmFuc2Zvcm0uUiwgaW5wdXQuUG9pbnQxIC0gdHJhbnNmb3JtLlBvc2l0aW9uKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBwMiA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHRyYW5zZm9ybS5SLCBpbnB1dC5Qb2ludDIgLSB0cmFuc2Zvcm0uUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBwMiAtIHAxO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2MSA9IF92ZXJ0ZXgxO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gX3ZlcnRleDI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZSA9IHYyIC0gdjE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gbmV3IFZlY3RvcjIoZS5ZLCAtZS5YKTtcclxuICAgICAgICAgICAgbm9ybWFsLk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gcSA9IHAxICsgdCAqIGRcclxuICAgICAgICAgICAgLy8gZG90KG5vcm1hbCwgcSAtIHYxKSA9IDBcclxuICAgICAgICAgICAgLy8gZG90KG5vcm1hbCwgcDEgLSB2MSkgKyB0ICogZG90KG5vcm1hbCwgZCkgPSAwXHJcbiAgICAgICAgICAgIGZsb2F0IG51bWVyYXRvciA9IFZlY3RvcjIuRG90KG5vcm1hbCwgdjEgLSBwMSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGRlbm9taW5hdG9yID0gVmVjdG9yMi5Eb3Qobm9ybWFsLCBkKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZW5vbWluYXRvciA9PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHQgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcclxuICAgICAgICAgICAgaWYgKHQgPCAwLjBmIHx8IDEuMGYgPCB0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcSA9IHAxICsgdCAqIGQ7XHJcblxyXG4gICAgICAgICAgICAvLyBxID0gdjEgKyBzICogclxyXG4gICAgICAgICAgICAvLyBzID0gZG90KHEgLSB2MSwgcikgLyBkb3QociwgcilcclxuICAgICAgICAgICAgVmVjdG9yMiByID0gdjIgLSB2MTtcclxuICAgICAgICAgICAgZmxvYXQgcnIgPSBWZWN0b3IyLkRvdChyLCByKTtcclxuICAgICAgICAgICAgaWYgKHJyID09IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgcyA9IFZlY3RvcjIuRG90KHEgLSB2MSwgcikgLyBycjtcclxuICAgICAgICAgICAgaWYgKHMgPCAwLjBmIHx8IDEuMGYgPCBzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG91dHB1dC5GcmFjdGlvbiA9IHQ7XHJcbiAgICAgICAgICAgIGlmIChudW1lcmF0b3IgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuTm9ybWFsID0gLW5vcm1hbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5Ob3JtYWwgPSBub3JtYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdpdmVuIGEgdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBhc3NvY2lhdGVkIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGEgY2hpbGQgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIgcmVzdWx0cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPlRoZSBjaGlsZCBzaGFwZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENvbXB1dGVBQUJCKG91dCBBQUJCIGFhYmIsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCBpbnQgY2hpbGRJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybSwgX3ZlcnRleDEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB0cmFuc2Zvcm0sIF92ZXJ0ZXgyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgbG93ZXIgPSBWZWN0b3IyLk1pbih2MSwgdjIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHVwcGVyID0gVmVjdG9yMi5NYXgodjEsIHYyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgciA9IG5ldyBWZWN0b3IyKFJhZGl1cywgUmFkaXVzKTtcclxuICAgICAgICAgICAgYWFiYi5Mb3dlckJvdW5kID0gbG93ZXIgLSByO1xyXG4gICAgICAgICAgICBhYWJiLlVwcGVyQm91bmQgPSB1cHBlciArIHI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGlzIHNoYXBlIHVzaW5nIGl0cyBkaW1lbnNpb25zIGFuZCBkZW5zaXR5LlxyXG4gICAgICAgIC8vLyBUaGUgaW5lcnRpYSB0ZW5zb3IgaXMgY29tcHV0ZWQgYWJvdXQgdGhlIGxvY2FsIG9yaWdpbiwgbm90IHRoZSBjZW50cm9pZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENvbXB1dGVQcm9wZXJ0aWVzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hc3NEYXRhLkNlbnRyb2lkID0gMC41ZiAqIChfdmVydGV4MSArIF92ZXJ0ZXgyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBDb21wdXRlU3VibWVyZ2VkQXJlYShWZWN0b3IyIG5vcm1hbCwgZmxvYXQgb2Zmc2V0LCBUcmFuc2Zvcm0geGYsIG91dCBWZWN0b3IyIHNjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2MgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29tcGFyZVRvKEVkZ2VTaGFwZSBzaGFwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoSGFzVmVydGV4MCA9PSBzaGFwZS5IYXNWZXJ0ZXgwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgSGFzVmVydGV4MyA9PSBzaGFwZS5IYXNWZXJ0ZXgzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGV4MCA9PSBzaGFwZS5WZXJ0ZXgwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGV4MSA9PSBzaGFwZS5WZXJ0ZXgxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGV4MiA9PSBzaGFwZS5WZXJ0ZXgyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGV4MyA9PSBzaGFwZS5WZXJ0ZXgzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIGxvb3AgU2hhcGUgaXMgYSBmcmVlIGZvcm0gc2VxdWVuY2Ugb2YgbGluZSBzZWdtZW50cyB0aGF0IGZvcm0gYSBjaXJjdWxhciBsaXN0LlxyXG4gICAgLy8vIFRoZSBsb29wIG1heSBjcm9zcyB1cG9uIGl0c2VsZiwgYnV0IHRoaXMgaXMgbm90IHJlY29tbWVuZGVkIGZvciBzbW9vdGggY29sbGlzaW9uLlxyXG4gICAgLy8vIFRoZSBsb29wIGhhcyBkb3VibGUgc2lkZWQgY29sbGlzaW9uLCBzbyB5b3UgY2FuIHVzZSBpbnNpZGUgYW5kIG91dHNpZGUgY29sbGlzaW9uLlxyXG4gICAgLy8vIFRoZXJlZm9yZSwgeW91IG1heSB1c2UgYW55IHdpbmRpbmcgb3JkZXIuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIExvb3BTaGFwZSA6IFNoYXBlXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgRWRnZVNoYXBlIF9lZGdlU2hhcGUgPSBuZXcgRWRnZVNoYXBlKCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIHZlcnRpY2VzLiBUaGVzZSBhcmUgbm90IG93bmVkL2ZyZWVkIGJ5IHRoZSBsb29wIFNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlcnRpY2VzIFZlcnRpY2VzO1xyXG5cclxuICAgICAgICBwcml2YXRlIExvb3BTaGFwZSgpXHJcbiAgICAgICAgICAgIDogYmFzZSgwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2hhcGVUeXBlID0gU2hhcGVUeXBlLkxvb3A7XHJcbiAgICAgICAgICAgIF9yYWRpdXMgPSBTZXR0aW5ncy5Qb2x5Z29uUmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIExvb3BTaGFwZShWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICAgICAgOiBiYXNlKDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgPSBTaGFwZVR5cGUuTG9vcDtcclxuICAgICAgICAgICAgX3JhZGl1cyA9IFNldHRpbmdzLlBvbHlnb25SYWRpdXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuQ29uc2VydmVNZW1vcnkpXHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHZlcnRpY2VzLlxyXG4gICAgICAgICAgICAgICAgVmVydGljZXMgPSBuZXcgVmVydGljZXModmVydGljZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBDaGlsZENvdW50XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gVmVydGljZXMuQ291bnQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBTaGFwZSBDbG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMb29wU2hhcGUgbG9vcCA9IG5ldyBMb29wU2hhcGUoKTtcclxuICAgICAgICAgICAgbG9vcC5fZGVuc2l0eSA9IF9kZW5zaXR5O1xyXG4gICAgICAgICAgICBsb29wLl9yYWRpdXMgPSBfcmFkaXVzO1xyXG4gICAgICAgICAgICBsb29wLlZlcnRpY2VzID0gVmVydGljZXM7XHJcbiAgICAgICAgICAgIGxvb3AuTWFzc0RhdGEgPSBNYXNzRGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIGxvb3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCBhIGNoaWxkIGVkZ2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlZGdlXCI+VGhlIGVkZ2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbmRleFwiPlRoZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEdldENoaWxkRWRnZShyZWYgRWRnZVNoYXBlIGVkZ2UsIGludCBpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgyIDw9IFZlcnRpY2VzLkNvdW50KTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gaW5kZXggJiYgaW5kZXggPCBWZXJ0aWNlcy5Db3VudCk7XHJcbiAgICAgICAgICAgIGVkZ2UuU2hhcGVUeXBlID0gU2hhcGVUeXBlLkVkZ2U7XHJcbiAgICAgICAgICAgIGVkZ2UuX3JhZGl1cyA9IF9yYWRpdXM7XHJcbiAgICAgICAgICAgIGVkZ2UuSGFzVmVydGV4MCA9IHRydWU7XHJcbiAgICAgICAgICAgIGVkZ2UuSGFzVmVydGV4MyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpbnQgaTAgPSBpbmRleCAtIDEgPj0gMCA/IGluZGV4IC0gMSA6IFZlcnRpY2VzLkNvdW50IC0gMTtcclxuICAgICAgICAgICAgaW50IGkxID0gaW5kZXg7XHJcbiAgICAgICAgICAgIGludCBpMiA9IGluZGV4ICsgMSA8IFZlcnRpY2VzLkNvdW50ID8gaW5kZXggKyAxIDogMDtcclxuICAgICAgICAgICAgaW50IGkzID0gaW5kZXggKyAyO1xyXG4gICAgICAgICAgICB3aGlsZSAoaTMgPj0gVmVydGljZXMuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGkzIC09IFZlcnRpY2VzLkNvdW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlZGdlLlZlcnRleDAgPSBWZXJ0aWNlc1tpMF07XHJcbiAgICAgICAgICAgIGVkZ2UuVmVydGV4MSA9IFZlcnRpY2VzW2kxXTtcclxuICAgICAgICAgICAgZWRnZS5WZXJ0ZXgyID0gVmVydGljZXNbaTJdO1xyXG4gICAgICAgICAgICBlZGdlLlZlcnRleDMgPSBWZXJ0aWNlc1tpM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRlc3QgYSBwb2ludCBmb3IgY29udGFpbm1lbnQgaW4gdGhpcyBzaGFwZS4gVGhpcyBvbmx5IHdvcmtzIGZvciBjb252ZXggc2hhcGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHNoYXBlIHdvcmxkIHRyYW5zZm9ybS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+YSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHNoYXBlPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIFRlc3RQb2ludChyZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgcmVmIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhc3QgYSByYXkgYWdhaW5zdCBhIGNoaWxkIHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3V0cHV0XCI+VGhlIHJheS1jYXN0IHJlc3VsdHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByYXktY2FzdCBpbnB1dCBwYXJhbWV0ZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzaGFwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNoaWxkSW5kZXhcIj5UaGUgY2hpbGQgc2hhcGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgcmF5LWNhc3QgaGl0cyB0aGUgc2hhcGU8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgUmF5Q2FzdChvdXQgUmF5Q2FzdE91dHB1dCBvdXRwdXQsIHJlZiBSYXlDYXN0SW5wdXQgaW5wdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgaW50IGNoaWxkSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoY2hpbGRJbmRleCA8IFZlcnRpY2VzLkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIGludCBpMSA9IGNoaWxkSW5kZXg7XHJcbiAgICAgICAgICAgIGludCBpMiA9IGNoaWxkSW5kZXggKyAxO1xyXG4gICAgICAgICAgICBpZiAoaTIgPT0gVmVydGljZXMuQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGkyID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2VkZ2VTaGFwZS5WZXJ0ZXgxID0gVmVydGljZXNbaTFdO1xyXG4gICAgICAgICAgICBfZWRnZVNoYXBlLlZlcnRleDIgPSBWZXJ0aWNlc1tpMl07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX2VkZ2VTaGFwZS5SYXlDYXN0KG91dCBvdXRwdXQsIHJlZiBpbnB1dCwgcmVmIHRyYW5zZm9ybSwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdpdmVuIGEgdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBhc3NvY2lhdGVkIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGEgY2hpbGQgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIgcmVzdWx0cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPlRoZSBjaGlsZCBzaGFwZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENvbXB1dGVBQUJCKG91dCBBQUJCIGFhYmIsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCBpbnQgY2hpbGRJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChjaGlsZEluZGV4IDwgVmVydGljZXMuQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgaW50IGkxID0gY2hpbGRJbmRleDtcclxuICAgICAgICAgICAgaW50IGkyID0gY2hpbGRJbmRleCArIDE7XHJcbiAgICAgICAgICAgIGlmIChpMiA9PSBWZXJ0aWNlcy5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaTIgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB0cmFuc2Zvcm0sIFZlcnRpY2VzW2kxXSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybSwgVmVydGljZXNbaTJdKTtcclxuXHJcbiAgICAgICAgICAgIGFhYmIuTG93ZXJCb3VuZCA9IFZlY3RvcjIuTWluKHYxLCB2Mik7XHJcbiAgICAgICAgICAgIGFhYmIuVXBwZXJCb3VuZCA9IFZlY3RvcjIuTWF4KHYxLCB2Mik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENoYWlucyBoYXZlIHplcm8gbWFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENvbXB1dGVQcm9wZXJ0aWVzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vRG9lcyBub3RoaW5nLiBMb29wIHNoYXBlcyBkb24ndCBoYXZlIHByb3BlcnRpZXMuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgQ29tcHV0ZVN1Ym1lcmdlZEFyZWEoVmVjdG9yMiBub3JtYWwsIGZsb2F0IG9mZnNldCwgVHJhbnNmb3JtIHhmLCBvdXQgVmVjdG9yMiBzYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNjID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlc1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gUmVwcmVzZW50cyBhIHNpbXBsZSBub24tc2VsZmludGVyc2VjdGluZyBjb252ZXggcG9seWdvbi5cclxuICAgIC8vLyBJZiB5b3Ugd2FudCB0byBoYXZlIGNvbmNhdmUgcG9seWdvbnMsIHlvdSB3aWxsIGhhdmUgdG8gdXNlIHRoZSA8c2VlIGNyZWY9XCJCYXlheml0RGVjb21wb3NlclwiLz4gb3IgdGhlIDxzZWUgY3JlZj1cIkVhcmNsaXBEZWNvbXBvc2VyXCIvPlxyXG4gICAgLy8vIHRvIGRlY29tcG9zZSB0aGUgY29uY2F2ZSBwb2x5Z29uIGludG8gMiBvciBtb3JlIGNvbnZleCBwb2x5Z29ucy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgUG9seWdvblNoYXBlIDogU2hhcGVcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVydGljZXMgTm9ybWFscztcclxuICAgICAgICBwdWJsaWMgVmVydGljZXMgVmVydGljZXM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIDxzZWUgY3JlZj1cIlBvbHlnb25TaGFwZVwiLz4gY2xhc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRlbnNpdHlcIj5UaGUgZGVuc2l0eS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBQb2x5Z29uU2hhcGUoVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGRlbnNpdHkpXHJcbiAgICAgICAgICAgIDogYmFzZShkZW5zaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2hhcGVUeXBlID0gU2hhcGVUeXBlLlBvbHlnb247XHJcbiAgICAgICAgICAgIF9yYWRpdXMgPSBTZXR0aW5ncy5Qb2x5Z29uUmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgU2V0KHZlcnRpY2VzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBQb2x5Z29uU2hhcGUoZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICAgICAgOiBiYXNlKGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgPSBTaGFwZVR5cGUuUG9seWdvbjtcclxuICAgICAgICAgICAgX3JhZGl1cyA9IFNldHRpbmdzLlBvbHlnb25SYWRpdXM7XHJcbiAgICAgICAgICAgIE5vcm1hbHMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIFBvbHlnb25TaGFwZSgpXHJcbiAgICAgICAgICAgIDogYmFzZSgwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2hhcGVUeXBlID0gU2hhcGVUeXBlLlBvbHlnb247XHJcbiAgICAgICAgICAgIF9yYWRpdXMgPSBTZXR0aW5ncy5Qb2x5Z29uUmFkaXVzO1xyXG4gICAgICAgICAgICBOb3JtYWxzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IENoaWxkQ291bnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAxOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgU2hhcGUgQ2xvbmUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9seWdvblNoYXBlIGNsb25lID0gbmV3IFBvbHlnb25TaGFwZSgpO1xyXG4gICAgICAgICAgICBjbG9uZS5TaGFwZVR5cGUgPSBTaGFwZVR5cGU7XHJcbiAgICAgICAgICAgIGNsb25lLl9yYWRpdXMgPSBfcmFkaXVzO1xyXG4gICAgICAgICAgICBjbG9uZS5fZGVuc2l0eSA9IF9kZW5zaXR5O1xyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkNvbnNlcnZlTWVtb3J5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5WZXJ0aWNlcyA9IFZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgY2xvbmUuTm9ybWFscyA9IE5vcm1hbHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5WZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyhWZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5Ob3JtYWxzID0gbmV3IFZlcnRpY2VzKE5vcm1hbHMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjbG9uZS5NYXNzRGF0YSA9IE1hc3NEYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvcHkgdmVydGljZXMuIFRoaXMgYXNzdW1lcyB0aGUgdmVydGljZXMgZGVmaW5lIGEgY29udmV4IHBvbHlnb24uXHJcbiAgICAgICAgLy8vIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgZXh0ZXJpb3IgaXMgdGhlIHRoZSByaWdodCBvZiBlYWNoIGVkZ2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldChWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCh2ZXJ0aWNlcy5Db3VudCA+PSAzICYmIHZlcnRpY2VzLkNvdW50IDw9IFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuQ29uc2VydmVNZW1vcnkpXHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHZlcnRpY2VzLlxyXG4gICAgICAgICAgICAgICAgVmVydGljZXMgPSBuZXcgVmVydGljZXModmVydGljZXMpO1xyXG5cclxuICAgICAgICAgICAgTm9ybWFscyA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcy5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG5vcm1hbHMuIEVuc3VyZSB0aGUgZWRnZXMgaGF2ZSBub24temVybyBsZW5ndGguXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGkxID0gaTtcclxuICAgICAgICAgICAgICAgIGludCBpMiA9IGkgKyAxIDwgdmVydGljZXMuQ291bnQgPyBpICsgMSA6IDA7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGVkZ2UgPSBWZXJ0aWNlc1tpMl0gLSBWZXJ0aWNlc1tpMV07XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZWRnZS5MZW5ndGhTcXVhcmVkKCkgPiBTZXR0aW5ncy5FcHNpbG9uICogU2V0dGluZ3MuRXBzaWxvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB0ZW1wID0gbmV3IFZlY3RvcjIoZWRnZS5ZLCAtZWRnZS5YKTtcclxuICAgICAgICAgICAgICAgIHRlbXAuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICBOb3JtYWxzLkFkZCh0ZW1wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuI2lmIERFQlVHXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgcG9seWdvbiBpcyBjb252ZXggYW5kIHRoZSBpbnRlcmlvclxyXG4gICAgICAgICAgICAvLyBpcyB0byB0aGUgbGVmdCBvZiBlYWNoIGVkZ2UuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGkxID0gaTtcclxuICAgICAgICAgICAgICAgIGludCBpMiA9IGkgKyAxIDwgVmVydGljZXMuQ291bnQgPyBpICsgMSA6IDA7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGVkZ2UgPSBWZXJ0aWNlc1tpMl0gLSBWZXJ0aWNlc1tpMV07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCB2ZXJ0aWNlcy5Db3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIHZlcnRpY2VzIG9uIHRoZSBjdXJyZW50IGVkZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT0gaTEgfHwgaiA9PSBpMilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiByID0gVmVydGljZXNbal0gLSBWZXJ0aWNlc1tpMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFlvdXIgcG9seWdvbiBpcyBub24tY29udmV4IChpdCBoYXMgYW4gaW5kZW50YXRpb24pIG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGNvbGluZWFyIGVkZ2VzLlxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBlZGdlLlggKiByLlkgLSBlZGdlLlkgKiByLlg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChzID4gMC4wZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuI2VuZGlmXHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBwb2x5Z29uIG1hc3MgZGF0YVxyXG4gICAgICAgICAgICBDb21wdXRlUHJvcGVydGllcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhpcyBzaGFwZSB1c2luZyBpdHMgZGltZW5zaW9ucyBhbmQgZGVuc2l0eS5cclxuICAgICAgICAvLy8gVGhlIGluZXJ0aWEgdGVuc29yIGlzIGNvbXB1dGVkIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4sIG5vdCB0aGUgY2VudHJvaWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDb21wdXRlUHJvcGVydGllcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBQb2x5Z29uIG1hc3MsIGNlbnRyb2lkLCBhbmQgaW5lcnRpYS5cclxuICAgICAgICAgICAgLy8gTGV0IHJobyBiZSB0aGUgcG9seWdvbiBkZW5zaXR5IGluIG1hc3MgcGVyIHVuaXQgYXJlYS5cclxuICAgICAgICAgICAgLy8gVGhlbjpcclxuICAgICAgICAgICAgLy8gbWFzcyA9IHJobyAqIGludChkQSlcclxuICAgICAgICAgICAgLy8gY2VudHJvaWQuWCA9ICgxL21hc3MpICogcmhvICogaW50KHggKiBkQSlcclxuICAgICAgICAgICAgLy8gY2VudHJvaWQuWSA9ICgxL21hc3MpICogcmhvICogaW50KHkgKiBkQSlcclxuICAgICAgICAgICAgLy8gSSA9IHJobyAqIGludCgoeCp4ICsgeSp5KSAqIGRBKVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBXZSBjYW4gY29tcHV0ZSB0aGVzZSBpbnRlZ3JhbHMgYnkgc3VtbWluZyBhbGwgdGhlIGludGVncmFsc1xyXG4gICAgICAgICAgICAvLyBmb3IgZWFjaCB0cmlhbmdsZSBvZiB0aGUgcG9seWdvbi4gVG8gZXZhbHVhdGUgdGhlIGludGVncmFsXHJcbiAgICAgICAgICAgIC8vIGZvciBhIHNpbmdsZSB0cmlhbmdsZSwgd2UgbWFrZSBhIGNoYW5nZSBvZiB2YXJpYWJsZXMgdG9cclxuICAgICAgICAgICAgLy8gdGhlICh1LHYpIGNvb3JkaW5hdGVzIG9mIHRoZSB0cmlhbmdsZTpcclxuICAgICAgICAgICAgLy8geCA9IHgwICsgZTF4ICogdSArIGUyeCAqIHZcclxuICAgICAgICAgICAgLy8geSA9IHkwICsgZTF5ICogdSArIGUyeSAqIHZcclxuICAgICAgICAgICAgLy8gd2hlcmUgMCA8PSB1ICYmIDAgPD0gdiAmJiB1ICsgdiA8PSAxLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBXZSBpbnRlZ3JhdGUgdSBmcm9tIFswLDEtdl0gYW5kIHRoZW4gdiBmcm9tIFswLDFdLlxyXG4gICAgICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gdXNlIHRoZSBKYWNvYmlhbiBvZiB0aGUgdHJhbnNmb3JtYXRpb246XHJcbiAgICAgICAgICAgIC8vIEQgPSBjcm9zcyhlMSwgZTIpXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFNpbXBsaWZpY2F0aW9uOiB0cmlhbmdsZSBjZW50cm9pZCA9ICgxLzMpICogKHAxICsgcDIgKyBwMylcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIGRlcml2YXRpb24gaXMgaGFuZGxlZCBieSBjb21wdXRlciBhbGdlYnJhLlxyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KFZlcnRpY2VzLkNvdW50ID49IDMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9kZW5zaXR5IDw9IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGNlbnRlciA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgZmxvYXQgYXJlYSA9IDAuMGY7XHJcbiAgICAgICAgICAgIGZsb2F0IEkgPSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgLy8gcFJlZiBpcyB0aGUgcmVmZXJlbmNlIHBvaW50IGZvciBmb3JtaW5nIHRyaWFuZ2xlcy5cclxuICAgICAgICAgICAgLy8gSXQncyBsb2NhdGlvbiBkb2Vzbid0IGNoYW5nZSB0aGUgcmVzdWx0IChleGNlcHQgZm9yIHJvdW5kaW5nIGVycm9yKS5cclxuICAgICAgICAgICAgVmVjdG9yMiBwUmVmID0gVmVjdG9yMi5aZXJvO1xyXG5cclxuI2lmIGZhbHNlXHJcbiAgICAvLyBUaGlzIGNvZGUgd291bGQgcHV0IHRoZSByZWZlcmVuY2UgcG9pbnQgaW5zaWRlIHRoZSBwb2x5Z29uLlxyXG5cdCAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb3VudDsgKytpKVxyXG5cdCAgICAgICAge1xyXG5cdFx0ICAgICAgICBwUmVmICs9IHZzW2ldO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcFJlZiAqPSAxLjBmIC8gY291bnQ7XHJcbiNlbmRpZlxyXG5cclxuICAgICAgICAgICAgY29uc3QgZmxvYXQgaW52MyA9IDEuMGYgLyAzLjBmO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBWZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbmdsZSB2ZXJ0aWNlcy5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBwUmVmO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMiA9IFZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMyA9IGkgKyAxIDwgVmVydGljZXMuQ291bnQgPyBWZXJ0aWNlc1tpICsgMV0gOiBWZXJ0aWNlc1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGUxID0gcDIgLSBwMTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZTIgPSBwMyAtIHAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGQ7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIGUxLCByZWYgZTIsIG91dCBkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0cmlhbmdsZUFyZWEgPSAwLjVmICogZDtcclxuICAgICAgICAgICAgICAgIGFyZWEgKz0gdHJpYW5nbGVBcmVhO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFyZWEgd2VpZ2h0ZWQgY2VudHJvaWRcclxuICAgICAgICAgICAgICAgIGNlbnRlciArPSB0cmlhbmdsZUFyZWEgKiBpbnYzICogKHAxICsgcDIgKyBwMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgcHggPSBwMS5YLCBweSA9IHAxLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBleDEgPSBlMS5YLCBleTEgPSBlMS5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZXgyID0gZTIuWCwgZXkyID0gZTIuWTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnR4MiA9IGludjMgKiAoMC4yNWYgKiAoZXgxICogZXgxICsgZXgyICogZXgxICsgZXgyICogZXgyKSArIChweCAqIGV4MSArIHB4ICogZXgyKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjVmICogcHggKiBweDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGludHkyID0gaW52MyAqICgwLjI1ZiAqIChleTEgKiBleTEgKyBleTIgKiBleTEgKyBleTIgKiBleTIpICsgKHB5ICogZXkxICsgcHkgKiBleTIpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuNWYgKiBweSAqIHB5O1xyXG5cclxuICAgICAgICAgICAgICAgIEkgKz0gZCAqIChpbnR4MiArIGludHkyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9UaGUgYXJlYSBpcyB0b28gc21hbGwgZm9yIHRoZSBlbmdpbmUgdG8gaGFuZGxlLlxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoYXJlYSA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG5cclxuICAgICAgICAgICAgLy8gV2Ugc2F2ZSB0aGUgYXJlYVxyXG4gICAgICAgICAgICBNYXNzRGF0YS5BcmVhID0gYXJlYTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRvdGFsIG1hc3NcclxuICAgICAgICAgICAgTWFzc0RhdGEuTWFzcyA9IF9kZW5zaXR5ICogYXJlYTtcclxuXHJcbiAgICAgICAgICAgIC8vIENlbnRlciBvZiBtYXNzXHJcbiAgICAgICAgICAgIGNlbnRlciAqPSAxLjBmIC8gYXJlYTtcclxuICAgICAgICAgICAgTWFzc0RhdGEuQ2VudHJvaWQgPSBjZW50ZXI7XHJcblxyXG4gICAgICAgICAgICAvLyBJbmVydGlhIHRlbnNvciByZWxhdGl2ZSB0byB0aGUgbG9jYWwgb3JpZ2luLlxyXG4gICAgICAgICAgICBNYXNzRGF0YS5JbmVydGlhID0gX2RlbnNpdHkgKiBJO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBCdWlsZCB2ZXJ0aWNlcyB0byByZXByZXNlbnQgYW4gYXhpcy1hbGlnbmVkIGJveC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImhhbGZXaWR0aFwiPlRoZSBoYWxmLXdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaGFsZkhlaWdodFwiPlRoZSBoYWxmLWhlaWdodC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldEFzQm94KGZsb2F0IGhhbGZXaWR0aCwgZmxvYXQgaGFsZkhlaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNldChQb2x5Z29uVG9vbHMuQ3JlYXRlUmVjdGFuZ2xlKGhhbGZXaWR0aCwgaGFsZkhlaWdodCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBCdWlsZCB2ZXJ0aWNlcyB0byByZXByZXNlbnQgYW4gb3JpZW50ZWQgYm94LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaGFsZldpZHRoXCI+VGhlIGhhbGYtd2lkdGguLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaGFsZkhlaWdodFwiPlRoZSBoYWxmLWhlaWdodC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNlbnRlclwiPlRoZSBjZW50ZXIgb2YgdGhlIGJveCBpbiBsb2NhbCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFuZ2xlXCI+VGhlIHJvdGF0aW9uIG9mIHRoZSBib3ggaW4gbG9jYWwgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRBc0JveChmbG9hdCBoYWxmV2lkdGgsIGZsb2F0IGhhbGZIZWlnaHQsIFZlY3RvcjIgY2VudGVyLCBmbG9hdCBhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNldChQb2x5Z29uVG9vbHMuQ3JlYXRlUmVjdGFuZ2xlKGhhbGZXaWR0aCwgaGFsZkhlaWdodCwgY2VudGVyLCBhbmdsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUZXN0IGEgcG9pbnQgZm9yIGNvbnRhaW5tZW50IGluIHRoaXMgc2hhcGUuIFRoaXMgb25seSB3b3JrcyBmb3IgY29udmV4IHNoYXBlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSBzaGFwZSB3b3JsZCB0cmFuc2Zvcm0uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPmEgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBzaGFwZTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBUZXN0UG9pbnQocmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0sIHJlZiBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBwTG9jYWwgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB0cmFuc2Zvcm0uUiwgcG9pbnQgLSB0cmFuc2Zvcm0uUG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBWZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkb3QgPSBWZWN0b3IyLkRvdChOb3JtYWxzW2ldLCBwTG9jYWwgLSBWZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYXN0IGEgcmF5IGFnYWluc3QgYSBjaGlsZCBzaGFwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm91dHB1dFwiPlRoZSByYXktY2FzdCByZXN1bHRzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgcmF5LWNhc3QgaW5wdXQgcGFyYW1ldGVycy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaGlsZEluZGV4XCI+VGhlIGNoaWxkIHNoYXBlIGluZGV4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIHJheS1jYXN0IGhpdHMgdGhlIHNoYXBlPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIFJheUNhc3Qob3V0IFJheUNhc3RPdXRwdXQgb3V0cHV0LCByZWYgUmF5Q2FzdElucHV0IGlucHV0LCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBjaGlsZEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gbmV3IFJheUNhc3RPdXRwdXQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgcmF5IGludG8gdGhlIHBvbHlnb24ncyBmcmFtZSBvZiByZWZlcmVuY2UuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB0cmFuc2Zvcm0uUiwgaW5wdXQuUG9pbnQxIC0gdHJhbnNmb3JtLlBvc2l0aW9uKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBwMiA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHRyYW5zZm9ybS5SLCBpbnB1dC5Qb2ludDIgLSB0cmFuc2Zvcm0uUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBwMiAtIHAxO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbG93ZXIgPSAwLjBmLCB1cHBlciA9IGlucHV0Lk1heEZyYWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgaW50IGluZGV4ID0gLTE7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIHAgPSBwMSArIGEgKiBkXHJcbiAgICAgICAgICAgICAgICAvLyBkb3Qobm9ybWFsLCBwIC0gdikgPSAwXHJcbiAgICAgICAgICAgICAgICAvLyBkb3Qobm9ybWFsLCBwMSAtIHYpICsgYSAqIGRvdChub3JtYWwsIGQpID0gMFxyXG4gICAgICAgICAgICAgICAgZmxvYXQgbnVtZXJhdG9yID0gVmVjdG9yMi5Eb3QoTm9ybWFsc1tpXSwgVmVydGljZXNbaV0gLSBwMSk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkZW5vbWluYXRvciA9IFZlY3RvcjIuRG90KE5vcm1hbHNbaV0sIGQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkZW5vbWluYXRvciA9PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmF0b3IgPCAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB3ZSB3YW50IHRoaXMgcHJlZGljYXRlIHdpdGhvdXQgZGl2aXNpb246XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG93ZXIgPCBudW1lcmF0b3IgLyBkZW5vbWluYXRvciwgd2hlcmUgZGVub21pbmF0b3IgPCAwXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgZGVub21pbmF0b3IgPCAwLCB3ZSBoYXZlIHRvIGZsaXAgdGhlIGluZXF1YWxpdHk6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbG93ZXIgPCBudW1lcmF0b3IgLyBkZW5vbWluYXRvciA8PT0+IGRlbm9taW5hdG9yICogbG93ZXIgPiBudW1lcmF0b3IuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbm9taW5hdG9yIDwgMC4wZiAmJiBudW1lcmF0b3IgPCBsb3dlciAqIGRlbm9taW5hdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVhc2UgbG93ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZWdtZW50IGVudGVycyB0aGlzIGhhbGYtc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVub21pbmF0b3IgPiAwLjBmICYmIG51bWVyYXRvciA8IHVwcGVyICogZGVub21pbmF0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWNyZWFzZSB1cHBlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgZXhpdHMgdGhpcyBoYWxmLXNwYWNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlIG9mIGVwc2lsb24gaGVyZSBjYXVzZXMgdGhlIGFzc2VydCBvbiBsb3dlciB0byB0cmlwXHJcbiAgICAgICAgICAgICAgICAvLyBpbiBzb21lIGNhc2VzLiBBcHBhcmVudGx5IHRoZSB1c2Ugb2YgZXBzaWxvbiB3YXMgdG8gbWFrZSBlZGdlXHJcbiAgICAgICAgICAgICAgICAvLyBzaGFwZXMgd29yaywgYnV0IG5vdyB0aG9zZSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5LlxyXG4gICAgICAgICAgICAgICAgLy9pZiAodXBwZXIgPCBsb3dlciAtIGIyX2Vwc2lsb24pXHJcbiAgICAgICAgICAgICAgICBpZiAodXBwZXIgPCBsb3dlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwLjBmIDw9IGxvd2VyICYmIGxvd2VyIDw9IGlucHV0Lk1heEZyYWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuRnJhY3Rpb24gPSBsb3dlcjtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5Ob3JtYWwgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybS5SLCBOb3JtYWxzW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHaXZlbiBhIHRyYW5zZm9ybSwgY29tcHV0ZSB0aGUgYXNzb2NpYXRlZCBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhIGNoaWxkIHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiIHJlc3VsdHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBzaGFwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNoaWxkSW5kZXhcIj5UaGUgY2hpbGQgc2hhcGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDb21wdXRlQUFCQihvdXQgQUFCQiBhYWJiLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgaW50IGNoaWxkSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIGxvd2VyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB0cmFuc2Zvcm0sIFZlcnRpY2VzWzBdKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB1cHBlciA9IGxvd2VyO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBWZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHYgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybSwgVmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgbG93ZXIgPSBWZWN0b3IyLk1pbihsb3dlciwgdik7XHJcbiAgICAgICAgICAgICAgICB1cHBlciA9IFZlY3RvcjIuTWF4KHVwcGVyLCB2KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByID0gbmV3IFZlY3RvcjIoUmFkaXVzLCBSYWRpdXMpO1xyXG4gICAgICAgICAgICBhYWJiLkxvd2VyQm91bmQgPSBsb3dlciAtIHI7XHJcbiAgICAgICAgICAgIGFhYmIuVXBwZXJCb3VuZCA9IHVwcGVyICsgcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIENvbXBhcmVUbyhQb2x5Z29uU2hhcGUgc2hhcGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoVmVydGljZXMuQ291bnQgIT0gc2hhcGUuVmVydGljZXMuQ291bnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChWZXJ0aWNlc1tpXSAhPSBzaGFwZS5WZXJ0aWNlc1tpXSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoUmFkaXVzID09IHNoYXBlLlJhZGl1cyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE1hc3NEYXRhID09IHNoYXBlLk1hc3NEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBDb21wdXRlU3VibWVyZ2VkQXJlYShWZWN0b3IyIG5vcm1hbCwgZmxvYXQgb2Zmc2V0LCBUcmFuc2Zvcm0geGYsIG91dCBWZWN0b3IyIHNjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2MgPSBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICAvL1RyYW5zZm9ybSBwbGFuZSBpbnRvIHNoYXBlIGNvLW9yZGluYXRlc1xyXG4gICAgICAgICAgICBWZWN0b3IyIG5vcm1hbEwgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB4Zi5SLCBub3JtYWwpO1xyXG4gICAgICAgICAgICBmbG9hdCBvZmZzZXRMID0gb2Zmc2V0IC0gVmVjdG9yMi5Eb3Qobm9ybWFsLCB4Zi5Qb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICBmbG9hdFtdIGRlcHRocyA9IG5ldyBmbG9hdFtTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXNdO1xyXG4gICAgICAgICAgICBpbnQgZGl2ZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgaW50IGludG9JbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBpbnQgb3V0b0luZGV4ID0gLTE7XHJcblxyXG4gICAgICAgICAgICBib29sIGxhc3RTdWJtZXJnZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaW50IGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBWZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkZXB0aHNbaV0gPSBWZWN0b3IyLkRvdChub3JtYWxMLCBWZXJ0aWNlc1tpXSkgLSBvZmZzZXRMO1xyXG4gICAgICAgICAgICAgICAgYm9vbCBpc1N1Ym1lcmdlZCA9IGRlcHRoc1tpXSA8IC1TZXR0aW5ncy5FcHNpbG9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N1Ym1lcmdlZClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFzdFN1Ym1lcmdlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50b0luZGV4ID0gaSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZlQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFN1Ym1lcmdlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0b0luZGV4ID0gaSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZlQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RTdWJtZXJnZWQgPSBpc1N1Ym1lcmdlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKGRpdmVDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U3VibWVyZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Db21wbGV0ZWx5IHN1Ym1lcmdlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYyA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYsIE1hc3NEYXRhLkNlbnRyb2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hc3NEYXRhLk1hc3MgLyBEZW5zaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0NvbXBsZXRlbHkgZHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50b0luZGV4ID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50b0luZGV4ID0gVmVydGljZXMuQ291bnQgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRvSW5kZXggPSBWZXJ0aWNlcy5Db3VudCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGludCBpbnRvSW5kZXgyID0gKGludG9JbmRleCArIDEpICUgVmVydGljZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIGludCBvdXRvSW5kZXgyID0gKG91dG9JbmRleCArIDEpICUgVmVydGljZXMuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbnRvTGFtYmRhID0gKDAgLSBkZXB0aHNbaW50b0luZGV4XSkgLyAoZGVwdGhzW2ludG9JbmRleDJdIC0gZGVwdGhzW2ludG9JbmRleF0pO1xyXG4gICAgICAgICAgICBmbG9hdCBvdXRvTGFtYmRhID0gKDAgLSBkZXB0aHNbb3V0b0luZGV4XSkgLyAoZGVwdGhzW291dG9JbmRleDJdIC0gZGVwdGhzW291dG9JbmRleF0pO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBpbnRvVmVjID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlc1tpbnRvSW5kZXhdLlggKiAoMSAtIGludG9MYW1iZGEpICsgVmVydGljZXNbaW50b0luZGV4Ml0uWCAqIGludG9MYW1iZGEsXHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlc1tpbnRvSW5kZXhdLlkgKiAoMSAtIGludG9MYW1iZGEpICsgVmVydGljZXNbaW50b0luZGV4Ml0uWSAqIGludG9MYW1iZGEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIG91dG9WZWMgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzW291dG9JbmRleF0uWCAqICgxIC0gb3V0b0xhbWJkYSkgKyBWZXJ0aWNlc1tvdXRvSW5kZXgyXS5YICogb3V0b0xhbWJkYSxcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzW291dG9JbmRleF0uWSAqICgxIC0gb3V0b0xhbWJkYSkgKyBWZXJ0aWNlc1tvdXRvSW5kZXgyXS5ZICogb3V0b0xhbWJkYSk7XHJcblxyXG4gICAgICAgICAgICAvL0luaXRpYWxpemUgYWNjdW11bGF0b3JcclxuICAgICAgICAgICAgZmxvYXQgYXJlYSA9IDA7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgY2VudGVyID0gbmV3IFZlY3RvcjIoMCwgMCk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDIgPSBWZXJ0aWNlc1tpbnRvSW5kZXgyXTtcclxuICAgICAgICAgICAgVmVjdG9yMiBwMztcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGtfaW52MyA9IDEuMGYgLyAzLjBmO1xyXG5cclxuICAgICAgICAgICAgLy9BbiBhd2t3YXJkIGxvb3AgZnJvbSBpbnRvSW5kZXgyKzEgdG8gb3V0SW5kZXgyXHJcbiAgICAgICAgICAgIGkgPSBpbnRvSW5kZXgyO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSAhPSBvdXRvSW5kZXgyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpID0gKGkgKyAxKSAlIFZlcnRpY2VzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gb3V0b0luZGV4MilcclxuICAgICAgICAgICAgICAgICAgICBwMyA9IG91dG9WZWM7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcDMgPSBWZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vQWRkIHRoZSB0cmlhbmdsZSBmb3JtZWQgYnkgaW50b1ZlYyxwMixwM1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZTEgPSBwMiAtIGludG9WZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBlMiA9IHAzIC0gaW50b1ZlYztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgRCA9IE1hdGhVdGlscy5Dcm9zcyhlMSwgZTIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB0cmlhbmdsZUFyZWEgPSAwLjVmICogRDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYXJlYSArPSB0cmlhbmdsZUFyZWE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFyZWEgd2VpZ2h0ZWQgY2VudHJvaWRcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIgKz0gdHJpYW5nbGVBcmVhICoga19pbnYzICogKGludG9WZWMgKyBwMiArIHAzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBwMiA9IHAzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL05vcm1hbGl6ZSBhbmQgdHJhbnNmb3JtIGNlbnRyb2lkXHJcbiAgICAgICAgICAgIGNlbnRlciAqPSAxLjBmIC8gYXJlYTtcclxuXHJcbiAgICAgICAgICAgIHNjID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZiwgY2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIE1haW50YWlucyBhIGZpeGVkIGFuZ2xlIGJldHdlZW4gdHdvIGJvZGllc1xyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBBbmdsZUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgQmlhc0ZhY3RvcjtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4SW1wdWxzZTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgU29mdG5lc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYmlhcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9qb2ludEVycm9yO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21hc3NGYWN0b3I7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdGFyZ2V0QW5nbGU7XHJcblxyXG4gICAgICAgIGludGVybmFsIEFuZ2xlSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkFuZ2xlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEFuZ2xlSm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QilcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHlBLCBib2R5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5BbmdsZTtcclxuICAgICAgICAgICAgVGFyZ2V0QW5nbGUgPSAwO1xyXG4gICAgICAgICAgICBCaWFzRmFjdG9yID0gLjJmO1xyXG4gICAgICAgICAgICBTb2Z0bmVzcyA9IDBmO1xyXG4gICAgICAgICAgICBNYXhJbXB1bHNlID0gZmxvYXQuTWF4VmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVGFyZ2V0QW5nbGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdGFyZ2V0QW5nbGU7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBfdGFyZ2V0QW5nbGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RhcmdldEFuZ2xlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5Qb3NpdGlvbjsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUIuUG9zaXRpb247IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgICAgICAvL3JldHVybiBfaW52X2R0ICogX2ltcHVsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2pvaW50RXJyb3IgPSAoQm9keUIuU3dlZXAuQSAtIEJvZHlBLlN3ZWVwLkEgLSBUYXJnZXRBbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBfYmlhcyA9IC1CaWFzRmFjdG9yICogc3RlcC5pbnZfZHQgKiBfam9pbnRFcnJvcjtcclxuXHJcbiAgICAgICAgICAgIF9tYXNzRmFjdG9yID0gKDEgLSBTb2Z0bmVzcykgLyAoQm9keUEuSW52SSArIEJvZHlCLkludkkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBwID0gKF9iaWFzIC0gQm9keUIuQW5ndWxhclZlbG9jaXR5ICsgQm9keUEuQW5ndWxhclZlbG9jaXR5KSAqIF9tYXNzRmFjdG9yO1xyXG4gICAgICAgICAgICBCb2R5QS5Bbmd1bGFyVmVsb2NpdHkgLT0gQm9keUEuSW52SSAqIE1hdGguU2lnbihwKSAqIE1hdGguTWluKChmbG9hdClNYXRoLkFicyhwKSwgTWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgIEJvZHlCLkFuZ3VsYXJWZWxvY2l0eSArPSBCb2R5Qi5JbnZJICogTWF0aC5TaWduKHApICogTWF0aC5NaW4oKGZsb2F0KU1hdGguQWJzKHApLCBNYXhJbXB1bHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vbm8gcG9zaXRpb24gc29sdmluZyBmb3IgdGhpcyBqb2ludFxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLyAxLUQgcmFpbmVkIHN5c3RlbVxyXG4gICAgLy8gbSAodjIgLSB2MSkgPSBsYW1iZGFcclxuICAgIC8vIHYyICsgKGJldGEvaCkgKiB4MSArIGdhbW1hICogbGFtYmRhID0gMCwgZ2FtbWEgaGFzIHVuaXRzIG9mIGludmVyc2UgbWFzcy5cclxuICAgIC8vIHgyID0geDEgKyBoICogdjJcclxuXHJcbiAgICAvLyAxLUQgbWFzcy1kYW1wZXItc3ByaW5nIHN5c3RlbVxyXG4gICAgLy8gbSAodjIgLSB2MSkgKyBoICogZCAqIHYyICsgaCAqIGsgKiBcclxuXHJcbiAgICAvLyBDID0gbm9ybShwMiAtIHAxKSAtIExcclxuICAgIC8vIHUgPSAocDIgLSBwMSkgLyBub3JtKHAyIC0gcDEpXHJcbiAgICAvLyBDZG90ID0gZG90KHUsIHYyICsgY3Jvc3ModzIsIHIyKSAtIHYxIC0gY3Jvc3ModzEsIHIxKSlcclxuICAgIC8vIEogPSBbLXUgLWNyb3NzKHIxLCB1KSB1IGNyb3NzKHIyLCB1KV1cclxuICAgIC8vIEsgPSBKICogaW52TSAqIEpUXHJcbiAgICAvLyAgID0gaW52TWFzczEgKyBpbnZJMSAqIGNyb3NzKHIxLCB1KV4yICsgaW52TWFzczIgKyBpbnZJMiAqIGNyb3NzKHIyLCB1KV4yXHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgZGlzdGFuY2Ugam9pbnQgcmFpbnMgdHdvIHBvaW50cyBvbiB0d28gYm9kaWVzXHJcbiAgICAvLy8gdG8gcmVtYWluIGF0IGEgZml4ZWQgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLiBZb3UgY2FuIHZpZXdcclxuICAgIC8vLyB0aGlzIGFzIGEgbWFzc2xlc3MsIHJpZ2lkIHJvZC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRGlzdGFuY2VKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUIncyBvcmlnaW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckI7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2JpYXM7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfZ2FtbWE7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXNzO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3RtcEZsb2F0MTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3RtcFZlY3RvcjE7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF91O1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBEaXN0YW5jZUpvaW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5EaXN0YW5jZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyByZXF1aXJlcyBkZWZpbmluZyBhblxyXG4gICAgICAgIC8vLyBhbmNob3IgcG9pbnQgb24gYm90aCBib2RpZXMgYW5kIHRoZSBub24temVybyBsZW5ndGggb2YgdGhlXHJcbiAgICAgICAgLy8vIGRpc3RhbmNlIGpvaW50LiBJZiB5b3UgZG9uJ3Qgc3VwcGx5IGEgbGVuZ3RoLCB0aGUgbG9jYWwgYW5jaG9yIHBvaW50c1xyXG4gICAgICAgIC8vLyBpcyB1c2VkIHNvIHRoYXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBjYW4gdmlvbGF0ZSB0aGUgY29uc3RyYWludFxyXG4gICAgICAgIC8vLyBzbGlnaHRseS4gVGhpcyBoZWxwcyB3aGVuIHNhdmluZyBhbmQgbG9hZGluZyBhIGdhbWUuXHJcbiAgICAgICAgLy8vIEB3YXJuaW5nIERvIG5vdCB1c2UgYSB6ZXJvIG9yIHNob3J0IGxlbmd0aC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+VGhlIGZpcnN0IGJvZHk8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+VGhlIHNlY29uZCBib2R5PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckFcIj5UaGUgZmlyc3QgYm9keSBhbmNob3I8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsQW5jaG9yQlwiPlRoZSBzZWNvbmQgYm9keSBhbmNob3I8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBEaXN0YW5jZUpvaW50KEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxBbmNob3JBLCBWZWN0b3IyIGxvY2FsQW5jaG9yQilcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHlBLCBib2R5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5EaXN0YW5jZTtcclxuXHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gV29ybGRBbmNob3JCIC0gV29ybGRBbmNob3JBO1xyXG4gICAgICAgICAgICBMZW5ndGggPSBkLkxlbmd0aCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbmF0dXJhbCBsZW5ndGggYmV0d2VlbiB0aGUgYW5jaG9yIHBvaW50cy5cclxuICAgICAgICAvLy8gTWFuaXB1bGF0aW5nIHRoZSBsZW5ndGggY2FuIGxlYWQgdG8gbm9uLXBoeXNpY2FsIGJlaGF2aW9yIHdoZW4gdGhlIGZyZXF1ZW5jeSBpcyB6ZXJvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExlbmd0aCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG1hc3Mtc3ByaW5nLWRhbXBlciBmcmVxdWVuY3kgaW4gSGVydHouXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRnJlcXVlbmN5IHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZGFtcGluZyByYXRpby4gMCA9IG5vIGRhbXBpbmcsIDEgPSBjcml0aWNhbCBkYW1waW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IERhbXBpbmdSYXRpbyB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBzZWFsZWQgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBzZWFsZWQgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgRiA9IChpbnZfZHQgKiBfaW1wdWxzZSkgKiBfdTtcclxuICAgICAgICAgICAgcmV0dXJuIEY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAuMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIGIxLlhmLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjIuWGYuUiwgTG9jYWxBbmNob3JCIC0gYjIuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBfdSA9IGIyLlN3ZWVwLkMgKyByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzaW5ndWxhcml0eS5cclxuICAgICAgICAgICAgZmxvYXQgbGVuZ3RoID0gX3UuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBTZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdSAqPSAxLjBmIC8gbGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3UgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGNyMXUsIGNyMnU7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjEsIHJlZiBfdSwgb3V0IGNyMXUpO1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIyLCByZWYgX3UsIG91dCBjcjJ1KTtcclxuICAgICAgICAgICAgZmxvYXQgaW52TWFzcyA9IGIxLkludk1hc3MgKyBiMS5JbnZJICogY3IxdSAqIGNyMXUgKyBiMi5JbnZNYXNzICsgYjIuSW52SSAqIGNyMnUgKiBjcjJ1O1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoaW52TWFzcyA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICBfbWFzcyA9IGludk1hc3MgIT0gMC4wZiA/IDEuMGYgLyBpbnZNYXNzIDogMC4wZjtcclxuXHJcbiAgICAgICAgICAgIGlmIChGcmVxdWVuY3kgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDID0gbGVuZ3RoIC0gTGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZyZXF1ZW5jeVxyXG4gICAgICAgICAgICAgICAgZmxvYXQgb21lZ2EgPSAyLjBmICogU2V0dGluZ3MuUGkgKiBGcmVxdWVuY3k7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICAgICAgZmxvYXQgZCA9IDIuMGYgKiBfbWFzcyAqIERhbXBpbmdSYXRpbyAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsgPSBfbWFzcyAqIG9tZWdhICogb21lZ2E7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcclxuICAgICAgICAgICAgICAgIF9nYW1tYSA9IHN0ZXAuZHQgKiAoZCArIHN0ZXAuZHQgKiBrKTtcclxuICAgICAgICAgICAgICAgIF9nYW1tYSA9IF9nYW1tYSAhPSAwLjBmID8gMS4wZiAvIF9nYW1tYSA6IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBfYmlhcyA9IEMgKiBzdGVwLmR0ICogayAqIF9nYW1tYTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IGludk1hc3MgKyBfZ2FtbWE7XHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IF9tYXNzICE9IDAuMGYgPyAxLjBmIC8gX21hc3MgOiAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSB0aGUgaW1wdWxzZSB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IF9pbXB1bHNlICogX3U7XHJcbiAgICAgICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMSwgcmVmIFAsIG91dCBfdG1wRmxvYXQxKTtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludkkgKiAvKiByMSB4IFAgKi8gX3RtcEZsb2F0MTtcclxuICAgICAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIyLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52SSAqIC8qIHIyIHggUCAqLyBfdG1wRmxvYXQxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KHUsIHYgKyBjcm9zcyh3LCByKSlcclxuICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsLCByZWYgcjEsIG91dCBfdG1wVmVjdG9yMSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsICsgX3RtcFZlY3RvcjE7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCwgcmVmIHIyLCBvdXQgX3RtcFZlY3RvcjEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArIF90bXBWZWN0b3IxO1xyXG4gICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX3UsIHYyIC0gdjEpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fbWFzcyAqIChDZG90ICsgX2JpYXMgKyBfZ2FtbWEgKiBfaW1wdWxzZSk7XHJcbiAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX3U7XHJcbiAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgLT0gYjEuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjEsIHJlZiBQLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludkkgKiBfdG1wRmxvYXQxO1xyXG4gICAgICAgICAgICBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIyLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZJICogX3RtcEZsb2F0MTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChGcmVxdWVuY3kgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBwb3NpdGlvbiBjb3JyZWN0aW9uIGZvciBzb2Z0IGRpc3RhbmNlIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBiMi5Td2VlcC5DICsgcjIgLSBiMS5Td2VlcC5DIC0gcjE7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBsZW5ndGggPSBkLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBkIC89IGxlbmd0aDtcclxuICAgICAgICAgICAgZmxvYXQgQyA9IGxlbmd0aCAtIExlbmd0aDtcclxuICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDLCAtU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbiwgU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbik7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9tYXNzICogQztcclxuICAgICAgICAgICAgX3UgPSBkO1xyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX3U7XHJcblxyXG4gICAgICAgICAgICBiMS5Td2VlcC5DIC09IGIxLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIxLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICBiMS5Td2VlcC5BIC09IGIxLkludkkgKiBfdG1wRmxvYXQxO1xyXG4gICAgICAgICAgICBiMi5Td2VlcC5DICs9IGIyLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIyLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICBiMi5Td2VlcC5BICs9IGIyLkludkkgKiBfdG1wRmxvYXQxO1xyXG5cclxuICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgYjIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkFicyhDKSA8IFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgRml4ZWRBbmdsZUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgQmlhc0ZhY3RvcjtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4SW1wdWxzZTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgU29mdG5lc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYmlhcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9qb2ludEVycm9yO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21hc3NGYWN0b3I7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdGFyZ2V0QW5nbGU7XHJcblxyXG4gICAgICAgIHB1YmxpYyBGaXhlZEFuZ2xlSm9pbnQoQm9keSBib2R5QSlcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHlBKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkZpeGVkQW5nbGU7XHJcbiAgICAgICAgICAgIFRhcmdldEFuZ2xlID0gMDtcclxuICAgICAgICAgICAgQmlhc0ZhY3RvciA9IC4yZjtcclxuICAgICAgICAgICAgU29mdG5lc3MgPSAwZjtcclxuICAgICAgICAgICAgTWF4SW1wdWxzZSA9IGZsb2F0Lk1heFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IFRhcmdldEFuZ2xlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3RhcmdldEFuZ2xlOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gX3RhcmdldEFuZ2xlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF90YXJnZXRBbmdsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuUG9zaXRpb247IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLlBvc2l0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldCB7IERlYnVnLkFzc2VydChmYWxzZSwgXCJZb3UgY2FuJ3Qgc2V0IHRoZSB3b3JsZCBhbmNob3Igb24gdGhpcyBqb2ludCB0eXBlLlwiKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1RPRE9cclxuICAgICAgICAgICAgLy9yZXR1cm4gX2ludl9kdCAqIF9pbXB1bHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9qb2ludEVycm9yID0gQm9keUEuU3dlZXAuQSAtIFRhcmdldEFuZ2xlO1xyXG5cclxuICAgICAgICAgICAgX2JpYXMgPSAtQmlhc0ZhY3RvciAqIHN0ZXAuaW52X2R0ICogX2pvaW50RXJyb3I7XHJcblxyXG4gICAgICAgICAgICBfbWFzc0ZhY3RvciA9ICgxIC0gU29mdG5lc3MpIC8gKEJvZHlBLkludkkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBwID0gKF9iaWFzIC0gQm9keUEuQW5ndWxhclZlbG9jaXR5KSAqIF9tYXNzRmFjdG9yO1xyXG4gICAgICAgICAgICBCb2R5QS5Bbmd1bGFyVmVsb2NpdHkgKz0gQm9keUEuSW52SSAqIE1hdGguU2lnbihwKSAqIE1hdGguTWluKChmbG9hdClNYXRoLkFicyhwKSwgTWF4SW1wdWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL25vIHBvc2l0aW9uIHNvbHZpbmcgZm9yIHRoaXMgam9pbnRcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8gMS1EIHJhaW5lZCBzeXN0ZW1cclxuICAgIC8vIG0gKHYyIC0gdjEpID0gbGFtYmRhXHJcbiAgICAvLyB2MiArIChiZXRhL2gpICogeDEgKyBnYW1tYSAqIGxhbWJkYSA9IDAsIGdhbW1hIGhhcyB1bml0cyBvZiBpbnZlcnNlIG1hc3MuXHJcbiAgICAvLyB4MiA9IHgxICsgaCAqIHYyXHJcblxyXG4gICAgLy8gMS1EIG1hc3MtZGFtcGVyLXNwcmluZyBzeXN0ZW1cclxuICAgIC8vIG0gKHYyIC0gdjEpICsgaCAqIGQgKiB2MiArIGggKiBrICogXHJcblxyXG4gICAgLy8gQyA9IG5vcm0ocDIgLSBwMSkgLSBMXHJcbiAgICAvLyB1ID0gKHAyIC0gcDEpIC8gbm9ybShwMiAtIHAxKVxyXG4gICAgLy8gQ2RvdCA9IGRvdCh1LCB2MiArIGNyb3NzKHcyLCByMikgLSB2MSAtIGNyb3NzKHcxLCByMSkpXHJcbiAgICAvLyBKID0gWy11IC1jcm9zcyhyMSwgdSkgdSBjcm9zcyhyMiwgdSldXHJcbiAgICAvLyBLID0gSiAqIGludk0gKiBKVFxyXG4gICAgLy8gICA9IGludk1hc3MxICsgaW52STEgKiBjcm9zcyhyMSwgdSleMiArIGludk1hc3MyICsgaW52STIgKiBjcm9zcyhyMiwgdSleMlxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIGRpc3RhbmNlIGpvaW50IHJhaW5zIHR3byBwb2ludHMgb24gdHdvIGJvZGllc1xyXG4gICAgLy8vIHRvIHJlbWFpbiBhdCBhIGZpeGVkIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci4gWW91IGNhbiB2aWV3XHJcbiAgICAvLy8gdGhpcyBhcyBhIG1hc3NsZXNzLCByaWdpZCByb2QuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIEZpeGVkRGlzdGFuY2VKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbG9jYWwgYW5jaG9yIHBvaW50IHJlbGF0aXZlIHRvIGJvZHlBJ3Mgb3JpZ2luLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9iaWFzO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2dhbW1hO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzcztcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3U7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF93b3JsZEFuY2hvckI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyByZXF1aXJlcyBkZWZpbmluZyBhblxyXG4gICAgICAgIC8vLyBhbmNob3IgcG9pbnQgb24gYm90aCBib2RpZXMgYW5kIHRoZSBub24temVybyBsZW5ndGggb2YgdGhlXHJcbiAgICAgICAgLy8vIGRpc3RhbmNlIGpvaW50LiBJZiB5b3UgZG9uJ3Qgc3VwcGx5IGEgbGVuZ3RoLCB0aGUgbG9jYWwgYW5jaG9yIHBvaW50c1xyXG4gICAgICAgIC8vLyBpcyB1c2VkIHNvIHRoYXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBjYW4gdmlvbGF0ZSB0aGUgY29uc3RyYWludFxyXG4gICAgICAgIC8vLyBzbGlnaHRseS4gVGhpcyBoZWxwcyB3aGVuIHNhdmluZyBhbmQgbG9hZGluZyBhIGdhbWUuXHJcbiAgICAgICAgLy8vIEB3YXJuaW5nIERvIG5vdCB1c2UgYSB6ZXJvIG9yIHNob3J0IGxlbmd0aC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlcIj5UaGUgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBbmNob3JcIj5UaGUgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZEFuY2hvclwiPlRoZSB3b3JsZCBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgRml4ZWREaXN0YW5jZUpvaW50KEJvZHkgYm9keSwgVmVjdG9yMiBib2R5QW5jaG9yLCBWZWN0b3IyIHdvcmxkQW5jaG9yKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5GaXhlZERpc3RhbmNlO1xyXG5cclxuICAgICAgICAgICAgTG9jYWxBbmNob3JBID0gYm9keUFuY2hvcjtcclxuICAgICAgICAgICAgX3dvcmxkQW5jaG9yQiA9IHdvcmxkQW5jaG9yO1xyXG5cclxuICAgICAgICAgICAgLy9DYWxjdWxhdGUgdGhlIGxlbmd0aFxyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBXb3JsZEFuY2hvckIgLSBXb3JsZEFuY2hvckE7XHJcbiAgICAgICAgICAgIExlbmd0aCA9IGQuTGVuZ3RoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBuYXR1cmFsIGxlbmd0aCBiZXR3ZWVuIHRoZSBhbmNob3IgcG9pbnRzLlxyXG4gICAgICAgIC8vLyBNYW5pcHVsYXRpbmcgdGhlIGxlbmd0aCBjYW4gbGVhZCB0byBub24tcGh5c2ljYWwgYmVoYXZpb3Igd2hlbiB0aGUgZnJlcXVlbmN5IGlzIHplcm8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTGVuZ3RoIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWFzcy1zcHJpbmctZGFtcGVyIGZyZXF1ZW5jeSBpbiBIZXJ0ei5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBGcmVxdWVuY3kgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBkYW1waW5nIHJhdGlvLiAwID0gbm8gZGFtcGluZywgMSA9IGNyaXRpY2FsIGRhbXBpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGFtcGluZ1JhdGlvIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHNlYWxlZCBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHNlYWxlZCBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF93b3JsZEFuY2hvckI7IH1cclxuICAgICAgICAgICAgc2V0IHsgX3dvcmxkQW5jaG9yQiA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludkR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChpbnZEdCAqIF9pbXB1bHNlKSAqIF91O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludkR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAuMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxyXG4gICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gX3dvcmxkQW5jaG9yQjtcclxuICAgICAgICAgICAgX3UgPSByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzaW5ndWxhcml0eS5cclxuICAgICAgICAgICAgZmxvYXQgbGVuZ3RoID0gX3UuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBTZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdSAqPSAxLjBmIC8gbGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3UgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGNyMXUgPSBNYXRoVXRpbHMuQ3Jvc3MocjEsIF91KTtcclxuICAgICAgICAgICAgZmxvYXQgY3IydSA9IE1hdGhVdGlscy5Dcm9zcyhyMiwgX3UpO1xyXG4gICAgICAgICAgICBmbG9hdCBpbnZNYXNzID0gYjEuSW52TWFzcyArIGIxLkludkkgKiBjcjF1ICogY3IxdSArIDAgKiBjcjJ1ICogY3IydTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGludk1hc3MgPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgX21hc3MgPSBpbnZNYXNzICE9IDAuMGYgPyAxLjBmIC8gaW52TWFzcyA6IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBpZiAoRnJlcXVlbmN5ID4gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQyA9IGxlbmd0aCAtIExlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGcmVxdWVuY3lcclxuICAgICAgICAgICAgICAgIGZsb2F0IG9tZWdhID0gMi4wZiAqIFNldHRpbmdzLlBpICogRnJlcXVlbmN5O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcclxuICAgICAgICAgICAgICAgIGZsb2F0IGQgPSAyLjBmICogX21hc3MgKiBEYW1waW5nUmF0aW8gKiBvbWVnYTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTcHJpbmcgc3RpZmZuZXNzXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrID0gX21hc3MgKiBvbWVnYSAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG1hZ2ljIGZvcm11bGFzXHJcbiAgICAgICAgICAgICAgICBfZ2FtbWEgPSBzdGVwLmR0ICogKGQgKyBzdGVwLmR0ICogayk7XHJcbiAgICAgICAgICAgICAgICBfZ2FtbWEgPSBfZ2FtbWEgIT0gMC4wZiA/IDEuMGYgLyBfZ2FtbWEgOiAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX2JpYXMgPSBDICogc3RlcC5kdCAqIGsgKiBfZ2FtbWE7XHJcblxyXG4gICAgICAgICAgICAgICAgX21hc3MgPSBpbnZNYXNzICsgX2dhbW1hO1xyXG4gICAgICAgICAgICAgICAgX21hc3MgPSBfbWFzcyAhPSAwLjBmID8gMS4wZiAvIF9tYXNzIDogMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgdGhlIGltcHVsc2UgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZSAqIF91O1xyXG4gICAgICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBiMS5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIFApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KHUsIHYgKyBjcm9zcyh3LCByKSlcclxuICAgICAgICAgICAgVmVjdG9yMiB2MSA9IGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKyBNYXRoVXRpbHMuQ3Jvc3MoYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwsIHIxKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IFZlY3RvcjIuRG90KF91LCB2MiAtIHYxKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX21hc3MgKiAoQ2RvdCArIF9iaWFzICsgX2dhbW1hICogX2ltcHVsc2UpO1xyXG4gICAgICAgICAgICBfaW1wdWxzZSArPSBpbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIF91O1xyXG4gICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtPSBiMS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIxLCBQKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChGcmVxdWVuY3kgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBwb3NpdGlvbiBjb3JyZWN0aW9uIGZvciBzb2Z0IGRpc3RhbmNlIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBfd29ybGRBbmNob3JCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gcjIgLSBiMS5Td2VlcC5DIC0gcjE7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBsZW5ndGggPSBkLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBkIC89IGxlbmd0aDtcclxuICAgICAgICAgICAgZmxvYXQgQyA9IGxlbmd0aCAtIExlbmd0aDtcclxuICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDLCAtU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbiwgU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbik7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9tYXNzICogQztcclxuICAgICAgICAgICAgX3UgPSBkO1xyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX3U7XHJcblxyXG4gICAgICAgICAgICBiMS5Td2VlcC5DIC09IGIxLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiMS5Td2VlcC5BIC09IGIxLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIFApO1xyXG5cclxuICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkFicyhDKSA8IFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8gUG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxyXG4gICAgLy8gQ2RvdCA9IHYyIC0gdjFcclxuICAgIC8vICAgICAgPSB2MiArIGNyb3NzKHcyLCByMikgLSB2MSAtIGNyb3NzKHcxLCByMSlcclxuICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3IF1cclxuICAgIC8vIElkZW50aXR5IHVzZWQ6XHJcbiAgICAvLyB3IGsgJSAocnggaSArIHJ5IGopID0gdyAqICgtcnkgaSArIHJ4IGopXHJcblxyXG4gICAgLy8gQW5nbGUgY29uc3RyYWludFxyXG4gICAgLy8gQ2RvdCA9IHcyIC0gdzFcclxuICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxyXG4gICAgLy8gSyA9IGludkkxICsgaW52STJcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gRnJpY3Rpb24gam9pbnQuIFRoaXMgaXMgdXNlZCBmb3IgdG9wLWRvd24gZnJpY3Rpb24uXHJcbiAgICAvLy8gSXQgcHJvdmlkZXMgMkQgdHJhbnNsYXRpb25hbCBmcmljdGlvbiBhbmQgYW5ndWxhciBmcmljdGlvbi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRml4ZWRGcmljdGlvbkpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG1heGltdW0gZnJpY3Rpb24gZm9yY2UgaW4gTi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhGb3JjZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBmcmljdGlvbiB0b3JxdWUgaW4gTi1tLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heFRvcnF1ZTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYW5ndWxhckltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYW5ndWxhck1hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9saW5lYXJJbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgTWF0MjIgX2xpbmVhck1hc3M7XHJcblxyXG4gICAgICAgIHB1YmxpYyBGaXhlZEZyaWN0aW9uSm9pbnQoQm9keSBib2R5LCBWZWN0b3IyIGxvY2FsQW5jaG9yQSlcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuRml4ZWRGcmljdGlvbjtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JBID0gbG9jYWxBbmNob3JBO1xyXG5cclxuICAgICAgICAgICAgLy9TZXR0aW5nIGRlZmF1bHQgbWF4IGZvcmNlIGFuZCBtYXggdG9ycXVlXHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IGdyYXZpdHkgPSAxMC4wZjtcclxuXHJcbiAgICAgICAgICAgIC8vIEZvciBhIGNpcmNsZTogSSA9IDAuNSAqIG0gKiByICogciA9PT4gciA9IHNxcnQoMiAqIEkgLyBtKVxyXG4gICAgICAgICAgICBmbG9hdCByYWRpdXMgPSAoZmxvYXQpTWF0aC5TcXJ0KDIuMCAqIChib2R5LkluZXJ0aWEgLyBib2R5Lk1hc3MpKTtcclxuXHJcbiAgICAgICAgICAgIE1heEZvcmNlID0gYm9keS5NYXNzICogZ3Jhdml0eTtcclxuICAgICAgICAgICAgTWF4VG9ycXVlID0gYm9keS5NYXNzICogcmFkaXVzICogZ3Jhdml0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gVmVjdG9yMi5aZXJvOyB9XHJcbiAgICAgICAgICAgIHNldCB7IERlYnVnLkFzc2VydChmYWxzZSwgXCJZb3UgY2FuJ3Qgc2V0IHRoZSB3b3JsZCBhbmNob3Igb24gdGhpcyBqb2ludCB0eXBlLlwiKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZEVClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZEVCAqIF9saW5lYXJJbXB1bHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludkRUKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludkRUICogX2FuZ3VsYXJJbXB1bHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkE7XHJcbiAgICAgICAgICAgIGJBLkdldFRyYW5zZm9ybShvdXQgeGZBKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzIG1hdHJpeC5cclxuICAgICAgICAgICAgVmVjdG9yMiByQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLlIsIExvY2FsQW5jaG9yQSAtIGJBLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3XVxyXG4gICAgICAgICAgICAvLyAgICAgWyAwICAgICAgIC0xIDAgICAgICAgMV1cclxuICAgICAgICAgICAgLy8gcl9za2V3ID0gWy1yeTsgcnhdXHJcblxyXG4gICAgICAgICAgICAvLyBNYXRsYWJcclxuICAgICAgICAgICAgLy8gSyA9IFsgbUErcjF5XjIqaUErbUIrcjJ5XjIqaUIsICAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCAgICAgICAgICAtcjF5KmlBLXIyeSppQl1cclxuICAgICAgICAgICAgLy8gICAgIFsgIC1yMXkqaUEqcjF4LXIyeSppQipyMngsIG1BK3IxeF4yKmlBK21CK3IyeF4yKmlCLCAgICAgICAgICAgcjF4KmlBK3IyeCppQl1cclxuICAgICAgICAgICAgLy8gICAgIFsgICAgICAgICAgLXIxeSppQS1yMnkqaUIsICAgICAgICAgICByMXgqaUErcjJ4KmlCLCAgICAgICAgICAgICAgICAgICBpQStpQl1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG1BID0gYkEuSW52TWFzcztcclxuICAgICAgICAgICAgZmxvYXQgaUEgPSBiQS5JbnZJO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSzEgPSBuZXcgTWF0MjIoKTtcclxuICAgICAgICAgICAgSzEuQ29sMS5YID0gbUE7XHJcbiAgICAgICAgICAgIEsxLkNvbDIuWCA9IDAuMGY7XHJcbiAgICAgICAgICAgIEsxLkNvbDEuWSA9IDAuMGY7XHJcbiAgICAgICAgICAgIEsxLkNvbDIuWSA9IG1BO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSzIgPSBuZXcgTWF0MjIoKTtcclxuICAgICAgICAgICAgSzIuQ29sMS5YID0gaUEgKiByQS5ZICogckEuWTtcclxuICAgICAgICAgICAgSzIuQ29sMi5YID0gLWlBICogckEuWCAqIHJBLlk7XHJcbiAgICAgICAgICAgIEsyLkNvbDEuWSA9IC1pQSAqIHJBLlggKiByQS5ZO1xyXG4gICAgICAgICAgICBLMi5Db2wyLlkgPSBpQSAqIHJBLlggKiByQS5YO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSzEyO1xyXG4gICAgICAgICAgICBNYXQyMi5BZGQocmVmIEsxLCByZWYgSzIsIG91dCBLMTIpO1xyXG5cclxuICAgICAgICAgICAgX2xpbmVhck1hc3MgPSBLMTIuSW52ZXJzZTtcclxuXHJcbiAgICAgICAgICAgIF9hbmd1bGFyTWFzcyA9IGlBO1xyXG4gICAgICAgICAgICBpZiAoX2FuZ3VsYXJNYXNzID4gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJNYXNzID0gMS4wZiAvIF9hbmd1bGFyTWFzcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgIF9hbmd1bGFySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gbmV3IFZlY3RvcjIoX2xpbmVhckltcHVsc2UuWCwgX2xpbmVhckltcHVsc2UuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYkEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBtQSAqIFA7XHJcbiAgICAgICAgICAgICAgICBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtPSBpQSAqIChNYXRoVXRpbHMuQ3Jvc3MockEsIFApICsgX2FuZ3VsYXJJbXB1bHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHZBID0gYkEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgd0EgPSBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG1BID0gYkEuSW52TWFzcztcclxuICAgICAgICAgICAgZmxvYXQgaUEgPSBiQS5JbnZJO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQTtcclxuICAgICAgICAgICAgYkEuR2V0VHJhbnNmb3JtKG91dCB4ZkEpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLlIsIExvY2FsQW5jaG9yQSAtIGJBLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIGFuZ3VsYXIgZnJpY3Rpb25cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IC13QTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX2FuZ3VsYXJNYXNzICogQ2RvdDtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gX2FuZ3VsYXJJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiBNYXhUb3JxdWU7XHJcbiAgICAgICAgICAgICAgICBfYW5ndWxhckltcHVsc2UgPSBNYXRoVXRpbHMuQ2xhbXAoX2FuZ3VsYXJJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9hbmd1bGFySW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgZnJpY3Rpb25cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBDZG90ID0gLXZBIC0gTWF0aFV0aWxzLkNyb3NzKHdBLCByQSk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlID0gLU1hdGhVdGlscy5NdWx0aXBseShyZWYgX2xpbmVhck1hc3MsIENkb3QpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBvbGRJbXB1bHNlID0gX2xpbmVhckltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBfbGluZWFySW1wdWxzZSArPSBpbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IG1heEltcHVsc2UgPSBzdGVwLmR0ICogTWF4Rm9yY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9saW5lYXJJbXB1bHNlLkxlbmd0aFNxdWFyZWQoKSA+IG1heEltcHVsc2UgKiBtYXhJbXB1bHNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlICo9IG1heEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9saW5lYXJJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2QSAtPSBtQSAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIE1hdGhVdGlscy5Dcm9zcyhyQSwgaW1wdWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2QTtcclxuICAgICAgICAgICAgYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3QTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBGaXhlZExpbmVKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9heCwgX2F5O1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2JpYXM7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVNb3RvcjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9nYW1tYTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9pbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfbG9jYWxYQXhpcztcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2xvY2FsWUF4aXNBO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TW90b3JUb3JxdWU7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yTWFzcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvclNwZWVkO1xyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zQXg7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc0F5O1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3NCeDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zQnk7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3NwcmluZ0ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc3ByaW5nTWFzcztcclxuXHJcbiAgICAgICAgLy8gTGluZWFyIGNvbnN0cmFpbnQgKHBvaW50LXRvLWxpbmUpXHJcbiAgICAgICAgLy8gZCA9IHBCIC0gcEEgPSB4QiArIHJCIC0geEEgLSByQVxyXG4gICAgICAgIC8vIEMgPSBkb3QoYXksIGQpXHJcbiAgICAgICAgLy8gQ2RvdCA9IGRvdChkLCBjcm9zcyh3QSwgYXkpKSArIGRvdChheSwgdkIgKyBjcm9zcyh3QiwgckIpIC0gdkEgLSBjcm9zcyh3QSwgckEpKVxyXG4gICAgICAgIC8vICAgICAgPSAtZG90KGF5LCB2QSkgLSBkb3QoY3Jvc3MoZCArIHJBLCBheSksIHdBKSArIGRvdChheSwgdkIpICsgZG90KGNyb3NzKHJCLCBheSksIHZCKVxyXG4gICAgICAgIC8vIEogPSBbLWF5LCAtY3Jvc3MoZCArIHJBLCBheSksIGF5LCBjcm9zcyhyQiwgYXkpXVxyXG5cclxuICAgICAgICAvLyBTcHJpbmcgbGluZWFyIGNvbnN0cmFpbnRcclxuICAgICAgICAvLyBDID0gZG90KGF4LCBkKVxyXG4gICAgICAgIC8vIENkb3QgPSA9IC1kb3QoYXgsIHZBKSAtIGRvdChjcm9zcyhkICsgckEsIGF4KSwgd0EpICsgZG90KGF4LCB2QikgKyBkb3QoY3Jvc3MockIsIGF4KSwgdkIpXHJcbiAgICAgICAgLy8gSiA9IFstYXggLWNyb3NzKGQrckEsIGF4KSBheCBjcm9zcyhyQiwgYXgpXVxyXG5cclxuICAgICAgICAvLyBNb3RvciByb3RhdGlvbmFsIGNvbnN0cmFpbnRcclxuICAgICAgICAvLyBDZG90ID0gd0IgLSB3QVxyXG4gICAgICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBGaXhlZExpbmVKb2ludCgpIHsgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkZpeGVkTGluZTsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgRml4ZWRMaW5lSm9pbnQoQm9keSBib2R5LCBWZWN0b3IyIHdvcmxkQW5jaG9yLCBWZWN0b3IyIGF4aXMpXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkZpeGVkTGluZTtcclxuXHJcbiAgICAgICAgICAgIEJvZHlCID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSB3b3JsZEFuY2hvcjtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gQm9keUIuR2V0TG9jYWxQb2ludCh3b3JsZEFuY2hvcik7XHJcbiAgICAgICAgICAgIExvY2FsWEF4aXMgPSBheGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JCIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gTG9jYWxBbmNob3JBOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSm9pbnRUcmFuc2xhdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuICAgICAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBBID0gYkEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwQiA9IGJCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IHBCIC0gcEE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXMgPSBiQS5HZXRXb3JsZFZlY3RvcihMb2NhbFhBeGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0cmFuc2xhdGlvbiA9IFZlY3RvcjIuRG90KGQsIGF4aXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSm9pbnRTcGVlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHdBID0gQm9keUEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB3QiA9IEJvZHlCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdCIC0gd0E7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIE1vdG9yRW5hYmxlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVNb3RvcjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keUEuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgQm9keUIuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZU1vdG9yID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNb3RvclNwZWVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keUEuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgQm9keUIuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX21vdG9yU3BlZWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21vdG9yU3BlZWQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhNb3RvclRvcnF1ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHlBLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIEJvZHlCLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF9tYXhNb3RvclRvcnF1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbWF4TW90b3JUb3JxdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBGcmVxdWVuY3kgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGFtcGluZ1JhdGlvIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxYQXhpc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9sb2NhbFhBeGlzOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbG9jYWxYQXhpcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgX2xvY2FsWUF4aXNBID0gTWF0aFV0aWxzLkNyb3NzKDEuMGYsIF9sb2NhbFhBeGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZEdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZEdCAqIChfaW1wdWxzZSAqIF9heSArIF9zcHJpbmdJbXB1bHNlICogX2F4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZEdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZEdCAqIF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgTG9jYWxDZW50ZXJBID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBMb2NhbENlbnRlckIgPSBiQi5Mb2NhbENlbnRlcjtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkI7XHJcbiAgICAgICAgICAgIGJCLkdldFRyYW5zZm9ybShvdXQgeGZCKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzZXMuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgckEgPSBMb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBMb2NhbEFuY2hvckIgLSBMb2NhbENlbnRlckIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBiQi5Td2VlcC5DICsgckIgLSByQTtcclxuXHJcbiAgICAgICAgICAgIEludk1hc3NBID0gMC4wZjtcclxuICAgICAgICAgICAgSW52SUEgPSAwLjBmO1xyXG4gICAgICAgICAgICBJbnZNYXNzQiA9IGJCLkludk1hc3M7XHJcbiAgICAgICAgICAgIEludklCID0gYkIuSW52STtcclxuXHJcbiAgICAgICAgICAgIC8vIFBvaW50IHRvIGxpbmUgY29uc3RyYWludFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfYXkgPSBfbG9jYWxZQXhpc0E7XHJcbiAgICAgICAgICAgICAgICBfc0F5ID0gTWF0aFV0aWxzLkNyb3NzKGQgKyByQSwgX2F5KTtcclxuICAgICAgICAgICAgICAgIF9zQnkgPSBNYXRoVXRpbHMuQ3Jvc3MockIsIF9heSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX21hc3MgPSBJbnZNYXNzQSArIEludk1hc3NCICsgSW52SUEgKiBfc0F5ICogX3NBeSArIEludklCICogX3NCeSAqIF9zQnk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9tYXNzID4gMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbWFzcyA9IDEuMGYgLyBfbWFzcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3ByaW5nIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgX3NwcmluZ01hc3MgPSAwLjBmO1xyXG4gICAgICAgICAgICBpZiAoRnJlcXVlbmN5ID4gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2F4ID0gTG9jYWxYQXhpcztcclxuICAgICAgICAgICAgICAgIF9zQXggPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHJBLCBfYXgpO1xyXG4gICAgICAgICAgICAgICAgX3NCeCA9IE1hdGhVdGlscy5Dcm9zcyhyQiwgX2F4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZNYXNzID0gSW52TWFzc0EgKyBJbnZNYXNzQiArIEludklBICogX3NBeCAqIF9zQXggKyBJbnZJQiAqIF9zQnggKiBfc0J4O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnZNYXNzID4gMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3ByaW5nTWFzcyA9IDEuMGYgLyBpbnZNYXNzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBDID0gVmVjdG9yMi5Eb3QoZCwgX2F4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRnJlcXVlbmN5XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgb21lZ2EgPSAyLjBmICogU2V0dGluZ3MuUGkgKiBGcmVxdWVuY3k7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBkYSA9IDIuMGYgKiBfc3ByaW5nTWFzcyAqIERhbXBpbmdSYXRpbyAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTcHJpbmcgc3RpZmZuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgayA9IF9zcHJpbmdNYXNzICogb21lZ2EgKiBvbWVnYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcclxuICAgICAgICAgICAgICAgICAgICBfZ2FtbWEgPSBzdGVwLmR0ICogKGRhICsgc3RlcC5kdCAqIGspO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZ2FtbWEgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2dhbW1hID0gMS4wZiAvIF9nYW1tYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9iaWFzID0gQyAqIHN0ZXAuZHQgKiBrICogX2dhbW1hO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfc3ByaW5nTWFzcyA9IGludk1hc3MgKyBfZ2FtbWE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zcHJpbmdNYXNzID4gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gMS4wZiAvIF9zcHJpbmdNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zcHJpbmdJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUm90YXRpb25hbCBtb3RvclxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gSW52SUEgKyBJbnZJQjtcclxuICAgICAgICAgICAgICAgIGlmIChfbW90b3JNYXNzID4gMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gMS4wZiAvIF9tb3Rvck1hc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciB2YXJpYWJsZSB0aW1lIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBfc3ByaW5nSW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZSAqIF9heSArIF9zcHJpbmdJbXB1bHNlICogX2F4O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTEIgPSBfaW1wdWxzZSAqIF9zQnkgKyBfc3ByaW5nSW1wdWxzZSAqIF9zQnggKyBfbW90b3JJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52SUIgKiBMQjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9zcHJpbmdJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdkEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIGZsb2F0IHdBID0gMC4wZjtcclxuICAgICAgICAgICAgVmVjdG9yMiB2QiA9IGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHdCID0gYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBzcHJpbmcgY29uc3RyYWludFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX2F4LCB2QiAtIHZBKSArIF9zQnggKiB3QiAtIF9zQXggKiB3QTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX3NwcmluZ01hc3MgKiAoQ2RvdCArIF9iaWFzICsgX2dhbW1hICogX3NwcmluZ0ltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgX3NwcmluZ0ltcHVsc2UgKz0gaW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX2F4O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTEEgPSBpbXB1bHNlICogX3NBeDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IExCID0gaW1wdWxzZSAqIF9zQng7XHJcblxyXG4gICAgICAgICAgICAgICAgdkEgLT0gSW52TWFzc0EgKiBQO1xyXG4gICAgICAgICAgICAgICAgd0EgLT0gSW52SUEgKiBMQTtcclxuXHJcbiAgICAgICAgICAgICAgICB2QiArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgICAgICB3QiArPSBJbnZJQiAqIExCO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSByb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IHdCIC0gd0EgLSBfbW90b3JTcGVlZDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX21vdG9yTWFzcyAqIENkb3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgb2xkSW1wdWxzZSA9IF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIF9tYXhNb3RvclRvcnF1ZTtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSBNYXRoVXRpbHMuQ2xhbXAoX21vdG9ySW1wdWxzZSArIGltcHVsc2UsIC1tYXhJbXB1bHNlLCBtYXhJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBfbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB3QSAtPSBJbnZJQSAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB3QiArPSBJbnZJQiAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50IHRvIGxpbmUgY29uc3RyYWludFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX2F5LCB2QiAtIHZBKSArIF9zQnkgKiB3QiAtIF9zQXkgKiB3QTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfbWFzcyAqICgtQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSArPSBpbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfYXk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMQiA9IGltcHVsc2UgKiBfc0J5O1xyXG5cclxuICAgICAgICAgICAgICAgIHZCICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHdCICs9IEludklCICogTEI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2QjtcclxuICAgICAgICAgICAgYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3QjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgeEEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IGFuZ2xlQSA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHhCID0gYkIuU3dlZXAuQztcclxuICAgICAgICAgICAgZmxvYXQgYW5nbGVCID0gYkIuU3dlZXAuQTtcclxuXHJcbiAgICAgICAgICAgIE1hdDIyIFJBID0gbmV3IE1hdDIyKGFuZ2xlQSk7XHJcbiAgICAgICAgICAgIE1hdDIyIFJCID0gbmV3IE1hdDIyKGFuZ2xlQik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHJBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSQSwgTG9jYWxBbmNob3JBIC0gTG9jYWxDZW50ZXJBKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByQiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUkIsIExvY2FsQW5jaG9yQiAtIExvY2FsQ2VudGVyQik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IHhCICsgckIgLSB4QSAtIHJBO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBheSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUkEsIF9sb2NhbFlBeGlzQSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBzQnkgPSBNYXRoVXRpbHMuQ3Jvc3MockIsIGF5KTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IEMgPSBWZWN0b3IyLkRvdChkLCBheSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBrID0gSW52TWFzc0EgKyBJbnZNYXNzQiArIEludklBICogX3NBeSAqIF9zQXkgKyBJbnZJQiAqIF9zQnkgKiBfc0J5O1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgaW1wdWxzZTtcclxuICAgICAgICAgICAgaWYgKGsgIT0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IC1DIC8gaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogYXk7XHJcbiAgICAgICAgICAgIGZsb2F0IExCID0gaW1wdWxzZSAqIHNCeTtcclxuXHJcbiAgICAgICAgICAgIHhCICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgYW5nbGVCICs9IEludklCICogTEI7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPX0VSSU4gcmVtb3ZlIG5lZWQgZm9yIHRoaXMuXHJcbiAgICAgICAgICAgIGJCLlN3ZWVwLkMgPSB4QjtcclxuICAgICAgICAgICAgYkIuU3dlZXAuQSA9IGFuZ2xlQjtcclxuICAgICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkFicyhDKSA8PSBTZXR0aW5ncy5MaW5lYXJTbG9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IEdldE1vdG9yVG9ycXVlKGZsb2F0IGludkR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludkR0ICogX21vdG9ySW1wdWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgbW91c2Ugam9pbnQgaXMgdXNlZCB0byBtYWtlIGEgcG9pbnQgb24gYSBib2R5IHRyYWNrIGFcclxuICAgIC8vLyBzcGVjaWZpZWQgd29ybGQgcG9pbnQuIFRoaXMgYSBzb2Z0IGNvbnN0cmFpbnQgd2l0aCBhIG1heGltdW1cclxuICAgIC8vLyBmb3JjZS4gVGhpcyBhbGxvd3MgdGhlIGNvbnN0cmFpbnQgdG8gc3RyZXRjaCBhbmQgd2l0aG91dFxyXG4gICAgLy8vIGFwcGx5aW5nIGh1Z2UgZm9yY2VzLlxyXG4gICAgLy8vIE5PVEU6IHRoaXMgam9pbnQgaXMgbm90IGRvY3VtZW50ZWQgaW4gdGhlIG1hbnVhbCBiZWNhdXNlIGl0IHdhc1xyXG4gICAgLy8vIGRldmVsb3BlZCB0byBiZSB1c2VkIGluIHRoZSB0ZXN0YmVkLiBJZiB5b3Ugd2FudCB0byBsZWFybiBob3cgdG9cclxuICAgIC8vLyB1c2UgdGhlIG1vdXNlIGpvaW50LCBsb29rIGF0IHRoZSB0ZXN0YmVkLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBGaXhlZE1vdXNlSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX0M7IC8vIHBvc2l0aW9uIGVycm9yXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYmV0YTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9nYW1tYTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBNYXQyMiBfbWFzczsgLy8gZWZmZWN0aXZlIG1hc3MgZm9yIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQuXHJcblxyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfd29ybGRBbmNob3I7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyByZXF1aXJlcyBhIHdvcmxkIHRhcmdldCBwb2ludCxcclxuICAgICAgICAvLy8gdHVuaW5nIHBhcmFtZXRlcnMsIGFuZCB0aGUgdGltZSBzdGVwLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keVwiPlRoZSBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid29ybGRBbmNob3JcIj5UaGUgdGFyZ2V0LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIEZpeGVkTW91c2VKb2ludChCb2R5IGJvZHksIFZlY3RvcjIgd29ybGRBbmNob3IpXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkZpeGVkTW91c2U7XHJcbiAgICAgICAgICAgIEZyZXF1ZW5jeSA9IDUuMGY7XHJcbiAgICAgICAgICAgIERhbXBpbmdSYXRpbyA9IDAuN2Y7XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQod29ybGRBbmNob3IuSXNWYWxpZCgpKTtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgIEJvZHlBLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgIF93b3JsZEFuY2hvciA9IHdvcmxkQW5jaG9yO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBCb2R5QS5HZXRMb2NhbFBvaW50KHdvcmxkQW5jaG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3dvcmxkQW5jaG9yOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5QS5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfd29ybGRBbmNob3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBjb25zdHJhaW50IGZvcmNlIHRoYXQgY2FuIGJlIGV4ZXJ0ZWRcclxuICAgICAgICAvLy8gdG8gbW92ZSB0aGUgY2FuZGlkYXRlIGJvZHkuIFVzdWFsbHkgeW91IHdpbGwgZXhwcmVzc1xyXG4gICAgICAgIC8vLyBhcyBzb21lIG11bHRpcGxlIG9mIHRoZSB3ZWlnaHQgKG11bHRpcGxpZXIgKiBtYXNzICogZ3Jhdml0eSkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4Rm9yY2UgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSByZXNwb25zZSBzcGVlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBGcmVxdWVuY3kgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBkYW1waW5nIHJhdGlvLiAwID0gbm8gZGFtcGluZywgMSA9IGNyaXRpY2FsIGRhbXBpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGFtcGluZ1JhdGlvIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogX2ltcHVsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIDAuMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBtYXNzID0gYi5NYXNzO1xyXG5cclxuICAgICAgICAgICAgLy8gRnJlcXVlbmN5XHJcbiAgICAgICAgICAgIGZsb2F0IG9tZWdhID0gMi4wZiAqIFNldHRpbmdzLlBpICogRnJlcXVlbmN5O1xyXG5cclxuICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICBmbG9hdCBkID0gMi4wZiAqIG1hc3MgKiBEYW1waW5nUmF0aW8gKiBvbWVnYTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcclxuICAgICAgICAgICAgZmxvYXQgayA9IG1hc3MgKiAob21lZ2EgKiBvbWVnYSk7XHJcblxyXG4gICAgICAgICAgICAvLyBtYWdpYyBmb3JtdWxhc1xyXG4gICAgICAgICAgICAvLyBnYW1tYSBoYXMgdW5pdHMgb2YgaW52ZXJzZSBtYXNzLlxyXG4gICAgICAgICAgICAvLyBiZXRhIGhhcyB1bml0cyBvZiBpbnZlcnNlIHRpbWUuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChkICsgc3RlcC5kdCAqIGsgPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuXHJcbiAgICAgICAgICAgIF9nYW1tYSA9IHN0ZXAuZHQgKiAoZCArIHN0ZXAuZHQgKiBrKTtcclxuICAgICAgICAgICAgaWYgKF9nYW1tYSAhPSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfZ2FtbWEgPSAxLjBmIC8gX2dhbW1hO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfYmV0YSA9IHN0ZXAuZHQgKiBrICogX2dhbW1hO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICBiLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBLICAgID0gWygxL20xICsgMS9tMikgKiBleWUoMikgLSBza2V3KHIxKSAqIGludkkxICogc2tldyhyMSkgLSBza2V3KHIyKSAqIGludkkyICogc2tldyhyMildXHJcbiAgICAgICAgICAgIC8vICAgICAgPSBbMS9tMSsxL20yICAgICAwICAgIF0gKyBpbnZJMSAqIFtyMS5ZKnIxLlkgLXIxLlgqcjEuWV0gKyBpbnZJMiAqIFtyMS5ZKnIxLlkgLXIxLlgqcjEuWV1cclxuICAgICAgICAgICAgLy8gICAgICAgIFsgICAgMCAgICAgMS9tMSsxL20yXSAgICAgICAgICAgWy1yMS5YKnIxLlkgcjEuWCpyMS5YXSAgICAgICAgICAgWy1yMS5YKnIxLlkgcjEuWCpyMS5YXVxyXG4gICAgICAgICAgICBmbG9hdCBpbnZNYXNzID0gYi5JbnZNYXNzO1xyXG4gICAgICAgICAgICBmbG9hdCBpbnZJID0gYi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSzEgPSBuZXcgTWF0MjIobmV3IFZlY3RvcjIoaW52TWFzcywgMC4wZiksIG5ldyBWZWN0b3IyKDAuMGYsIGludk1hc3MpKTtcclxuICAgICAgICAgICAgTWF0MjIgSzIgPSBuZXcgTWF0MjIobmV3IFZlY3RvcjIoaW52SSAqIHIuWSAqIHIuWSwgLWludkkgKiByLlggKiByLlkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMigtaW52SSAqIHIuWCAqIHIuWSwgaW52SSAqIHIuWCAqIHIuWCkpO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSztcclxuICAgICAgICAgICAgTWF0MjIuQWRkKHJlZiBLMSwgcmVmIEsyLCBvdXQgSyk7XHJcblxyXG4gICAgICAgICAgICBLLkNvbDEuWCArPSBfZ2FtbWE7XHJcbiAgICAgICAgICAgIEsuQ29sMi5ZICs9IF9nYW1tYTtcclxuXHJcbiAgICAgICAgICAgIF9tYXNzID0gSy5JbnZlcnNlO1xyXG5cclxuICAgICAgICAgICAgX0MgPSBiLlN3ZWVwLkMgKyByIC0gX3dvcmxkQW5jaG9yO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlYXQgd2l0aCBzb21lIGRhbXBpbmdcclxuICAgICAgICAgICAgYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAqPSAwLjk4ZjtcclxuXHJcbiAgICAgICAgICAgIC8vIFdhcm0gc3RhcnRpbmcuXHJcbiAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgYi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGludk1hc3MgKiBfaW1wdWxzZTtcclxuICAgICAgICAgICAgYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBpbnZJICogTWF0aFV0aWxzLkNyb3NzKHIsIF9pbXB1bHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICBiLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgciA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2RvdCA9IHYgKyBjcm9zcyh3LCByKVxyXG4gICAgICAgICAgICBWZWN0b3IyIENkb3QgPSBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKyBNYXRoVXRpbHMuQ3Jvc3MoYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCwgcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgaW1wdWxzZSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgX21hc3MsIC0oQ2RvdCArIF9iZXRhICogX0MgKyBfZ2FtbWEgKiBfaW1wdWxzZSkpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBvbGRJbXB1bHNlID0gX2ltcHVsc2U7XHJcbiAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcbiAgICAgICAgICAgIGZsb2F0IG1heEltcHVsc2UgPSBzdGVwLmR0ICogTWF4Rm9yY2U7XHJcbiAgICAgICAgICAgIGlmIChfaW1wdWxzZS5MZW5ndGhTcXVhcmVkKCkgPiBtYXhJbXB1bHNlICogbWF4SW1wdWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gbWF4SW1wdWxzZSAvIF9pbXB1bHNlLkxlbmd0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGltcHVsc2UgPSBfaW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYi5JbnZNYXNzICogaW1wdWxzZTtcclxuICAgICAgICAgICAgYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MociwgaW1wdWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLyBMaW5lYXIgY29uc3RyYWludCAocG9pbnQtdG8tbGluZSlcclxuICAgIC8vIGQgPSBwMiAtIHAxID0geDIgKyByMiAtIHgxIC0gcjFcclxuICAgIC8vIEMgPSBkb3QocGVycCwgZClcclxuICAgIC8vIENkb3QgPSBkb3QoZCwgY3Jvc3ModzEsIHBlcnApKSArIGRvdChwZXJwLCB2MiArIGNyb3NzKHcyLCByMikgLSB2MSAtIGNyb3NzKHcxLCByMSkpXHJcbiAgICAvLyAgICAgID0gLWRvdChwZXJwLCB2MSkgLSBkb3QoY3Jvc3MoZCArIHIxLCBwZXJwKSwgdzEpICsgZG90KHBlcnAsIHYyKSArIGRvdChjcm9zcyhyMiwgcGVycCksIHYyKVxyXG4gICAgLy8gSiA9IFstcGVycCwgLWNyb3NzKGQgKyByMSwgcGVycCksIHBlcnAsIGNyb3NzKHIyLHBlcnApXVxyXG4gICAgLy9cclxuICAgIC8vIEFuZ3VsYXIgY29uc3RyYWludFxyXG4gICAgLy8gQyA9IGEyIC0gYTEgKyBhX2luaXRpYWxcclxuICAgIC8vIENkb3QgPSB3MiAtIHcxXHJcbiAgICAvLyBKID0gWzAgMCAtMSAwIDAgMV1cclxuICAgIC8vXHJcbiAgICAvLyBLID0gSiAqIGludk0gKiBKVFxyXG4gICAgLy9cclxuICAgIC8vIEogPSBbLWEgLXMxIGEgczJdXHJcbiAgICAvLyAgICAgWzAgIC0xICAwICAxXVxyXG4gICAgLy8gYSA9IHBlcnBcclxuICAgIC8vIHMxID0gY3Jvc3MoZCArIHIxLCBhKSA9IGNyb3NzKHAyIC0geDEsIGEpXHJcbiAgICAvLyBzMiA9IGNyb3NzKHIyLCBhKSA9IGNyb3NzKHAyIC0geDIsIGEpXHJcbiAgICAvLyBNb3Rvci9MaW1pdCBsaW5lYXIgY29uc3RyYWludFxyXG4gICAgLy8gQyA9IGRvdChheDEsIGQpXHJcbiAgICAvLyBDZG90ID0gPSAtZG90KGF4MSwgdjEpIC0gZG90KGNyb3NzKGQgKyByMSwgYXgxKSwgdzEpICsgZG90KGF4MSwgdjIpICsgZG90KGNyb3NzKHIyLCBheDEpLCB2MilcclxuICAgIC8vIEogPSBbLWF4MSAtY3Jvc3MoZCtyMSxheDEpIGF4MSBjcm9zcyhyMixheDEpXVxyXG4gICAgLy8gQmxvY2sgU29sdmVyXHJcbiAgICAvLyBXZSBkZXZlbG9wIGEgYmxvY2sgc29sdmVyIHRoYXQgaW5jbHVkZXMgdGhlIGpvaW50IGxpbWl0LiBUaGlzIG1ha2VzIHRoZSBsaW1pdCBzdGlmZiAoaW5lbGFzdGljKSBldmVuXHJcbiAgICAvLyB3aGVuIHRoZSBtYXNzIGhhcyBwb29yIGRpc3RyaWJ1dGlvbiAobGVhZGluZyB0byBsYXJnZSB0b3JxdWVzIGFib3V0IHRoZSBqb2ludCBhbmNob3IgcG9pbnRzKS5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgSmFjb2JpYW4gaGFzIDMgcm93czpcclxuICAgIC8vIEogPSBbLXVUIC1zMSB1VCBzMl0gLy8gbGluZWFyXHJcbiAgICAvLyAgICAgWzAgICAtMSAgIDAgIDFdIC8vIGFuZ3VsYXJcclxuICAgIC8vICAgICBbLXZUIC1hMSB2VCBhMl0gLy8gbGltaXRcclxuICAgIC8vXHJcbiAgICAvLyB1ID0gcGVycFxyXG4gICAgLy8gdiA9IGF4aXNcclxuICAgIC8vIHMxID0gY3Jvc3MoZCArIHIxLCB1KSwgczIgPSBjcm9zcyhyMiwgdSlcclxuICAgIC8vIGExID0gY3Jvc3MoZCArIHIxLCB2KSwgYTIgPSBjcm9zcyhyMiwgdilcclxuICAgIC8vIE0gKiAodjIgLSB2MSkgPSBKVCAqIGRmXHJcbiAgICAvLyBKICogdjIgPSBiaWFzXHJcbiAgICAvL1xyXG4gICAgLy8gdjIgPSB2MSArIGludk0gKiBKVCAqIGRmXHJcbiAgICAvLyBKICogKHYxICsgaW52TSAqIEpUICogZGYpID0gYmlhc1xyXG4gICAgLy8gSyAqIGRmID0gYmlhcyAtIEogKiB2MSA9IC1DZG90XHJcbiAgICAvLyBLID0gSiAqIGludk0gKiBKVFxyXG4gICAgLy8gQ2RvdCA9IEogKiB2MSAtIGJpYXNcclxuICAgIC8vXHJcbiAgICAvLyBOb3cgc29sdmUgZm9yIGYyLlxyXG4gICAgLy8gZGYgPSBmMiAtIGYxXHJcbiAgICAvLyBLICogKGYyIC0gZjEpID0gLUNkb3RcclxuICAgIC8vIGYyID0gaW52SyAqICgtQ2RvdCkgKyBmMVxyXG4gICAgLy9cclxuICAgIC8vIENsYW1wIGFjY3VtdWxhdGVkIGxpbWl0IGltcHVsc2UuXHJcbiAgICAvLyBsb3dlcjogZjIoMykgPSBtYXgoZjIoMyksIDApXHJcbiAgICAvLyB1cHBlcjogZjIoMykgPSBtaW4oZjIoMyksIDApXHJcbiAgICAvL1xyXG4gICAgLy8gU29sdmUgZm9yIGNvcnJlY3QgZjIoMToyKVxyXG4gICAgLy8gSygxOjIsIDE6MikgKiBmMigxOjIpID0gLUNkb3QoMToyKSAtIEsoMToyLDMpICogZjIoMykgKyBLKDE6MiwxOjMpICogZjFcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICA9IC1DZG90KDE6MikgLSBLKDE6MiwzKSAqIGYyKDMpICsgSygxOjIsMToyKSAqIGYxKDE6MikgKyBLKDE6MiwzKSAqIGYxKDMpXHJcbiAgICAvLyBLKDE6MiwgMToyKSAqIGYyKDE6MikgPSAtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiAoZjIoMykgLSBmMSgzKSkgKyBLKDE6MiwxOjIpICogZjEoMToyKVxyXG4gICAgLy8gZjIoMToyKSA9IGludksoMToyLDE6MikgKiAoLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpKSArIGYxKDE6MilcclxuICAgIC8vXHJcbiAgICAvLyBOb3cgY29tcHV0ZSBpbXB1bHNlIHRvIGJlIGFwcGxpZWQ6XHJcbiAgICAvLyBkZiA9IGYyIC0gZjFcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBwcmlzbWF0aWMgam9pbnQuIFRoaXMgam9pbnQgcHJvdmlkZXMgb25lIGRlZ3JlZSBvZiBmcmVlZG9tOiB0cmFuc2xhdGlvblxyXG4gICAgLy8vIGFsb25nIGFuIGF4aXMgZml4ZWQgaW4gYm9keTEuIFJlbGF0aXZlIHJvdGF0aW9uIGlzIHByZXZlbnRlZC4gWW91IGNhblxyXG4gICAgLy8vIHVzZSBhIGpvaW50IGxpbWl0IHRvIHJlc3RyaWN0IHRoZSByYW5nZSBvZiBtb3Rpb24gYW5kIGEgam9pbnQgbW90b3IgdG9cclxuICAgIC8vLyBkcml2ZSB0aGUgbW90aW9uIG9yIHRvIG1vZGVsIGpvaW50IGZyaWN0aW9uLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBGaXhlZFByaXNtYXRpY0pvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIE1hdDMzIF9LO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ExLCBfYTI7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9heGlzO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfZW5hYmxlTGltaXQ7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVNb3RvcjtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjMgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBMaW1pdFN0YXRlIF9saW1pdFN0YXRlO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfbG9jYWxYQXhpczE7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9sb2NhbFlBeGlzMTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9sb3dlclRyYW5zbGF0aW9uO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21heE1vdG9yRm9yY2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JNYXNzOyAvLyBlZmZlY3RpdmUgbWFzcyBmb3IgbW90b3IvbGltaXQgdHJhbnNsYXRpb25hbCBjb25zdHJhaW50LlxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yU3BlZWQ7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9wZXJwO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3JlZkFuZ2xlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3MxLCBfczI7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdXBwZXJUcmFuc2xhdGlvbjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIHJlcXVpcmVzIGRlZmluaW5nIGEgbGluZSBvZlxyXG4gICAgICAgIC8vLyBtb3Rpb24gdXNpbmcgYW4gYXhpcyBhbmQgYW4gYW5jaG9yIHBvaW50LiBUaGUgZGVmaW5pdGlvbiB1c2VzIGxvY2FsXHJcbiAgICAgICAgLy8vIGFuY2hvciBwb2ludHMgYW5kIGEgbG9jYWwgYXhpcyBzbyB0aGF0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICAvLy8gY2FuIHZpb2xhdGUgdGhlIGNvbnN0cmFpbnQgc2xpZ2h0bHkuIFRoZSBqb2ludCB0cmFuc2xhdGlvbiBpcyB6ZXJvXHJcbiAgICAgICAgLy8vIHdoZW4gdGhlIGxvY2FsIGFuY2hvciBwb2ludHMgY29pbmNpZGUgaW4gd29ybGQgc3BhY2UuIFVzaW5nIGxvY2FsXHJcbiAgICAgICAgLy8vIGFuY2hvcnMgYW5kIGEgbG9jYWwgYXhpcyBoZWxwcyB3aGVuIHNhdmluZyBhbmQgbG9hZGluZyBhIGdhbWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5XCI+VGhlIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZEFuY2hvclwiPlRoZSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJheGlzXCI+VGhlIGF4aXMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgRml4ZWRQcmlzbWF0aWNKb2ludChCb2R5IGJvZHksIFZlY3RvcjIgd29ybGRBbmNob3IsIFZlY3RvcjIgYXhpcylcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuRml4ZWRQcmlzbWF0aWM7XHJcblxyXG4gICAgICAgICAgICBCb2R5QiA9IEJvZHlBO1xyXG5cclxuICAgICAgICAgICAgTG9jYWxBbmNob3JBID0gd29ybGRBbmNob3I7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQiA9IEJvZHlCLkdldExvY2FsUG9pbnQod29ybGRBbmNob3IpO1xyXG5cclxuICAgICAgICAgICAgX2xvY2FsWEF4aXMxID0gYXhpcztcclxuICAgICAgICAgICAgX2xvY2FsWUF4aXMxID0gTWF0aFV0aWxzLkNyb3NzKDEuMGYsIF9sb2NhbFhBeGlzMSk7XHJcbiAgICAgICAgICAgIF9yZWZBbmdsZSA9IEJvZHlCLlJvdGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JCIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gTG9jYWxBbmNob3JBOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBqb2ludCB0cmFuc2xhdGlvbiwgdXN1YWxseSBpbiBtZXRlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEpvaW50VHJhbnNsYXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGQgPSBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQikgLSBMb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXMgPSBfbG9jYWxYQXhpczE7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuRG90KGQsIGF4aXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBqb2ludCB0cmFuc2xhdGlvbiBzcGVlZCwgdXN1YWxseSBpbiBtZXRlcnMgcGVyIHNlY29uZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSm9pbnRTcGVlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjI7XHJcbiAgICAgICAgICAgICAgICBCb2R5Qi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMSA9IExvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBCb2R5Qi5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAxID0gcjE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gQm9keUIuU3dlZXAuQyArIHIyO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gcDIgLSBwMTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpcyA9IF9sb2NhbFhBeGlzMTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHYxID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2MiA9IEJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCB3MSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB3MiA9IEJvZHlCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHNwZWVkID0gVmVjdG9yMi5Eb3QoZCwgTWF0aFV0aWxzLkNyb3NzKHcxLCBheGlzKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyLkRvdChheGlzLCB2MiArIE1hdGhVdGlscy5Dcm9zcyh3MiwgcjIpIC0gdjEgLSBNYXRoVXRpbHMuQ3Jvc3ModzEsIHIxKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSXMgdGhlIGpvaW50IGxpbWl0IGVuYWJsZWQ/XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIFtsaW1pdCBlbmFibGVkXTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBMaW1pdEVuYWJsZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfZW5hYmxlTGltaXQ7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChCb2R5QS5GaXhlZFJvdGF0aW9uID09IGZhbHNlLCBcIldhcm5pbmc6IGxpbWl0cyBkb2VzIGN1cnJlbnRseSBub3Qgd29yayB3aXRoIGZpeGVkIHJvdGF0aW9uXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9lbmFibGVMaW1pdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgbG93ZXIgam9pbnQgbGltaXQsIHVzdWFsbHkgaW4gbWV0ZXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBMb3dlckxpbWl0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2xvd2VyVHJhbnNsYXRpb247IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9sb3dlclRyYW5zbGF0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB1cHBlciBqb2ludCBsaW1pdCwgdXN1YWxseSBpbiBtZXRlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFVwcGVyTGltaXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdXBwZXJUcmFuc2xhdGlvbjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX3VwcGVyVHJhbnNsYXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJcyB0aGUgam9pbnQgbW90b3IgZW5hYmxlZD9cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgW21vdG9yIGVuYWJsZWRdOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIE1vdG9yRW5hYmxlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVNb3RvcjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZU1vdG9yID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSBtb3RvciBzcGVlZCwgdXN1YWxseSBpbiBtZXRlcnMgcGVyIHNlY29uZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHNwZWVkLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1vdG9yU3BlZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JTcGVlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbW90b3JTcGVlZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIG1heGltdW0gbW90b3IgZm9yY2UsIHVzdWFsbHkgaW4gTi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGZvcmNlLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heE1vdG9yRm9yY2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbWF4TW90b3JGb3JjZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBtb3RvciBmb3JjZSwgdXN1YWxseSBpbiBOLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNb3RvckZvcmNlIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxYQXhpczFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbG9jYWxYQXhpczE7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9sb2NhbFhBeGlzMSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgX2xvY2FsWUF4aXMxID0gTWF0aFV0aWxzLkNyb3NzKDEuMGYsIF9sb2NhbFhBeGlzMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIChfaW1wdWxzZS5YICogX3BlcnAgKyAoTW90b3JGb3JjZSArIF9pbXB1bHNlLlopICogX2F4aXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBfaW1wdWxzZS5ZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIExvY2FsQ2VudGVyQSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgTG9jYWxDZW50ZXJCID0gYkIuTG9jYWxDZW50ZXI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYyO1xyXG4gICAgICAgICAgICBiQi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzc2VzLlxyXG4gICAgICAgICAgICBWZWN0b3IyIHIxID0gTG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjIuUiwgTG9jYWxBbmNob3JCIC0gTG9jYWxDZW50ZXJCKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gYkIuU3dlZXAuQyArIHIyIC0gLyogYjEuX3N3ZWVwLkNlbnRlciAtICovIHIxO1xyXG5cclxuICAgICAgICAgICAgSW52TWFzc0EgPSAwLjBmO1xyXG4gICAgICAgICAgICBJbnZJQSA9IDAuMGY7XHJcbiAgICAgICAgICAgIEludk1hc3NCID0gYkIuSW52TWFzcztcclxuICAgICAgICAgICAgSW52SUIgPSBiQi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtb3RvciBKYWNvYmlhbiBhbmQgZWZmZWN0aXZlIG1hc3MuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9heGlzID0gX2xvY2FsWEF4aXMxO1xyXG4gICAgICAgICAgICAgICAgX2ExID0gTWF0aFV0aWxzLkNyb3NzKGQgKyByMSwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgX2EyID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfYXhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX21vdG9yTWFzcyA9IEludk1hc3NBICsgSW52TWFzc0IgKyBJbnZJQSAqIF9hMSAqIF9hMSArIEludklCICogX2EyICogX2EyO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbW90b3JNYXNzID4gU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gMS4wZiAvIF9tb3Rvck1hc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByaXNtYXRpYyBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfcGVycCA9IF9sb2NhbFlBeGlzMTtcclxuXHJcbiAgICAgICAgICAgICAgICBfczEgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHIxLCBfcGVycCk7XHJcbiAgICAgICAgICAgICAgICBfczIgPSBNYXRoVXRpbHMuQ3Jvc3MocjIsIF9wZXJwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtMSA9IEludk1hc3NBLCBtMiA9IEludk1hc3NCO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaTEgPSBJbnZJQSwgaTIgPSBJbnZJQjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTEgPSBtMSArIG0yICsgaTEgKiBfczEgKiBfczEgKyBpMiAqIF9zMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMiA9IGkxICogX3MxICsgaTIgKiBfczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTMgPSBpMSAqIF9zMSAqIF9hMSArIGkyICogX3MyICogX2EyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazIyID0gaTEgKyBpMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsyMyA9IGkxICogX2ExICsgaTIgKiBfYTI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMzMgPSBtMSArIG0yICsgaTEgKiBfYTEgKiBfYTEgKyBpMiAqIF9hMiAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgICAgICBfSy5Db2wxID0gbmV3IFZlY3RvcjMoazExLCBrMTIsIGsxMyk7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wyID0gbmV3IFZlY3RvcjMoazEyLCBrMjIsIGsyMyk7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wzID0gbmV3IFZlY3RvcjMoazEzLCBrMjMsIGszMyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbW90b3IgYW5kIGxpbWl0IHRlcm1zLlxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBqb2ludFRyYW5zbGF0aW9uID0gVmVjdG9yMi5Eb3QoX2F4aXMsIGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKF91cHBlclRyYW5zbGF0aW9uIC0gX2xvd2VyVHJhbnNsYXRpb24pIDwgMi4wZiAqIFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkVxdWFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2xhdGlvbiA8PSBfbG93ZXJUcmFuc2xhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5BdExvd2VyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkF0TG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpvaW50VHJhbnNsYXRpb24gPj0gX3VwcGVyVHJhbnNsYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5BdFVwcGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBNb3RvckZvcmNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgTW90b3JGb3JjZSAqPSBzdGVwLmR0UmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gX2ltcHVsc2UuWCAqIF9wZXJwICsgKE1vdG9yRm9yY2UgKyBfaW1wdWxzZS5aKSAqIF9heGlzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDIgPSBfaW1wdWxzZS5YICogX3MyICsgX2ltcHVsc2UuWSArIChNb3RvckZvcmNlICsgX2ltcHVsc2UuWikgKiBfYTI7XHJcblxyXG4gICAgICAgICAgICAgICAgYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBJbnZJQiAqIEwyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSBWZWN0b3IzLlplcm87XHJcbiAgICAgICAgICAgICAgICBNb3RvckZvcmNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBmbG9hdCB3MSA9IDAuMGY7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3MiA9IGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgbGluZWFyIG1vdG9yIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTW90b3IgJiYgX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5FcXVhbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IFZlY3RvcjIuRG90KF9heGlzLCB2MiAtIHYxKSArIF9hMiAqIHcyIC0gX2ExICogdzE7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gX21vdG9yTWFzcyAqIChfbW90b3JTcGVlZCAtIENkb3QpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgb2xkSW1wdWxzZSA9IE1vdG9yRm9yY2U7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIF9tYXhNb3RvckZvcmNlO1xyXG4gICAgICAgICAgICAgICAgTW90b3JGb3JjZSA9IE1hdGhVdGlscy5DbGFtcChNb3RvckZvcmNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IE1vdG9yRm9yY2UgLSBvbGRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfYXhpcztcclxuICAgICAgICAgICAgICAgIGZsb2F0IEwxID0gaW1wdWxzZSAqIF9hMTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IEwyID0gaW1wdWxzZSAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgICAgICB2MSAtPSBJbnZNYXNzQSAqIFA7XHJcbiAgICAgICAgICAgICAgICB3MSAtPSBJbnZJQSAqIEwxO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHcyICs9IEludklCICogTDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgQ2RvdDEgPSBuZXcgVmVjdG9yMihWZWN0b3IyLkRvdChfcGVycCwgdjIgLSB2MSkgKyBfczIgKiB3MiAtIF9zMSAqIHcxLCB3MiAtIHcxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTGltaXQgJiYgX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5JbmFjdGl2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU29sdmUgcHJpc21hdGljIGFuZCBsaW1pdCBjb25zdHJhaW50IGluIGJsb2NrIGZvcm0uXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90MiA9IFZlY3RvcjIuRG90KF9heGlzLCB2MiAtIHYxKSArIF9hMiAqIHcyIC0gX2ExICogdzE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzIENkb3QgPSBuZXcgVmVjdG9yMyhDZG90MS5YLCBDZG90MS5ZLCBDZG90Mik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMyBmMSA9IF9pbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMyBkZiA9IF9LLlNvbHZlMzMoLUNkb3QpO1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKz0gZGY7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuQXRMb3dlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gTWF0aC5NYXgoX2ltcHVsc2UuWiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IE1hdGguTWluKF9pbXB1bHNlLlosIDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGYyKDE6MikgPSBpbnZLKDE6MiwxOjIpICogKC1DZG90KDE6MikgLSBLKDE6MiwzKSAqIChmMigzKSAtIGYxKDMpKSkgKyBmMSgxOjIpXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGIgPSAtQ2RvdDEgLSAoX2ltcHVsc2UuWiAtIGYxLlopICogbmV3IFZlY3RvcjIoX0suQ29sMy5YLCBfSy5Db2wzLlkpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBmMnIgPSBfSy5Tb2x2ZTIyKGIpICsgbmV3IFZlY3RvcjIoZjEuWCwgZjEuWSk7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZS5YID0gZjJyLlg7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZS5ZID0gZjJyLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGYgPSBfaW1wdWxzZSAtIGYxO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IGRmLlggKiBfcGVycCArIGRmLlogKiBfYXhpcztcclxuICAgICAgICAgICAgICAgIGZsb2F0IEwyID0gZGYuWCAqIF9zMiArIGRmLlkgKyBkZi5aICogX2EyO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHcyICs9IEludklCICogTDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBMaW1pdCBpcyBpbmFjdGl2ZSwganVzdCBzb2x2ZSB0aGUgcHJpc21hdGljIGNvbnN0cmFpbnQgaW4gYmxvY2sgZm9ybS5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZGYgPSBfSy5Tb2x2ZTIyKC1DZG90MSk7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZS5YICs9IGRmLlg7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZS5ZICs9IGRmLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gZGYuWCAqIF9wZXJwO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDIgPSBkZi5YICogX3MyICsgZGYuWTtcclxuXHJcbiAgICAgICAgICAgICAgICB2MiArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgICAgICB3MiArPSBJbnZJQiAqIEwyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsID0gdjI7XHJcbiAgICAgICAgICAgIGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gdzI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL0JvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBjMSA9IFZlY3RvcjIuWmVybzsgLy8gYjEuX3N3ZWVwLkNlbnRlcjtcclxuICAgICAgICAgICAgZmxvYXQgYTEgPSAwLjBmOyAvLyBiMS5fc3dlZXAuQW5nbGU7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGMyID0gYjIuU3dlZXAuQztcclxuICAgICAgICAgICAgZmxvYXQgYTIgPSBiMi5Td2VlcC5BO1xyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgbGluZWFyIGxpbWl0IGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIGZsb2F0IGxpbmVhckVycm9yID0gMC4wZjtcclxuICAgICAgICAgICAgYm9vbCBhY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZmxvYXQgQzIgPSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgUjEgPSBuZXcgTWF0MjIoYTEpO1xyXG4gICAgICAgICAgICBNYXQyMiBSMiA9IG5ldyBNYXQyMihhMik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSMSwgTG9jYWxBbmNob3JBIC0gTG9jYWxDZW50ZXJBKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUjIsIExvY2FsQW5jaG9yQiAtIExvY2FsQ2VudGVyQik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGMyICsgcjIgLSBjMSAtIHIxO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVMaW1pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2F4aXMgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFIxLCBfbG9jYWxYQXhpczEpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9hMSA9IE1hdGhVdGlscy5Dcm9zcyhkICsgcjEsIF9heGlzKTtcclxuICAgICAgICAgICAgICAgIF9hMiA9IE1hdGhVdGlscy5Dcm9zcyhyMiwgX2F4aXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHRyYW5zbGF0aW9uID0gVmVjdG9yMi5Eb3QoX2F4aXMsIGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKF91cHBlclRyYW5zbGF0aW9uIC0gX2xvd2VyVHJhbnNsYXRpb24pIDwgMi4wZiAqIFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBhbmd1bGFyIGNvcnJlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgQzIgPSBNYXRoVXRpbHMuQ2xhbXAodHJhbnNsYXRpb24sIC1TZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uLCBTZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lYXJFcnJvciA9IChmbG9hdClNYXRoLkFicyh0cmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zbGF0aW9uIDw9IF9sb3dlclRyYW5zbGF0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgbGluZWFyIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzb21lIHNsb3AuXHJcbiAgICAgICAgICAgICAgICAgICAgQzIgPSBNYXRoVXRpbHMuQ2xhbXAodHJhbnNsYXRpb24gLSBfbG93ZXJUcmFuc2xhdGlvbiArIFNldHRpbmdzLkxpbmVhclNsb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLVNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24sIDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gX2xvd2VyVHJhbnNsYXRpb24gLSB0cmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPj0gX3VwcGVyVHJhbnNsYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBsaW5lYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cclxuICAgICAgICAgICAgICAgICAgICBDMiA9IE1hdGhVdGlscy5DbGFtcCh0cmFuc2xhdGlvbiAtIF91cHBlclRyYW5zbGF0aW9uIC0gU2V0dGluZ3MuTGluZWFyU2xvcCwgMC4wZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lYXJFcnJvciA9IHRyYW5zbGF0aW9uIC0gX3VwcGVyVHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3BlcnAgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFIxLCBfbG9jYWxZQXhpczEpO1xyXG5cclxuICAgICAgICAgICAgX3MxID0gTWF0aFV0aWxzLkNyb3NzKGQgKyByMSwgX3BlcnApO1xyXG4gICAgICAgICAgICBfczIgPSBNYXRoVXRpbHMuQ3Jvc3MocjIsIF9wZXJwKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjMgaW1wdWxzZTtcclxuICAgICAgICAgICAgVmVjdG9yMiBDMSA9IG5ldyBWZWN0b3IyKFZlY3RvcjIuRG90KF9wZXJwLCBkKSwgYTIgLSBhMSAtIF9yZWZBbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IE1hdGguTWF4KGxpbmVhckVycm9yLCAoZmxvYXQpTWF0aC5BYnMoQzEuWCkpO1xyXG4gICAgICAgICAgICBmbG9hdCBhbmd1bGFyRXJyb3IgPSAoZmxvYXQpTWF0aC5BYnMoQzEuWSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYWN0aXZlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtMSA9IEludk1hc3NBLCBtMiA9IEludk1hc3NCO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaTEgPSBJbnZJQSwgaTIgPSBJbnZJQjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTEgPSBtMSArIG0yICsgaTEgKiBfczEgKiBfczEgKyBpMiAqIF9zMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMiA9IGkxICogX3MxICsgaTIgKiBfczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTMgPSBpMSAqIF9zMSAqIF9hMSArIGkyICogX3MyICogX2EyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazIyID0gaTEgKyBpMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsyMyA9IGkxICogX2ExICsgaTIgKiBfYTI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMzMgPSBtMSArIG0yICsgaTEgKiBfYTEgKiBfYTEgKyBpMiAqIF9hMiAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgICAgICBfSy5Db2wxID0gbmV3IFZlY3RvcjMoazExLCBrMTIsIGsxMyk7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wyID0gbmV3IFZlY3RvcjMoazEyLCBrMjIsIGsyMyk7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wzID0gbmV3IFZlY3RvcjMoazEzLCBrMjMsIGszMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMyBDID0gbmV3IFZlY3RvcjMoLUMxLlgsIC1DMS5ZLCAtQzIpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9LLlNvbHZlMzMoQyk7IC8vIG5lZ2F0ZWQgYWJvdmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG0xID0gSW52TWFzc0EsIG0yID0gSW52TWFzc0I7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpMSA9IEludklBLCBpMiA9IEludklCO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMSA9IG0xICsgbTIgKyBpMSAqIF9zMSAqIF9zMSArIGkyICogX3MyICogX3MyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazEyID0gaTEgKiBfczEgKyBpMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsyMiA9IGkxICsgaTI7XHJcblxyXG4gICAgICAgICAgICAgICAgX0suQ29sMSA9IG5ldyBWZWN0b3IzKGsxMSwgazEyLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIF9LLkNvbDIgPSBuZXcgVmVjdG9yMyhrMTIsIGsyMiwgMC4wZik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlMSA9IF9LLlNvbHZlMjIoLUMxKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UuWCA9IGltcHVsc2UxLlg7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlLlkgPSBpbXB1bHNlMS5ZO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZS5YICogX3BlcnAgKyBpbXB1bHNlLlogKiBfYXhpcztcclxuICAgICAgICAgICAgZmxvYXQgTDIgPSBpbXB1bHNlLlggKiBfczIgKyBpbXB1bHNlLlkgKyBpbXB1bHNlLlogKiBfYTI7XHJcblxyXG4gICAgICAgICAgICBjMiArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgIGEyICs9IEludklCICogTDI7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPX0VSSU4gcmVtb3ZlIG5lZWQgZm9yIHRoaXMuXHJcbiAgICAgICAgICAgIGIyLlN3ZWVwLkMgPSBjMjtcclxuICAgICAgICAgICAgYjIuU3dlZXAuQSA9IGEyO1xyXG4gICAgICAgICAgICBiMi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVhckVycm9yIDw9IFNldHRpbmdzLkxpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IFNldHRpbmdzLkFuZ3VsYXJTbG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIHJldm9sdXRlIGpvaW50IHJhaW5zIHRvIGJvZGllcyB0byBzaGFyZSBhIGNvbW1vbiBwb2ludCB3aGlsZSB0aGV5XHJcbiAgICAvLy8gYXJlIGZyZWUgdG8gcm90YXRlIGFib3V0IHRoZSBwb2ludC4gVGhlIHJlbGF0aXZlIHJvdGF0aW9uIGFib3V0IHRoZSBzaGFyZWRcclxuICAgIC8vLyBwb2ludCBpcyB0aGUgam9pbnQgYW5nbGUuIFlvdSBjYW4gbGltaXQgdGhlIHJlbGF0aXZlIHJvdGF0aW9uIHdpdGhcclxuICAgIC8vLyBhIGpvaW50IGxpbWl0IHRoYXQgc3BlY2lmaWVzIGEgbG93ZXIgYW5kIHVwcGVyIGFuZ2xlLiBZb3UgY2FuIHVzZSBhIG1vdG9yXHJcbiAgICAvLy8gdG8gZHJpdmUgdGhlIHJlbGF0aXZlIHJvdGF0aW9uIGFib3V0IHRoZSBzaGFyZWQgcG9pbnQuIEEgbWF4aW11bSBtb3RvciB0b3JxdWVcclxuICAgIC8vLyBpcyBwcm92aWRlZCBzbyB0aGF0IGluZmluaXRlIGZvcmNlcyBhcmUgbm90IGdlbmVyYXRlZC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRml4ZWRSZXZvbHV0ZUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX2VuYWJsZUxpbWl0O1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfZW5hYmxlTW90b3I7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IzIF9pbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgTGltaXRTdGF0ZSBfbGltaXRTdGF0ZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9sb3dlckFuZ2xlO1xyXG4gICAgICAgIHByaXZhdGUgTWF0MzMgX21hc3M7IC8vIGVmZmVjdGl2ZSBtYXNzIGZvciBwb2ludC10by1wb2ludCBjb25zdHJhaW50LlxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21heE1vdG9yVG9ycXVlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9ySW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3Rvck1hc3M7IC8vIGVmZmVjdGl2ZSBtYXNzIGZvciBtb3Rvci9saW1pdCBhbmd1bGFyIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JTcGVlZDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF91cHBlckFuZ2xlO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfd29ybGRBbmNob3I7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZSB0aGUgYm9kaWVzLCBhbmNob3JzLCBhbmQgcmVmZXJlbmNlIGFuZ2xlIHVzaW5nIHRoZSB3b3JsZFxyXG4gICAgICAgIC8vLyBhbmNob3IuXHJcbiAgICAgICAgLy8vIFRoaXMgcmVxdWlyZXMgZGVmaW5pbmcgYW5cclxuICAgICAgICAvLy8gYW5jaG9yIHBvaW50IHdoZXJlIHRoZSBib2RpZXMgYXJlIGpvaW5lZC4gVGhlIGRlZmluaXRpb25cclxuICAgICAgICAvLy8gdXNlcyBsb2NhbCBhbmNob3IgcG9pbnRzIHNvIHRoYXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvblxyXG4gICAgICAgIC8vLyBjYW4gdmlvbGF0ZSB0aGUgY29uc3RyYWludCBzbGlnaHRseS4gWW91IGFsc28gbmVlZCB0b1xyXG4gICAgICAgIC8vLyBzcGVjaWZ5IHRoZSBpbml0aWFsIHJlbGF0aXZlIGFuZ2xlIGZvciBqb2ludCBsaW1pdHMuIFRoaXNcclxuICAgICAgICAvLy8gaGVscHMgd2hlbiBzYXZpbmcgYW5kIGxvYWRpbmcgYSBnYW1lLlxyXG4gICAgICAgIC8vLyBUaGUgbG9jYWwgYW5jaG9yIHBvaW50cyBhcmUgbWVhc3VyZWQgZnJvbSB0aGUgYm9keSdzIG9yaWdpblxyXG4gICAgICAgIC8vLyByYXRoZXIgdGhhbiB0aGUgY2VudGVyIG9mIG1hc3MgYmVjYXVzZTpcclxuICAgICAgICAvLy8gMS4geW91IG1pZ2h0IG5vdCBrbm93IHdoZXJlIHRoZSBjZW50ZXIgb2YgbWFzcyB3aWxsIGJlLlxyXG4gICAgICAgIC8vLyAyLiBpZiB5b3UgYWRkL3JlbW92ZSBzaGFwZXMgZnJvbSBhIGJvZHkgYW5kIHJlY29tcHV0ZSB0aGUgbWFzcyxcclxuICAgICAgICAvLy8gdGhlIGpvaW50cyB3aWxsIGJlIGJyb2tlbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlcIj5UaGUgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBbmNob3JcIj5UaGUgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZEFuY2hvclwiPlRoZSB3b3JsZCBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgRml4ZWRSZXZvbHV0ZUpvaW50KEJvZHkgYm9keSwgVmVjdG9yMiBib2R5QW5jaG9yLCBWZWN0b3IyIHdvcmxkQW5jaG9yKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5GaXhlZFJldm9sdXRlO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hhbmdlZCB0byBsb2NhbCBjb29yZGluYXRlcy5cclxuICAgICAgICAgICAgTG9jYWxBbmNob3JBID0gYm9keUFuY2hvcjtcclxuICAgICAgICAgICAgX3dvcmxkQW5jaG9yID0gd29ybGRBbmNob3I7XHJcblxyXG4gICAgICAgICAgICBSZWZlcmVuY2VBbmdsZSA9IC1Cb2R5QS5Sb3RhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIF9pbXB1bHNlID0gVmVjdG9yMy5aZXJvO1xyXG5cclxuICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfd29ybGRBbmNob3I7IH1cclxuICAgICAgICAgICAgc2V0IHsgX3dvcmxkQW5jaG9yID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSZWZlcmVuY2VBbmdsZSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IGpvaW50IGFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEpvaW50QW5nbGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5Td2VlcC5BIC0gUmVmZXJlbmNlQW5nbGU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IGpvaW50IGFuZ2xlIHNwZWVkIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSm9pbnRTcGVlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElzIHRoZSBqb2ludCBsaW1pdCBlbmFibGVkP1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiBbbGltaXQgZW5hYmxlZF07IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgTGltaXRFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2VuYWJsZUxpbWl0OyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfZW5hYmxlTGltaXQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGxvd2VyIGpvaW50IGxpbWl0IGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExvd2VyTGltaXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbG93ZXJBbmdsZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2xvd2VyQW5nbGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHVwcGVyIGpvaW50IGxpbWl0IGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFVwcGVyTGltaXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdXBwZXJBbmdsZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX3VwcGVyQW5nbGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJcyB0aGUgam9pbnQgbW90b3IgZW5hYmxlZD9cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgW21vdG9yIGVuYWJsZWRdOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIE1vdG9yRW5hYmxlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVNb3RvcjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZU1vdG9yID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSBtb3RvciBzcGVlZCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBzcGVlZC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNb3RvclNwZWVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX21vdG9yU3BlZWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21vdG9yU3BlZWQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSwgdXN1YWxseSBpbiBOLW0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSB0b3JxdWUuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TW90b3JUb3JxdWVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbWF4TW90b3JUb3JxdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21heE1vdG9yVG9ycXVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBtb3RvciB0b3JxdWUsIHVzdWFsbHkgaW4gTi1tLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNb3RvclRvcnF1ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tb3RvckltcHVsc2U7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogbmV3IFZlY3RvcjIoX2ltcHVsc2UuWCwgX2ltcHVsc2UuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIF9pbXB1bHNlLlo7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVNb3RvciB8fCBfZW5hYmxlTGltaXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFlvdSBjYW5ub3QgY3JlYXRlIGEgcm90YXRpb24gbGltaXQgYmV0d2VlbiBib2RpZXMgdGhhdFxyXG4gICAgICAgICAgICAgICAgLy8gYm90aCBoYXZlIGZpeGVkIHJvdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGIxLkludkkgPiAwLjBmIC8qIHx8IGIyLl9pbnZJID4gMC4wZiovKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gX3dvcmxkQW5jaG9yOyAvLyBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tld11cclxuICAgICAgICAgICAgLy8gICAgIFsgMCAgICAgICAtMSAwICAgICAgIDFdXHJcbiAgICAgICAgICAgIC8vIHJfc2tldyA9IFstcnk7IHJ4XVxyXG5cclxuICAgICAgICAgICAgLy8gTWF0bGFiXHJcbiAgICAgICAgICAgIC8vIEsgPSBbIG0xK3IxeV4yKmkxK20yK3IyeV4yKmkyLCAgLXIxeSppMSpyMXgtcjJ5KmkyKnIyeCwgICAgICAgICAgLXIxeSppMS1yMnkqaTJdXHJcbiAgICAgICAgICAgIC8vICAgICBbICAtcjF5KmkxKnIxeC1yMnkqaTIqcjJ4LCBtMStyMXheMippMSttMityMnheMippMiwgICAgICAgICAgIHIxeCppMStyMngqaTJdXHJcbiAgICAgICAgICAgIC8vICAgICBbICAgICAgICAgIC1yMXkqaTEtcjJ5KmkyLCAgICAgICAgICAgcjF4KmkxK3IyeCppMiwgICAgICAgICAgICAgICAgICAgaTEraTJdXHJcblxyXG4gICAgICAgICAgICBmbG9hdCBtMSA9IGIxLkludk1hc3M7XHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IG0yID0gMDtcclxuICAgICAgICAgICAgZmxvYXQgaTEgPSBiMS5JbnZJO1xyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCBpMiA9IDA7XHJcblxyXG4gICAgICAgICAgICBfbWFzcy5Db2wxLlggPSBtMSArIG0yICsgcjEuWSAqIHIxLlkgKiBpMSArIHIyLlkgKiByMi5ZICogaTI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDIuWCA9IC1yMS5ZICogcjEuWCAqIGkxIC0gcjIuWSAqIHIyLlggKiBpMjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMy5YID0gLXIxLlkgKiBpMSAtIHIyLlkgKiBpMjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMS5ZID0gX21hc3MuQ29sMi5YO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlkgPSBtMSArIG0yICsgcjEuWCAqIHIxLlggKiBpMSArIHIyLlggKiByMi5YICogaTI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWSA9IHIxLlggKiBpMSArIHIyLlggKiBpMjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMS5aID0gX21hc3MuQ29sMy5YO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlogPSBfbWFzcy5Db2wzLlk7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWiA9IGkxICsgaTI7XHJcblxyXG4gICAgICAgICAgICBfbW90b3JNYXNzID0gaTEgKyBpMjtcclxuICAgICAgICAgICAgaWYgKF9tb3Rvck1hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gMS4wZiAvIF9tb3Rvck1hc3M7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTW90b3IgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBqb2ludEFuZ2xlID0gMCAtIGIxLlN3ZWVwLkEgLSBSZWZlcmVuY2VBbmdsZTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLkFicyhfdXBwZXJBbmdsZSAtIF9sb3dlckFuZ2xlKSA8IDIuMGYgKiBTZXR0aW5ncy5Bbmd1bGFyU2xvcClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuRXF1YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqb2ludEFuZ2xlIDw9IF9sb3dlckFuZ2xlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkF0TG93ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkF0TG93ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqb2ludEFuZ2xlID49IF91cHBlckFuZ2xlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkF0VXBwZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSBpbXB1bHNlcyB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gbmV3IFZlY3RvcjIoX2ltcHVsc2UuWCwgX2ltcHVsc2UuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBtMSAqIFA7XHJcbiAgICAgICAgICAgICAgICBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtPSBpMSAqIChNYXRoVXRpbHMuQ3Jvc3MocjEsIFApICsgX21vdG9ySW1wdWxzZSArIF9pbXB1bHNlLlopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSBWZWN0b3IzLlplcm87XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgdzEgPSBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgY29uc3QgZmxvYXQgdzIgPSAwO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbTEgPSBiMS5JbnZNYXNzO1xyXG4gICAgICAgICAgICBmbG9hdCBpMSA9IGIxLkludkk7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBtb3RvciBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yICYmIF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuRXF1YWwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSB3MiAtIHcxIC0gX21vdG9yU3BlZWQ7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gX21vdG9yTWFzcyAqICgtQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gX21vdG9ySW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1heEltcHVsc2UgPSBzdGVwLmR0ICogX21heE1vdG9yVG9ycXVlO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IE1hdGhVdGlscy5DbGFtcChfbW90b3JJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHcxIC09IGkxICogaW1wdWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgbGltaXQgY29uc3RyYWludC5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVMaW1pdCAmJiBfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkluYWN0aXZlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIyID0gX3dvcmxkQW5jaG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgQ2RvdDEgPSB2MiArIE1hdGhVdGlscy5Dcm9zcyh3MiwgcjIpIC0gdjEgLSBNYXRoVXRpbHMuQ3Jvc3ModzEsIHIxKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QyID0gdzIgLSB3MTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjMgQ2RvdCA9IG5ldyBWZWN0b3IzKENkb3QxLlgsIENkb3QxLlksIENkb3QyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzIGltcHVsc2UgPSBfbWFzcy5Tb2x2ZTMzKC1DZG90KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5FcXVhbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZSArPSBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdExvd2VyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ld0ltcHVsc2UgPSBfaW1wdWxzZS5aICsgaW1wdWxzZS5aO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbXB1bHNlIDwgMC4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcmVkdWNlZCA9IF9tYXNzLlNvbHZlMjIoLUNkb3QxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS5YID0gcmVkdWNlZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLlkgPSByZWR1Y2VkLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2UuWiA9IC1faW1wdWxzZS5aO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5YICs9IHJlZHVjZWQuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWSArPSByZWR1Y2VkLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXdJbXB1bHNlID0gX2ltcHVsc2UuWiArIGltcHVsc2UuWjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW1wdWxzZSA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHJlZHVjZWQgPSBfbWFzcy5Tb2x2ZTIyKC1DZG90MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2UuWCA9IHJlZHVjZWQuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS5ZID0gcmVkdWNlZC5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLlogPSAtX2ltcHVsc2UuWjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWCArPSByZWR1Y2VkLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlkgKz0gcmVkdWNlZC5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gbmV3IFZlY3RvcjIoaW1wdWxzZS5YLCBpbXB1bHNlLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHYxIC09IG0xICogUDtcclxuICAgICAgICAgICAgICAgIHcxIC09IGkxICogKE1hdGhVdGlscy5Dcm9zcyhyMSwgUCkgKyBpbXB1bHNlLlopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMiA9IF93b3JsZEFuY2hvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTb2x2ZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIENkb3QgPSB2MiArIE1hdGhVdGlscy5Dcm9zcyh3MiwgcjIpIC0gdjEgLSBNYXRoVXRpbHMuQ3Jvc3ModzEsIHIxKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaW1wdWxzZSA9IF9tYXNzLlNvbHZlMjIoLUNkb3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggKz0gaW1wdWxzZS5YO1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UuWSArPSBpbXB1bHNlLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEgLT0gbTEgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgdzEgLT0gaTEgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsID0gdjE7XHJcbiAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gdzE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBUT0RPX0VSSU4gYmxvY2sgc29sdmUgd2l0aCBsaW1pdC4gQ09NRSBPTiBFUklOXHJcblxyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBhbmd1bGFyRXJyb3IgPSAwLjBmO1xyXG4gICAgICAgICAgICBmbG9hdCBwb3NpdGlvbkVycm9yO1xyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgYW5ndWxhciBsaW1pdCBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0ICYmIF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuSW5hY3RpdmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGFuZ2xlID0gMCAtIGIxLlN3ZWVwLkEgLSBSZWZlcmVuY2VBbmdsZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGxpbWl0SW1wdWxzZSA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuRXF1YWwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBhbmd1bGFyIGNvcnJlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgQyA9IE1hdGhVdGlscy5DbGFtcChhbmdsZSAtIF9sb3dlckFuZ2xlLCAtU2V0dGluZ3MuTWF4QW5ndWxhckNvcnJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXR0aW5ncy5NYXhBbmd1bGFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLV9tb3Rvck1hc3MgKiBDO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IChmbG9hdClNYXRoLkFicyhDKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuQXRMb3dlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBDID0gYW5nbGUgLSBfbG93ZXJBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSAtQztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBhbmd1bGFyIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzb21lIHNsb3AuXHJcbiAgICAgICAgICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDICsgU2V0dGluZ3MuQW5ndWxhclNsb3AsIC1TZXR0aW5ncy5NYXhBbmd1bGFyQ29ycmVjdGlvbiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLV9tb3Rvck1hc3MgKiBDO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBhbmdsZSAtIF91cHBlckFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IEM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxyXG4gICAgICAgICAgICAgICAgICAgIEMgPSBNYXRoVXRpbHMuQ2xhbXAoQyAtIFNldHRpbmdzLkFuZ3VsYXJTbG9wLCAwLjBmLCBTZXR0aW5ncy5NYXhBbmd1bGFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLV9tb3Rvck1hc3MgKiBDO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkEgLT0gYjEuSW52SSAqIGxpbWl0SW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIyID0gX3dvcmxkQW5jaG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgQyA9IFZlY3RvcjIuWmVybyArIHIyIC0gYjEuU3dlZXAuQyAtIHIxO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25FcnJvciA9IEMuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52TWFzczEgPSBiMS5JbnZNYXNzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQgaW52TWFzczIgPSAwO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52STEgPSBiMS5JbnZJO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQgaW52STIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBsYXJnZSBkZXRhY2htZW50LlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmxvYXQga19hbGxvd2VkU3RyZXRjaCA9IDEwLjBmICogU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICAgICAgICAgIGlmIChDLkxlbmd0aFNxdWFyZWQoKSA+IGtfYWxsb3dlZFN0cmV0Y2ggKiBrX2FsbG93ZWRTdHJldGNoKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIHBhcnRpY2xlIHNvbHV0aW9uIChubyByb3RhdGlvbikuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB1ID0gQztcclxuICAgICAgICAgICAgICAgICAgICB1Lk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGsgPSBpbnZNYXNzMSArIGludk1hc3MyO1xyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChrID4gU2V0dGluZ3MuRXBzaWxvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbSA9IDEuMGYgLyBrO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgaW1wdWxzZTIgPSBtICogKC1DKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBrX2JldGEgPSAwLjVmO1xyXG4gICAgICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkMgLT0ga19iZXRhICogaW52TWFzczEgKiBpbXB1bHNlMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgQyA9IFZlY3RvcjIuWmVybyArIHIyIC0gYjEuU3dlZXAuQyAtIHIxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIE1hdDIyIEsxID0gbmV3IE1hdDIyKG5ldyBWZWN0b3IyKGludk1hc3MxICsgaW52TWFzczIsIDAuMGYpLCBuZXcgVmVjdG9yMigwLjBmLCBpbnZNYXNzMSArIGludk1hc3MyKSk7XHJcbiAgICAgICAgICAgICAgICBNYXQyMiBLMiA9IG5ldyBNYXQyMihuZXcgVmVjdG9yMihpbnZJMSAqIHIxLlkgKiByMS5ZLCAtaW52STEgKiByMS5YICogcjEuWSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMigtaW52STEgKiByMS5YICogcjEuWSwgaW52STEgKiByMS5YICogcjEuWCkpO1xyXG4gICAgICAgICAgICAgICAgTWF0MjIgSzMgPSBuZXcgTWF0MjIobmV3IFZlY3RvcjIoaW52STIgKiByMi5ZICogcjIuWSwgLWludkkyICogcjIuWCAqIHIyLlkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoLWludkkyICogcjIuWCAqIHIyLlksIGludkkyICogcjIuWCAqIHIyLlgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBNYXQyMiBLYTtcclxuICAgICAgICAgICAgICAgIE1hdDIyLkFkZChyZWYgSzEsIHJlZiBLMiwgb3V0IEthKTtcclxuXHJcbiAgICAgICAgICAgICAgICBNYXQyMiBLO1xyXG4gICAgICAgICAgICAgICAgTWF0MjIuQWRkKHJlZiBLYSwgcmVmIEszLCBvdXQgSyk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlID0gSy5Tb2x2ZSgtQyk7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuU3dlZXAuQyAtPSBiMS5JbnZNYXNzICogaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkEgLT0gYjEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgaW1wdWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uRXJyb3IgPD0gU2V0dGluZ3MuTGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gU2V0dGluZ3MuQW5ndWxhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vIFBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcclxuICAgIC8vIENkb3QgPSB2MiAtIHYxXHJcbiAgICAvLyAgICAgID0gdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpXHJcbiAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tldyBdXHJcbiAgICAvLyBJZGVudGl0eSB1c2VkOlxyXG4gICAgLy8gdyBrICUgKHJ4IGkgKyByeSBqKSA9IHcgKiAoLXJ5IGkgKyByeCBqKVxyXG5cclxuICAgIC8vIEFuZ2xlIGNvbnN0cmFpbnRcclxuICAgIC8vIENkb3QgPSB3MiAtIHcxXHJcbiAgICAvLyBKID0gWzAgMCAtMSAwIDAgMV1cclxuICAgIC8vIEsgPSBpbnZJMSArIGludkkyXHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEZyaWN0aW9uIGpvaW50LiBUaGlzIGlzIHVzZWQgZm9yIHRvcC1kb3duIGZyaWN0aW9uLlxyXG4gICAgLy8vIEl0IHByb3ZpZGVzIDJEIHRyYW5zbGF0aW9uYWwgZnJpY3Rpb24gYW5kIGFuZ3VsYXIgZnJpY3Rpb24uXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIEZyaWN0aW9uSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQTtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckI7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYW5ndWxhckltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYW5ndWxhck1hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9saW5lYXJJbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgTWF0MjIgX2xpbmVhck1hc3M7XHJcblxyXG4gICAgICAgIGludGVybmFsIEZyaWN0aW9uSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkZyaWN0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEZyaWN0aW9uSm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbEFuY2hvckEsIFZlY3RvcjIgbG9jYWxBbmNob3JCKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keUEsIGJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkZyaWN0aW9uO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpOyB9XHJcbiAgICAgICAgICAgIHNldCB7IERlYnVnLkFzc2VydChmYWxzZSwgXCJZb3UgY2FuJ3Qgc2V0IHRoZSB3b3JsZCBhbmNob3Igb24gdGhpcyBqb2ludCB0eXBlLlwiKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBmcmljdGlvbiBmb3JjZSBpbiBOLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heEZvcmNlIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBmcmljdGlvbiB0b3JxdWUgaW4gTi1tLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heFRvcnF1ZSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIF9saW5lYXJJbXB1bHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBfYW5ndWxhckltcHVsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZBLCB4ZkI7XHJcbiAgICAgICAgICAgIGJBLkdldFRyYW5zZm9ybShvdXQgeGZBKTtcclxuICAgICAgICAgICAgYkIuR2V0VHJhbnNmb3JtKG91dCB4ZkIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxyXG4gICAgICAgICAgICBWZWN0b3IyIHJBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgTG9jYWxBbmNob3JBIC0gYkEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHJCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIuUiwgTG9jYWxBbmNob3JCIC0gYkIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXHJcbiAgICAgICAgICAgIC8vICAgICBbIDAgICAgICAgLTEgMCAgICAgICAxXVxyXG4gICAgICAgICAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cclxuXHJcbiAgICAgICAgICAgIC8vIE1hdGxhYlxyXG4gICAgICAgICAgICAvLyBLID0gWyBtQStyMXleMippQSttQityMnleMippQiwgIC1yMXkqaUEqcjF4LXIyeSppQipyMngsICAgICAgICAgIC1yMXkqaUEtcjJ5KmlCXVxyXG4gICAgICAgICAgICAvLyAgICAgWyAgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgbUErcjF4XjIqaUErbUIrcjJ4XjIqaUIsICAgICAgICAgICByMXgqaUErcjJ4KmlCXVxyXG4gICAgICAgICAgICAvLyAgICAgWyAgICAgICAgICAtcjF5KmlBLXIyeSppQiwgICAgICAgICAgIHIxeCppQStyMngqaUIsICAgICAgICAgICAgICAgICAgIGlBK2lCXVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgbUEgPSBiQS5JbnZNYXNzLCBtQiA9IGJCLkludk1hc3M7XHJcbiAgICAgICAgICAgIGZsb2F0IGlBID0gYkEuSW52SSwgaUIgPSBiQi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSzEgPSBuZXcgTWF0MjIoKTtcclxuICAgICAgICAgICAgSzEuQ29sMS5YID0gbUEgKyBtQjtcclxuICAgICAgICAgICAgSzEuQ29sMi5YID0gMC4wZjtcclxuICAgICAgICAgICAgSzEuQ29sMS5ZID0gMC4wZjtcclxuICAgICAgICAgICAgSzEuQ29sMi5ZID0gbUEgKyBtQjtcclxuXHJcbiAgICAgICAgICAgIE1hdDIyIEsyID0gbmV3IE1hdDIyKCk7XHJcbiAgICAgICAgICAgIEsyLkNvbDEuWCA9IGlBICogckEuWSAqIHJBLlk7XHJcbiAgICAgICAgICAgIEsyLkNvbDIuWCA9IC1pQSAqIHJBLlggKiByQS5ZO1xyXG4gICAgICAgICAgICBLMi5Db2wxLlkgPSAtaUEgKiByQS5YICogckEuWTtcclxuICAgICAgICAgICAgSzIuQ29sMi5ZID0gaUEgKiByQS5YICogckEuWDtcclxuXHJcbiAgICAgICAgICAgIE1hdDIyIEszID0gbmV3IE1hdDIyKCk7XHJcbiAgICAgICAgICAgIEszLkNvbDEuWCA9IGlCICogckIuWSAqIHJCLlk7XHJcbiAgICAgICAgICAgIEszLkNvbDIuWCA9IC1pQiAqIHJCLlggKiByQi5ZO1xyXG4gICAgICAgICAgICBLMy5Db2wxLlkgPSAtaUIgKiByQi5YICogckIuWTtcclxuICAgICAgICAgICAgSzMuQ29sMi5ZID0gaUIgKiByQi5YICogckIuWDtcclxuXHJcbiAgICAgICAgICAgIE1hdDIyIEsxMjtcclxuICAgICAgICAgICAgTWF0MjIuQWRkKHJlZiBLMSwgcmVmIEsyLCBvdXQgSzEyKTtcclxuXHJcbiAgICAgICAgICAgIE1hdDIyIEs7XHJcbiAgICAgICAgICAgIE1hdDIyLkFkZChyZWYgSzEyLCByZWYgSzMsIG91dCBLKTtcclxuXHJcbiAgICAgICAgICAgIF9saW5lYXJNYXNzID0gSy5JbnZlcnNlO1xyXG5cclxuICAgICAgICAgICAgX2FuZ3VsYXJNYXNzID0gaUEgKyBpQjtcclxuICAgICAgICAgICAgaWYgKF9hbmd1bGFyTWFzcyA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9hbmd1bGFyTWFzcyA9IDEuMGYgLyBfYW5ndWxhck1hc3M7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5FbmFibGVXYXJtc3RhcnRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICBfbGluZWFySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBfYW5ndWxhckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IG5ldyBWZWN0b3IyKF9saW5lYXJJbXB1bHNlLlgsIF9saW5lYXJJbXB1bHNlLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgLT0gbUEgKiBQO1xyXG4gICAgICAgICAgICAgICAgYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gaUEgKiAoTWF0aFV0aWxzLkNyb3NzKHJBLCBQKSArIF9hbmd1bGFySW1wdWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBtQiAqIFA7XHJcbiAgICAgICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBpQiAqIChNYXRoVXRpbHMuQ3Jvc3MockIsIFApICsgX2FuZ3VsYXJJbXB1bHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdkEgPSBiQS5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3QSA9IGJBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHZCID0gYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgd0IgPSBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG1BID0gYkEuSW52TWFzcywgbUIgPSBiQi5JbnZNYXNzO1xyXG4gICAgICAgICAgICBmbG9hdCBpQSA9IGJBLkludkksIGlCID0gYkIuSW52STtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkEsIHhmQjtcclxuICAgICAgICAgICAgYkEuR2V0VHJhbnNmb3JtKG91dCB4ZkEpO1xyXG4gICAgICAgICAgICBiQi5HZXRUcmFuc2Zvcm0ob3V0IHhmQik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHJBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgTG9jYWxBbmNob3JBIC0gYkEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHJCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIuUiwgTG9jYWxBbmNob3JCIC0gYkIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgYW5ndWxhciBmcmljdGlvblxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gd0IgLSB3QTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX2FuZ3VsYXJNYXNzICogQ2RvdDtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gX2FuZ3VsYXJJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiBNYXhUb3JxdWU7XHJcbiAgICAgICAgICAgICAgICBfYW5ndWxhckltcHVsc2UgPSBNYXRoVXRpbHMuQ2xhbXAoX2FuZ3VsYXJJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9hbmd1bGFySW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgd0EgLT0gaUEgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgZnJpY3Rpb25cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBDZG90ID0gdkIgKyBNYXRoVXRpbHMuQ3Jvc3Mod0IsIHJCKSAtIHZBIC0gTWF0aFV0aWxzLkNyb3NzKHdBLCByQSk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlID0gLU1hdGhVdGlscy5NdWx0aXBseShyZWYgX2xpbmVhck1hc3MsIENkb3QpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBvbGRJbXB1bHNlID0gX2xpbmVhckltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBfbGluZWFySW1wdWxzZSArPSBpbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IG1heEltcHVsc2UgPSBzdGVwLmR0ICogTWF4Rm9yY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9saW5lYXJJbXB1bHNlLkxlbmd0aFNxdWFyZWQoKSA+IG1heEltcHVsc2UgKiBtYXhJbXB1bHNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlICo9IG1heEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9saW5lYXJJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2QSAtPSBtQSAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIE1hdGhVdGlscy5Dcm9zcyhyQSwgaW1wdWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdkIgKz0gbUIgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgd0IgKz0gaUIgKiBNYXRoVXRpbHMuQ3Jvc3MockIsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiQS5MaW5lYXJWZWxvY2l0eUludGVybmFsID0gdkE7XHJcbiAgICAgICAgICAgIGJBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gd0E7XHJcbiAgICAgICAgICAgIGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2QjtcclxuICAgICAgICAgICAgYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3QjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBnZWFyIGpvaW50IGlzIHVzZWQgdG8gY29ubmVjdCB0d28gam9pbnRzIHRvZ2V0aGVyLiBFaXRoZXIgam9pbnRcclxuICAgIC8vLyBjYW4gYmUgYSByZXZvbHV0ZSBvciBwcmlzbWF0aWMgam9pbnQuIFlvdSBzcGVjaWZ5IGEgZ2VhciByYXRpb1xyXG4gICAgLy8vIHRvIGJpbmQgdGhlIG1vdGlvbnMgdG9nZXRoZXI6XHJcbiAgICAvLy8gY29vcmRpbmF0ZTEgKyByYXRpbyAqIGNvb3JkaW5hdGUyID0gYW50XHJcbiAgICAvLy8gVGhlIHJhdGlvIGNhbiBiZSBuZWdhdGl2ZSBvciBwb3NpdGl2ZS4gSWYgb25lIGpvaW50IGlzIGEgcmV2b2x1dGUgam9pbnRcclxuICAgIC8vLyBhbmQgdGhlIG90aGVyIGpvaW50IGlzIGEgcHJpc21hdGljIGpvaW50LCB0aGVuIHRoZSByYXRpbyB3aWxsIGhhdmUgdW5pdHNcclxuICAgIC8vLyBvZiBsZW5ndGggb3IgdW5pdHMgb2YgMS9sZW5ndGguXHJcbiAgICAvLy8gQHdhcm5pbmcgVGhlIHJldm9sdXRlIGFuZCBwcmlzbWF0aWMgam9pbnRzIG11c3QgYmUgYXR0YWNoZWQgdG9cclxuICAgIC8vLyBmaXhlZCBib2RpZXMgKHdoaWNoIG11c3QgYmUgYm9keTEgb24gdGhvc2Ugam9pbnRzKS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgR2VhckpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIEphY29iaWFuIF9KO1xyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9hbnQ7XHJcbiAgICAgICAgcHJpdmF0ZSBGaXhlZFByaXNtYXRpY0pvaW50IF9maXhlZFByaXNtYXRpYzE7XHJcbiAgICAgICAgcHJpdmF0ZSBGaXhlZFByaXNtYXRpY0pvaW50IF9maXhlZFByaXNtYXRpYzI7XHJcbiAgICAgICAgcHJpdmF0ZSBGaXhlZFJldm9sdXRlSm9pbnQgX2ZpeGVkUmV2b2x1dGUxO1xyXG4gICAgICAgIHByaXZhdGUgRml4ZWRSZXZvbHV0ZUpvaW50IF9maXhlZFJldm9sdXRlMjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9pbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBQcmlzbWF0aWNKb2ludCBfcHJpc21hdGljMTtcclxuICAgICAgICBwcml2YXRlIFByaXNtYXRpY0pvaW50IF9wcmlzbWF0aWMyO1xyXG4gICAgICAgIHByaXZhdGUgUmV2b2x1dGVKb2ludCBfcmV2b2x1dGUxO1xyXG4gICAgICAgIHByaXZhdGUgUmV2b2x1dGVKb2ludCBfcmV2b2x1dGUyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlcXVpcmVzIHR3byBleGlzdGluZyByZXZvbHV0ZSBvciBwcmlzbWF0aWMgam9pbnRzIChhbnkgY29tYmluYXRpb24gd2lsbCB3b3JrKS5cclxuICAgICAgICAvLy8gVGhlIHByb3ZpZGVkIGpvaW50cyBtdXN0IGF0dGFjaCBhIGR5bmFtaWMgYm9keSB0byBhIHN0YXRpYyBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiam9pbnRBXCI+VGhlIGZpcnN0IGpvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiam9pbnRCXCI+VGhlIHNlY29uZCBqb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJhdGlvXCI+VGhlIHJhdGlvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIEdlYXJKb2ludChKb2ludCBqb2ludEEsIEpvaW50IGpvaW50QiwgZmxvYXQgcmF0aW8pXHJcbiAgICAgICAgICAgIDogYmFzZShqb2ludEEuQm9keUEsIGpvaW50QS5Cb2R5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5HZWFyO1xyXG4gICAgICAgICAgICBKb2ludEEgPSBqb2ludEE7XHJcbiAgICAgICAgICAgIEpvaW50QiA9IGpvaW50QjtcclxuICAgICAgICAgICAgUmF0aW8gPSByYXRpbztcclxuXHJcbiAgICAgICAgICAgIEpvaW50VHlwZSB0eXBlMSA9IGpvaW50QS5Kb2ludFR5cGU7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSB0eXBlMiA9IGpvaW50Qi5Kb2ludFR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgaXRzIHRoZSByaWdodCBraW5kIG9mIGpvaW50XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCh0eXBlMSA9PSBKb2ludFR5cGUuUmV2b2x1dGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUxID09IEpvaW50VHlwZS5QcmlzbWF0aWMgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUxID09IEpvaW50VHlwZS5GaXhlZFJldm9sdXRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlMSA9PSBKb2ludFR5cGUuRml4ZWRQcmlzbWF0aWMpO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQodHlwZTIgPT0gSm9pbnRUeXBlLlJldm9sdXRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlMiA9PSBKb2ludFR5cGUuUHJpc21hdGljIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlMiA9PSBKb2ludFR5cGUuRml4ZWRSZXZvbHV0ZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTIgPT0gSm9pbnRUeXBlLkZpeGVkUHJpc21hdGljKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgcHJpc21hdGljIGFuZCByZXZvbHV0ZSBqb2ludCwgdGhlIGZpcnN0IGJvZHkgbXVzdCBiZSBzdGF0aWMuXHJcbiAgICAgICAgICAgIGlmICh0eXBlMSA9PSBKb2ludFR5cGUuUmV2b2x1dGUgfHwgdHlwZTEgPT0gSm9pbnRUeXBlLlByaXNtYXRpYylcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChqb2ludEEuQm9keUEuQm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKTtcclxuICAgICAgICAgICAgaWYgKHR5cGUyID09IEpvaW50VHlwZS5SZXZvbHV0ZSB8fCB0eXBlMiA9PSBKb2ludFR5cGUuUHJpc21hdGljKVxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGpvaW50Qi5Cb2R5QS5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgY29vcmRpbmF0ZTEgPSAwLjBmLCBjb29yZGluYXRlMiA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5SZXZvbHV0ZTpcclxuICAgICAgICAgICAgICAgICAgICBCb2R5QSA9IGpvaW50QS5Cb2R5QjtcclxuICAgICAgICAgICAgICAgICAgICBfcmV2b2x1dGUxID0gKFJldm9sdXRlSm9pbnQpam9pbnRBO1xyXG4gICAgICAgICAgICAgICAgICAgIExvY2FsQW5jaG9yMSA9IF9yZXZvbHV0ZTEuTG9jYWxBbmNob3JCO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUxID0gX3Jldm9sdXRlMS5Kb2ludEFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBKb2ludFR5cGUuUHJpc21hdGljOlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlBID0gam9pbnRBLkJvZHlCO1xyXG4gICAgICAgICAgICAgICAgICAgIF9wcmlzbWF0aWMxID0gKFByaXNtYXRpY0pvaW50KWpvaW50QTtcclxuICAgICAgICAgICAgICAgICAgICBMb2NhbEFuY2hvcjEgPSBfcHJpc21hdGljMS5Mb2NhbEFuY2hvckI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTEgPSBfcHJpc21hdGljMS5Kb2ludFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBKb2ludFR5cGUuRml4ZWRSZXZvbHV0ZTpcclxuICAgICAgICAgICAgICAgICAgICBCb2R5QSA9IGpvaW50QS5Cb2R5QTtcclxuICAgICAgICAgICAgICAgICAgICBfZml4ZWRSZXZvbHV0ZTEgPSAoRml4ZWRSZXZvbHV0ZUpvaW50KWpvaW50QTtcclxuICAgICAgICAgICAgICAgICAgICBMb2NhbEFuY2hvcjEgPSBfZml4ZWRSZXZvbHV0ZTEuTG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUxID0gX2ZpeGVkUmV2b2x1dGUxLkpvaW50QW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5GaXhlZFByaXNtYXRpYzpcclxuICAgICAgICAgICAgICAgICAgICBCb2R5QSA9IGpvaW50QS5Cb2R5QTtcclxuICAgICAgICAgICAgICAgICAgICBfZml4ZWRQcmlzbWF0aWMxID0gKEZpeGVkUHJpc21hdGljSm9pbnQpam9pbnRBO1xyXG4gICAgICAgICAgICAgICAgICAgIExvY2FsQW5jaG9yMSA9IF9maXhlZFByaXNtYXRpYzEuTG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUxID0gX2ZpeGVkUHJpc21hdGljMS5Kb2ludFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5SZXZvbHV0ZTpcclxuICAgICAgICAgICAgICAgICAgICBCb2R5QiA9IGpvaW50Qi5Cb2R5QjtcclxuICAgICAgICAgICAgICAgICAgICBfcmV2b2x1dGUyID0gKFJldm9sdXRlSm9pbnQpam9pbnRCO1xyXG4gICAgICAgICAgICAgICAgICAgIExvY2FsQW5jaG9yMiA9IF9yZXZvbHV0ZTIuTG9jYWxBbmNob3JCO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUyID0gX3Jldm9sdXRlMi5Kb2ludEFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBKb2ludFR5cGUuUHJpc21hdGljOlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlCID0gam9pbnRCLkJvZHlCO1xyXG4gICAgICAgICAgICAgICAgICAgIF9wcmlzbWF0aWMyID0gKFByaXNtYXRpY0pvaW50KWpvaW50QjtcclxuICAgICAgICAgICAgICAgICAgICBMb2NhbEFuY2hvcjIgPSBfcHJpc21hdGljMi5Mb2NhbEFuY2hvckI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTIgPSBfcHJpc21hdGljMi5Kb2ludFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBKb2ludFR5cGUuRml4ZWRSZXZvbHV0ZTpcclxuICAgICAgICAgICAgICAgICAgICBCb2R5QiA9IGpvaW50Qi5Cb2R5QTtcclxuICAgICAgICAgICAgICAgICAgICBfZml4ZWRSZXZvbHV0ZTIgPSAoRml4ZWRSZXZvbHV0ZUpvaW50KWpvaW50QjtcclxuICAgICAgICAgICAgICAgICAgICBMb2NhbEFuY2hvcjIgPSBfZml4ZWRSZXZvbHV0ZTIuTG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUyID0gX2ZpeGVkUmV2b2x1dGUyLkpvaW50QW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5GaXhlZFByaXNtYXRpYzpcclxuICAgICAgICAgICAgICAgICAgICBCb2R5QiA9IGpvaW50Qi5Cb2R5QTtcclxuICAgICAgICAgICAgICAgICAgICBfZml4ZWRQcmlzbWF0aWMyID0gKEZpeGVkUHJpc21hdGljSm9pbnQpam9pbnRCO1xyXG4gICAgICAgICAgICAgICAgICAgIExvY2FsQW5jaG9yMiA9IF9maXhlZFByaXNtYXRpYzIuTG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUyID0gX2ZpeGVkUHJpc21hdGljMi5Kb2ludFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfYW50ID0gY29vcmRpbmF0ZTEgKyBSYXRpbyAqIGNvb3JkaW5hdGUyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvcjEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yMik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBnZWFyIHJhdGlvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJhdGlvIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZmlyc3QgcmV2b2x1dGUvcHJpc21hdGljIGpvaW50IGF0dGFjaGVkIHRvIHRoZSBnZWFyIGpvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEpvaW50IEpvaW50QSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIHNlY29uZCByZXZvbHV0ZS9wcmlzbWF0aWMgam9pbnQgYXR0YWNoZWQgdG8gdGhlIGdlYXIgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgSm9pbnQgSm9pbnRCIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3IxIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yMiB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZSAqIF9KLkxpbmVhckI7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBQO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgIEJvZHlCLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgciA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yMiAtIEJvZHlCLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gX2ltcHVsc2UgKiBfSi5MaW5lYXJCO1xyXG4gICAgICAgICAgICBmbG9hdCBMID0gX2ltcHVsc2UgKiBfSi5Bbmd1bGFyQiAtIE1hdGhVdGlscy5Dcm9zcyhyLCBQKTtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIEw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBLID0gMC4wZjtcclxuICAgICAgICAgICAgX0ouU2V0WmVybygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9yZXZvbHV0ZTEgIT0gbnVsbCB8fCBfZml4ZWRSZXZvbHV0ZTEgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX0ouQW5ndWxhckEgPSAtMS4wZjtcclxuICAgICAgICAgICAgICAgIEsgKz0gYjEuSW52STtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdWc7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3ByaXNtYXRpYzEgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB1ZyA9IF9wcmlzbWF0aWMxLkxvY2FsWEF4aXMxOyAvLyBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmZzEuUiwgX3ByaXNtYXRpYzEuTG9jYWxYQXhpczEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHVnID0gX2ZpeGVkUHJpc21hdGljMS5Mb2NhbFhBeGlzMTsgLy8gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZmcxLlIsIF9wcmlzbWF0aWMxLkxvY2FsWEF4aXMxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0geGYxIC8qLCB4ZmcxKi87XHJcbiAgICAgICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgICAgICAvL2cxLkdldFRyYW5zZm9ybShvdXQgeGZnMSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgciA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yMSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGNydWcgPSBNYXRoVXRpbHMuQ3Jvc3MociwgdWcpO1xyXG4gICAgICAgICAgICAgICAgX0ouTGluZWFyQSA9IC11ZztcclxuICAgICAgICAgICAgICAgIF9KLkFuZ3VsYXJBID0gLWNydWc7XHJcbiAgICAgICAgICAgICAgICBLICs9IGIxLkludk1hc3MgKyBiMS5JbnZJICogY3J1ZyAqIGNydWc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfcmV2b2x1dGUyICE9IG51bGwgfHwgX2ZpeGVkUmV2b2x1dGUyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9KLkFuZ3VsYXJCID0gLVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgSyArPSBSYXRpbyAqIFJhdGlvICogYjIuSW52STtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdWc7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3ByaXNtYXRpYzIgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB1ZyA9IF9wcmlzbWF0aWMyLkxvY2FsWEF4aXMxOyAvLyBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmZzEuUiwgX3ByaXNtYXRpYzEuTG9jYWxYQXhpczEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHVnID0gX2ZpeGVkUHJpc21hdGljMi5Mb2NhbFhBeGlzMTsgLy8gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZmcxLlIsIF9wcmlzbWF0aWMxLkxvY2FsWEF4aXMxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0gLyp4ZmcxLCovIHhmMjtcclxuICAgICAgICAgICAgICAgIC8vZzEuR2V0VHJhbnNmb3JtKG91dCB4ZmcxKTtcclxuICAgICAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvcjIgLSBiMi5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBjcnVnID0gTWF0aFV0aWxzLkNyb3NzKHIsIHVnKTtcclxuICAgICAgICAgICAgICAgIF9KLkxpbmVhckIgPSAtUmF0aW8gKiB1ZztcclxuICAgICAgICAgICAgICAgIF9KLkFuZ3VsYXJCID0gLVJhdGlvICogY3J1ZztcclxuICAgICAgICAgICAgICAgIEsgKz0gUmF0aW8gKiBSYXRpbyAqIChiMi5JbnZNYXNzICsgYjIuSW52SSAqIGNydWcgKiBjcnVnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEsgPiAwLjBmKTtcclxuICAgICAgICAgICAgX21hc3MgPSBLID4gMC4wZiA/IDEuMGYgLyBLIDogMC4wZjtcclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5FbmFibGVXYXJtc3RhcnRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFdhcm0gc3RhcnRpbmcuXHJcbiAgICAgICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIxLkludk1hc3MgKiBfaW1wdWxzZSAqIF9KLkxpbmVhckE7XHJcbiAgICAgICAgICAgICAgICBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMS5JbnZJICogX2ltcHVsc2UgKiBfSi5Bbmd1bGFyQTtcclxuICAgICAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52TWFzcyAqIF9pbXB1bHNlICogX0ouTGluZWFyQjtcclxuICAgICAgICAgICAgICAgIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludkkgKiBfaW1wdWxzZSAqIF9KLkFuZ3VsYXJCO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IF9KLkNvbXB1dGUoYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCwgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwsIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfbWFzcyAqICgtQ2RvdCk7XHJcbiAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIxLkludk1hc3MgKiBpbXB1bHNlICogX0ouTGluZWFyQTtcclxuICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjEuSW52SSAqIGltcHVsc2UgKiBfSi5Bbmd1bGFyQTtcclxuICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZNYXNzICogaW1wdWxzZSAqIF9KLkxpbmVhckI7XHJcbiAgICAgICAgICAgIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludkkgKiBpbXB1bHNlICogX0ouQW5ndWxhckI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCBsaW5lYXJFcnJvciA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYjIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGNvb3JkaW5hdGUxID0gMC4wZiwgY29vcmRpbmF0ZTIgPSAwLjBmO1xyXG4gICAgICAgICAgICBpZiAoX3Jldm9sdXRlMSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlMSA9IF9yZXZvbHV0ZTEuSm9pbnRBbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfZml4ZWRSZXZvbHV0ZTEgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZTEgPSBfZml4ZWRSZXZvbHV0ZTEuSm9pbnRBbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfcHJpc21hdGljMSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlMSA9IF9wcmlzbWF0aWMxLkpvaW50VHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX2ZpeGVkUHJpc21hdGljMSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlMSA9IF9maXhlZFByaXNtYXRpYzEuSm9pbnRUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9yZXZvbHV0ZTIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZTIgPSBfcmV2b2x1dGUyLkpvaW50QW5nbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX2ZpeGVkUmV2b2x1dGUyICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUyID0gX2ZpeGVkUmV2b2x1dGUyLkpvaW50QW5nbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3ByaXNtYXRpYzIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZTIgPSBfcHJpc21hdGljMi5Kb2ludFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF9maXhlZFByaXNtYXRpYzIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZTIgPSBfZml4ZWRQcmlzbWF0aWMyLkpvaW50VHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IEMgPSBfYW50IC0gKGNvb3JkaW5hdGUxICsgUmF0aW8gKiBjb29yZGluYXRlMik7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gX21hc3MgKiAoLUMpO1xyXG5cclxuICAgICAgICAgICAgYjEuU3dlZXAuQyArPSBiMS5JbnZNYXNzICogaW1wdWxzZSAqIF9KLkxpbmVhckE7XHJcbiAgICAgICAgICAgIGIxLlN3ZWVwLkEgKz0gYjEuSW52SSAqIGltcHVsc2UgKiBfSi5Bbmd1bGFyQTtcclxuICAgICAgICAgICAgYjIuU3dlZXAuQyArPSBiMi5JbnZNYXNzICogaW1wdWxzZSAqIF9KLkxpbmVhckI7XHJcbiAgICAgICAgICAgIGIyLlN3ZWVwLkEgKz0gYjIuSW52SSAqIGltcHVsc2UgKiBfSi5Bbmd1bGFyQjtcclxuXHJcbiAgICAgICAgICAgIGIxLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGIyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPX0VSSU4gbm90IGltcGxlbWVudGVkXHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8IFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgcHVibGljIGNsYXNzIExpbmVKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9heCwgX2F5O1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2JpYXM7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVNb3RvcjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9nYW1tYTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9pbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfbG9jYWxYQXhpcztcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2xvY2FsWUF4aXNBO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TW90b3JUb3JxdWU7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yTWFzcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvclNwZWVkO1xyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zQXg7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc0F5O1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3NCeDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zQnk7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3NwcmluZ0ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc3ByaW5nTWFzcztcclxuXHJcbiAgICAgICAgLy8gTGluZWFyIGNvbnN0cmFpbnQgKHBvaW50LXRvLWxpbmUpXHJcbiAgICAgICAgLy8gZCA9IHBCIC0gcEEgPSB4QiArIHJCIC0geEEgLSByQVxyXG4gICAgICAgIC8vIEMgPSBkb3QoYXksIGQpXHJcbiAgICAgICAgLy8gQ2RvdCA9IGRvdChkLCBjcm9zcyh3QSwgYXkpKSArIGRvdChheSwgdkIgKyBjcm9zcyh3QiwgckIpIC0gdkEgLSBjcm9zcyh3QSwgckEpKVxyXG4gICAgICAgIC8vICAgICAgPSAtZG90KGF5LCB2QSkgLSBkb3QoY3Jvc3MoZCArIHJBLCBheSksIHdBKSArIGRvdChheSwgdkIpICsgZG90KGNyb3NzKHJCLCBheSksIHZCKVxyXG4gICAgICAgIC8vIEogPSBbLWF5LCAtY3Jvc3MoZCArIHJBLCBheSksIGF5LCBjcm9zcyhyQiwgYXkpXVxyXG5cclxuICAgICAgICAvLyBTcHJpbmcgbGluZWFyIGNvbnN0cmFpbnRcclxuICAgICAgICAvLyBDID0gZG90KGF4LCBkKVxyXG4gICAgICAgIC8vIENkb3QgPSA9IC1kb3QoYXgsIHZBKSAtIGRvdChjcm9zcyhkICsgckEsIGF4KSwgd0EpICsgZG90KGF4LCB2QikgKyBkb3QoY3Jvc3MockIsIGF4KSwgdkIpXHJcbiAgICAgICAgLy8gSiA9IFstYXggLWNyb3NzKGQrckEsIGF4KSBheCBjcm9zcyhyQiwgYXgpXVxyXG5cclxuICAgICAgICAvLyBNb3RvciByb3RhdGlvbmFsIGNvbnN0cmFpbnRcclxuICAgICAgICAvLyBDZG90ID0gd0IgLSB3QVxyXG4gICAgICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBMaW5lSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkxpbmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTGluZUpvaW50KEJvZHkgYkEsIEJvZHkgYkIsIFZlY3RvcjIgYW5jaG9yLCBWZWN0b3IyIGF4aXMpXHJcbiAgICAgICAgICAgIDogYmFzZShiQSwgYkIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuTGluZTtcclxuXHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IGJBLkdldExvY2FsUG9pbnQoYW5jaG9yKTtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gYkIuR2V0TG9jYWxQb2ludChhbmNob3IpO1xyXG4gICAgICAgICAgICBMb2NhbFhBeGlzID0gYkEuR2V0TG9jYWxWZWN0b3IoYXhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckEgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckIgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFRyYW5zbGF0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcEEgPSBiQS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBCID0gYkIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gcEIgLSBwQTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpcyA9IGJBLkdldFdvcmxkVmVjdG9yKExvY2FsWEF4aXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHRyYW5zbGF0aW9uID0gVmVjdG9yMi5Eb3QoZCwgYXhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFNwZWVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgd0EgPSBCb2R5QS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHdCID0gQm9keUIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd0IgLSB3QTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgTW90b3JFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2VuYWJsZU1vdG9yOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5QS5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBCb2R5Qi5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfZW5hYmxlTW90b3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1vdG9yU3BlZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5QS5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBCb2R5Qi5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JTcGVlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbW90b3JTcGVlZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heE1vdG9yVG9ycXVlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keUEuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgQm9keUIuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX21heE1vdG9yVG9ycXVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhNb3RvclRvcnF1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyZXF1ZW5jeSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBEYW1waW5nUmF0aW8geyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbFhBeGlzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2xvY2FsWEF4aXM7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9sb2NhbFhBeGlzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBfbG9jYWxZQXhpc0EgPSBNYXRoVXRpbHMuQ3Jvc3MoMS4wZiwgX2xvY2FsWEF4aXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludkR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludkR0ICogKF9pbXB1bHNlICogX2F5ICsgX3NwcmluZ0ltcHVsc2UgKiBfYXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludkR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludkR0ICogX21vdG9ySW1wdWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIExvY2FsQ2VudGVyQSA9IGJBLkxvY2FsQ2VudGVyO1xyXG4gICAgICAgICAgICBMb2NhbENlbnRlckIgPSBiQi5Mb2NhbENlbnRlcjtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkE7XHJcbiAgICAgICAgICAgIGJBLkdldFRyYW5zZm9ybShvdXQgeGZBKTtcclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQjtcclxuICAgICAgICAgICAgYkIuR2V0VHJhbnNmb3JtKG91dCB4ZkIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3Nlcy5cclxuICAgICAgICAgICAgVmVjdG9yMiByQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLlIsIExvY2FsQW5jaG9yQSAtIExvY2FsQ2VudGVyQSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBMb2NhbEFuY2hvckIgLSBMb2NhbENlbnRlckIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBiQi5Td2VlcC5DICsgckIgLSBiQS5Td2VlcC5DIC0gckE7XHJcblxyXG4gICAgICAgICAgICBJbnZNYXNzQSA9IGJBLkludk1hc3M7XHJcbiAgICAgICAgICAgIEludklBID0gYkEuSW52STtcclxuICAgICAgICAgICAgSW52TWFzc0IgPSBiQi5JbnZNYXNzO1xyXG4gICAgICAgICAgICBJbnZJQiA9IGJCLkludkk7XHJcblxyXG4gICAgICAgICAgICAvLyBQb2ludCB0byBsaW5lIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2F5ID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgX2xvY2FsWUF4aXNBKTtcclxuICAgICAgICAgICAgICAgIF9zQXkgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHJBLCBfYXkpO1xyXG4gICAgICAgICAgICAgICAgX3NCeSA9IE1hdGhVdGlscy5Dcm9zcyhyQiwgX2F5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IEludk1hc3NBICsgSW52TWFzc0IgKyBJbnZJQSAqIF9zQXkgKiBfc0F5ICsgSW52SUIgKiBfc0J5ICogX3NCeTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX21hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9tYXNzID0gMS4wZiAvIF9tYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTcHJpbmcgY29uc3RyYWludFxyXG4gICAgICAgICAgICBfc3ByaW5nTWFzcyA9IDAuMGY7XHJcbiAgICAgICAgICAgIGlmIChGcmVxdWVuY3kgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfYXggPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBMb2NhbFhBeGlzKTtcclxuICAgICAgICAgICAgICAgIF9zQXggPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHJBLCBfYXgpO1xyXG4gICAgICAgICAgICAgICAgX3NCeCA9IE1hdGhVdGlscy5Dcm9zcyhyQiwgX2F4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZNYXNzID0gSW52TWFzc0EgKyBJbnZNYXNzQiArIEludklBICogX3NBeCAqIF9zQXggKyBJbnZJQiAqIF9zQnggKiBfc0J4O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnZNYXNzID4gMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3ByaW5nTWFzcyA9IDEuMGYgLyBpbnZNYXNzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBDID0gVmVjdG9yMi5Eb3QoZCwgX2F4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRnJlcXVlbmN5XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgb21lZ2EgPSAyLjBmICogU2V0dGluZ3MuUGkgKiBGcmVxdWVuY3k7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBkYSA9IDIuMGYgKiBfc3ByaW5nTWFzcyAqIERhbXBpbmdSYXRpbyAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTcHJpbmcgc3RpZmZuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgayA9IF9zcHJpbmdNYXNzICogb21lZ2EgKiBvbWVnYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcclxuICAgICAgICAgICAgICAgICAgICBfZ2FtbWEgPSBzdGVwLmR0ICogKGRhICsgc3RlcC5kdCAqIGspO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZ2FtbWEgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2dhbW1hID0gMS4wZiAvIF9nYW1tYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9iaWFzID0gQyAqIHN0ZXAuZHQgKiBrICogX2dhbW1hO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfc3ByaW5nTWFzcyA9IGludk1hc3MgKyBfZ2FtbWE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zcHJpbmdNYXNzID4gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gMS4wZiAvIF9zcHJpbmdNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zcHJpbmdJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUm90YXRpb25hbCBtb3RvclxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gSW52SUEgKyBJbnZJQjtcclxuICAgICAgICAgICAgICAgIGlmIChfbW90b3JNYXNzID4gMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gMS4wZiAvIF9tb3Rvck1hc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciB2YXJpYWJsZSB0aW1lIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBfc3ByaW5nSW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZSAqIF9heSArIF9zcHJpbmdJbXB1bHNlICogX2F4O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTEEgPSBfaW1wdWxzZSAqIF9zQXkgKyBfc3ByaW5nSW1wdWxzZSAqIF9zQXggKyBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTEIgPSBfaW1wdWxzZSAqIF9zQnkgKyBfc3ByaW5nSW1wdWxzZSAqIF9zQnggKyBfbW90b3JJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgLT0gSW52TWFzc0EgKiBQO1xyXG4gICAgICAgICAgICAgICAgYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gSW52SUEgKiBMQTtcclxuXHJcbiAgICAgICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IEludklCICogTEI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBfc3ByaW5nSW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdkEgPSBiQS5MaW5lYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgZmxvYXQgd0EgPSBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgVmVjdG9yMiB2QiA9IGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHdCID0gYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBzcHJpbmcgY29uc3RyYWludFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX2F4LCB2QiAtIHZBKSArIF9zQnggKiB3QiAtIF9zQXggKiB3QTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX3NwcmluZ01hc3MgKiAoQ2RvdCArIF9iaWFzICsgX2dhbW1hICogX3NwcmluZ0ltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgX3NwcmluZ0ltcHVsc2UgKz0gaW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX2F4O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTEEgPSBpbXB1bHNlICogX3NBeDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IExCID0gaW1wdWxzZSAqIF9zQng7XHJcblxyXG4gICAgICAgICAgICAgICAgdkEgLT0gSW52TWFzc0EgKiBQO1xyXG4gICAgICAgICAgICAgICAgd0EgLT0gSW52SUEgKiBMQTtcclxuXHJcbiAgICAgICAgICAgICAgICB2QiArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgICAgICB3QiArPSBJbnZJQiAqIExCO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSByb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IHdCIC0gd0EgLSBfbW90b3JTcGVlZDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX21vdG9yTWFzcyAqIENkb3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgb2xkSW1wdWxzZSA9IF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIF9tYXhNb3RvclRvcnF1ZTtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSBNYXRoVXRpbHMuQ2xhbXAoX21vdG9ySW1wdWxzZSArIGltcHVsc2UsIC1tYXhJbXB1bHNlLCBtYXhJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBfbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB3QSAtPSBJbnZJQSAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB3QiArPSBJbnZJQiAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50IHRvIGxpbmUgY29uc3RyYWludFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX2F5LCB2QiAtIHZBKSArIF9zQnkgKiB3QiAtIF9zQXkgKiB3QTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfbWFzcyAqICgtQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSArPSBpbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfYXk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMQSA9IGltcHVsc2UgKiBfc0F5O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTEIgPSBpbXB1bHNlICogX3NCeTtcclxuXHJcbiAgICAgICAgICAgICAgICB2QSAtPSBJbnZNYXNzQSAqIFA7XHJcbiAgICAgICAgICAgICAgICB3QSAtPSBJbnZJQSAqIExBO1xyXG5cclxuICAgICAgICAgICAgICAgIHZCICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHdCICs9IEludklCICogTEI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2QTtcclxuICAgICAgICAgICAgYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3QTtcclxuICAgICAgICAgICAgYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHZCO1xyXG4gICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdCO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHhBID0gYkEuU3dlZXAuQztcclxuICAgICAgICAgICAgZmxvYXQgYW5nbGVBID0gYkEuU3dlZXAuQTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgeEIgPSBiQi5Td2VlcC5DO1xyXG4gICAgICAgICAgICBmbG9hdCBhbmdsZUIgPSBiQi5Td2VlcC5BO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgUkEgPSBuZXcgTWF0MjIoYW5nbGVBKTtcclxuICAgICAgICAgICAgTWF0MjIgUkIgPSBuZXcgTWF0MjIoYW5nbGVCKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgckEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFJBLCBMb2NhbEFuY2hvckEgLSBMb2NhbENlbnRlckEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHJCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSQiwgTG9jYWxBbmNob3JCIC0gTG9jYWxDZW50ZXJCKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0geEIgKyByQiAtIHhBIC0gckE7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGF5ID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSQSwgX2xvY2FsWUF4aXNBKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHNBeSA9IE1hdGhVdGlscy5Dcm9zcyhkICsgckEsIGF5KTtcclxuICAgICAgICAgICAgZmxvYXQgc0J5ID0gTWF0aFV0aWxzLkNyb3NzKHJCLCBheSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBDID0gVmVjdG9yMi5Eb3QoZCwgYXkpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgayA9IEludk1hc3NBICsgSW52TWFzc0IgKyBJbnZJQSAqIF9zQXkgKiBfc0F5ICsgSW52SUIgKiBfc0J5ICogX3NCeTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2U7XHJcbiAgICAgICAgICAgIGlmIChrICE9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSAtQyAvIGs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIGF5O1xyXG4gICAgICAgICAgICBmbG9hdCBMQSA9IGltcHVsc2UgKiBzQXk7XHJcbiAgICAgICAgICAgIGZsb2F0IExCID0gaW1wdWxzZSAqIHNCeTtcclxuXHJcbiAgICAgICAgICAgIHhBIC09IEludk1hc3NBICogUDtcclxuICAgICAgICAgICAgYW5nbGVBIC09IEludklBICogTEE7XHJcbiAgICAgICAgICAgIHhCICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgYW5nbGVCICs9IEludklCICogTEI7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPX0VSSU4gcmVtb3ZlIG5lZWQgZm9yIHRoaXMuXHJcbiAgICAgICAgICAgIGJBLlN3ZWVwLkMgPSB4QTtcclxuICAgICAgICAgICAgYkEuU3dlZXAuQSA9IGFuZ2xlQTtcclxuICAgICAgICAgICAgYkIuU3dlZXAuQyA9IHhCO1xyXG4gICAgICAgICAgICBiQi5Td2VlcC5BID0gYW5nbGVCO1xyXG4gICAgICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKEMpIDw9IFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgR2V0TW90b3JUb3JxdWUoZmxvYXQgaW52RHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52RHQgKiBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vIExpbmVhciBjb25zdHJhaW50IChwb2ludC10by1saW5lKVxyXG4gICAgLy8gZCA9IHAyIC0gcDEgPSB4MiArIHIyIC0geDEgLSByMVxyXG4gICAgLy8gQyA9IGRvdChwZXJwLCBkKVxyXG4gICAgLy8gQ2RvdCA9IGRvdChkLCBjcm9zcyh3MSwgcGVycCkpICsgZG90KHBlcnAsIHYyICsgY3Jvc3ModzIsIHIyKSAtIHYxIC0gY3Jvc3ModzEsIHIxKSlcclxuICAgIC8vICAgICAgPSAtZG90KHBlcnAsIHYxKSAtIGRvdChjcm9zcyhkICsgcjEsIHBlcnApLCB3MSkgKyBkb3QocGVycCwgdjIpICsgZG90KGNyb3NzKHIyLCBwZXJwKSwgdjIpXHJcbiAgICAvLyBKID0gWy1wZXJwLCAtY3Jvc3MoZCArIHIxLCBwZXJwKSwgcGVycCwgY3Jvc3MocjIscGVycCldXHJcbiAgICAvL1xyXG4gICAgLy8gQW5ndWxhciBjb25zdHJhaW50XHJcbiAgICAvLyBDID0gYTIgLSBhMSArIGFfaW5pdGlhbFxyXG4gICAgLy8gQ2RvdCA9IHcyIC0gdzFcclxuICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxyXG4gICAgLy9cclxuICAgIC8vIEsgPSBKICogaW52TSAqIEpUXHJcbiAgICAvL1xyXG4gICAgLy8gSiA9IFstYSAtczEgYSBzMl1cclxuICAgIC8vICAgICBbMCAgLTEgIDAgIDFdXHJcbiAgICAvLyBhID0gcGVycFxyXG4gICAgLy8gczEgPSBjcm9zcyhkICsgcjEsIGEpID0gY3Jvc3MocDIgLSB4MSwgYSlcclxuICAgIC8vIHMyID0gY3Jvc3MocjIsIGEpID0gY3Jvc3MocDIgLSB4MiwgYSlcclxuICAgIC8vIE1vdG9yL0xpbWl0IGxpbmVhciBjb25zdHJhaW50XHJcbiAgICAvLyBDID0gZG90KGF4MSwgZClcclxuICAgIC8vIENkb3QgPSA9IC1kb3QoYXgxLCB2MSkgLSBkb3QoY3Jvc3MoZCArIHIxLCBheDEpLCB3MSkgKyBkb3QoYXgxLCB2MikgKyBkb3QoY3Jvc3MocjIsIGF4MSksIHYyKVxyXG4gICAgLy8gSiA9IFstYXgxIC1jcm9zcyhkK3IxLGF4MSkgYXgxIGNyb3NzKHIyLGF4MSldXHJcbiAgICAvLyBCbG9jayBTb2x2ZXJcclxuICAgIC8vIFdlIGRldmVsb3AgYSBibG9jayBzb2x2ZXIgdGhhdCBpbmNsdWRlcyB0aGUgam9pbnQgbGltaXQuIFRoaXMgbWFrZXMgdGhlIGxpbWl0IHN0aWZmIChpbmVsYXN0aWMpIGV2ZW5cclxuICAgIC8vIHdoZW4gdGhlIG1hc3MgaGFzIHBvb3IgZGlzdHJpYnV0aW9uIChsZWFkaW5nIHRvIGxhcmdlIHRvcnF1ZXMgYWJvdXQgdGhlIGpvaW50IGFuY2hvciBwb2ludHMpLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBKYWNvYmlhbiBoYXMgMyByb3dzOlxyXG4gICAgLy8gSiA9IFstdVQgLXMxIHVUIHMyXSAvLyBsaW5lYXJcclxuICAgIC8vICAgICBbMCAgIC0xICAgMCAgMV0gLy8gYW5ndWxhclxyXG4gICAgLy8gICAgIFstdlQgLWExIHZUIGEyXSAvLyBsaW1pdFxyXG4gICAgLy9cclxuICAgIC8vIHUgPSBwZXJwXHJcbiAgICAvLyB2ID0gYXhpc1xyXG4gICAgLy8gczEgPSBjcm9zcyhkICsgcjEsIHUpLCBzMiA9IGNyb3NzKHIyLCB1KVxyXG4gICAgLy8gYTEgPSBjcm9zcyhkICsgcjEsIHYpLCBhMiA9IGNyb3NzKHIyLCB2KVxyXG4gICAgLy8gTSAqICh2MiAtIHYxKSA9IEpUICogZGZcclxuICAgIC8vIEogKiB2MiA9IGJpYXNcclxuICAgIC8vXHJcbiAgICAvLyB2MiA9IHYxICsgaW52TSAqIEpUICogZGZcclxuICAgIC8vIEogKiAodjEgKyBpbnZNICogSlQgKiBkZikgPSBiaWFzXHJcbiAgICAvLyBLICogZGYgPSBiaWFzIC0gSiAqIHYxID0gLUNkb3RcclxuICAgIC8vIEsgPSBKICogaW52TSAqIEpUXHJcbiAgICAvLyBDZG90ID0gSiAqIHYxIC0gYmlhc1xyXG4gICAgLy9cclxuICAgIC8vIE5vdyBzb2x2ZSBmb3IgZjIuXHJcbiAgICAvLyBkZiA9IGYyIC0gZjFcclxuICAgIC8vIEsgKiAoZjIgLSBmMSkgPSAtQ2RvdFxyXG4gICAgLy8gZjIgPSBpbnZLICogKC1DZG90KSArIGYxXHJcbiAgICAvL1xyXG4gICAgLy8gQ2xhbXAgYWNjdW11bGF0ZWQgbGltaXQgaW1wdWxzZS5cclxuICAgIC8vIGxvd2VyOiBmMigzKSA9IG1heChmMigzKSwgMClcclxuICAgIC8vIHVwcGVyOiBmMigzKSA9IG1pbihmMigzKSwgMClcclxuICAgIC8vXHJcbiAgICAvLyBTb2x2ZSBmb3IgY29ycmVjdCBmMigxOjIpXHJcbiAgICAvLyBLKDE6MiwgMToyKSAqIGYyKDE6MikgPSAtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiBmMigzKSArIEsoMToyLDE6MykgKiBmMVxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgID0gLUNkb3QoMToyKSAtIEsoMToyLDMpICogZjIoMykgKyBLKDE6MiwxOjIpICogZjEoMToyKSArIEsoMToyLDMpICogZjEoMylcclxuICAgIC8vIEsoMToyLCAxOjIpICogZjIoMToyKSA9IC1DZG90KDE6MikgLSBLKDE6MiwzKSAqIChmMigzKSAtIGYxKDMpKSArIEsoMToyLDE6MikgKiBmMSgxOjIpXHJcbiAgICAvLyBmMigxOjIpID0gaW52SygxOjIsMToyKSAqICgtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiAoZjIoMykgLSBmMSgzKSkpICsgZjEoMToyKVxyXG4gICAgLy9cclxuICAgIC8vIE5vdyBjb21wdXRlIGltcHVsc2UgdG8gYmUgYXBwbGllZDpcclxuICAgIC8vIGRmID0gZjIgLSBmMVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIHByaXNtYXRpYyBqb2ludC4gVGhpcyBqb2ludCBwcm92aWRlcyBvbmUgZGVncmVlIG9mIGZyZWVkb206IHRyYW5zbGF0aW9uXHJcbiAgICAvLy8gYWxvbmcgYW4gYXhpcyBmaXhlZCBpbiBib2R5MS4gUmVsYXRpdmUgcm90YXRpb24gaXMgcHJldmVudGVkLiBZb3UgY2FuXHJcbiAgICAvLy8gdXNlIGEgam9pbnQgbGltaXQgdG8gcmVzdHJpY3QgdGhlIHJhbmdlIG9mIG1vdGlvbiBhbmQgYSBqb2ludCBtb3RvciB0b1xyXG4gICAgLy8vIGRyaXZlIHRoZSBtb3Rpb24gb3IgdG8gbW9kZWwgam9pbnQgZnJpY3Rpb24uXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFByaXNtYXRpY0pvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckE7XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQjtcclxuICAgICAgICBwcml2YXRlIE1hdDMzIF9LO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ExLCBfYTI7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9heGlzO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfZW5hYmxlTGltaXQ7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVNb3RvcjtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjMgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBMaW1pdFN0YXRlIF9saW1pdFN0YXRlO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfbG9jYWxYQXhpczE7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9sb2NhbFlBeGlzMTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9sb3dlclRyYW5zbGF0aW9uO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21heE1vdG9yRm9yY2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yTWFzczsgLy8gZWZmZWN0aXZlIG1hc3MgZm9yIG1vdG9yL2xpbWl0IHRyYW5zbGF0aW9uYWwgY29uc3RyYWludC5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvclNwZWVkO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfcGVycDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9yZWZBbmdsZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zMSwgX3MyO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3VwcGVyVHJhbnNsYXRpb247XHJcblxyXG4gICAgICAgIGludGVybmFsIFByaXNtYXRpY0pvaW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5QcmlzbWF0aWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgcmVxdWlyZXMgZGVmaW5pbmcgYSBsaW5lIG9mXHJcbiAgICAgICAgLy8vIG1vdGlvbiB1c2luZyBhbiBheGlzIGFuZCBhbiBhbmNob3IgcG9pbnQuIFRoZSBkZWZpbml0aW9uIHVzZXMgbG9jYWxcclxuICAgICAgICAvLy8gYW5jaG9yIHBvaW50cyBhbmQgYSBsb2NhbCBheGlzIHNvIHRoYXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvblxyXG4gICAgICAgIC8vLyBjYW4gdmlvbGF0ZSB0aGUgY29uc3RyYWludCBzbGlnaHRseS4gVGhlIGpvaW50IHRyYW5zbGF0aW9uIGlzIHplcm9cclxuICAgICAgICAvLy8gd2hlbiB0aGUgbG9jYWwgYW5jaG9yIHBvaW50cyBjb2luY2lkZSBpbiB3b3JsZCBzcGFjZS4gVXNpbmcgbG9jYWxcclxuICAgICAgICAvLy8gYW5jaG9ycyBhbmQgYSBsb2NhbCBheGlzIGhlbHBzIHdoZW4gc2F2aW5nIGFuZCBsb2FkaW5nIGEgZ2FtZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+VGhlIGZpcnN0IGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPlRoZSBzZWNvbmQgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsQW5jaG9yQVwiPlRoZSBmaXJzdCBib2R5IGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsQW5jaG9yQlwiPlRoZSBzZWNvbmQgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJheGlzXCI+VGhlIGF4aXMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgUHJpc21hdGljSm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbEFuY2hvckEsIFZlY3RvcjIgbG9jYWxBbmNob3JCLCBWZWN0b3IyIGF4aXMpXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5QSwgYm9keUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuUHJpc21hdGljO1xyXG5cclxuICAgICAgICAgICAgTG9jYWxBbmNob3JBID0gbG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckIgPSBsb2NhbEFuY2hvckI7XHJcblxyXG4gICAgICAgICAgICBfbG9jYWxYQXhpczEgPSBCb2R5QS5HZXRMb2NhbFZlY3RvcihheGlzKTtcclxuICAgICAgICAgICAgX2xvY2FsWUF4aXMxID0gTWF0aFV0aWxzLkNyb3NzKDEuMGYsIF9sb2NhbFhBeGlzMSk7XHJcbiAgICAgICAgICAgIF9yZWZBbmdsZSA9IEJvZHlCLlJvdGF0aW9uIC0gQm9keUEuUm90YXRpb247XHJcblxyXG4gICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IGpvaW50IHRyYW5zbGF0aW9uLCB1c3VhbGx5IGluIG1ldGVycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSm9pbnRUcmFuc2xhdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKSAtIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpcyA9IEJvZHlBLkdldFdvcmxkVmVjdG9yKHJlZiBfbG9jYWxYQXhpczEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLkRvdChkLCBheGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgam9pbnQgdHJhbnNsYXRpb24gc3BlZWQsIHVzdWFsbHkgaW4gbWV0ZXJzIHBlciBzZWNvbmQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEpvaW50U3BlZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgICAgICBCb2R5QS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgICAgICBCb2R5Qi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIEJvZHlBLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBCb2R5Qi5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAxID0gQm9keUEuU3dlZXAuQyArIHIxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMiA9IEJvZHlCLlN3ZWVwLkMgKyByMjtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IHAyIC0gcDE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXMgPSBCb2R5QS5HZXRXb3JsZFZlY3RvcihyZWYgX2xvY2FsWEF4aXMxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHYxID0gQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBCb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgdzEgPSBCb2R5QS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHcyID0gQm9keUIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgc3BlZWQgPSBWZWN0b3IyLkRvdChkLCBNYXRoVXRpbHMuQ3Jvc3ModzEsIGF4aXMpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIuRG90KGF4aXMsIHYyICsgTWF0aFV0aWxzLkNyb3NzKHcyLCByMikgLSB2MSAtIE1hdGhVdGlscy5Dcm9zcyh3MSwgcjEpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJcyB0aGUgam9pbnQgbGltaXQgZW5hYmxlZD9cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgW2xpbWl0IGVuYWJsZWRdOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIExpbWl0RW5hYmxlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVMaW1pdDsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEJvZHlBLkZpeGVkUm90YXRpb24gPT0gZmFsc2UgfHwgQm9keUIuRml4ZWRSb3RhdGlvbiA9PSBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIldhcm5pbmc6IGxpbWl0cyBkb2VzIGN1cnJlbnRseSBub3Qgd29yayB3aXRoIGZpeGVkIHJvdGF0aW9uXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9lbmFibGVMaW1pdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgbG93ZXIgam9pbnQgbGltaXQsIHVzdWFsbHkgaW4gbWV0ZXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBMb3dlckxpbWl0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2xvd2VyVHJhbnNsYXRpb247IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9sb3dlclRyYW5zbGF0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB1cHBlciBqb2ludCBsaW1pdCwgdXN1YWxseSBpbiBtZXRlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFVwcGVyTGltaXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdXBwZXJUcmFuc2xhdGlvbjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX3VwcGVyVHJhbnNsYXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJcyB0aGUgam9pbnQgbW90b3IgZW5hYmxlZD9cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgW21vdG9yIGVuYWJsZWRdOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIE1vdG9yRW5hYmxlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVNb3RvcjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZU1vdG9yID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSBtb3RvciBzcGVlZCwgdXN1YWxseSBpbiBtZXRlcnMgcGVyIHNlY29uZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHNwZWVkLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1vdG9yU3BlZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JTcGVlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbW90b3JTcGVlZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIG1heGltdW0gbW90b3IgZm9yY2UsIHVzdWFsbHkgaW4gTi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGZvcmNlLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heE1vdG9yRm9yY2VcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbWF4TW90b3JGb3JjZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX21heE1vdG9yRm9yY2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgbW90b3IgZm9yY2UsIHVzdWFsbHkgaW4gTi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTW90b3JGb3JjZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tb3RvckltcHVsc2U7IH1cclxuICAgICAgICAgICAgc2V0IHsgX21vdG9ySW1wdWxzZSA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbFhBeGlzMVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9sb2NhbFhBeGlzMTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xvY2FsWEF4aXMxID0gQm9keUEuR2V0TG9jYWxWZWN0b3IodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgX2xvY2FsWUF4aXMxID0gTWF0aFV0aWxzLkNyb3NzKDEuMGYsIF9sb2NhbFhBeGlzMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSZWZlcmVuY2VBbmdsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9yZWZBbmdsZTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBfcmVmQW5nbGUgPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogKF9pbXB1bHNlLlggKiBfcGVycCArIChfbW90b3JJbXB1bHNlICsgX2ltcHVsc2UuWikgKiBfYXhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIF9pbXB1bHNlLlk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBMb2NhbENlbnRlckEgPSBiMS5Mb2NhbENlbnRlcjtcclxuICAgICAgICAgICAgTG9jYWxDZW50ZXJCID0gYjIuTG9jYWxDZW50ZXI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3Nlcy5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIExvY2FsQ2VudGVyQSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBMb2NhbENlbnRlckIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBiMi5Td2VlcC5DICsgcjIgLSBiMS5Td2VlcC5DIC0gcjE7XHJcblxyXG4gICAgICAgICAgICBJbnZNYXNzQSA9IGIxLkludk1hc3M7XHJcbiAgICAgICAgICAgIEludklBID0gYjEuSW52STtcclxuICAgICAgICAgICAgSW52TWFzc0IgPSBiMi5JbnZNYXNzO1xyXG4gICAgICAgICAgICBJbnZJQiA9IGIyLkludkk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG1vdG9yIEphY29iaWFuIGFuZCBlZmZlY3RpdmUgbWFzcy5cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2F4aXMgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBfbG9jYWxYQXhpczEpO1xyXG4gICAgICAgICAgICAgICAgX2ExID0gTWF0aFV0aWxzLkNyb3NzKGQgKyByMSwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgX2EyID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfYXhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgX21vdG9yTWFzcyA9IEludk1hc3NBICsgSW52TWFzc0IgKyBJbnZJQSAqIF9hMSAqIF9hMSArIEludklCICogX2EyICogX2EyO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbW90b3JNYXNzID4gU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gMS4wZiAvIF9tb3Rvck1hc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByaXNtYXRpYyBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfcGVycCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIF9sb2NhbFlBeGlzMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX3MxID0gTWF0aFV0aWxzLkNyb3NzKGQgKyByMSwgX3BlcnApO1xyXG4gICAgICAgICAgICAgICAgX3MyID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfcGVycCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgbTEgPSBJbnZNYXNzQSwgbTIgPSBJbnZNYXNzQjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGkxID0gSW52SUEsIGkyID0gSW52SUI7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgazExID0gbTEgKyBtMiArIGkxICogX3MxICogX3MxICsgaTIgKiBfczIgKiBfczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTIgPSBpMSAqIF9zMSArIGkyICogX3MyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazEzID0gaTEgKiBfczEgKiBfYTEgKyBpMiAqIF9zMiAqIF9hMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsyMiA9IGkxICsgaTI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMjMgPSBpMSAqIF9hMSArIGkyICogX2EyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazMzID0gbTEgKyBtMiArIGkxICogX2ExICogX2ExICsgaTIgKiBfYTIgKiBfYTI7XHJcblxyXG4gICAgICAgICAgICAgICAgX0suQ29sMSA9IG5ldyBWZWN0b3IzKGsxMSwgazEyLCBrMTMpO1xyXG4gICAgICAgICAgICAgICAgX0suQ29sMiA9IG5ldyBWZWN0b3IzKGsxMiwgazIyLCBrMjMpO1xyXG4gICAgICAgICAgICAgICAgX0suQ29sMyA9IG5ldyBWZWN0b3IzKGsxMywgazIzLCBrMzMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG1vdG9yIGFuZCBsaW1pdCB0ZXJtcy5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVMaW1pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgam9pbnRUcmFuc2xhdGlvbiA9IFZlY3RvcjIuRG90KF9heGlzLCBkKTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLkFicyhfdXBwZXJUcmFuc2xhdGlvbiAtIF9sb3dlclRyYW5zbGF0aW9uKSA8IDIuMGYgKiBTZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5FcXVhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpvaW50VHJhbnNsYXRpb24gPD0gX2xvd2VyVHJhbnNsYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuQXRMb3dlcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5BdExvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqb2ludFRyYW5zbGF0aW9uID49IF91cHBlclRyYW5zbGF0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuQXRVcHBlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5JbmFjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5JbmFjdGl2ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVNb3RvciA9PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5FbmFibGVXYXJtc3RhcnRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IF9pbXB1bHNlLlggKiBfcGVycCArIChfbW90b3JJbXB1bHNlICsgX2ltcHVsc2UuWikgKiBfYXhpcztcclxuICAgICAgICAgICAgICAgIGZsb2F0IEwxID0gX2ltcHVsc2UuWCAqIF9zMSArIF9pbXB1bHNlLlkgKyAoX21vdG9ySW1wdWxzZSArIF9pbXB1bHNlLlopICogX2ExO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDIgPSBfaW1wdWxzZS5YICogX3MyICsgX2ltcHVsc2UuWSArIChfbW90b3JJbXB1bHNlICsgX2ltcHVsc2UuWikgKiBfYTI7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBJbnZNYXNzQSAqIFA7XHJcbiAgICAgICAgICAgICAgICBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtPSBJbnZJQSAqIEwxO1xyXG5cclxuICAgICAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52SUIgKiBMMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlID0gVmVjdG9yMy5aZXJvO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgdzEgPSBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MiA9IGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHcyID0gYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgbW90b3IgY29uc3RyYWludC5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVNb3RvciAmJiBfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkVxdWFsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX2F4aXMsIHYyIC0gdjEpICsgX2EyICogdzIgLSBfYTEgKiB3MTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfbW90b3JNYXNzICogKF9tb3RvclNwZWVkIC0gQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gX21vdG9ySW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1heEltcHVsc2UgPSBzdGVwLmR0ICogX21heE1vdG9yRm9yY2U7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gTWF0aFV0aWxzLkNsYW1wKF9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX21vdG9ySW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIF9heGlzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDEgPSBpbXB1bHNlICogX2ExO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDIgPSBpbXB1bHNlICogX2EyO1xyXG5cclxuICAgICAgICAgICAgICAgIHYxIC09IEludk1hc3NBICogUDtcclxuICAgICAgICAgICAgICAgIHcxIC09IEludklBICogTDE7XHJcblxyXG4gICAgICAgICAgICAgICAgdjIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgdzIgKz0gSW52SUIgKiBMMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBDZG90MSA9IG5ldyBWZWN0b3IyKFZlY3RvcjIuRG90KF9wZXJwLCB2MiAtIHYxKSArIF9zMiAqIHcyIC0gX3MxICogdzEsIHcyIC0gdzEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVMaW1pdCAmJiBfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkluYWN0aXZlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTb2x2ZSBwcmlzbWF0aWMgYW5kIGxpbWl0IGNvbnN0cmFpbnQgaW4gYmxvY2sgZm9ybS5cclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QyID0gVmVjdG9yMi5Eb3QoX2F4aXMsIHYyIC0gdjEpICsgX2EyICogdzIgLSBfYTEgKiB3MTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjMgQ2RvdCA9IG5ldyBWZWN0b3IzKENkb3QxLlgsIENkb3QxLlksIENkb3QyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzIGYxID0gX2ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzIGRmID0gX0suU29sdmUzMygtQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSArPSBkZjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdExvd2VyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSBNYXRoLk1heChfaW1wdWxzZS5aLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gTWF0aC5NaW4oX2ltcHVsc2UuWiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZjIoMToyKSA9IGludksoMToyLDE6MikgKiAoLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpKSArIGYxKDE6MilcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYiA9IC1DZG90MSAtIChfaW1wdWxzZS5aIC0gZjEuWikgKiBuZXcgVmVjdG9yMihfSy5Db2wzLlgsIF9LLkNvbDMuWSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGYyciA9IF9LLlNvbHZlMjIoYikgKyBuZXcgVmVjdG9yMihmMS5YLCBmMS5ZKTtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggPSBmMnIuWDtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlkgPSBmMnIuWTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZiA9IF9pbXB1bHNlIC0gZjE7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gZGYuWCAqIF9wZXJwICsgZGYuWiAqIF9heGlzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDEgPSBkZi5YICogX3MxICsgZGYuWSArIGRmLlogKiBfYTE7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMMiA9IGRmLlggKiBfczIgKyBkZi5ZICsgZGYuWiAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgICAgICB2MSAtPSBJbnZNYXNzQSAqIFA7XHJcbiAgICAgICAgICAgICAgICB3MSAtPSBJbnZJQSAqIEwxO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHcyICs9IEludklCICogTDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBMaW1pdCBpcyBpbmFjdGl2ZSwganVzdCBzb2x2ZSB0aGUgcHJpc21hdGljIGNvbnN0cmFpbnQgaW4gYmxvY2sgZm9ybS5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZGYgPSBfSy5Tb2x2ZTIyKC1DZG90MSk7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZS5YICs9IGRmLlg7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZS5ZICs9IGRmLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gZGYuWCAqIF9wZXJwO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDEgPSBkZi5YICogX3MxICsgZGYuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IEwyID0gZGYuWCAqIF9zMiArIGRmLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEgLT0gSW52TWFzc0EgKiBQO1xyXG4gICAgICAgICAgICAgICAgdzEgLT0gSW52SUEgKiBMMTtcclxuXHJcbiAgICAgICAgICAgICAgICB2MiArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgICAgICB3MiArPSBJbnZJQiAqIEwyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsID0gdjE7XHJcbiAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gdzE7XHJcbiAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2MjtcclxuICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3MjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBjMSA9IGIxLlN3ZWVwLkM7XHJcbiAgICAgICAgICAgIGZsb2F0IGExID0gYjEuU3dlZXAuQTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgYzIgPSBiMi5Td2VlcC5DO1xyXG4gICAgICAgICAgICBmbG9hdCBhMiA9IGIyLlN3ZWVwLkE7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgbGltaXQgY29uc3RyYWludC5cclxuICAgICAgICAgICAgZmxvYXQgbGluZWFyRXJyb3IgPSAwLjBmO1xyXG4gICAgICAgICAgICBib29sIGFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmbG9hdCBDMiA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBSMSA9IG5ldyBNYXQyMihhMSk7XHJcbiAgICAgICAgICAgIE1hdDIyIFIyID0gbmV3IE1hdDIyKGEyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFIxLCBMb2NhbEFuY2hvckEgLSBMb2NhbENlbnRlckEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSMiwgTG9jYWxBbmNob3JCIC0gTG9jYWxDZW50ZXJCKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gYzIgKyByMiAtIGMxIC0gcjE7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfYXhpcyA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUjEsIF9sb2NhbFhBeGlzMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2ExID0gTWF0aFV0aWxzLkNyb3NzKGQgKyByMSwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgX2EyID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfYXhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgdHJhbnNsYXRpb24gPSBWZWN0b3IyLkRvdChfYXhpcywgZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMoX3VwcGVyVHJhbnNsYXRpb24gLSBfbG93ZXJUcmFuc2xhdGlvbikgPCAyLjBmICogU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBDMiA9IE1hdGhVdGlscy5DbGFtcCh0cmFuc2xhdGlvbiwgLVNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24sIFNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gKGZsb2F0KU1hdGguQWJzKHRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPD0gX2xvd2VyVHJhbnNsYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBsaW5lYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cclxuICAgICAgICAgICAgICAgICAgICBDMiA9IE1hdGhVdGlscy5DbGFtcCh0cmFuc2xhdGlvbiAtIF9sb3dlclRyYW5zbGF0aW9uICsgU2V0dGluZ3MuTGluZWFyU2xvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZWFyRXJyb3IgPSBfbG93ZXJUcmFuc2xhdGlvbiAtIHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFuc2xhdGlvbiA+PSBfdXBwZXJUcmFuc2xhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGxpbmVhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxyXG4gICAgICAgICAgICAgICAgICAgIEMyID0gTWF0aFV0aWxzLkNsYW1wKHRyYW5zbGF0aW9uIC0gX3VwcGVyVHJhbnNsYXRpb24gLSBTZXR0aW5ncy5MaW5lYXJTbG9wLCAwLjBmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gdHJhbnNsYXRpb24gLSBfdXBwZXJUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfcGVycCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUjEsIF9sb2NhbFlBeGlzMSk7XHJcblxyXG4gICAgICAgICAgICBfczEgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHIxLCBfcGVycCk7XHJcbiAgICAgICAgICAgIF9zMiA9IE1hdGhVdGlscy5Dcm9zcyhyMiwgX3BlcnApO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMyBpbXB1bHNlO1xyXG4gICAgICAgICAgICBWZWN0b3IyIEMxID0gbmV3IFZlY3RvcjIoVmVjdG9yMi5Eb3QoX3BlcnAsIGQpLCBhMiAtIGExIC0gUmVmZXJlbmNlQW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgbGluZWFyRXJyb3IgPSBNYXRoLk1heChsaW5lYXJFcnJvciwgKGZsb2F0KU1hdGguQWJzKEMxLlgpKTtcclxuICAgICAgICAgICAgZmxvYXQgYW5ndWxhckVycm9yID0gKGZsb2F0KU1hdGguQWJzKEMxLlkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFjdGl2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbTEgPSBJbnZNYXNzQSwgbTIgPSBJbnZNYXNzQjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGkxID0gSW52SUEsIGkyID0gSW52SUI7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgazExID0gbTEgKyBtMiArIGkxICogX3MxICogX3MxICsgaTIgKiBfczIgKiBfczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTIgPSBpMSAqIF9zMSArIGkyICogX3MyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazEzID0gaTEgKiBfczEgKiBfYTEgKyBpMiAqIF9zMiAqIF9hMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsyMiA9IGkxICsgaTI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMjMgPSBpMSAqIF9hMSArIGkyICogX2EyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazMzID0gbTEgKyBtMiArIGkxICogX2ExICogX2ExICsgaTIgKiBfYTIgKiBfYTI7XHJcblxyXG4gICAgICAgICAgICAgICAgX0suQ29sMSA9IG5ldyBWZWN0b3IzKGsxMSwgazEyLCBrMTMpO1xyXG4gICAgICAgICAgICAgICAgX0suQ29sMiA9IG5ldyBWZWN0b3IzKGsxMiwgazIyLCBrMjMpO1xyXG4gICAgICAgICAgICAgICAgX0suQ29sMyA9IG5ldyBWZWN0b3IzKGsxMywgazIzLCBrMzMpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjMgQyA9IG5ldyBWZWN0b3IzKC1DMS5YLCAtQzEuWSwgLUMyKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBfSy5Tb2x2ZTMzKEMpOyAvLyBuZWdhdGVkIGFib3ZlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtMSA9IEludk1hc3NBLCBtMiA9IEludk1hc3NCO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaTEgPSBJbnZJQSwgaTIgPSBJbnZJQjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTEgPSBtMSArIG0yICsgaTEgKiBfczEgKiBfczEgKyBpMiAqIF9zMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMiA9IGkxICogX3MxICsgaTIgKiBfczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMjIgPSBpMSArIGkyO1xyXG5cclxuICAgICAgICAgICAgICAgIF9LLkNvbDEgPSBuZXcgVmVjdG9yMyhrMTEsIGsxMiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wyID0gbmV3IFZlY3RvcjMoazEyLCBrMjIsIDAuMGYpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaW1wdWxzZTEgPSBfSy5Tb2x2ZTIyKC1DMSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlLlggPSBpbXB1bHNlMS5YO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZS5ZID0gaW1wdWxzZTEuWTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UuWCAqIF9wZXJwICsgaW1wdWxzZS5aICogX2F4aXM7XHJcbiAgICAgICAgICAgIGZsb2F0IEwxID0gaW1wdWxzZS5YICogX3MxICsgaW1wdWxzZS5ZICsgaW1wdWxzZS5aICogX2ExO1xyXG4gICAgICAgICAgICBmbG9hdCBMMiA9IGltcHVsc2UuWCAqIF9zMiArIGltcHVsc2UuWSArIGltcHVsc2UuWiAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgIGMxIC09IEludk1hc3NBICogUDtcclxuICAgICAgICAgICAgYTEgLT0gSW52SUEgKiBMMTtcclxuICAgICAgICAgICAgYzIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICBhMiArPSBJbnZJQiAqIEwyO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ET19FUklOIHJlbW92ZSBuZWVkIGZvciB0aGlzLlxyXG4gICAgICAgICAgICBiMS5Td2VlcC5DID0gYzE7XHJcbiAgICAgICAgICAgIGIxLlN3ZWVwLkEgPSBhMTtcclxuICAgICAgICAgICAgYjIuU3dlZXAuQyA9IGMyO1xyXG4gICAgICAgICAgICBiMi5Td2VlcC5BID0gYTI7XHJcbiAgICAgICAgICAgIGIxLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGIyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbGluZWFyRXJyb3IgPD0gU2V0dGluZ3MuTGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gU2V0dGluZ3MuQW5ndWxhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoZSBwdWxsZXkgam9pbnQgaXMgY29ubmVjdGVkIHRvIHR3byBib2RpZXMgYW5kIHR3byBmaXhlZCBncm91bmQgcG9pbnRzLlxyXG4gICAgLy8vIFRoZSBwdWxsZXkgc3VwcG9ydHMgYSByYXRpbyBzdWNoIHRoYXQ6XHJcbiAgICAvLy8gbGVuZ3RoMSArIHJhdGlvICogbGVuZ3RoMiA8IS0tPC0tPj0gYW50XHJcbiAgICAvLy8gWWVzLCB0aGUgZm9yY2UgdHJhbnNtaXR0ZWQgaXMgc2NhbGVkIGJ5IHRoZSByYXRpby5cclxuICAgIC8vLyBUaGUgcHVsbGV5IGFsc28gZW5mb3JjZXMgYSBtYXhpbXVtIGxlbmd0aCBsaW1pdCBvbiBib3RoIHNpZGVzLiBUaGlzIGlzXHJcbiAgICAvLy8gdXNlZnVsIHRvIHByZXZlbnQgb25lIHNpZGUgb2YgdGhlIHB1bGxleSBoaXR0aW5nIHRoZSB0b3AuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFB1bGxleUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgZmlyc3QgZ3JvdW5kIGFuY2hvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHcm91bmRBbmNob3JBO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgc2Vjb25kIGdyb3VuZCBhbmNob3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR3JvdW5kQW5jaG9yQjtcclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQjtcclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1pblB1bGxleUxlbmd0aCA9IDIuMGY7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYW50O1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbGVuZ3RoQTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9sZW5ndGhCO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xpbWl0SW1wdWxzZTE7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbGltaXRJbXB1bHNlMjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9saW1pdE1hc3MxO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xpbWl0TWFzczI7XHJcbiAgICAgICAgcHJpdmF0ZSBMaW1pdFN0YXRlIF9saW1pdFN0YXRlMTtcclxuICAgICAgICBwcml2YXRlIExpbWl0U3RhdGUgX2xpbWl0U3RhdGUyO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21heExlbmd0aEE7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TGVuZ3RoQjtcclxuXHJcbiAgICAgICAgLy8gRWZmZWN0aXZlIG1hc3Nlc1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3B1bGxleU1hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBMaW1pdFN0YXRlIF9zdGF0ZTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3UxO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfdTI7XHJcblxyXG4gICAgICAgIGludGVybmFsIFB1bGxleUpvaW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5QdWxsZXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemUgdGhlIGJvZGllcywgYW5jaG9ycywgbGVuZ3RocywgbWF4IGxlbmd0aHMsIGFuZCByYXRpbyB1c2luZyB0aGUgd29ybGQgYW5jaG9ycy5cclxuICAgICAgICAvLy8gVGhpcyByZXF1aXJlcyB0d28gZ3JvdW5kIGFuY2hvcnMsXHJcbiAgICAgICAgLy8vIHR3byBkeW5hbWljIGJvZHkgYW5jaG9yIHBvaW50cywgbWF4IGxlbmd0aHMgZm9yIGVhY2ggc2lkZSxcclxuICAgICAgICAvLy8gYW5kIGEgcHVsbGV5IHJhdGlvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj5UaGUgZmlyc3QgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+VGhlIHNlY29uZCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZ3JvdW5kQW5jaG9yQVwiPlRoZSBncm91bmQgYW5jaG9yIGZvciB0aGUgZmlyc3QgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImdyb3VuZEFuY2hvckJcIj5UaGUgZ3JvdW5kIGFuY2hvciBmb3IgdGhlIHNlY29uZCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JBXCI+VGhlIGZpcnN0IGJvZHkgYW5jaG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JCXCI+VGhlIHNlY29uZCBib2R5IGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJhdGlvXCI+VGhlIHJhdGlvLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFB1bGxleUpvaW50KEJvZHkgYm9keUEsIEJvZHkgYm9keUIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZ3JvdW5kQW5jaG9yQSwgVmVjdG9yMiBncm91bmRBbmNob3JCLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsQW5jaG9yQSwgVmVjdG9yMiBsb2NhbEFuY2hvckIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHJhdGlvKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keUEsIGJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLlB1bGxleTtcclxuXHJcbiAgICAgICAgICAgIEdyb3VuZEFuY2hvckEgPSBncm91bmRBbmNob3JBO1xyXG4gICAgICAgICAgICBHcm91bmRBbmNob3JCID0gZ3JvdW5kQW5jaG9yQjtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JBID0gbG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckIgPSBsb2NhbEFuY2hvckI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGQxID0gQm9keUEuR2V0V29ybGRQb2ludChsb2NhbEFuY2hvckEpIC0gZ3JvdW5kQW5jaG9yQTtcclxuICAgICAgICAgICAgX2xlbmd0aEEgPSBkMS5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZDIgPSBCb2R5Qi5HZXRXb3JsZFBvaW50KGxvY2FsQW5jaG9yQikgLSBncm91bmRBbmNob3JCO1xyXG4gICAgICAgICAgICBfbGVuZ3RoQiA9IGQyLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHJhdGlvICE9IDAuMGYpO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQocmF0aW8gPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgUmF0aW8gPSByYXRpbztcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IEMgPSBfbGVuZ3RoQSArIFJhdGlvICogX2xlbmd0aEI7XHJcblxyXG4gICAgICAgICAgICBNYXhMZW5ndGhBID0gQyAtIFJhdGlvICogTWluUHVsbGV5TGVuZ3RoO1xyXG4gICAgICAgICAgICBNYXhMZW5ndGhCID0gKEMgLSBNaW5QdWxsZXlMZW5ndGgpIC8gUmF0aW87XHJcblxyXG4gICAgICAgICAgICBfYW50ID0gX2xlbmd0aEEgKyBSYXRpbyAqIF9sZW5ndGhCO1xyXG5cclxuICAgICAgICAgICAgTWF4TGVuZ3RoQSA9IE1hdGguTWluKE1heExlbmd0aEEsIF9hbnQgLSBSYXRpbyAqIE1pblB1bGxleUxlbmd0aCk7XHJcbiAgICAgICAgICAgIE1heExlbmd0aEIgPSBNYXRoLk1pbihNYXhMZW5ndGhCLCAoX2FudCAtIE1pblB1bGxleUxlbmd0aCkgLyBSYXRpbyk7XHJcblxyXG4gICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIF9saW1pdEltcHVsc2UxID0gMC4wZjtcclxuICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTIgPSAwLjBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHNlZ21lbnQgYXR0YWNoZWQgdG8gYm9keTEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExlbmd0aEFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGQgPSBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSkgLSBHcm91bmRBbmNob3JBO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0IHsgX2xlbmd0aEEgPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBzZWdtZW50IGF0dGFjaGVkIHRvIGJvZHkyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBMZW5ndGhCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gQm9keUIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpIC0gR3JvdW5kQW5jaG9yQjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLkxlbmd0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldCB7IF9sZW5ndGhCID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBwdWxsZXkgcmF0aW8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJhdGlvIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heExlbmd0aEFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbWF4TGVuZ3RoQTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBfbWF4TGVuZ3RoQSA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TGVuZ3RoQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhMZW5ndGhCOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9tYXhMZW5ndGhCID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gX2ltcHVsc2UgKiBfdTI7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBQO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAwLjBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHAxID0gYjEuU3dlZXAuQyArIHIxO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHAyID0gYjIuU3dlZXAuQyArIHIyO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBzMSA9IEdyb3VuZEFuY2hvckE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgczIgPSBHcm91bmRBbmNob3JCO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwdWxsZXkgYXhlcy5cclxuICAgICAgICAgICAgX3UxID0gcDEgLSBzMTtcclxuICAgICAgICAgICAgX3UyID0gcDIgLSBzMjtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGxlbmd0aDEgPSBfdTEuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGZsb2F0IGxlbmd0aDIgPSBfdTIuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91MSAqPSAxLjBmIC8gbGVuZ3RoMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91MSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPiBTZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdTIgKj0gMS4wZiAvIGxlbmd0aDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdTIgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IEMgPSBfYW50IC0gbGVuZ3RoMSAtIFJhdGlvICogbGVuZ3RoMjtcclxuICAgICAgICAgICAgaWYgKEMgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3N0YXRlID0gTGltaXRTdGF0ZS5BdFVwcGVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA8IE1heExlbmd0aEEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlMSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgICAgICAgICBfbGltaXRJbXB1bHNlMSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZTEgPSBMaW1pdFN0YXRlLkF0VXBwZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGgyIDwgTWF4TGVuZ3RoQilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUyID0gTGltaXRTdGF0ZS5JbmFjdGl2ZTtcclxuICAgICAgICAgICAgICAgIF9saW1pdEltcHVsc2UyID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlMiA9IExpbWl0U3RhdGUuQXRVcHBlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cclxuICAgICAgICAgICAgZmxvYXQgY3IxdTEgPSBNYXRoVXRpbHMuQ3Jvc3MocjEsIF91MSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGNyMnUyID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfdTIpO1xyXG5cclxuICAgICAgICAgICAgX2xpbWl0TWFzczEgPSBiMS5JbnZNYXNzICsgYjEuSW52SSAqIGNyMXUxICogY3IxdTE7XHJcbiAgICAgICAgICAgIF9saW1pdE1hc3MyID0gYjIuSW52TWFzcyArIGIyLkludkkgKiBjcjJ1MiAqIGNyMnUyO1xyXG4gICAgICAgICAgICBfcHVsbGV5TWFzcyA9IF9saW1pdE1hc3MxICsgUmF0aW8gKiBSYXRpbyAqIF9saW1pdE1hc3MyO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoX2xpbWl0TWFzczEgPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KF9saW1pdE1hc3MyID4gU2V0dGluZ3MuRXBzaWxvbik7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChfcHVsbGV5TWFzcyA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICBfbGltaXRNYXNzMSA9IDEuMGYgLyBfbGltaXRNYXNzMTtcclxuICAgICAgICAgICAgX2xpbWl0TWFzczIgPSAxLjBmIC8gX2xpbWl0TWFzczI7XHJcbiAgICAgICAgICAgIF9wdWxsZXlNYXNzID0gMS4wZiAvIF9wdWxsZXlNYXNzO1xyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCB2YXJpYWJsZSB0aW1lIHN0ZXBzLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTEgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTIgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdhcm0gc3RhcnRpbmcuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAxID0gLShfaW1wdWxzZSArIF9saW1pdEltcHVsc2UxKSAqIF91MTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUDIgPSAoLVJhdGlvICogX2ltcHVsc2UgLSBfbGltaXRJbXB1bHNlMikgKiBfdTI7XHJcbiAgICAgICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIxLkludk1hc3MgKiBQMTtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIxLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIFAxKTtcclxuICAgICAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52TWFzcyAqIFAyO1xyXG4gICAgICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMiwgUDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTEgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTIgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3N0YXRlID09IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2MSA9IGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKyBNYXRoVXRpbHMuQ3Jvc3MoYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwsIHIxKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICsgTWF0aFV0aWxzLkNyb3NzKGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsLCByMik7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IC1WZWN0b3IyLkRvdChfdTEsIHYxKSAtIFJhdGlvICogVmVjdG9yMi5Eb3QoX3UyLCB2Mik7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gX3B1bGxleU1hc3MgKiAoLUNkb3QpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgb2xkSW1wdWxzZSA9IF9pbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSBNYXRoLk1heCgwLjBmLCBfaW1wdWxzZSArIGltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9pbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAxID0gLWltcHVsc2UgKiBfdTE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAyID0gLVJhdGlvICogaW1wdWxzZSAqIF91MjtcclxuICAgICAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjEuSW52TWFzcyAqIFAxO1xyXG4gICAgICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgUDEpO1xyXG4gICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZNYXNzICogUDI7XHJcbiAgICAgICAgICAgICAgICBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIyLCBQMik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZTEgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHYxID0gYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArIE1hdGhVdGlscy5Dcm9zcyhiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCwgcjEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSAtVmVjdG9yMi5Eb3QoX3UxLCB2MSk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9saW1pdE1hc3MxICogQ2RvdDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG9sZEltcHVsc2UgPSBfbGltaXRJbXB1bHNlMTtcclxuICAgICAgICAgICAgICAgIF9saW1pdEltcHVsc2UxID0gTWF0aC5NYXgoMC4wZiwgX2xpbWl0SW1wdWxzZTEgKyBpbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBfbGltaXRJbXB1bHNlMSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQMSA9IC1pbXB1bHNlICogX3UxO1xyXG4gICAgICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMS5JbnZNYXNzICogUDE7XHJcbiAgICAgICAgICAgICAgICBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIxLCBQMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZTIgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHYyID0gYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArIE1hdGhVdGlscy5Dcm9zcyhiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCwgcjIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSAtVmVjdG9yMi5Eb3QoX3UyLCB2Mik7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9saW1pdE1hc3MyICogQ2RvdDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG9sZEltcHVsc2UgPSBfbGltaXRJbXB1bHNlMjtcclxuICAgICAgICAgICAgICAgIF9saW1pdEltcHVsc2UyID0gTWF0aC5NYXgoMC4wZiwgX2xpbWl0SW1wdWxzZTIgKyBpbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBfbGltaXRJbXB1bHNlMiAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQMiA9IC1pbXB1bHNlICogX3UyO1xyXG4gICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZNYXNzICogUDI7XHJcbiAgICAgICAgICAgICAgICBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIyLCBQMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBzMSA9IEdyb3VuZEFuY2hvckE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgczIgPSBHcm91bmRBbmNob3JCO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbGluZWFyRXJyb3IgPSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9zdGF0ZSA9PSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjEsIHhmMjtcclxuICAgICAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAxID0gYjEuU3dlZXAuQyArIHIxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMiA9IGIyLlN3ZWVwLkMgKyByMjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHB1bGxleSBheGVzLlxyXG4gICAgICAgICAgICAgICAgX3UxID0gcDEgLSBzMTtcclxuICAgICAgICAgICAgICAgIF91MiA9IHAyIC0gczI7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgbGVuZ3RoMSA9IF91MS5MZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGxlbmd0aDIgPSBfdTIuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPiBTZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF91MSAqPSAxLjBmIC8gbGVuZ3RoMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdTEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPiBTZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF91MiAqPSAxLjBmIC8gbGVuZ3RoMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdTIgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgQyA9IF9hbnQgLSBsZW5ndGgxIC0gUmF0aW8gKiBsZW5ndGgyO1xyXG4gICAgICAgICAgICAgICAgbGluZWFyRXJyb3IgPSBNYXRoLk1heChsaW5lYXJFcnJvciwgLUMpO1xyXG5cclxuICAgICAgICAgICAgICAgIEMgPSBNYXRoVXRpbHMuQ2xhbXAoQyArIFNldHRpbmdzLkxpbmVhclNsb3AsIC1TZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX3B1bGxleU1hc3MgKiBDO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUDEgPSAtaW1wdWxzZSAqIF91MTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUDIgPSAtUmF0aW8gKiBpbXB1bHNlICogX3UyO1xyXG5cclxuICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkMgKz0gYjEuSW52TWFzcyAqIFAxO1xyXG4gICAgICAgICAgICAgICAgYjEuU3dlZXAuQSArPSBiMS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIxLCBQMSk7XHJcbiAgICAgICAgICAgICAgICBiMi5Td2VlcC5DICs9IGIyLkludk1hc3MgKiBQMjtcclxuICAgICAgICAgICAgICAgIGIyLlN3ZWVwLkEgKz0gYjIuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMiwgUDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGIxLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICBiMi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUxID09IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMSA9IGIxLlN3ZWVwLkMgKyByMTtcclxuXHJcbiAgICAgICAgICAgICAgICBfdTEgPSBwMSAtIHMxO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbGVuZ3RoMSA9IF91MS5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3UxICo9IDEuMGYgLyBsZW5ndGgxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF91MSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDID0gTWF4TGVuZ3RoQSAtIGxlbmd0aDE7XHJcbiAgICAgICAgICAgICAgICBsaW5lYXJFcnJvciA9IE1hdGguTWF4KGxpbmVhckVycm9yLCAtQyk7XHJcbiAgICAgICAgICAgICAgICBDID0gTWF0aFV0aWxzLkNsYW1wKEMgKyBTZXR0aW5ncy5MaW5lYXJTbG9wLCAtU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9saW1pdE1hc3MxICogQztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAxID0gLWltcHVsc2UgKiBfdTE7XHJcbiAgICAgICAgICAgICAgICBiMS5Td2VlcC5DICs9IGIxLkludk1hc3MgKiBQMTtcclxuICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkEgKz0gYjEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgUDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGIxLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZTIgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0geGYyO1xyXG4gICAgICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gYjIuU3dlZXAuQyArIHIyO1xyXG5cclxuICAgICAgICAgICAgICAgIF91MiA9IHAyIC0gczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBsZW5ndGgyID0gX3UyLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGgyID4gU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdTIgKj0gMS4wZiAvIGxlbmd0aDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3UyID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBNYXhMZW5ndGhCIC0gbGVuZ3RoMjtcclxuICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gTWF0aC5NYXgobGluZWFyRXJyb3IsIC1DKTtcclxuICAgICAgICAgICAgICAgIEMgPSBNYXRoVXRpbHMuQ2xhbXAoQyArIFNldHRpbmdzLkxpbmVhclNsb3AsIC1TZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX2xpbWl0TWFzczIgKiBDO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUDIgPSAtaW1wdWxzZSAqIF91MjtcclxuICAgICAgICAgICAgICAgIGIyLlN3ZWVwLkMgKz0gYjIuSW52TWFzcyAqIFAyO1xyXG4gICAgICAgICAgICAgICAgYjIuU3dlZXAuQSArPSBiMi5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIyLCBQMik7XHJcblxyXG4gICAgICAgICAgICAgICAgYjIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVhckVycm9yIDwgU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSByZXZvbHV0ZSBqb2ludCByYWlucyB0byBib2RpZXMgdG8gc2hhcmUgYSBjb21tb24gcG9pbnQgd2hpbGUgdGhleVxyXG4gICAgLy8vIGFyZSBmcmVlIHRvIHJvdGF0ZSBhYm91dCB0aGUgcG9pbnQuIFRoZSByZWxhdGl2ZSByb3RhdGlvbiBhYm91dCB0aGUgc2hhcmVkXHJcbiAgICAvLy8gcG9pbnQgaXMgdGhlIGpvaW50IGFuZ2xlLiBZb3UgY2FuIGxpbWl0IHRoZSByZWxhdGl2ZSByb3RhdGlvbiB3aXRoXHJcbiAgICAvLy8gYSBqb2ludCBsaW1pdCB0aGF0IHNwZWNpZmllcyBhIGxvd2VyIGFuZCB1cHBlciBhbmdsZS4gWW91IGNhbiB1c2UgYSBtb3RvclxyXG4gICAgLy8vIHRvIGRyaXZlIHRoZSByZWxhdGl2ZSByb3RhdGlvbiBhYm91dCB0aGUgc2hhcmVkIHBvaW50LiBBIG1heGltdW0gbW90b3IgdG9ycXVlXHJcbiAgICAvLy8gaXMgcHJvdmlkZWQgc28gdGhhdCBpbmZpbml0ZSBmb3JjZXMgYXJlIG5vdCBnZW5lcmF0ZWQuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFJldm9sdXRlSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQTtcclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JCO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfZW5hYmxlTGltaXQ7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVNb3RvcjtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjMgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBMaW1pdFN0YXRlIF9saW1pdFN0YXRlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xvd2VyQW5nbGU7XHJcbiAgICAgICAgcHJpdmF0ZSBNYXQzMyBfbWFzczsgLy8gZWZmZWN0aXZlIG1hc3MgZm9yIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TW90b3JUb3JxdWU7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yTWFzczsgLy8gZWZmZWN0aXZlIG1hc3MgZm9yIG1vdG9yL2xpbWl0IGFuZ3VsYXIgY29uc3RyYWludC5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvclNwZWVkO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3JlZmVyZW5jZUFuZ2xlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3RtcEZsb2F0MTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3RtcFZlY3RvcjEsIF90bXBWZWN0b3IyO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3VwcGVyQW5nbGU7XHJcblxyXG4gICAgICAgIGludGVybmFsIFJldm9sdXRlSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLlJldm9sdXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplIHRoZSBib2RpZXMgYW5kIGxvY2FsIGFuY2hvci5cclxuICAgICAgICAvLy8gVGhpcyByZXF1aXJlcyBkZWZpbmluZyBhblxyXG4gICAgICAgIC8vLyBhbmNob3IgcG9pbnQgd2hlcmUgdGhlIGJvZGllcyBhcmUgam9pbmVkLiBUaGUgZGVmaW5pdGlvblxyXG4gICAgICAgIC8vLyB1c2VzIGxvY2FsIGFuY2hvciBwb2ludHMgc28gdGhhdCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgLy8vIGNhbiB2aW9sYXRlIHRoZSBjb25zdHJhaW50IHNsaWdodGx5LiBZb3UgYWxzbyBuZWVkIHRvXHJcbiAgICAgICAgLy8vIHNwZWNpZnkgdGhlIGluaXRpYWwgcmVsYXRpdmUgYW5nbGUgZm9yIGpvaW50IGxpbWl0cy4gVGhpc1xyXG4gICAgICAgIC8vLyBoZWxwcyB3aGVuIHNhdmluZyBhbmQgbG9hZGluZyBhIGdhbWUuXHJcbiAgICAgICAgLy8vIFRoZSBsb2NhbCBhbmNob3IgcG9pbnRzIGFyZSBtZWFzdXJlZCBmcm9tIHRoZSBib2R5J3Mgb3JpZ2luXHJcbiAgICAgICAgLy8vIHJhdGhlciB0aGFuIHRoZSBjZW50ZXIgb2YgbWFzcyBiZWNhdXNlOlxyXG4gICAgICAgIC8vLyAxLiB5b3UgbWlnaHQgbm90IGtub3cgd2hlcmUgdGhlIGNlbnRlciBvZiBtYXNzIHdpbGwgYmUuXHJcbiAgICAgICAgLy8vIDIuIGlmIHlvdSBhZGQvcmVtb3ZlIHNoYXBlcyBmcm9tIGEgYm9keSBhbmQgcmVjb21wdXRlIHRoZSBtYXNzLFxyXG4gICAgICAgIC8vLyB0aGUgam9pbnRzIHdpbGwgYmUgYnJva2VuLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj5UaGUgZmlyc3QgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+VGhlIHNlY29uZCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JBXCI+VGhlIGZpcnN0IGJvZHkgYW5jaG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JCXCI+VGhlIHNlY29uZCBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgUmV2b2x1dGVKb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGxvY2FsQW5jaG9yQSwgVmVjdG9yMiBsb2NhbEFuY2hvckIpXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5QSwgYm9keUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuUmV2b2x1dGU7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGFuZ2VkIHRvIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcclxuXHJcbiAgICAgICAgICAgIFJlZmVyZW5jZUFuZ2xlID0gQm9keUIuUm90YXRpb24gLSBCb2R5QS5Sb3RhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIF9pbXB1bHNlID0gVmVjdG9yMy5aZXJvO1xyXG5cclxuICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmVmZXJlbmNlQW5nbGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcmVmZXJlbmNlQW5nbGU7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9yZWZlcmVuY2VBbmdsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBqb2ludCBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludEFuZ2xlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUIuU3dlZXAuQSAtIEJvZHlBLlN3ZWVwLkEgLSBSZWZlcmVuY2VBbmdsZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgam9pbnQgYW5nbGUgc3BlZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFNwZWVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLSBCb2R5QS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJcyB0aGUgam9pbnQgbGltaXQgZW5hYmxlZD9cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgW2xpbWl0IGVuYWJsZWRdOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIExpbWl0RW5hYmxlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVMaW1pdDsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZUxpbWl0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBsb3dlciBqb2ludCBsaW1pdCBpbiByYWRpYW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBMb3dlckxpbWl0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2xvd2VyQW5nbGU7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9sb3dlckFuZ2xlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB1cHBlciBqb2ludCBsaW1pdCBpbiByYWRpYW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBVcHBlckxpbWl0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3VwcGVyQW5nbGU7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF91cHBlckFuZ2xlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSXMgdGhlIGpvaW50IG1vdG9yIGVuYWJsZWQ/XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIFttb3RvciBlbmFibGVkXTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBNb3RvckVuYWJsZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfZW5hYmxlTW90b3I7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9lbmFibGVNb3RvciA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGUgbW90b3Igc3BlZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgc3BlZWQuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTW90b3JTcGVlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9tb3RvclNwZWVkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tb3RvclNwZWVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGUgbWF4aW11bSBtb3RvciB0b3JxdWUsIHVzdWFsbHkgaW4gTi1tLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgdG9ycXVlLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heE1vdG9yVG9ycXVlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX21heE1vdG9yVG9ycXVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhNb3RvclRvcnF1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgbW90b3IgdG9ycXVlLCB1c3VhbGx5IGluIE4tbS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTW90b3JUb3JxdWVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbW90b3JJbXB1bHNlOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gbmV3IFZlY3RvcjIoX2ltcHVsc2UuWCwgX2ltcHVsc2UuWSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBQO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBfaW1wdWxzZS5aO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVNb3RvciB8fCBfZW5hYmxlTGltaXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFlvdSBjYW5ub3QgY3JlYXRlIGEgcm90YXRpb24gbGltaXQgYmV0d2VlbiBib2RpZXMgdGhhdFxyXG4gICAgICAgICAgICAgICAgLy8gYm90aCBoYXZlIGZpeGVkIHJvdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGIxLkludkkgPiAwLjBmIHx8IGIyLkludkkgPiAwLjBmKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxyXG4gICAgICAgICAgICAvKlRyYW5zZm9ybSB4ZjEsIHhmMjtcclxuICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG4gICAgICAgICAgICBiMi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7Ki9cclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIGIxLlhmLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjIuWGYuUiwgTG9jYWxBbmNob3JCIC0gYjIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXHJcbiAgICAgICAgICAgIC8vICAgICBbIDAgICAgICAgLTEgMCAgICAgICAxXVxyXG4gICAgICAgICAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cclxuXHJcbiAgICAgICAgICAgIC8vIE1hdGxhYlxyXG4gICAgICAgICAgICAvLyBLID0gWyBtMStyMXleMippMSttMityMnleMippMiwgIC1yMXkqaTEqcjF4LXIyeSppMipyMngsICAgICAgICAgIC1yMXkqaTEtcjJ5KmkyXVxyXG4gICAgICAgICAgICAvLyAgICAgWyAgLXIxeSppMSpyMXgtcjJ5KmkyKnIyeCwgbTErcjF4XjIqaTErbTIrcjJ4XjIqaTIsICAgICAgICAgICByMXgqaTErcjJ4KmkyXVxyXG4gICAgICAgICAgICAvLyAgICAgWyAgICAgICAgICAtcjF5KmkxLXIyeSppMiwgICAgICAgICAgIHIxeCppMStyMngqaTIsICAgICAgICAgICAgICAgICAgIGkxK2kyXVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgbTEgPSBiMS5JbnZNYXNzLCBtMiA9IGIyLkludk1hc3M7XHJcbiAgICAgICAgICAgIGZsb2F0IGkxID0gYjEuSW52SSwgaTIgPSBiMi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgX21hc3MuQ29sMS5YID0gbTEgKyBtMiArIHIxLlkgKiByMS5ZICogaTEgKyByMi5ZICogcjIuWSAqIGkyO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlggPSAtcjEuWSAqIHIxLlggKiBpMSAtIHIyLlkgKiByMi5YICogaTI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWCA9IC1yMS5ZICogaTEgLSByMi5ZICogaTI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDEuWSA9IF9tYXNzLkNvbDIuWDtcclxuICAgICAgICAgICAgX21hc3MuQ29sMi5ZID0gbTEgKyBtMiArIHIxLlggKiByMS5YICogaTEgKyByMi5YICogcjIuWCAqIGkyO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wzLlkgPSByMS5YICogaTEgKyByMi5YICogaTI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDEuWiA9IF9tYXNzLkNvbDMuWDtcclxuICAgICAgICAgICAgX21hc3MuQ29sMi5aID0gX21hc3MuQ29sMy5ZO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wzLlogPSBpMSArIGkyO1xyXG5cclxuICAgICAgICAgICAgX21vdG9yTWFzcyA9IGkxICsgaTI7XHJcbiAgICAgICAgICAgIGlmIChfbW90b3JNYXNzID4gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX21vdG9yTWFzcyA9IDEuMGYgLyBfbW90b3JNYXNzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVMaW1pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgam9pbnRBbmdsZSA9IGIyLlN3ZWVwLkEgLSBiMS5Td2VlcC5BIC0gUmVmZXJlbmNlQW5nbGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMoX3VwcGVyQW5nbGUgLSBfbG93ZXJBbmdsZSkgPCAyLjBmICogU2V0dGluZ3MuQW5ndWxhclNsb3ApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkVxdWFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRBbmdsZSA8PSBfbG93ZXJBbmdsZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5BdExvd2VyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5BdExvd2VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRBbmdsZSA+PSBfdXBwZXJBbmdsZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5BdFVwcGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5JbmFjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5JbmFjdGl2ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IG5ldyBWZWN0b3IyKF9pbXB1bHNlLlgsIF9pbXB1bHNlLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgLT0gbTEgKiBQO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMSwgcmVmIFAsIG91dCBfdG1wRmxvYXQxKTtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGkxICogKCAvKiByMSB4IFAgKi9fdG1wRmxvYXQxICsgX21vdG9ySW1wdWxzZSArIF9pbXB1bHNlLlopO1xyXG5cclxuICAgICAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gbTIgKiBQO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMiwgcmVmIFAsIG91dCBfdG1wRmxvYXQxKTtcclxuICAgICAgICAgICAgICAgIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGkyICogKCAvKiByMiB4IFAgKi9fdG1wRmxvYXQxICsgX21vdG9ySW1wdWxzZSArIF9pbXB1bHNlLlopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSBWZWN0b3IzLlplcm87XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYjIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3MSA9IGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgdzIgPSBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG0xID0gYjEuSW52TWFzcywgbTIgPSBiMi5JbnZNYXNzO1xyXG4gICAgICAgICAgICBmbG9hdCBpMSA9IGIxLkludkksIGkyID0gYjIuSW52STtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIG1vdG9yIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTW90b3IgJiYgX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5FcXVhbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IHcyIC0gdzEgLSBfbW90b3JTcGVlZDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfbW90b3JNYXNzICogKC1DZG90KTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG9sZEltcHVsc2UgPSBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiBfbWF4TW90b3JUb3JxdWU7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gTWF0aFV0aWxzLkNsYW1wKF9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX21vdG9ySW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgdzEgLT0gaTEgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgdzIgKz0gaTIgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW1pdCBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0ICYmIF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuSW5hY3RpdmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8qVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG4gICAgICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpOyovXHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjEuWGYuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjIuWGYuUiwgTG9jYWxBbmNob3JCIC0gYjIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyh3MiwgcmVmIHIyLCBvdXQgX3RtcFZlY3RvcjIpO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHcxLCByZWYgcjEsIG91dCBfdG1wVmVjdG9yMSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIENkb3QxID0gdjIgKyAvKiB3MiB4IHIyICovIF90bXBWZWN0b3IyIC0gdjEgLSAvKiB3MSB4IHIxICovIF90bXBWZWN0b3IxO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdDIgPSB3MiAtIHcxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMyBDZG90ID0gbmV3IFZlY3RvcjMoQ2RvdDEuWCwgQ2RvdDEuWSwgQ2RvdDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjMgaW1wdWxzZSA9IF9tYXNzLlNvbHZlMzMoLUNkb3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkVxdWFsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkF0TG93ZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3SW1wdWxzZSA9IF9pbXB1bHNlLlogKyBpbXB1bHNlLlo7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0ltcHVsc2UgPCAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiByZWR1Y2VkID0gX21hc3MuU29sdmUyMigtQ2RvdDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLlggPSByZWR1Y2VkLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2UuWSA9IHJlZHVjZWQuWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS5aID0gLV9pbXB1bHNlLlo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggKz0gcmVkdWNlZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5ZICs9IHJlZHVjZWQuWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ld0ltcHVsc2UgPSBfaW1wdWxzZS5aICsgaW1wdWxzZS5aO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbXB1bHNlID4gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcmVkdWNlZCA9IF9tYXNzLlNvbHZlMjIoLUNkb3QxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS5YID0gcmVkdWNlZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLlkgPSByZWR1Y2VkLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2UuWiA9IC1faW1wdWxzZS5aO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5YICs9IHJlZHVjZWQuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWSArPSByZWR1Y2VkLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBuZXcgVmVjdG9yMihpbXB1bHNlLlgsIGltcHVsc2UuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEgLT0gbTEgKiBQO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMSwgcmVmIFAsIG91dCBfdG1wRmxvYXQxKTtcclxuICAgICAgICAgICAgICAgIHcxIC09IGkxICogKCAvKiByMSB4IFAgKi9fdG1wRmxvYXQxICsgaW1wdWxzZS5aKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2MiArPSBtMiAqIFA7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIyLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICAgICAgdzIgKz0gaTIgKiAoIC8qIHIyIHggUCAqL190bXBGbG9hdDEgKyBpbXB1bHNlLlopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLypUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgICAgICBiMi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7Ki9cclxuXHJcbiAgICAgICAgICAgICAgICBfdG1wVmVjdG9yMSA9IExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyO1xyXG4gICAgICAgICAgICAgICAgX3RtcFZlY3RvcjIgPSBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcjtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIGIxLlhmLlIsIHJlZiBfdG1wVmVjdG9yMSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBiMi5YZi5SLCByZWYgX3RtcFZlY3RvcjIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyh3MiwgcmVmIHIyLCBvdXQgX3RtcFZlY3RvcjIpO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHcxLCByZWYgcjEsIG91dCBfdG1wVmVjdG9yMSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIENkb3QgPSB2MiArIC8qIHcyIHggcjIgKi8gX3RtcFZlY3RvcjIgLSB2MSAtIC8qIHcxIHggcjEgKi8gX3RtcFZlY3RvcjE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGltcHVsc2UgPSBfbWFzcy5Tb2x2ZTIyKC1DZG90KTtcclxuXHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZS5YICs9IGltcHVsc2UuWDtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlkgKz0gaW1wdWxzZS5ZO1xyXG5cclxuICAgICAgICAgICAgICAgIHYxIC09IG0xICogaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjEsIHJlZiBpbXB1bHNlLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgICAgICB3MSAtPSBpMSAqIC8qIHIxIHggaW1wdWxzZSAqLyBfdG1wRmxvYXQxO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyICs9IG0yICogaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjIsIHJlZiBpbXB1bHNlLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgICAgICB3MiArPSBpMiAqIC8qIHIyIHggaW1wdWxzZSAqLyBfdG1wRmxvYXQxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsID0gdjE7XHJcbiAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gdzE7XHJcbiAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2MjtcclxuICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3MjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiBibG9jayBzb2x2ZSB3aXRoIGxpbWl0LiBDT01FIE9OIEVSSU5cclxuXHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgYW5ndWxhckVycm9yID0gMC4wZjtcclxuICAgICAgICAgICAgZmxvYXQgcG9zaXRpb25FcnJvcjtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIGFuZ3VsYXIgbGltaXQgY29uc3RyYWludC5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVMaW1pdCAmJiBfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkluYWN0aXZlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBhbmdsZSA9IGIyLlN3ZWVwLkEgLSBiMS5Td2VlcC5BIC0gUmVmZXJlbmNlQW5nbGU7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBsaW1pdEltcHVsc2UgPSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkVxdWFsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBNYXRoVXRpbHMuQ2xhbXAoYW5nbGUgLSBfbG93ZXJBbmdsZSwgLVNldHRpbmdzLk1heEFuZ3VsYXJDb3JyZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0dGluZ3MuTWF4QW5ndWxhckNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9IC1fbW90b3JNYXNzICogQztcclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSAoZmxvYXQpTWF0aC5BYnMoQyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkF0TG93ZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgQyA9IGFuZ2xlIC0gX2xvd2VyQW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhckVycm9yID0gLUM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxyXG4gICAgICAgICAgICAgICAgICAgIEMgPSBNYXRoVXRpbHMuQ2xhbXAoQyArIFNldHRpbmdzLkFuZ3VsYXJTbG9wLCAtU2V0dGluZ3MuTWF4QW5ndWxhckNvcnJlY3Rpb24sIDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9IC1fbW90b3JNYXNzICogQztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBDID0gYW5nbGUgLSBfdXBwZXJBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSBDO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cclxuICAgICAgICAgICAgICAgICAgICBDID0gTWF0aFV0aWxzLkNsYW1wKEMgLSBTZXR0aW5ncy5Bbmd1bGFyU2xvcCwgMC4wZiwgU2V0dGluZ3MuTWF4QW5ndWxhckNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0SW1wdWxzZSA9IC1fbW90b3JNYXNzICogQztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBiMS5Td2VlcC5BIC09IGIxLkludkkgKiBsaW1pdEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBiMi5Td2VlcC5BICs9IGIyLkludkkgKiBsaW1pdEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIGIyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8qVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG4gICAgICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpOyovXHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjEuWGYuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjIuWGYuUiwgTG9jYWxBbmNob3JCIC0gYjIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgQyA9IGIyLlN3ZWVwLkMgKyByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXJyb3IgPSBDLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGludk1hc3MxID0gYjEuSW52TWFzcywgaW52TWFzczIgPSBiMi5JbnZNYXNzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52STEgPSBiMS5JbnZJLCBpbnZJMiA9IGIyLkludkk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGxhcmdlIGRldGFjaG1lbnQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBrX2FsbG93ZWRTdHJldGNoID0gMTAuMGYgKiBTZXR0aW5ncy5MaW5lYXJTbG9wO1xyXG4gICAgICAgICAgICAgICAgaWYgKEMuTGVuZ3RoU3F1YXJlZCgpID4ga19hbGxvd2VkU3RyZXRjaCAqIGtfYWxsb3dlZFN0cmV0Y2gpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgcGFydGljbGUgc29sdXRpb24gKG5vIHJvdGF0aW9uKS5cclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHUgPSBDO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgayA9IGludk1hc3MxICsgaW52TWFzczI7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGsgPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBtID0gMS4wZiAvIGs7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlMiA9IG0gKiAoLUMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IGtfYmV0YSA9IDAuNWY7XHJcbiAgICAgICAgICAgICAgICAgICAgYjEuU3dlZXAuQyAtPSBrX2JldGEgKiBpbnZNYXNzMSAqIGltcHVsc2UyO1xyXG4gICAgICAgICAgICAgICAgICAgIGIyLlN3ZWVwLkMgKz0ga19iZXRhICogaW52TWFzczIgKiBpbXB1bHNlMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgQyA9IGIyLlN3ZWVwLkMgKyByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBNYXQyMiBLMSA9IG5ldyBNYXQyMihuZXcgVmVjdG9yMihpbnZNYXNzMSArIGludk1hc3MyLCAwLjBmKSwgbmV3IFZlY3RvcjIoMC4wZiwgaW52TWFzczEgKyBpbnZNYXNzMikpO1xyXG4gICAgICAgICAgICAgICAgTWF0MjIgSzIgPSBuZXcgTWF0MjIobmV3IFZlY3RvcjIoaW52STEgKiByMS5ZICogcjEuWSwgLWludkkxICogcjEuWCAqIHIxLlkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoLWludkkxICogcjEuWCAqIHIxLlksIGludkkxICogcjEuWCAqIHIxLlgpKTtcclxuICAgICAgICAgICAgICAgIE1hdDIyIEszID0gbmV3IE1hdDIyKG5ldyBWZWN0b3IyKGludkkyICogcjIuWSAqIHIyLlksIC1pbnZJMiAqIHIyLlggKiByMi5ZKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKC1pbnZJMiAqIHIyLlggKiByMi5ZLCBpbnZJMiAqIHIyLlggKiByMi5YKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgTWF0MjIgS2E7XHJcbiAgICAgICAgICAgICAgICBNYXQyMi5BZGQocmVmIEsxLCByZWYgSzIsIG91dCBLYSk7XHJcblxyXG4gICAgICAgICAgICAgICAgTWF0MjIgSztcclxuICAgICAgICAgICAgICAgIE1hdDIyLkFkZChyZWYgS2EsIHJlZiBLMywgb3V0IEspO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGltcHVsc2UgPSBLLlNvbHZlKC1DKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS5Td2VlcC5DIC09IGIxLkludk1hc3MgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMSwgcmVmIGltcHVsc2UsIG91dCBfdG1wRmxvYXQxKTtcclxuICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkEgLT0gYjEuSW52SSAqIC8qIHIxIHggaW1wdWxzZSAqLyBfdG1wRmxvYXQxO1xyXG5cclxuICAgICAgICAgICAgICAgIGIyLlN3ZWVwLkMgKz0gYjIuSW52TWFzcyAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIyLCByZWYgaW1wdWxzZSwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICAgICAgYjIuU3dlZXAuQSArPSBiMi5JbnZJICogLyogcjIgeCBpbXB1bHNlICovIF90bXBGbG9hdDE7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIGIyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbkVycm9yIDw9IFNldHRpbmdzLkxpbmVhclNsb3AgJiYgYW5ndWxhckVycm9yIDw9IFNldHRpbmdzLkFuZ3VsYXJTbG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMTAgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbVxyXG4qXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8gTGltaXQ6XHJcbiAgICAvLyBDID0gbm9ybShwQiAtIHBBKSAtIExcclxuICAgIC8vIHUgPSAocEIgLSBwQSkgLyBub3JtKHBCIC0gcEEpXHJcbiAgICAvLyBDZG90ID0gZG90KHUsIHZCICsgY3Jvc3Mod0IsIHJCKSAtIHZBIC0gY3Jvc3Mod0EsIHJBKSlcclxuICAgIC8vIEogPSBbLXUgLWNyb3NzKHJBLCB1KSB1IGNyb3NzKHJCLCB1KV1cclxuICAgIC8vIEsgPSBKICogaW52TSAqIEpUXHJcbiAgICAvLyAgID0gaW52TWFzc0EgKyBpbnZJQSAqIGNyb3NzKHJBLCB1KV4yICsgaW52TWFzc0IgKyBpbnZJQiAqIGNyb3NzKHJCLCB1KV4yXHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgcm9wZSBqb2ludCBlbmZvcmNlcyBhIG1heGltdW0gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAgICAvLy8gb24gdHdvIGJvZGllcy4gSXQgaGFzIG5vIG90aGVyIGVmZmVjdC5cclxuICAgIC8vLyBXYXJuaW5nOiBpZiB5b3UgYXR0ZW1wdCB0byBjaGFuZ2UgdGhlIG1heGltdW0gbGVuZ3RoIGR1cmluZ1xyXG4gICAgLy8vIHRoZSBzaW11bGF0aW9uIHlvdSB3aWxsIGdldCBzb21lIG5vbi1waHlzaWNhbCBiZWhhdmlvci5cclxuICAgIC8vLyBBIG1vZGVsIHRoYXQgd291bGQgYWxsb3cgeW91IHRvIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgbGVuZ3RoXHJcbiAgICAvLy8gd291bGQgaGF2ZSBzb21lIHNwb25naW5lc3MsIHNvIEkgY2hvc2Ugbm90IHRvIGltcGxlbWVudCBpdFxyXG4gICAgLy8vIHRoYXQgd2F5LiBTZWUgYjJEaXN0YW5jZUpvaW50IGlmIHlvdSB3YW50IHRvIGR5bmFtaWNhbGx5XHJcbiAgICAvLy8gY29udHJvbCBsZW5ndGguXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFJvcGVKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQjtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9sZW5ndGg7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9yQSwgX3JCO1xyXG4gICAgICAgIHByaXZhdGUgTGltaXRTdGF0ZSBfc3RhdGU7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF91O1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBSb3BlSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLlJvcGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgUm9wZUpvaW50KEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxBbmNob3JBLCBWZWN0b3IyIGxvY2FsQW5jaG9yQilcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHlBLCBib2R5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5Sb3BlO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IFdvcmxkQW5jaG9yQiAtIFdvcmxkQW5jaG9yQTtcclxuICAgICAgICAgICAgTWF4TGVuZ3RoID0gZC5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIF9tYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICBfc3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICBfbGVuZ3RoID0gMC4wZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyBHZXQgdGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSByb3BlLlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhMZW5ndGggeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTGltaXRTdGF0ZSBTdGF0ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9zdGF0ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHNlYWxlZCBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHNlYWxlZCBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52RHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKGludkR0ICogX2ltcHVsc2UpICogX3U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52RHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgIGJBLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjI7XHJcbiAgICAgICAgICAgIGJCLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIF9yQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGJBLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgX3JCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjIuUiwgTG9jYWxBbmNob3JCIC0gYkIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gUm9wZSBheGlzXHJcbiAgICAgICAgICAgIF91ID0gYkIuU3dlZXAuQyArIF9yQiAtIGJBLlN3ZWVwLkMgLSBfckE7XHJcblxyXG4gICAgICAgICAgICBfbGVuZ3RoID0gX3UuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBDID0gX2xlbmd0aCAtIE1heExlbmd0aDtcclxuICAgICAgICAgICAgaWYgKEMgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSBMaW1pdFN0YXRlLkF0VXBwZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2xlbmd0aCA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91ICo9IDEuMGYgLyBfbGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3UgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgZWZmZWN0aXZlIG1hc3MuXHJcbiAgICAgICAgICAgIGZsb2F0IGNyQSA9IE1hdGhVdGlscy5Dcm9zcyhfckEsIF91KTtcclxuICAgICAgICAgICAgZmxvYXQgY3JCID0gTWF0aFV0aWxzLkNyb3NzKF9yQiwgX3UpO1xyXG4gICAgICAgICAgICBmbG9hdCBpbnZNYXNzID0gYkEuSW52TWFzcyArIGJBLkludkkgKiBjckEgKiBjckEgKyBiQi5JbnZNYXNzICsgYkIuSW52SSAqIGNyQiAqIGNyQjtcclxuXHJcbiAgICAgICAgICAgIF9tYXNzID0gaW52TWFzcyAhPSAwLjBmID8gMS4wZiAvIGludk1hc3MgOiAwLjBmO1xyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgdGhlIGltcHVsc2UgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZSAqIF91O1xyXG4gICAgICAgICAgICAgICAgYkEuTGluZWFyVmVsb2NpdHkgLT0gYkEuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgICAgICBiQS5Bbmd1bGFyVmVsb2NpdHkgLT0gYkEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhfckEsIFApO1xyXG4gICAgICAgICAgICAgICAgYkIuTGluZWFyVmVsb2NpdHkgKz0gYkIuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHkgKz0gYkIuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhfckIsIFApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2RvdCA9IGRvdCh1LCB2ICsgY3Jvc3ModywgcikpXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdkEgPSBiQS5MaW5lYXJWZWxvY2l0eSArIE1hdGhVdGlscy5Dcm9zcyhiQS5Bbmd1bGFyVmVsb2NpdHksIF9yQSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdkIgPSBiQi5MaW5lYXJWZWxvY2l0eSArIE1hdGhVdGlscy5Dcm9zcyhiQi5Bbmd1bGFyVmVsb2NpdHksIF9yQik7XHJcbiAgICAgICAgICAgIGZsb2F0IEMgPSBfbGVuZ3RoIC0gTWF4TGVuZ3RoO1xyXG4gICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX3UsIHZCIC0gdkEpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlZGljdGl2ZSBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICBpZiAoQyA8IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENkb3QgKz0gc3RlcC5pbnZfZHQgKiBDO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9tYXNzICogQ2RvdDtcclxuICAgICAgICAgICAgZmxvYXQgb2xkSW1wdWxzZSA9IF9pbXB1bHNlO1xyXG4gICAgICAgICAgICBfaW1wdWxzZSA9IE1hdGguTWluKDAuMGYsIF9pbXB1bHNlICsgaW1wdWxzZSk7XHJcbiAgICAgICAgICAgIGltcHVsc2UgPSBfaW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX3U7XHJcbiAgICAgICAgICAgIGJBLkxpbmVhclZlbG9jaXR5IC09IGJBLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiQS5Bbmd1bGFyVmVsb2NpdHkgLT0gYkEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhfckEsIFApO1xyXG4gICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eSArPSBiQi5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgYkIuQW5ndWxhclZlbG9jaXR5ICs9IGJCLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MoX3JCLCBQKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgYkEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMjtcclxuICAgICAgICAgICAgYkIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGJBLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByQiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGJCLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdSA9IGJCLlN3ZWVwLkMgKyByQiAtIGJBLlN3ZWVwLkMgLSByQTtcclxuXHJcblxyXG4gICAgICAgICAgICBmbG9hdCBsZW5ndGggPSB1Lkxlbmd0aCgpO1xyXG4gICAgICAgICAgICB1Lk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgQyA9IGxlbmd0aCAtIE1heExlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIEMgPSBNYXRoVXRpbHMuQ2xhbXAoQywgMC4wZiwgU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbik7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9tYXNzICogQztcclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIHU7XHJcblxyXG4gICAgICAgICAgICBiQS5Td2VlcC5DIC09IGJBLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiQS5Td2VlcC5BIC09IGJBLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MockEsIFApO1xyXG4gICAgICAgICAgICBiQi5Td2VlcC5DICs9IGJCLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiQi5Td2VlcC5BICs9IGJCLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MockIsIFApO1xyXG5cclxuICAgICAgICAgICAgYkEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgYkIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggLSBNYXhMZW5ndGggPCBTZXR0aW5ncy5MaW5lYXJTbG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIGRpc3RhbmNlIGpvaW50IGNvbnRyYWlucyB0d28gcG9pbnRzIG9uIHR3byBib2RpZXNcclxuICAgIC8vLyB0byByZW1haW4gYXQgYSBmaXhlZCBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuIFlvdSBjYW4gdmlld1xyXG4gICAgLy8vIHRoaXMgYXMgYSBtYXNzbGVzcywgcmlnaWQgcm9kLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBTbGlkZXJKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgLy8gMS1EIGNvbnN0cmFpbmVkIHN5c3RlbVxyXG4gICAgICAgIC8vIG0gKHYyIC0gdjEpID0gbGFtYmRhXHJcbiAgICAgICAgLy8gdjIgKyAoYmV0YS9oKSAqIHgxICsgZ2FtbWEgKiBsYW1iZGEgPSAwLCBnYW1tYSBoYXMgdW5pdHMgb2YgaW52ZXJzZSBtYXNzLlxyXG4gICAgICAgIC8vIHgyID0geDEgKyBoICogdjJcclxuXHJcbiAgICAgICAgLy8gMS1EIG1hc3MtZGFtcGVyLXNwcmluZyBzeXN0ZW1cclxuICAgICAgICAvLyBtICh2MiAtIHYxKSArIGggKiBkICogdjIgKyBoICogayAqIFxyXG5cclxuICAgICAgICAvLyBDID0gbm9ybShwMiAtIHAxKSAtIExcclxuICAgICAgICAvLyB1ID0gKHAyIC0gcDEpIC8gbm9ybShwMiAtIHAxKVxyXG4gICAgICAgIC8vIENkb3QgPSBkb3QodSwgdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpKVxyXG4gICAgICAgIC8vIEogPSBbLXUgLWNyb3NzKHIxLCB1KSB1IGNyb3NzKHIyLCB1KV1cclxuICAgICAgICAvLyBLID0gSiAqIGludk0gKiBKVFxyXG4gICAgICAgIC8vICAgPSBpbnZNYXNzMSArIGludkkxICogY3Jvc3MocjEsIHUpXjIgKyBpbnZNYXNzMiArIGludkkyICogY3Jvc3MocjIsIHUpXjJcclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckI7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYmlhcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9nYW1tYTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9pbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF91O1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBTbGlkZXJKb2ludCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuU2xpZGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgPHNlZSBjcmVmPVwiU2xpZGVySm9pbnRcIi8+IGNsYXNzLlxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBEbyBub3QgdXNlIGEgemVybyBvciBzaG9ydCBsZW5ndGguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPlRoZSBmaXJzdCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj5UaGUgc2Vjb25kIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckFcIj5UaGUgZmlyc3QgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckJcIj5UaGUgc2Vjb25kIGJvZHkgYW5jaG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWluTGVuZ3RoXCI+VGhlIG1pbmltdW0gbGVuZ3RoIGJldHdlZW4gYW5jaG9ycG9pbnRzPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhsZW5ndGhcIj5UaGUgbWF4aW11bSBsZW5ndGggYmV0d2VlbiBhbmNob3Jwb2ludHMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgU2xpZGVySm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbEFuY2hvckEsIFZlY3RvcjIgbG9jYWxBbmNob3JCLCBmbG9hdCBtaW5MZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG1heGxlbmd0aClcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHlBLCBib2R5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5TbGlkZXI7XHJcblxyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcclxuICAgICAgICAgICAgTWF4TGVuZ3RoID0gbWF4bGVuZ3RoO1xyXG4gICAgICAgICAgICBNaW5MZW5ndGggPSBtaW5MZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIGxlbmd0aCBiZXR3ZWVuIHRoZSBhbmNob3IgcG9pbnRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgbGVuZ3RoLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heExlbmd0aCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG1pbmltYWwgbGVuZ3RoIGJldHdlZW4gdGhlIGFuY2hvciBwb2ludHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBsZW5ndGguPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWluTGVuZ3RoIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWFzcy1zcHJpbmctZGFtcGVyIGZyZXF1ZW5jeSBpbiBIZXJ0ei5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGZyZXF1ZW5jeS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBGcmVxdWVuY3kgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBkYW1waW5nIHJhdGlvLiAwID0gbm8gZGFtcGluZywgMSA9IGNyaXRpY2FsIGRhbXBpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBkYW1waW5nIHJhdGlvLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IERhbXBpbmdSYXRpbyB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpOyB9XHJcbiAgICAgICAgICAgIHNldCB7IERlYnVnLkFzc2VydChmYWxzZSwgXCJZb3UgY2FuJ3Qgc2V0IHRoZSB3b3JsZCBhbmNob3Igb24gdGhpcyBqb2ludCB0eXBlLlwiKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIEYgPSAoaW52X2R0ICogX2ltcHVsc2UpICogX3U7XHJcbiAgICAgICAgICAgIHJldHVybiBGO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAwLjBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzIG1hdHJpeC5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgX3UgPSBiMi5Td2VlcC5DICsgcjIgLSBiMS5Td2VlcC5DIC0gcjE7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgc2luZ3VsYXJpdHkuXHJcbiAgICAgICAgICAgIGZsb2F0IGxlbmd0aCA9IF91Lkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IE1heExlbmd0aCAmJiBsZW5ndGggPiBNaW5MZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91ICo9IDEuMGYgLyBsZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgY3IxdSA9IE1hdGhVdGlscy5Dcm9zcyhyMSwgX3UpO1xyXG4gICAgICAgICAgICBmbG9hdCBjcjJ1ID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfdSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGludk1hc3MgPSBiMS5JbnZNYXNzICsgYjEuSW52SSAqIGNyMXUgKiBjcjF1ICsgYjIuSW52TWFzcyArIGIyLkludkkgKiBjcjJ1ICogY3IydTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGludk1hc3MgPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgX21hc3MgPSBpbnZNYXNzICE9IDAuMGYgPyAxLjBmIC8gaW52TWFzcyA6IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBpZiAoRnJlcXVlbmN5ID4gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQyA9IGxlbmd0aCAtIE1heExlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGcmVxdWVuY3lcclxuICAgICAgICAgICAgICAgIGZsb2F0IG9tZWdhID0gMi4wZiAqIFNldHRpbmdzLlBpICogRnJlcXVlbmN5O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERhbXBpbmcgY29lZmZpY2llbnRcclxuICAgICAgICAgICAgICAgIGZsb2F0IGQgPSAyLjBmICogX21hc3MgKiBEYW1waW5nUmF0aW8gKiBvbWVnYTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTcHJpbmcgc3RpZmZuZXNzXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrID0gX21hc3MgKiBvbWVnYSAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG1hZ2ljIGZvcm11bGFzXHJcbiAgICAgICAgICAgICAgICBfZ2FtbWEgPSBzdGVwLmR0ICogKGQgKyBzdGVwLmR0ICogayk7XHJcbiAgICAgICAgICAgICAgICBfZ2FtbWEgPSBfZ2FtbWEgIT0gMC4wZiA/IDEuMGYgLyBfZ2FtbWEgOiAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX2JpYXMgPSBDICogc3RlcC5kdCAqIGsgKiBfZ2FtbWE7XHJcblxyXG4gICAgICAgICAgICAgICAgX21hc3MgPSBpbnZNYXNzICsgX2dhbW1hO1xyXG4gICAgICAgICAgICAgICAgX21hc3MgPSBfbWFzcyAhPSAwLjBmID8gMS4wZiAvIF9tYXNzIDogMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgdGhlIGltcHVsc2UgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZSAqIF91O1xyXG4gICAgICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBiMS5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIFApO1xyXG4gICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgICAgIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjIsIFApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBiMi5Td2VlcC5DICsgcjIgLSBiMS5Td2VlcC5DIC0gcjE7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBsZW5ndGggPSBkLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IE1heExlbmd0aCAmJiBsZW5ndGggPiBNaW5MZW5ndGgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2RvdCA9IGRvdCh1LCB2ICsgY3Jvc3ModywgcikpXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsICsgTWF0aFV0aWxzLkNyb3NzKGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsLCByMSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICsgTWF0aFV0aWxzLkNyb3NzKGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsLCByMik7XHJcbiAgICAgICAgICAgIGZsb2F0IENkb3QgPSBWZWN0b3IyLkRvdChfdSwgdjIgLSB2MSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9tYXNzICogKENkb3QgKyBfYmlhcyArIF9nYW1tYSAqIF9pbXB1bHNlKTtcclxuICAgICAgICAgICAgX2ltcHVsc2UgKz0gaW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfdTtcclxuICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBiMS5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gYjEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgUCk7XHJcbiAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjIsIFApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKEZyZXF1ZW5jeSA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHBvc2l0aW9uIGNvcnJlY3Rpb24gZm9yIHNvZnQgZGlzdGFuY2UgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGIyLlN3ZWVwLkMgKyByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGxlbmd0aCA9IGQuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgTWF4TGVuZ3RoICYmIGxlbmd0aCA+IE1pbkxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT0gMC4wZilcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgZCAvPSBsZW5ndGg7XHJcbiAgICAgICAgICAgIGZsb2F0IEMgPSBsZW5ndGggLSBNYXhMZW5ndGg7XHJcbiAgICAgICAgICAgIEMgPSBNYXRoVXRpbHMuQ2xhbXAoQywgLVNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24sIFNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fbWFzcyAqIEM7XHJcbiAgICAgICAgICAgIF91ID0gZDtcclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIF91O1xyXG5cclxuICAgICAgICAgICAgYjEuU3dlZXAuQyAtPSBiMS5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgYjEuU3dlZXAuQSAtPSBiMS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIxLCBQKTtcclxuICAgICAgICAgICAgYjIuU3dlZXAuQyArPSBiMi5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgYjIuU3dlZXAuQSArPSBiMi5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIyLCBQKTtcclxuXHJcbiAgICAgICAgICAgIGIxLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGIyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5BYnMoQykgPCBTZXR0aW5ncy5MaW5lYXJTbG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vIFBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcclxuICAgIC8vIEMgPSBwMiAtIHAxXHJcbiAgICAvLyBDZG90ID0gdjIgLSB2MVxyXG4gICAgLy8gICAgICA9IHYyICsgY3Jvc3ModzIsIHIyKSAtIHYxIC0gY3Jvc3ModzEsIHIxKVxyXG4gICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXcgXVxyXG4gICAgLy8gSWRlbnRpdHkgdXNlZDpcclxuICAgIC8vIHcgayAlIChyeCBpICsgcnkgaikgPSB3ICogKC1yeSBpICsgcnggailcclxuXHJcbiAgICAvLyBBbmdsZSBjb25zdHJhaW50XHJcbiAgICAvLyBDID0gYW5nbGUyIC0gYW5nbGUxIC0gcmVmZXJlbmNlQW5nbGVcclxuICAgIC8vIENkb3QgPSB3MiAtIHcxXHJcbiAgICAvLyBKID0gWzAgMCAtMSAwIDAgMV1cclxuICAgIC8vIEsgPSBpbnZJMSArIGludkkyXHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgd2VsZCBqb2ludCBlc3NlbnRpYWxseSBnbHVlcyB0d28gYm9kaWVzIHRvZ2V0aGVyLiBBIHdlbGQgam9pbnQgbWF5XHJcbiAgICAvLy8gZGlzdG9ydCBzb21ld2hhdCBiZWNhdXNlIHRoZSBpc2xhbmQgY29uc3RyYWludCBzb2x2ZXIgaXMgYXBwcm94aW1hdGUuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFdlbGRKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQjtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjMgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBNYXQzMyBfbWFzcztcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgV2VsZEpvaW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5XZWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBZb3UgbmVlZCB0byBzcGVjaWZ5IGEgbG9jYWwgYW5jaG9yIHBvaW50XHJcbiAgICAgICAgLy8vIHdoZXJlIHRoZXkgYXJlIGF0dGFjaGVkIGFuZCB0aGUgcmVsYXRpdmUgYm9keSBhbmdsZS4gVGhlIHBvc2l0aW9uXHJcbiAgICAgICAgLy8vIG9mIHRoZSBhbmNob3IgcG9pbnQgaXMgaW1wb3J0YW50IGZvciBjb21wdXRpbmcgdGhlIHJlYWN0aW9uIHRvcnF1ZS5cclxuICAgICAgICAvLy8gWW91IGNhbiBjaGFuZ2UgdGhlIGFuY2hvciBwb2ludHMgcmVsYXRpdmUgdG8gYm9keUEgb3IgYm9keUIgYnkgY2hhbmdpbmcgTG9jYWxBbmNob3JBXHJcbiAgICAgICAgLy8vIGFuZC9vciBMb2NhbEFuY2hvckIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPlRoZSBmaXJzdCBib2R5PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPlRoZSBzZWNvbmQgYm9keTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JBXCI+VGhlIGZpcnN0IGJvZHkgYW5jaG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JCXCI+VGhlIHNlY29uZCBib2R5IGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBXZWxkSm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbEFuY2hvckEsIFZlY3RvcjIgbG9jYWxBbmNob3JCKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keUEsIGJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLldlbGQ7XHJcblxyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcclxuICAgICAgICAgICAgUmVmZXJlbmNlQW5nbGUgPSBCb2R5Qi5Sb3RhdGlvbiAtIEJvZHlBLlJvdGF0aW9uO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBib2R5MiBhbmdsZSBtaW51cyBib2R5MSBhbmdsZSBpbiB0aGUgcmVmZXJlbmNlIHN0YXRlIChyYWRpYW5zKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSZWZlcmVuY2VBbmdsZSB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogbmV3IFZlY3RvcjIoX2ltcHVsc2UuWCwgX2ltcHVsc2UuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIF9pbXB1bHNlLlo7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZBLCB4ZkI7XHJcbiAgICAgICAgICAgIGJBLkdldFRyYW5zZm9ybShvdXQgeGZBKTtcclxuICAgICAgICAgICAgYkIuR2V0VHJhbnNmb3JtKG91dCB4ZkIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxyXG4gICAgICAgICAgICBWZWN0b3IyIHJBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgTG9jYWxBbmNob3JBIC0gYkEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHJCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIuUiwgTG9jYWxBbmNob3JCIC0gYkIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXHJcbiAgICAgICAgICAgIC8vICAgICBbIDAgICAgICAgLTEgMCAgICAgICAxXVxyXG4gICAgICAgICAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cclxuXHJcbiAgICAgICAgICAgIC8vIE1hdGxhYlxyXG4gICAgICAgICAgICAvLyBLID0gWyBtQStyMXleMippQSttQityMnleMippQiwgIC1yMXkqaUEqcjF4LXIyeSppQipyMngsICAgICAgICAgIC1yMXkqaUEtcjJ5KmlCXVxyXG4gICAgICAgICAgICAvLyAgICAgWyAgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgbUErcjF4XjIqaUErbUIrcjJ4XjIqaUIsICAgICAgICAgICByMXgqaUErcjJ4KmlCXVxyXG4gICAgICAgICAgICAvLyAgICAgWyAgICAgICAgICAtcjF5KmlBLXIyeSppQiwgICAgICAgICAgIHIxeCppQStyMngqaUIsICAgICAgICAgICAgICAgICAgIGlBK2lCXVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgbUEgPSBiQS5JbnZNYXNzLCBtQiA9IGJCLkludk1hc3M7XHJcbiAgICAgICAgICAgIGZsb2F0IGlBID0gYkEuSW52SSwgaUIgPSBiQi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgX21hc3MuQ29sMS5YID0gbUEgKyBtQiArIHJBLlkgKiByQS5ZICogaUEgKyByQi5ZICogckIuWSAqIGlCO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlggPSAtckEuWSAqIHJBLlggKiBpQSAtIHJCLlkgKiByQi5YICogaUI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWCA9IC1yQS5ZICogaUEgLSByQi5ZICogaUI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDEuWSA9IF9tYXNzLkNvbDIuWDtcclxuICAgICAgICAgICAgX21hc3MuQ29sMi5ZID0gbUEgKyBtQiArIHJBLlggKiByQS5YICogaUEgKyByQi5YICogckIuWCAqIGlCO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wzLlkgPSByQS5YICogaUEgKyByQi5YICogaUI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDEuWiA9IF9tYXNzLkNvbDMuWDtcclxuICAgICAgICAgICAgX21hc3MuQ29sMi5aID0gX21hc3MuQ29sMy5ZO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wzLlogPSBpQSArIGlCO1xyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBuZXcgVmVjdG9yMihfaW1wdWxzZS5YLCBfaW1wdWxzZS5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiQS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IG1BICogUDtcclxuICAgICAgICAgICAgICAgIGJBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGlBICogKE1hdGhVdGlscy5Dcm9zcyhyQSwgUCkgKyBfaW1wdWxzZS5aKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IG1CICogUDtcclxuICAgICAgICAgICAgICAgIGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGlCICogKE1hdGhVdGlscy5Dcm9zcyhyQiwgUCkgKyBfaW1wdWxzZS5aKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlID0gVmVjdG9yMy5aZXJvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2QSA9IGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHdBID0gYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdkIgPSBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3QiA9IGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbUEgPSBiQS5JbnZNYXNzLCBtQiA9IGJCLkludk1hc3M7XHJcbiAgICAgICAgICAgIGZsb2F0IGlBID0gYkEuSW52SSwgaUIgPSBiQi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQSwgeGZCO1xyXG4gICAgICAgICAgICBiQS5HZXRUcmFuc2Zvcm0ob3V0IHhmQSk7XHJcbiAgICAgICAgICAgIGJCLkdldFRyYW5zZm9ybShvdXQgeGZCKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgckEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBMb2NhbEFuY2hvckEgLSBiQS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBMb2NhbEFuY2hvckIgLSBiQi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyAgU29sdmUgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxyXG4gICAgICAgICAgICBWZWN0b3IyIENkb3QxID0gdkIgKyBNYXRoVXRpbHMuQ3Jvc3Mod0IsIHJCKSAtIHZBIC0gTWF0aFV0aWxzLkNyb3NzKHdBLCByQSk7XHJcbiAgICAgICAgICAgIGZsb2F0IENkb3QyID0gd0IgLSB3QTtcclxuICAgICAgICAgICAgVmVjdG9yMyBDZG90ID0gbmV3IFZlY3RvcjMoQ2RvdDEuWCwgQ2RvdDEuWSwgQ2RvdDIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMyBpbXB1bHNlID0gX21hc3MuU29sdmUzMygtQ2RvdCk7XHJcbiAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBuZXcgVmVjdG9yMihpbXB1bHNlLlgsIGltcHVsc2UuWSk7XHJcblxyXG4gICAgICAgICAgICB2QSAtPSBtQSAqIFA7XHJcbiAgICAgICAgICAgIHdBIC09IGlBICogKE1hdGhVdGlscy5Dcm9zcyhyQSwgUCkgKyBpbXB1bHNlLlopO1xyXG5cclxuICAgICAgICAgICAgdkIgKz0gbUIgKiBQO1xyXG4gICAgICAgICAgICB3QiArPSBpQiAqIChNYXRoVXRpbHMuQ3Jvc3MockIsIFApICsgaW1wdWxzZS5aKTtcclxuXHJcbiAgICAgICAgICAgIGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2QTtcclxuICAgICAgICAgICAgYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3QTtcclxuICAgICAgICAgICAgYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHZCO1xyXG4gICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdCO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBtQSA9IGJBLkludk1hc3MsIG1CID0gYkIuSW52TWFzcztcclxuICAgICAgICAgICAgZmxvYXQgaUEgPSBiQS5JbnZJLCBpQiA9IGJCLkludkk7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZBO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZCO1xyXG4gICAgICAgICAgICBiQS5HZXRUcmFuc2Zvcm0ob3V0IHhmQSk7XHJcbiAgICAgICAgICAgIGJCLkdldFRyYW5zZm9ybShvdXQgeGZCKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgckEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBMb2NhbEFuY2hvckEgLSBiQS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBMb2NhbEFuY2hvckIgLSBiQi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIEMxID0gYkIuU3dlZXAuQyArIHJCIC0gYkEuU3dlZXAuQyAtIHJBO1xyXG4gICAgICAgICAgICBmbG9hdCBDMiA9IGJCLlN3ZWVwLkEgLSBiQS5Td2VlcC5BIC0gUmVmZXJlbmNlQW5nbGU7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgbGFyZ2UgZGV0YWNobWVudC5cclxuICAgICAgICAgICAgY29uc3QgZmxvYXQga19hbGxvd2VkU3RyZXRjaCA9IDEwLjBmICogU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICAgICAgZmxvYXQgcG9zaXRpb25FcnJvciA9IEMxLkxlbmd0aCgpO1xyXG4gICAgICAgICAgICBmbG9hdCBhbmd1bGFyRXJyb3IgPSAoZmxvYXQpTWF0aC5BYnMoQzIpO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb25FcnJvciA+IGtfYWxsb3dlZFN0cmV0Y2gpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlBICo9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICBpQiAqPSAxLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfbWFzcy5Db2wxLlggPSBtQSArIG1CICsgckEuWSAqIHJBLlkgKiBpQSArIHJCLlkgKiByQi5ZICogaUI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDIuWCA9IC1yQS5ZICogckEuWCAqIGlBIC0gckIuWSAqIHJCLlggKiBpQjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMy5YID0gLXJBLlkgKiBpQSAtIHJCLlkgKiBpQjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMS5ZID0gX21hc3MuQ29sMi5YO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlkgPSBtQSArIG1CICsgckEuWCAqIHJBLlggKiBpQSArIHJCLlggKiByQi5YICogaUI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWSA9IHJBLlggKiBpQSArIHJCLlggKiBpQjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMS5aID0gX21hc3MuQ29sMy5YO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlogPSBfbWFzcy5Db2wzLlk7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWiA9IGlBICsgaUI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IzIEMgPSBuZXcgVmVjdG9yMyhDMS5YLCBDMS5ZLCBDMik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IzIGltcHVsc2UgPSBfbWFzcy5Tb2x2ZTMzKC1DKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IG5ldyBWZWN0b3IyKGltcHVsc2UuWCwgaW1wdWxzZS5ZKTtcclxuXHJcbiAgICAgICAgICAgIGJBLlN3ZWVwLkMgLT0gbUEgKiBQO1xyXG4gICAgICAgICAgICBiQS5Td2VlcC5BIC09IGlBICogKE1hdGhVdGlscy5Dcm9zcyhyQSwgUCkgKyBpbXB1bHNlLlopO1xyXG5cclxuICAgICAgICAgICAgYkIuU3dlZXAuQyArPSBtQiAqIFA7XHJcbiAgICAgICAgICAgIGJCLlN3ZWVwLkEgKz0gaUIgKiAoTWF0aFV0aWxzLkNyb3NzKHJCLCBQKSArIGltcHVsc2UuWik7XHJcblxyXG4gICAgICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uRXJyb3IgPD0gU2V0dGluZ3MuTGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gU2V0dGluZ3MuQW5ndWxhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcmsuSW5wdXQ7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuVXRpbGl0eVxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgUGh5c2ljc0dhbWVTY3JlZW4gOiBHYW1lU2NyZWVuXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIENhbWVyYTJEIENhbWVyYTtcclxuICAgICAgICBwcm90ZWN0ZWQgV29ybGQgV29ybGQ7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2FnZW50Rm9yY2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYWdlbnRUb3JxdWU7XHJcbiAgICAgICAgcHJpdmF0ZSBGaXhlZE1vdXNlSm9pbnQgX2ZpeGVkTW91c2VKb2ludDtcclxuICAgICAgICBwcml2YXRlIEJvZHkgX3VzZXJBZ2VudDtcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIFBoeXNpY3NHYW1lU2NyZWVuKFNjcmVlbk1hbmFnZXIgc2NyZWVuTWFuYWdlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEhhc0N1cnNvciA9IHRydWU7XHJcbiAgICAgICAgICAgIEVuYWJsZUNhbWVyYUNvbnRyb2wgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdXNlckFnZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgV29ybGQgPSBudWxsO1xyXG4gICAgICAgICAgICBDYW1lcmEgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgU2NyZWVuTWFuYWdlciA9IHNjcmVlbk1hbmFnZXI7XHJcbiAgICAgICAgICAgIC8vV2UgZW5hYmxlIGRpYWdub3N0aWNzIHRvIHNob3cgZ2V0IHZhbHVlcyBmb3Igb3VyIHBlcmZvcm1hbmNlIGNvdW50ZXJzLlxyXG4gICAgICAgICAgICBTZXR0aW5ncy5FbmFibGVEaWFnbm9zdGljcyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoV29ybGQgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV29ybGQgPSBuZXcgV29ybGQoVmVjdG9yMi5aZXJvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdvcmxkLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChDYW1lcmEgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ2FtZXJhID0gbmV3IENhbWVyYTJEKHNjcmVlbk1hbmFnZXIuR3JhcGhpY3NEZXZpY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ2FtZXJhLlJlc2V0Q2FtZXJhKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExvYWRpbmcgbWF5IHRha2UgYSB3aGlsZS4uLiBzbyBwcmV2ZW50IHRoZSBnYW1lIGZyb20gXCJjYXRjaGluZyB1cFwiIG9uY2Ugd2UgZmluaXNoZWQgbG9hZGluZ1xyXG5cdFx0XHQvL25ldyBNb25vR2FtZS5pT1MgZG9lc24ndCBzZWVtIHRvIGxpa2UgdGhpcywgbmVlZCB0byByZXRlc3Qgb24gb3RoZXIgcGxhdGZvcm1zXHJcbiAgICAgICAgICAgIC8vc2NyZWVuTWFuYWdlci5HYW1lLlJlc2V0RWxhcHNlZFRpbWUoKTtcclxuXHRcdFx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZUNhbWVyYUNvbnRyb2wgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgdm9pZCBTZXRVc2VyQWdlbnQoQm9keSBhZ2VudCwgZmxvYXQgZm9yY2UsIGZsb2F0IHRvcnF1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF91c2VyQWdlbnQgPSBhZ2VudDtcclxuICAgICAgICAgICAgX2FnZW50Rm9yY2UgPSBmb3JjZTtcclxuICAgICAgICAgICAgX2FnZW50VG9ycXVlID0gdG9ycXVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgTG9hZENvbnRlbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmFzZS5Mb2FkQ29udGVudCgpOyAgICBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIFVwZGF0ZShHYW1lVGltZSBnYW1lVGltZSwgYm9vbCBvdGhlclNjcmVlbkhhc0ZvY3VzLCBib29sIGNvdmVyZWRCeU90aGVyU2NyZWVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkQnlPdGhlclNjcmVlbiAmJiAhb3RoZXJTY3JlZW5IYXNGb2N1cylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gdmFyaWFibGUgdGltZSBzdGVwIGJ1dCBuZXZlciBsZXNzIHRoZW4gMzAgSHpcclxuICAgICAgICAgICAgICAgIFdvcmxkLlN0ZXAoTWF0aC5NaW4oKGZsb2F0KWdhbWVUaW1lLkVsYXBzZWRHYW1lVGltZS5Ub3RhbFNlY29uZHMsICgxZiAvIDUwZikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdvcmxkLlN0ZXAoMGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENhbWVyYS5VcGRhdGUoZ2FtZVRpbWUpO1xyXG4gICAgICAgICAgICBiYXNlLlVwZGF0ZShnYW1lVGltZSwgb3RoZXJTY3JlZW5IYXNGb2N1cywgY292ZXJlZEJ5T3RoZXJTY3JlZW4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgRHJhdyhHYW1lVGltZSBnYW1lVGltZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeCBwcm9qZWN0aW9uID0gQ2FtZXJhLlNpbVByb2plY3Rpb247XHJcbiAgICAgICAgICAgIE1hdHJpeCB2aWV3ID0gQ2FtZXJhLlNpbVZpZXc7XHJcblxyXG4gICAgICAgICAgICBiYXNlLkRyYXcoZ2FtZVRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heS5Td2VlcFxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgRFRTd2VlcENvbnN0cmFpbnQgOiBUcmlhbmd1bGF0aW9uQ29uc3RyYWludFxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2l2ZSB0d28gcG9pbnRzIGluIGFueSBvcmRlci4gV2lsbCBhbHdheXMgYmUgb3JkZXJlZCBzb1xyXG4gICAgICAgIC8vLyB0aGF0IHEueSA+IHAueSBhbmQgcS54ID4gcC54IGlmIHNhbWUgeSB2YWx1ZSBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBEVFN3ZWVwQ29uc3RyYWludChUcmlhbmd1bGF0aW9uUG9pbnQgcDEsIFRyaWFuZ3VsYXRpb25Qb2ludCBwMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFAgPSBwMTtcclxuICAgICAgICAgICAgUSA9IHAyO1xyXG4gICAgICAgICAgICBpZiAocDEuWSA+IHAyLlkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFEgPSBwMTtcclxuICAgICAgICAgICAgICAgIFAgPSBwMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwMS5ZID09IHAyLlkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwMS5YID4gcDIuWClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBRID0gcDE7XHJcbiAgICAgICAgICAgICAgICAgICAgUCA9IHAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocDEuWCA9PSBwMi5YKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKCBcIkZhaWxlZCB0byBjcmVhdGUgY29uc3RyYWludCB7fT17fVwiLCBwMSwgcDIgKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRHVwbGljYXRlUG9pbnRFeGNlcHRpb24oIHAxICsgXCI9XCIgKyBwMiApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBRLkFkZEVkZ2UodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5LlN3ZWVwXHJcbntcclxuICAgIC8qKlxyXG4gICAgICogXHJcbiAgICAgKiBAYXV0aG9yIFRob21hcyDDhWhsw6luLCB0aGFobGVuQGdtYWlsLmNvbVxyXG4gICAgICpcclxuICAgICAqL1xyXG5cclxuICAgIHB1YmxpYyBjbGFzcyBEVFN3ZWVwQ29udGV4dCA6IFRyaWFuZ3VsYXRpb25Db250ZXh0XHJcbiAgICB7XHJcbiAgICAgICAgLy8gSW5pdGFsIHRyaWFuZ2xlIGZhY3Rvciwgc2VlZCB0cmlhbmdsZSB3aWxsIGV4dGVuZCAzMCUgb2YgXHJcbiAgICAgICAgLy8gUG9pbnRTZXQgd2lkdGggdG8gYm90aCBsZWZ0IGFuZCByaWdodC5cclxuICAgICAgICBwcml2YXRlIGNvbnN0IGZsb2F0IEFMUEhBID0gMC4zZjtcclxuXHJcbiAgICAgICAgcHVibGljIERUU3dlZXBCYXNpbiBCYXNpbiA9IG5ldyBEVFN3ZWVwQmFzaW4oKTtcclxuICAgICAgICBwdWJsaWMgRFRTd2VlcEVkZ2VFdmVudCBFZGdlRXZlbnQgPSBuZXcgRFRTd2VlcEVkZ2VFdmVudCgpO1xyXG5cclxuICAgICAgICBwcml2YXRlIERUU3dlZXBQb2ludENvbXBhcmF0b3IgX2NvbXBhcmF0b3IgPSBuZXcgRFRTd2VlcFBvaW50Q29tcGFyYXRvcigpO1xyXG4gICAgICAgIHB1YmxpYyBBZHZhbmNpbmdGcm9udCBhRnJvbnQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBEVFN3ZWVwQ29udGV4dCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDbGVhcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRpb25Qb2ludCBIZWFkIHsgZ2V0OyBzZXQ7IH1cclxuICAgICAgICBwdWJsaWMgVHJpYW5ndWxhdGlvblBvaW50IFRhaWwgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVGcm9tTGlzdChEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJpYW5nbGVzLlJlbW92ZSh0cmlhbmdsZSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBhbGwgbmVpZ2hib3IgcG9pbnRlcnMgdG8gdGhpcyB0cmlhbmdsZVxyXG4gICAgICAgICAgICAvLyAgICAgICAgZm9yKCBpbnQgaT0wOyBpPDM7IGkrKyApXHJcbiAgICAgICAgICAgIC8vICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgaWYoIHRyaWFuZ2xlLm5laWdoYm9yc1tpXSAhPSBudWxsIClcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRyaWFuZ2xlLm5laWdoYm9yc1tpXS5jbGVhck5laWdoYm9yKCB0cmlhbmdsZSApO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gICAgICAgIH1cclxuICAgICAgICAgICAgLy8gICAgICAgIHRyaWFuZ2xlLmNsZWFyTmVpZ2hib3JzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNZXNoQ2xlYW4oRGVsYXVuYXlUcmlhbmdsZSB0cmlhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1lc2hDbGVhblJlcSh0cmlhbmdsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgTWVzaENsZWFuUmVxKERlbGF1bmF5VHJpYW5nbGUgdHJpYW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodHJpYW5nbGUgIT0gbnVsbCAmJiAhdHJpYW5nbGUuSXNJbnRlcmlvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGUuSXNJbnRlcmlvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBUcmlhbmd1bGF0YWJsZS5BZGRUcmlhbmdsZSh0cmlhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyaWFuZ2xlLkVkZ2VJc0NvbnN0cmFpbmVkW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWVzaENsZWFuUmVxKHRyaWFuZ2xlLk5laWdoYm9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBDbGVhcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiYXNlLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIFRyaWFuZ2xlcy5DbGVhcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkTm9kZShBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICBDb25zb2xlLldyaXRlTGluZSggXCJhZGQ6XCIgKyBub2RlLmtleSArIFwiOlwiICsgU3lzdGVtLmlkZW50aXR5SGFzaENvZGUobm9kZS5rZXkpKTtcclxuICAgICAgICAgICAgLy8gICAgICAgIG1fbm9kZVRyZWUucHV0KCBub2RlLmdldEtleSgpLCBub2RlICk7XHJcbiAgICAgICAgICAgIGFGcm9udC5BZGROb2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlTm9kZShBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICBDb25zb2xlLldyaXRlTGluZSggXCJyZW1vdmU6XCIgKyBub2RlLmtleSArIFwiOlwiICsgU3lzdGVtLmlkZW50aXR5SGFzaENvZGUobm9kZS5rZXkpKTtcclxuICAgICAgICAgICAgLy8gICAgICAgIG1fbm9kZVRyZWUuZGVsZXRlKCBub2RlLmdldEtleSgpICk7XHJcbiAgICAgICAgICAgIGFGcm9udC5SZW1vdmVOb2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250Tm9kZSBMb2NhdGVOb2RlKFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBhRnJvbnQuTG9jYXRlTm9kZShwb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDcmVhdGVBZHZhbmNpbmdGcm9udCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgaGVhZCwgdGFpbCwgbWlkZGxlO1xyXG4gICAgICAgICAgICAvLyBJbml0aWFsIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgaVRyaWFuZ2xlID0gbmV3IERlbGF1bmF5VHJpYW5nbGUoUG9pbnRzWzBdLCBUYWlsLCBIZWFkKTtcclxuICAgICAgICAgICAgVHJpYW5nbGVzLkFkZChpVHJpYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgaGVhZCA9IG5ldyBBZHZhbmNpbmdGcm9udE5vZGUoaVRyaWFuZ2xlLlBvaW50c1sxXSk7XHJcbiAgICAgICAgICAgIGhlYWQuVHJpYW5nbGUgPSBpVHJpYW5nbGU7XHJcbiAgICAgICAgICAgIG1pZGRsZSA9IG5ldyBBZHZhbmNpbmdGcm9udE5vZGUoaVRyaWFuZ2xlLlBvaW50c1swXSk7XHJcbiAgICAgICAgICAgIG1pZGRsZS5UcmlhbmdsZSA9IGlUcmlhbmdsZTtcclxuICAgICAgICAgICAgdGFpbCA9IG5ldyBBZHZhbmNpbmdGcm9udE5vZGUoaVRyaWFuZ2xlLlBvaW50c1syXSk7XHJcblxyXG4gICAgICAgICAgICBhRnJvbnQgPSBuZXcgQWR2YW5jaW5nRnJvbnQoaGVhZCwgdGFpbCk7XHJcbiAgICAgICAgICAgIGFGcm9udC5BZGROb2RlKG1pZGRsZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBJIHRoaW5rIGl0IHdvdWxkIGJlIG1vcmUgaW50dWl0aXZlIGlmIGhlYWQgaXMgbWlkZGxlcyBuZXh0IGFuZCBub3QgcHJldmlvdXNcclxuICAgICAgICAgICAgLy8gICAgICAgc28gc3dhcCBoZWFkIGFuZCB0YWlsXHJcbiAgICAgICAgICAgIGFGcm9udC5IZWFkLk5leHQgPSBtaWRkbGU7XHJcbiAgICAgICAgICAgIG1pZGRsZS5OZXh0ID0gYUZyb250LlRhaWw7XHJcbiAgICAgICAgICAgIG1pZGRsZS5QcmV2ID0gYUZyb250LkhlYWQ7XHJcbiAgICAgICAgICAgIGFGcm9udC5UYWlsLlByZXYgPSBtaWRkbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRyeSB0byBtYXAgYSBub2RlIHRvIGFsbCBzaWRlcyBvZiB0aGlzIHRyaWFuZ2xlIHRoYXQgZG9uJ3QgaGF2ZSBcclxuICAgICAgICAvLy8gYSBuZWlnaGJvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcFRyaWFuZ2xlVG9Ob2RlcyhEZWxhdW5heVRyaWFuZ2xlIHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgbjtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0Lk5laWdoYm9yc1tpXSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBhRnJvbnQuTG9jYXRlUG9pbnQodC5Qb2ludENXKHQuUG9pbnRzW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uVHJpYW5nbGUgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgUHJlcGFyZVRyaWFuZ3VsYXRpb24oVHJpYW5ndWxhdGFibGUgdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJhc2UuUHJlcGFyZVRyaWFuZ3VsYXRpb24odCk7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgeG1heCwgeG1pbjtcclxuICAgICAgICAgICAgZG91YmxlIHltYXgsIHltaW47XHJcblxyXG4gICAgICAgICAgICB4bWF4ID0geG1pbiA9IFBvaW50c1swXS5YO1xyXG4gICAgICAgICAgICB5bWF4ID0geW1pbiA9IFBvaW50c1swXS5ZO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGJvdW5kcy4gU2hvdWxkIGJlIGNvbWJpbmVkIHdpdGggdGhlIHNvcnRpbmdcclxuICAgICAgICAgICAgZm9yZWFjaCAoVHJpYW5ndWxhdGlvblBvaW50IHAgaW4gUG9pbnRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5YID4geG1heClcclxuICAgICAgICAgICAgICAgICAgICB4bWF4ID0gcC5YO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuWCA8IHhtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgeG1pbiA9IHAuWDtcclxuICAgICAgICAgICAgICAgIGlmIChwLlkgPiB5bWF4KVxyXG4gICAgICAgICAgICAgICAgICAgIHltYXggPSBwLlk7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5ZIDwgeW1pbilcclxuICAgICAgICAgICAgICAgICAgICB5bWluID0gcC5ZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgZGVsdGFYID0gQUxQSEEqKHhtYXggLSB4bWluKTtcclxuICAgICAgICAgICAgZG91YmxlIGRlbHRhWSA9IEFMUEhBKih5bWF4IC0geW1pbik7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBwMSA9IG5ldyBUcmlhbmd1bGF0aW9uUG9pbnQoeG1heCArIGRlbHRhWCwgeW1pbiAtIGRlbHRhWSk7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBwMiA9IG5ldyBUcmlhbmd1bGF0aW9uUG9pbnQoeG1pbiAtIGRlbHRhWCwgeW1pbiAtIGRlbHRhWSk7XHJcblxyXG4gICAgICAgICAgICBIZWFkID0gcDE7XHJcbiAgICAgICAgICAgIFRhaWwgPSBwMjtcclxuXHJcbiAgICAgICAgICAgIC8vICAgICAgICBsb25nIHRpbWUgPSBTeXN0ZW0ubmFub1RpbWUoKTtcclxuICAgICAgICAgICAgLy8gU29ydCB0aGUgcG9pbnRzIGFsb25nIHktYXhpc1xyXG4gICAgICAgICAgICBQb2ludHMuU29ydChfY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIC8vICAgICAgICBsb2dnZXIuaW5mbyggXCJUcmlhbmd1bGF0aW9uIHNldHVwIFt7fW1zXVwiLCAoIFN5c3RlbS5uYW5vVGltZSgpIC0gdGltZSApIC8gMWU2ICk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgRmluYWxpemVUcmlhbmd1bGF0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRhYmxlLkFkZFRyaWFuZ2xlcyhUcmlhbmdsZXMpO1xyXG4gICAgICAgICAgICBUcmlhbmdsZXMuQ2xlYXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUcmlhbmd1bGF0aW9uQ29uc3RyYWludCBOZXdDb25zdHJhaW50KFRyaWFuZ3VsYXRpb25Qb2ludCBhLCBUcmlhbmd1bGF0aW9uUG9pbnQgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRFRTd2VlcENvbnN0cmFpbnQoYSwgYik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIE5lc3RlZCB0eXBlOiBEVFN3ZWVwQmFzaW5cclxuXHJcbiAgICAgICAgcHVibGljIGNsYXNzIERUU3dlZXBCYXNpblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250Tm9kZSBib3R0b21Ob2RlO1xyXG4gICAgICAgICAgICBwdWJsaWMgYm9vbCBsZWZ0SGlnaGVzdDtcclxuICAgICAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250Tm9kZSBsZWZ0Tm9kZTtcclxuICAgICAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250Tm9kZSByaWdodE5vZGU7XHJcbiAgICAgICAgICAgIHB1YmxpYyBkb3VibGUgd2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gTmVzdGVkIHR5cGU6IERUU3dlZXBFZGdlRXZlbnRcclxuXHJcbiAgICAgICAgcHVibGljIGNsYXNzIERUU3dlZXBFZGdlRXZlbnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHB1YmxpYyBEVFN3ZWVwQ29uc3RyYWludCBDb25zdHJhaW5lZEVkZ2U7XHJcbiAgICAgICAgICAgIHB1YmxpYyBib29sIFJpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXkuU3dlZXBcclxue1xyXG4gICAgcHVibGljIGNsYXNzIERUU3dlZXBQb2ludENvbXBhcmF0b3IgOiBJQ29tcGFyZXI8VHJpYW5ndWxhdGlvblBvaW50PlxyXG4gICAge1xyXG4gICAgICAgICNyZWdpb24gSUNvbXBhcmVyPFRyaWFuZ3VsYXRpb25Qb2ludD4gTWVtYmVyc1xyXG5cclxuICAgICAgICBwdWJsaWMgaW50IENvbXBhcmUoVHJpYW5ndWxhdGlvblBvaW50IHAxLCBUcmlhbmd1bGF0aW9uUG9pbnQgcDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocDEuWSA8IHAyLlkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwMS5ZID4gcDIuWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocDEuWCA8IHAyLlgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocDEuWCA+IHAyLlgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG4vLyBDaGFuZ2VzIGZyb20gdGhlIEphdmEgdmVyc2lvblxyXG4vLyAgIFBvbHlnb24gY29uc3RydWN0b3JzIHNwcnVzZWQgdXAsIGNoZWNrcyBmb3IgMysgcG9seXNcclxuLy8gICBOYW1pbmcgb2YgZXZlcnl0aGluZ1xyXG4vLyAgIGdldFRyaWFuZ3VsYXRpb25Nb2RlKCkgLT4gVHJpYW5ndWxhdGlvbk1vZGUgeyBnZXQ7IH1cclxuLy8gICBFeGNlcHRpb25zIHJlcGxhY2VkXHJcbi8vIEZ1dHVyZSBwb3NzaWJpbGl0aWVzXHJcbi8vICAgV2UgaGF2ZSBhIGxvdCBvZiBBZGQvQ2xlYXIgbWV0aG9kcyAtLSB3ZSBtYXkgcHJlZmVyIHRvIGp1c3QgZXhwb3NlIHRoZSBjb250YWluZXJcclxuLy8gICBTb21lIHNlbGYtZXhwbGFuaXRvcnkgbWV0aG9kcyBtYXkgZGVzZXJ2ZSBjb21tZW50aW5nIGFueXdheXNcclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5MaW5xO1xyXG51c2luZyBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5O1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uUG9seWdvblxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgUG9seWdvbiA6IFRyaWFuZ3VsYXRhYmxlXHJcbiAgICB7XHJcbiAgICAgICAgcHJvdGVjdGVkIExpc3Q8UG9seWdvbj4gX2hvbGVzO1xyXG4gICAgICAgIHByb3RlY3RlZCBQb2x5Z29uUG9pbnQgX2xhc3Q7XHJcbiAgICAgICAgcHJvdGVjdGVkIExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBfcG9pbnRzID0gbmV3IExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PigpO1xyXG4gICAgICAgIHByb3RlY3RlZCBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gX3N0ZWluZXJQb2ludHM7XHJcbiAgICAgICAgcHJvdGVjdGVkIExpc3Q8RGVsYXVuYXlUcmlhbmdsZT4gX3RyaWFuZ2xlcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBwb2x5Z29uIGZyb20gYSBsaXN0IG9mIGF0IGxlYXN0IDMgcG9pbnRzIHdpdGggbm8gZHVwbGljYXRlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50c1wiPkEgbGlzdCBvZiB1bmlxdWUgcG9pbnRzPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgUG9seWdvbihJTGlzdDxQb2x5Z29uUG9pbnQ+IHBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwb2ludHMuQ291bnQgPCAzKSB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJMaXN0IGhhcyBmZXdlciB0aGFuIDMgcG9pbnRzXCIsIFwicG9pbnRzXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gTGV0cyBkbyBvbmUgc2FuaXR5IGNoZWNrIHRoYXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQgaGFzbid0IGdvdCBzYW1lIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIC8vIEl0cyBzb21ldGhpbmcgdGhhdCBvZnRlbiBoYXBwZW4gd2hlbiBpbXBvcnRpbmcgcG9seWdvbiBkYXRhIGZyb20gb3RoZXIgZm9ybWF0c1xyXG4gICAgICAgICAgICBpZiAocG9pbnRzWzBdLkVxdWFscyhwb2ludHNbcG9pbnRzLkNvdW50IC0gMV0pKSBwb2ludHMuUmVtb3ZlQXQocG9pbnRzLkNvdW50IC0gMSk7XHJcblxyXG4gICAgICAgICAgICBfcG9pbnRzLkFkZFJhbmdlKHBvaW50cy5DYXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4oKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIHBvbHlnb24gZnJvbSBhIGxpc3Qgb2YgYXQgbGVhc3QgMyBwb2ludHMgd2l0aCBubyBkdXBsaWNhdGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRzXCI+QSBsaXN0IG9mIHVuaXF1ZSBwb2ludHMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgUG9seWdvbihJRW51bWVyYWJsZTxQb2x5Z29uUG9pbnQ+IHBvaW50cykgOiB0aGlzKChwb2ludHMgYXMgSUxpc3Q8UG9seWdvblBvaW50PikgPz8gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Ub0FycmF5PGdsb2JhbDo6UG9seTJUcmkuVHJpYW5ndWxhdGlvbi5Qb2x5Z29uLlBvbHlnb25Qb2ludD4ocG9pbnRzKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgUG9seWdvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIElMaXN0PFBvbHlnb24+IEhvbGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2hvbGVzOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIFRyaWFuZ3VsYXRhYmxlIE1lbWJlcnNcclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRpb25Nb2RlIFRyaWFuZ3VsYXRpb25Nb2RlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gVHJpYW5ndWxhdGlvbk1vZGUuUG9seWdvbjsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIElMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gUG9pbnRzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3BvaW50czsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIElMaXN0PERlbGF1bmF5VHJpYW5nbGU+IFRyaWFuZ2xlc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF90cmlhbmdsZXM7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZFRyaWFuZ2xlKERlbGF1bmF5VHJpYW5nbGUgdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90cmlhbmdsZXMuQWRkKHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkVHJpYW5nbGVzKElFbnVtZXJhYmxlPERlbGF1bmF5VHJpYW5nbGU+IGxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfdHJpYW5nbGVzLkFkZFJhbmdlKGxpc3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXJUcmlhbmdsZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF90cmlhbmdsZXMgIT0gbnVsbCkgX3RyaWFuZ2xlcy5DbGVhcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGNvbnN0cmFpbnRzIGFuZCBwb3B1bGF0ZXMgdGhlIGNvbnRleHQgd2l0aCBwb2ludHNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRjeFwiPlRoZSBjb250ZXh0PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQcmVwYXJlVHJpYW5ndWxhdGlvbihUcmlhbmd1bGF0aW9uQ29udGV4dCB0Y3gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX3RyaWFuZ2xlcyA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdHJpYW5nbGVzID0gbmV3IExpc3Q8RGVsYXVuYXlUcmlhbmdsZT4oX3BvaW50cy5Db3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdHJpYW5nbGVzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE91dGVyIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX3BvaW50cy5Db3VudCAtIDE7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGN4Lk5ld0NvbnN0cmFpbnQoX3BvaW50c1tpXSwgX3BvaW50c1tpICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRjeC5OZXdDb25zdHJhaW50KF9wb2ludHNbMF0sIF9wb2ludHNbX3BvaW50cy5Db3VudCAtIDFdKTtcclxuICAgICAgICAgICAgdGN4LlBvaW50cy5BZGRSYW5nZShfcG9pbnRzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhvbGUgY29uc3RyYWludHNcclxuICAgICAgICAgICAgaWYgKF9ob2xlcyAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChQb2x5Z29uIHAgaW4gX2hvbGVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcC5fcG9pbnRzLkNvdW50IC0gMTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGN4Lk5ld0NvbnN0cmFpbnQocC5fcG9pbnRzW2ldLCBwLl9wb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGN4Lk5ld0NvbnN0cmFpbnQocC5fcG9pbnRzWzBdLCBwLl9wb2ludHNbcC5fcG9pbnRzLkNvdW50IC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRjeC5Qb2ludHMuQWRkUmFuZ2UocC5fcG9pbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9zdGVpbmVyUG9pbnRzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRjeC5Qb2ludHMuQWRkUmFuZ2UoX3N0ZWluZXJQb2ludHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZFN0ZWluZXJQb2ludChUcmlhbmd1bGF0aW9uUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX3N0ZWluZXJQb2ludHMgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3N0ZWluZXJQb2ludHMgPSBuZXcgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3N0ZWluZXJQb2ludHMuQWRkKHBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZFN0ZWluZXJQb2ludHMoTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IHBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfc3RlaW5lclBvaW50cyA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfc3RlaW5lclBvaW50cyA9IG5ldyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfc3RlaW5lclBvaW50cy5BZGRSYW5nZShwb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXJTdGVpbmVyUG9pbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfc3RlaW5lclBvaW50cyAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfc3RlaW5lclBvaW50cy5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZCBhIGhvbGUgdG8gdGhlIHBvbHlnb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2x5XCI+QSBzdWJ0cmFjdGlvbiBwb2x5Z29uIGZ1bGx5IGNvbnRhaW5lZCBpbnNpZGUgdGhpcyBwb2x5Z29uLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkSG9sZShQb2x5Z29uIHBvbHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2hvbGVzID09IG51bGwpIF9ob2xlcyA9IG5ldyBMaXN0PFBvbHlnb24+KCk7XHJcbiAgICAgICAgICAgIF9ob2xlcy5BZGQocG9seSk7XHJcbiAgICAgICAgICAgIC8vIFhYWDogdGVzdHMgY291bGQgYmUgbWFkZSBoZXJlIHRvIGJlIHN1cmUgaXQgaXMgZnVsbHkgaW5zaWRlXHJcbiAgICAgICAgICAgIC8vICAgICAgICBhZGRTdWJ0cmFjdGlvbiggcG9seS5nZXRQb2ludHMoKSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbnNlcnRzIG5ld1BvaW50IGFmdGVyIHBvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRcIj5UaGUgcG9pbnQgdG8gaW5zZXJ0IGFmdGVyIGluIHRoZSBwb2x5Z29uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJuZXdQb2ludFwiPlRoZSBwb2ludCB0byBpbnNlcnQgaW50byB0aGUgcG9seWdvbjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgSW5zZXJ0UG9pbnRBZnRlcihQb2x5Z29uUG9pbnQgcG9pbnQsIFBvbHlnb25Qb2ludCBuZXdQb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgXHJcbiAgICAgICAgICAgIGludCBpbmRleCA9IF9wb2ludHMuSW5kZXhPZihwb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBcIlRyaWVkIHRvIGluc2VydCBhIHBvaW50IGludG8gYSBQb2x5Z29uIGFmdGVyIGEgcG9pbnQgbm90IGJlbG9uZ2luZyB0byB0aGUgUG9seWdvblwiLCBcInBvaW50XCIpO1xyXG4gICAgICAgICAgICBuZXdQb2ludC5OZXh0ID0gcG9pbnQuTmV4dDtcclxuICAgICAgICAgICAgbmV3UG9pbnQuUHJldmlvdXMgPSBwb2ludDtcclxuICAgICAgICAgICAgcG9pbnQuTmV4dC5QcmV2aW91cyA9IG5ld1BvaW50O1xyXG4gICAgICAgICAgICBwb2ludC5OZXh0ID0gbmV3UG9pbnQ7XHJcbiAgICAgICAgICAgIF9wb2ludHMuSW5zZXJ0KGluZGV4ICsgMSwgbmV3UG9pbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbnNlcnRzIGxpc3QgKGFmdGVyIGxhc3QgcG9pbnQgaW4gcG9seWdvbj8pXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsaXN0XCI+PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRQb2ludHMoSUVudW1lcmFibGU8UG9seWdvblBvaW50PiBsaXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9seWdvblBvaW50IGZpcnN0O1xyXG4gICAgICAgICAgICBmb3JlYWNoIChQb2x5Z29uUG9pbnQgcCBpbiBsaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwLlByZXZpb3VzID0gX2xhc3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2xhc3QgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwLk5leHQgPSBfbGFzdC5OZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYXN0Lk5leHQgPSBwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX2xhc3QgPSBwO1xyXG4gICAgICAgICAgICAgICAgX3BvaW50cy5BZGQocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmlyc3QgPSAoUG9seWdvblBvaW50KSBfcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICBfbGFzdC5OZXh0ID0gZmlyc3Q7XHJcbiAgICAgICAgICAgIGZpcnN0LlByZXZpb3VzID0gX2xhc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgYSBwb2ludCBhZnRlciB0aGUgbGFzdCBpbiB0aGUgcG9seWdvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBcIj5UaGUgcG9pbnQgdG8gYWRkPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRQb2ludChQb2x5Z29uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHAuUHJldmlvdXMgPSBfbGFzdDtcclxuICAgICAgICAgICAgcC5OZXh0ID0gX2xhc3QuTmV4dDtcclxuICAgICAgICAgICAgX2xhc3QuTmV4dCA9IHA7XHJcbiAgICAgICAgICAgIF9wb2ludHMuQWRkKHApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZW1vdmVzIGEgcG9pbnQgZnJvbSB0aGUgcG9seWdvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBcIj48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZVBvaW50KFBvbHlnb25Qb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9seWdvblBvaW50IG5leHQsIHByZXY7XHJcblxyXG4gICAgICAgICAgICBuZXh0ID0gcC5OZXh0O1xyXG4gICAgICAgICAgICBwcmV2ID0gcC5QcmV2aW91cztcclxuICAgICAgICAgICAgcHJldi5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgbmV4dC5QcmV2aW91cyA9IHByZXY7XHJcbiAgICAgICAgICAgIF9wb2ludHMuUmVtb3ZlKHApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG4vLyBDaGFuZ2VzIGZyb20gdGhlIEphdmEgdmVyc2lvblxyXG4vLyAgIFJlcGxhY2VkIGdldC9zZXQgTmV4dC9QcmV2aW91cyB3aXRoIGF0dHJpYnV0ZXNcclxuLy8gRnV0dXJlIHBvc3NpYmlsaXRpZXNcclxuLy8gICBEb2N1bWVudGF0aW9uIVxyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uUG9seWdvblxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgUG9seWdvblBvaW50IDogVHJpYW5ndWxhdGlvblBvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFBvbHlnb25Qb2ludChkb3VibGUgeCwgZG91YmxlIHkpIDogYmFzZSh4LCB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBQb2x5Z29uUG9pbnQgTmV4dCB7IGdldDsgc2V0OyB9XHJcbiAgICAgICAgcHVibGljIFBvbHlnb25Qb2ludCBQcmV2aW91cyB7IGdldDsgc2V0OyB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXk7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5TZXRzXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBQb2ludFNldCA6IFRyaWFuZ3VsYXRhYmxlXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFBvaW50U2V0KExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBwb2ludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHMgPSBuZXcgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+KHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIFRyaWFuZ3VsYXRhYmxlIE1lbWJlcnNcclxuXHJcbiAgICAgICAgcHVibGljIElMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gUG9pbnRzIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG4gICAgICAgIHB1YmxpYyBJTGlzdDxEZWxhdW5heVRyaWFuZ2xlPiBUcmlhbmdsZXMgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIFRyaWFuZ3VsYXRpb25Nb2RlIFRyaWFuZ3VsYXRpb25Nb2RlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gVHJpYW5ndWxhdGlvbk1vZGUuVW5jb25zdHJhaW5lZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkVHJpYW5nbGUoRGVsYXVuYXlUcmlhbmdsZSB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJpYW5nbGVzLkFkZCh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZFRyaWFuZ2xlcyhJRW51bWVyYWJsZTxEZWxhdW5heVRyaWFuZ2xlPiBsaXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yZWFjaCAoRGVsYXVuYXlUcmlhbmdsZSB0cmkgaW4gbGlzdCkgVHJpYW5nbGVzLkFkZCh0cmkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXJUcmlhbmdsZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJpYW5nbGVzLkNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIFByZXBhcmVUcmlhbmd1bGF0aW9uKFRyaWFuZ3VsYXRpb25Db250ZXh0IHRjeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChUcmlhbmdsZXMgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJpYW5nbGVzID0gbmV3IExpc3Q8RGVsYXVuYXlUcmlhbmdsZT4oUG9pbnRzLkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyaWFuZ2xlcy5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRjeC5Qb2ludHMuQWRkUmFuZ2UoUG9pbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbnB1YmxpYyBjbGFzcyBRdWFkVHJlZUJyb2FkUGhhc2UgOiBJQnJvYWRQaGFzZVxyXG57XHJcbiAgICBwcml2YXRlIGNvbnN0IGludCBUcmVlVXBkYXRlVGhyZXNoID0gMTAwMDA7XHJcbiAgICBwcml2YXRlIGludCBfY3VycklEO1xyXG4gICAgcHJpdmF0ZSBEaWN0aW9uYXJ5PGludCwgRWxlbWVudDxGaXh0dXJlUHJveHk+PiBfaWRSZWdpc3RlcjtcclxuICAgIHByaXZhdGUgTGlzdDxFbGVtZW50PEZpeHR1cmVQcm94eT4+IF9tb3ZlQnVmZmVyO1xyXG4gICAgcHJpdmF0ZSBMaXN0PFBhaXI+IF9wYWlyQnVmZmVyO1xyXG4gICAgcHJpdmF0ZSBRdWFkVHJlZTxGaXh0dXJlUHJveHk+IF9xdWFkVHJlZTtcclxuICAgIHByaXZhdGUgaW50IF90cmVlTW92ZU51bTtcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQ3JlYXRlcyBhIG5ldyBxdWFkIHRyZWUgYnJvYWRwaGFzZSB3aXRoIHRoZSBzcGVjaWZpZWQgc3Bhbi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJzcGFuXCI+dGhlIG1heGltdW0gc3BhbiBvZiB0aGUgdHJlZSAod29ybGQgc2l6ZSk8L3BhcmFtPlxyXG4gICAgcHVibGljIFF1YWRUcmVlQnJvYWRQaGFzZShBQUJCIHNwYW4pXHJcbiAgICB7XHJcbiAgICAgICAgX3F1YWRUcmVlID0gbmV3IFF1YWRUcmVlPEZpeHR1cmVQcm94eT4oc3BhbiwgNSwgMTApO1xyXG4gICAgICAgIF9pZFJlZ2lzdGVyID0gbmV3IERpY3Rpb25hcnk8aW50LCBFbGVtZW50PEZpeHR1cmVQcm94eT4+KCk7XHJcbiAgICAgICAgX21vdmVCdWZmZXIgPSBuZXcgTGlzdDxFbGVtZW50PEZpeHR1cmVQcm94eT4+KCk7XHJcbiAgICAgICAgX3BhaXJCdWZmZXIgPSBuZXcgTGlzdDxQYWlyPigpO1xyXG4gICAgfVxyXG5cclxuICAgICNyZWdpb24gSUJyb2FkUGhhc2UgTWVtYmVyc1xyXG5cclxuICAgIC8vLzxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoZSBudW1iZXIgb2YgcHJveGllc1xyXG4gICAgLy8vPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGludCBQcm94eUNvdW50XHJcbiAgICB7XHJcbiAgICAgICAgZ2V0IHsgcmV0dXJuIF9pZFJlZ2lzdGVyLkNvdW50OyB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgR2V0RmF0QUFCQihpbnQgcHJveHlJRCwgb3V0IEFBQkIgYWFiYilcclxuICAgIHtcclxuICAgICAgICBpZiAoX2lkUmVnaXN0ZXIuQ29udGFpbnNLZXkocHJveHlJRCkpXHJcbiAgICAgICAgICAgIGFhYmIgPSBfaWRSZWdpc3Rlcltwcm94eUlEXS5TcGFuO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleU5vdEZvdW5kRXhjZXB0aW9uKFwicHJveHlJRCBub3QgZm91bmQgaW4gcmVnaXN0ZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgVXBkYXRlUGFpcnMoQnJvYWRwaGFzZURlbGVnYXRlIGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIF9wYWlyQnVmZmVyLkNsZWFyKCk7XHJcbiAgICAgICAgZm9yZWFjaCAoRWxlbWVudDxGaXh0dXJlUHJveHk+IHF0bm9kZSBpbiBfbW92ZUJ1ZmZlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFF1ZXJ5IHRyZWUsIGNyZWF0ZSBwYWlycyBhbmQgYWRkIHRoZW0gcGFpciBidWZmZXIuXHJcbiAgICAgICAgICAgIFF1ZXJ5KChnbG9iYWw6OlN5c3RlbS5GdW5jPGludCwgYm9vbD4pKHByb3h5SUQgPT4gUGFpckJ1ZmZlclF1ZXJ5Q2FsbGJhY2socHJveHlJRCwgcXRub2RlLlZhbHVlLlByb3h5SWQpKSwgcmVmIHF0bm9kZS5TcGFuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX21vdmVCdWZmZXIuQ2xlYXIoKTtcclxuXHJcbiAgICAgICAgLy8gU29ydCB0aGUgcGFpciBidWZmZXIgdG8gZXhwb3NlIGR1cGxpY2F0ZXMuXHJcbiAgICAgICAgX3BhaXJCdWZmZXIuU29ydCgpO1xyXG5cclxuICAgICAgICAvLyBTZW5kIHRoZSBwYWlycyBiYWNrIHRvIHRoZSBjbGllbnQuXHJcbiAgICAgICAgaW50IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgX3BhaXJCdWZmZXIuQ291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQYWlyIHByaW1hcnlQYWlyID0gX3BhaXJCdWZmZXJbaV07XHJcbiAgICAgICAgICAgIEZpeHR1cmVQcm94eSB1c2VyRGF0YUEgPSBHZXRQcm94eShwcmltYXJ5UGFpci5Qcm94eUlkQSk7XHJcbiAgICAgICAgICAgIEZpeHR1cmVQcm94eSB1c2VyRGF0YUIgPSBHZXRQcm94eShwcmltYXJ5UGFpci5Qcm94eUlkQik7XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjayhyZWYgdXNlckRhdGFBLCByZWYgdXNlckRhdGFCKTtcclxuICAgICAgICAgICAgKytpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2tpcCBhbnkgZHVwbGljYXRlIHBhaXJzLlxyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IF9wYWlyQnVmZmVyLkNvdW50ICYmIF9wYWlyQnVmZmVyW2ldLlByb3h5SWRBID09IHByaW1hcnlQYWlyLlByb3h5SWRBICYmXHJcbiAgICAgICAgICAgICAgICAgICBfcGFpckJ1ZmZlcltpXS5Qcm94eUlkQiA9PSBwcmltYXJ5UGFpci5Qcm94eUlkQilcclxuICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRlc3Qgb3ZlcmxhcCBvZiBmYXQgQUFCQnMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwicHJveHlJZEFcIj5UaGUgcHJveHkgaWQgQS48L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwicHJveHlJZEJcIj5UaGUgcHJveHkgaWQgQi48L3BhcmFtPlxyXG4gICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgIHB1YmxpYyBib29sIFRlc3RPdmVybGFwKGludCBwcm94eUlkQSwgaW50IHByb3h5SWRCKVxyXG4gICAge1xyXG4gICAgICAgIEFBQkIgYWFiYjE7XHJcbiAgICAgICAgQUFCQiBhYWJiMjtcclxuICAgICAgICBHZXRGYXRBQUJCKHByb3h5SWRBLCBvdXQgYWFiYjEpO1xyXG4gICAgICAgIEdldEZhdEFBQkIocHJveHlJZEIsIG91dCBhYWJiMik7XHJcbiAgICAgICAgcmV0dXJuIEFBQkIuVGVzdE92ZXJsYXAocmVmIGFhYmIxLCByZWYgYWFiYjIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbnQgQWRkUHJveHkocmVmIEZpeHR1cmVQcm94eSBwcm94eSlcclxuICAgIHtcclxuICAgICAgICBpbnQgcHJveHlJRCA9IF9jdXJySUQrKztcclxuICAgICAgICBwcm94eS5Qcm94eUlkID0gcHJveHlJRDtcclxuICAgICAgICBBQUJCIGFhYmIgPSBGYXR0ZW4ocmVmIHByb3h5LkFBQkIpO1xyXG4gICAgICAgIEVsZW1lbnQ8Rml4dHVyZVByb3h5PiBxdG5vZGUgPSBuZXcgRWxlbWVudDxGaXh0dXJlUHJveHk+KHByb3h5LCBhYWJiKTtcclxuXHJcbiAgICAgICAgX2lkUmVnaXN0ZXIuQWRkKHByb3h5SUQsIHF0bm9kZSk7XHJcbiAgICAgICAgX3F1YWRUcmVlLkFkZE5vZGUocXRub2RlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3h5SUQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgUmVtb3ZlUHJveHkoaW50IHByb3h5SWQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKF9pZFJlZ2lzdGVyLkNvbnRhaW5zS2V5KHByb3h5SWQpKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRWxlbWVudDxGaXh0dXJlUHJveHk+IHF0bm9kZSA9IF9pZFJlZ2lzdGVyW3Byb3h5SWRdO1xyXG4gICAgICAgICAgICBVbmJ1ZmZlck1vdmUocXRub2RlKTtcclxuICAgICAgICAgICAgX2lkUmVnaXN0ZXIuUmVtb3ZlKHByb3h5SWQpO1xyXG4gICAgICAgICAgICBfcXVhZFRyZWUuUmVtb3ZlTm9kZShxdG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlOb3RGb3VuZEV4Y2VwdGlvbihcInByb3h5SUQgbm90IGZvdW5kIGluIHJlZ2lzdGVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIE1vdmVQcm94eShpbnQgcHJveHlJZCwgcmVmIEFBQkIgYWFiYiwgVmVjdG9yMiBkaXNwbGFjZW1lbnQpXHJcbiAgICB7XHJcbiAgICAgICAgQUFCQiBmYXRBQUJCO1xyXG4gICAgICAgIEdldEZhdEFBQkIocHJveHlJZCwgb3V0IGZhdEFBQkIpO1xyXG5cclxuICAgICAgICAvL2V4aXQgaWYgbW92ZW1lbnQgaXMgd2l0aGluIGZhdCBhYWJiXHJcbiAgICAgICAgaWYgKGZhdEFBQkIuQ29udGFpbnMocmVmIGFhYmIpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIEV4dGVuZCBBQUJCLlxyXG4gICAgICAgIEFBQkIgYiA9IGFhYmI7XHJcbiAgICAgICAgVmVjdG9yMiByID0gbmV3IFZlY3RvcjIoU2V0dGluZ3MuQUFCQkV4dGVuc2lvbiwgU2V0dGluZ3MuQUFCQkV4dGVuc2lvbik7XHJcbiAgICAgICAgYi5Mb3dlckJvdW5kID0gYi5Mb3dlckJvdW5kIC0gcjtcclxuICAgICAgICBiLlVwcGVyQm91bmQgPSBiLlVwcGVyQm91bmQgKyByO1xyXG5cclxuICAgICAgICAvLyBQcmVkaWN0IEFBQkIgZGlzcGxhY2VtZW50LlxyXG4gICAgICAgIFZlY3RvcjIgZCA9IFNldHRpbmdzLkFBQkJNdWx0aXBsaWVyICogZGlzcGxhY2VtZW50O1xyXG5cclxuICAgICAgICBpZiAoZC5YIDwgMC4wZilcclxuICAgICAgICAgICAgYi5Mb3dlckJvdW5kLlggKz0gZC5YO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgYi5VcHBlckJvdW5kLlggKz0gZC5YO1xyXG5cclxuICAgICAgICBpZiAoZC5ZIDwgMC4wZilcclxuICAgICAgICAgICAgYi5Mb3dlckJvdW5kLlkgKz0gZC5ZO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgYi5VcHBlckJvdW5kLlkgKz0gZC5ZO1xyXG5cclxuXHJcbiAgICAgICAgRWxlbWVudDxGaXh0dXJlUHJveHk+IHF0bm9kZSA9IF9pZFJlZ2lzdGVyW3Byb3h5SWRdO1xyXG4gICAgICAgIHF0bm9kZS5WYWx1ZS5BQUJCID0gYjsgLy9ub3QgbmVjY2VzYXJ5IGZvciBRVHJlZSwgYnV0IG1pZ2h0IGJlIGFjY2Vzc2VkIGV4dGVybmFsbHlcclxuICAgICAgICBxdG5vZGUuU3BhbiA9IGI7XHJcblxyXG4gICAgICAgIFJlaW5zZXJ0Tm9kZShxdG5vZGUpO1xyXG5cclxuICAgICAgICBCdWZmZXJNb3ZlKHF0bm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIEZpeHR1cmVQcm94eSBHZXRQcm94eShpbnQgcHJveHlJZClcclxuICAgIHtcclxuICAgICAgICBpZiAoX2lkUmVnaXN0ZXIuQ29udGFpbnNLZXkocHJveHlJZCkpXHJcbiAgICAgICAgICAgIHJldHVybiBfaWRSZWdpc3Rlcltwcm94eUlkXS5WYWx1ZTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlOb3RGb3VuZEV4Y2VwdGlvbihcInByb3h5SUQgbm90IGZvdW5kIGluIHJlZ2lzdGVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIFRvdWNoUHJveHkoaW50IHByb3h5SWQpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKF9pZFJlZ2lzdGVyLkNvbnRhaW5zS2V5KHByb3h5SWQpKVxyXG4gICAgICAgICAgICBCdWZmZXJNb3ZlKF9pZFJlZ2lzdGVyW3Byb3h5SWRdKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlOb3RGb3VuZEV4Y2VwdGlvbihcInByb3h5SUQgbm90IGZvdW5kIGluIHJlZ2lzdGVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIFF1ZXJ5KEZ1bmM8aW50LCBib29sPiBjYWxsYmFjaywgcmVmIEFBQkIgcXVlcnkpXHJcbiAgICB7XHJcbiAgICAgICAgX3F1YWRUcmVlLlF1ZXJ5QUFCQigoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxnbG9iYWw6OkVsZW1lbnQ8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5GaXh0dXJlUHJveHk+LCBib29sPilUcmFuc2Zvcm1QcmVkaWNhdGUoKGdsb2JhbDo6U3lzdGVtLkZ1bmM8aW50LCBib29sPiljYWxsYmFjayksIHJlZiBxdWVyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgUmF5Q2FzdChGdW5jPFJheUNhc3RJbnB1dCwgaW50LCBmbG9hdD4gY2FsbGJhY2ssIHJlZiBSYXlDYXN0SW5wdXQgaW5wdXQpXHJcbiAgICB7XHJcbiAgICAgICAgX3F1YWRUcmVlLlJheUNhc3QoKGdsb2JhbDo6U3lzdGVtLkZ1bmM8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uUmF5Q2FzdElucHV0LCBnbG9iYWw6OkVsZW1lbnQ8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5GaXh0dXJlUHJveHk+LCBmbG9hdD4pVHJhbnNmb3JtUmF5Q2FsbGJhY2soKGdsb2JhbDo6U3lzdGVtLkZ1bmM8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uUmF5Q2FzdElucHV0LCBpbnQsIGZsb2F0PiljYWxsYmFjayksIHJlZiBpbnB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgI2VuZHJlZ2lvblxyXG5cclxuICAgIHByaXZhdGUgQUFCQiBGYXR0ZW4ocmVmIEFBQkIgYWFiYilcclxuICAgIHtcclxuICAgICAgICBWZWN0b3IyIHIgPSBuZXcgVmVjdG9yMihTZXR0aW5ncy5BQUJCRXh0ZW5zaW9uLCBTZXR0aW5ncy5BQUJCRXh0ZW5zaW9uKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFBQkIoYWFiYi5Mb3dlckJvdW5kIC0gciwgYWFiYi5VcHBlckJvdW5kICsgcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBGdW5jPEVsZW1lbnQ8Rml4dHVyZVByb3h5PiwgYm9vbD4gVHJhbnNmb3JtUHJlZGljYXRlKEZ1bmM8aW50LCBib29sPiBpZFByZWRpY2F0ZSlcclxuICAgIHtcclxuICAgICAgICBGdW5jPEVsZW1lbnQ8Rml4dHVyZVByb3h5PiwgYm9vbD4gcXRQcmVkID0gcXRub2RlID0+IGlkUHJlZGljYXRlKHF0bm9kZS5WYWx1ZS5Qcm94eUlkKTtcclxuICAgICAgICByZXR1cm4gcXRQcmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgRnVuYzxSYXlDYXN0SW5wdXQsIEVsZW1lbnQ8Rml4dHVyZVByb3h5PiwgZmxvYXQ+IFRyYW5zZm9ybVJheUNhbGxiYWNrKFxyXG4gICAgICAgIEZ1bmM8UmF5Q2FzdElucHV0LCBpbnQsIGZsb2F0PiBjYWxsYmFjaylcclxuICAgIHtcclxuICAgICAgICBGdW5jPFJheUNhc3RJbnB1dCwgRWxlbWVudDxGaXh0dXJlUHJveHk+LCBmbG9hdD4gbmV3Q2FsbGJhY2sgPVxyXG4gICAgICAgICAgICAoaW5wdXQsIHF0bm9kZSkgPT4gY2FsbGJhY2soaW5wdXQsIHF0bm9kZS5WYWx1ZS5Qcm94eUlkKTtcclxuICAgICAgICByZXR1cm4gbmV3Q2FsbGJhY2s7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBib29sIFBhaXJCdWZmZXJRdWVyeUNhbGxiYWNrKGludCBwcm94eUlELCBpbnQgYmFzZUlEKVxyXG4gICAge1xyXG4gICAgICAgIC8vIEEgcHJveHkgY2Fubm90IGZvcm0gYSBwYWlyIHdpdGggaXRzZWxmLlxyXG4gICAgICAgIGlmIChwcm94eUlEID09IGJhc2VJRClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIFBhaXIgcCA9IG5ldyBQYWlyKCk7XHJcbiAgICAgICAgcC5Qcm94eUlkQSA9IE1hdGguTWluKHByb3h5SUQsIGJhc2VJRCk7XHJcbiAgICAgICAgcC5Qcm94eUlkQiA9IE1hdGguTWF4KHByb3h5SUQsIGJhc2VJRCk7XHJcbiAgICAgICAgX3BhaXJCdWZmZXIuQWRkKHApO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZvaWQgUmVjb25zdHJ1Y3RUcmVlKClcclxuICAgIHtcclxuICAgICAgICAvL3RoaXMgaXMgZmFzdGVyIHRoYW4gX3F1YWRUcmVlLlJlY29uc3RydWN0KCksIHNpbmNlIHRoZSBxdWFkdHJlZSBtZXRob2QgcnVucyBhIHJlY3VzaXZlIHF1ZXJ5IHRvIGZpbmQgYWxsIG5vZGVzLlxyXG4gICAgICAgIF9xdWFkVHJlZS5DbGVhcigpO1xyXG4gICAgICAgIGZvcmVhY2ggKEVsZW1lbnQ8Rml4dHVyZVByb3h5PiBlbGVtIGluIF9pZFJlZ2lzdGVyLlZhbHVlcylcclxuICAgICAgICAgICAgX3F1YWRUcmVlLkFkZE5vZGUoZWxlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB2b2lkIFJlaW5zZXJ0Tm9kZShFbGVtZW50PEZpeHR1cmVQcm94eT4gcXRub2RlKVxyXG4gICAge1xyXG4gICAgICAgIF9xdWFkVHJlZS5SZW1vdmVOb2RlKHF0bm9kZSk7XHJcbiAgICAgICAgX3F1YWRUcmVlLkFkZE5vZGUocXRub2RlKTtcclxuXHJcbiAgICAgICAgaWYgKCsrX3RyZWVNb3ZlTnVtID4gVHJlZVVwZGF0ZVRocmVzaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFJlY29uc3RydWN0VHJlZSgpO1xyXG4gICAgICAgICAgICBfdHJlZU1vdmVOdW0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZvaWQgQnVmZmVyTW92ZShFbGVtZW50PEZpeHR1cmVQcm94eT4gcHJveHkpXHJcbiAgICB7XHJcbiAgICAgICAgX21vdmVCdWZmZXIuQWRkKHByb3h5KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZvaWQgVW5idWZmZXJNb3ZlKEVsZW1lbnQ8Rml4dHVyZVByb3h5PiBwcm94eSlcclxuICAgIHtcclxuICAgICAgICBfbW92ZUJ1ZmZlci5SZW1vdmUocHJveHkpO1xyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29udHJvbGxlcnNcclxue1xyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIEFic3RyYWN0Rm9yY2VDb250cm9sbGVyIDogQ29udHJvbGxlclxyXG4gICAge1xyXG4gICAgICAgICNyZWdpb24gRGVjYXlNb2RlcyBlbnVtXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTW9kZXMgZm9yIERlY2F5LiBBY3R1YWwgRGVjYXkgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBpbmhlcml0aW5nIFxyXG4gICAgICAgIC8vLyBjbGFzc2VzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZW51bSBEZWNheU1vZGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBOb25lLFxyXG4gICAgICAgICAgICBTdGVwLFxyXG4gICAgICAgICAgICBMaW5lYXIsXHJcbiAgICAgICAgICAgIEludmVyc2VTcXVhcmUsXHJcbiAgICAgICAgICAgIEN1cnZlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gRm9yY2VUeXBlcyBlbnVtXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRm9yY2V0eXBlcyBhcmUgdXNlZCBpbiB0aGUgZGVjYXkgbWF0aCB0byBwcm9wZXJseSBnZXQgdGhlIGRpc3RhbmNlLlxyXG4gICAgICAgIC8vLyBUaGV5IGFyZSBhbHNvIHVzZWQgdG8gZHJhdyBhIHJlcHJlc2VudGF0aW9uIGluIERlYnVnVmlld1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGVudW0gRm9yY2VUeXBlc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnQsXHJcbiAgICAgICAgICAgIExpbmUsXHJcbiAgICAgICAgICAgIEFyZWFcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBUaW1pbmdNb2RlcyBlbnVtXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGltaW5nIE1vZGVzXHJcbiAgICAgICAgLy8vIFN3aXRjaGVkOiBTdGFuZGFyZCBvbi9vZmYgbW9kZSB1c2luZyB0aGUgYmFzZWNsYXNzIGVuYWJsZWQgcHJvcGVydHlcclxuICAgICAgICAvLy8gVHJpZ2dlcmVkOiBXaGVuIHRoZSBUcmlnZ2VyKCkgbWV0aG9kIGlzIGNhbGxlZCB0aGUgZm9yY2UgaXMgYWN0aXZlIFxyXG4gICAgICAgIC8vLyBmb3IgYSBzcGVjaWZpZWQgSW1wdWxzZSBMZW5ndGhcclxuICAgICAgICAvLy8gQ3VydmU6IFN0aWxsIHRvIGJlIGRlZmluZWQuIFRoZSBiYXNpYyBpZGVhIGlzIGhhdmluZyBhIFRyaWdnZXIgXHJcbiAgICAgICAgLy8vIGNvbWJpbmVkIHdpdGggYSBjdXJ2ZSBmb3IgdGhlIHN0cmVuZ3RoXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZW51bSBUaW1pbmdNb2Rlc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU3dpdGNoZWQsXHJcbiAgICAgICAgICAgIFRyaWdnZXJlZCxcclxuICAgICAgICAgICAgQ3VydmVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDdXJ2ZSB0byBiZSB1c2VkIGZvciBEZWNheSBpbiBDdXJ2ZSBtb2RlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQ3VydmUgRGVjYXlDdXJ2ZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgRm9yY2V0eXBlIG9mIHRoZSBpbnN0YW5jZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEZvcmNlVHlwZXMgRm9yY2VUeXBlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFByb3ZpZGVkIGZvciByZXVzZSB0byBwcm92aWRlIFZhcmlhdGlvbiBmdW5jdGlvbmFsaXR5IGluIFxyXG4gICAgICAgIC8vLyBpbmhlcml0aW5nIGNsYXNzZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCBSYW5kb20gUmFuZG9taXplO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEN1cnZlIHVzZWQgYnkgQ3VydmUgTW9kZSBhcyBhbiBhbmltYXRlZCBtdWx0aXBsaWVyIGZvciB0aGUgZm9yY2UgXHJcbiAgICAgICAgLy8vIHN0cmVuZ3RoLlxyXG4gICAgICAgIC8vLyBPbmx5IHBvc2l0aW9ucyBiZXR3ZWVuIDAgYW5kIDEgYXJlIGNvbnNpZGVyZWQgYXMgdGhhdCByYW5nZSBpcyBcclxuICAgICAgICAvLy8gc3RyZXRjaGVkIHRvIGhhdmUgSW1wdWxzZUxlbmd0aC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBDdXJ2ZSBTdHJlbmd0aEN1cnZlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQWJzdHJhY3RGb3JjZUNvbnRyb2xsZXIoKVxyXG4gICAgICAgICAgICA6IGJhc2UoQ29udHJvbGxlclR5cGUuQWJzdHJhY3RGb3JjZUNvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIFN0cmVuZ3RoID0gMS4wZjtcclxuICAgICAgICAgICAgUG9zaXRpb24gPSBuZXcgVmVjdG9yMigwLCAwKTtcclxuICAgICAgICAgICAgTWF4aW11bVNwZWVkID0gMTAwLjBmO1xyXG4gICAgICAgICAgICBUaW1pbmdNb2RlID0gVGltaW5nTW9kZXMuU3dpdGNoZWQ7XHJcbiAgICAgICAgICAgIEltcHVsc2VUaW1lID0gMC4wZjtcclxuICAgICAgICAgICAgSW1wdWxzZUxlbmd0aCA9IDEuMGY7XHJcbiAgICAgICAgICAgIFRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBTdHJlbmd0aEN1cnZlID0gbmV3IEN1cnZlKCk7XHJcbiAgICAgICAgICAgIFZhcmlhdGlvbiA9IDAuMGY7XHJcbiAgICAgICAgICAgIFJhbmRvbWl6ZSA9IG5ldyBSYW5kb20oMTIzNCk7XHJcbiAgICAgICAgICAgIERlY2F5TW9kZSA9IERlY2F5TW9kZXMuTm9uZTtcclxuICAgICAgICAgICAgRGVjYXlDdXJ2ZSA9IG5ldyBDdXJ2ZSgpO1xyXG4gICAgICAgICAgICBEZWNheVN0YXJ0ID0gMC4wZjtcclxuICAgICAgICAgICAgRGVjYXlFbmQgPSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgU3RyZW5ndGhDdXJ2ZS5LZXlzLkFkZChuZXcgQ3VydmVLZXkoMCwgNSkpO1xyXG4gICAgICAgICAgICBTdHJlbmd0aEN1cnZlLktleXMuQWRkKG5ldyBDdXJ2ZUtleSgwLjFmLCA1KSk7XHJcbiAgICAgICAgICAgIFN0cmVuZ3RoQ3VydmUuS2V5cy5BZGQobmV3IEN1cnZlS2V5KDAuMmYsIC00KSk7XHJcbiAgICAgICAgICAgIFN0cmVuZ3RoQ3VydmUuS2V5cy5BZGQobmV3IEN1cnZlS2V5KDFmLCAwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE92ZXJsb2FkZWQgQ29udHN0cnVjdG9yIHdpdGggc3VwcGx5aW5nIFRpbWluZyBNb2RlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtb2RlXCI+PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgQWJzdHJhY3RGb3JjZUNvbnRyb2xsZXIoVGltaW5nTW9kZXMgbW9kZSlcclxuICAgICAgICAgICAgOiBiYXNlKENvbnRyb2xsZXJUeXBlLkFic3RyYWN0Rm9yY2VDb250cm9sbGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVGltaW5nTW9kZSA9IG1vZGU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUaW1pbmdNb2Rlcy5Td2l0Y2hlZDpcclxuICAgICAgICAgICAgICAgICAgICBFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgVGltaW5nTW9kZXMuVHJpZ2dlcmVkOlxyXG4gICAgICAgICAgICAgICAgICAgIEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgVGltaW5nTW9kZXMuQ3VydmU6XHJcbiAgICAgICAgICAgICAgICAgICAgRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdsb2JhbCBTdHJlbmd0aCBvZiB0aGUgZm9yY2UgdG8gYmUgYXBwbGllZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFN0cmVuZ3RoIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQb3NpdGlvbiBvZiB0aGUgRm9yY2UuIENhbiBiZSBpZ25vcmVkIChsZWZ0IGF0ICgwLDApIGZvciBmb3JjZXNcclxuICAgICAgICAvLy8gdGhhdCBhcmUgbm90IHBvc2l0aW9uLWRlcGVuZGVudFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgUG9zaXRpb24geyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1heGltdW0gc3BlZWQgb2YgdGhlIGJvZGllcy4gQm9kaWVzIHRoYXQgYXJlIHRyYXZlbGxpbmcgZmFzdGVyIGFyZVxyXG4gICAgICAgIC8vLyBzdXBwb3NlZCB0byBiZSBpZ25vcmVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4aW11bVNwZWVkIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNYXhpbXVtIEZvcmNlIHRvIGJlIGFwcGxpZWQuIEFzIG9wcG9zZWQgdG8gTWF4aW11bSBTcGVlZCB0aGlzIGlzIFxyXG4gICAgICAgIC8vLyBpbmRlcGVuZGVudCBvZiB0aGUgdmVsb2NpdHkgb2ZcclxuICAgICAgICAvLy8gdGhlIGFmZmVjdGVkIGJvZHlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhpbXVtRm9yY2UgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRpbWluZyBNb2RlIG9mIHRoZSBmb3JjZSBpbnN0YW5jZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFRpbWluZ01vZGVzIFRpbWluZ01vZGUgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRpbWUgb2YgdGhlIGN1cnJlbnQgaW1wdWxzZS4gSW5jcmVtZW50ZWQgaW4gdXBkYXRlIHRpbGwgXHJcbiAgICAgICAgLy8vIEltcHVsc2VMZW5ndGggaXMgcmVhY2hlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEltcHVsc2VUaW1lIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIExlbmd0aCBvZiBhIHRyaWdnZXJlZCBpbXB1bHNlLiBVc2VkIGluIGJvdGggVHJpZ2dlcmVkIGFuZCBDdXJ2ZSBNb2RlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSW1wdWxzZUxlbmd0aCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5kaWNhdGluZyBpZiB3ZSBhcmUgY3VycmVudGx5IGR1cmluZyBhbiBJbXB1bHNlIFxyXG4gICAgICAgIC8vLyAoVHJpZ2dlcmVkIGFuZCBDdXJ2ZSBNb2RlKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgVHJpZ2dlcmVkIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFZhcmlhdGlvbiBvZiB0aGUgZm9yY2UgYXBwbGllZCB0byBlYWNoIGJvZHkgYWZmZWN0ZWRcclxuICAgICAgICAvLy8gISEgTXVzdCBiZSB1c2VkIGluIGluaGVyaXRpbmcgY2xhc3NlcyBwcm9wZXJseSAhIVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFZhcmlhdGlvbiB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2VlIERlY2F5TW9kZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBEZWNheU1vZGVzIERlY2F5TW9kZSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3RhcnQgb2YgdGhlIGRpc3RhbmNlIGJhc2VkIERlY2F5LiBUbyBzZXQgYSBub24gZGVjYXlpbmcgYXJlYVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IERlY2F5U3RhcnQgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1heGltdW0gZGlzdGFuY2UgYSBmb3JjZSBzaG91bGQgYmUgYXBwbGllZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IERlY2F5RW5kIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDYWxjdWxhdGUgdGhlIERlY2F5IGZvciBhIGdpdmVuIGJvZHkuIE1lYW50IHRvIGVhc2UgZm9yY2UgXHJcbiAgICAgICAgLy8vIGRldmVsb3BtZW50IGFuZCBzdGljayB0byB0aGUgRFJZIHByaW5jaXBsZSBhbmQgcHJvdmlkZSB1bmlmaWVkIGFuZCBcclxuICAgICAgICAvLy8gcHJlZGljdGFibGUgZGVjYXkgbWF0aC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlcIj5UaGUgYm9keSB0byBjYWxjdWxhdGUgZGVjYXkgZm9yPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBtdWx0aXBsaWVyIHRvIG11bHRpcGx5IHRoZSBmb3JjZSB3aXRoIHRvIGFkZCBkZWNheSBcclxuICAgICAgICAvLy8gc3VwcG9ydCBpbiBpbmhlcml0aW5nIGNsYXNzZXM8L3JldHVybnM+XHJcbiAgICAgICAgcHJvdGVjdGVkIGZsb2F0IEdldERlY2F5TXVsdGlwbGllcihCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1RPRE86IENvbnNpZGVyIEZvcmNlVHlwZSBpbiBkaXN0YW5jZSBjYWxjdWxhdGlvbiFcclxuICAgICAgICAgICAgZmxvYXQgZGlzdGFuY2UgPSAoYm9keS5Qb3NpdGlvbiAtIFBvc2l0aW9uKS5MZW5ndGgoKTtcclxuICAgICAgICAgICAgc3dpdGNoIChEZWNheU1vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGVjYXlNb2Rlcy5Ob25lOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBEZWNheU1vZGVzLlN0ZXA6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBEZWNheUVuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY2F5TW9kZXMuTGluZWFyOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgRGVjYXlTdGFydClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBEZWNheUVuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKERlY2F5RW5kIC0gRGVjYXlTdGFydCAvIGRpc3RhbmNlIC0gRGVjYXlTdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBEZWNheU1vZGVzLkludmVyc2VTcXVhcmU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBEZWNheVN0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxLjBmIC8gKChkaXN0YW5jZSAtIERlY2F5U3RhcnQpICogKGRpc3RhbmNlIC0gRGVjYXlTdGFydCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgRGVjYXlNb2Rlcy5DdXJ2ZTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IERlY2F5U3RhcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMS4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY2F5Q3VydmUuRXZhbHVhdGUoZGlzdGFuY2UgLSBEZWNheVN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRyaWdnZXJzIHRoZSB0cmlnZ2VyIG1vZGVzIChUcmlnZ2VyIGFuZCBDdXJ2ZSlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFRyaWdnZXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgSW1wdWxzZVRpbWUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbmhlcml0ZWQgZnJvbSBDb250cm9sbGVyXHJcbiAgICAgICAgLy8vIERlcGVuZGluZyBvbiB0aGUgVGltaW5nTW9kZSBwZXJmb3JtIHRpbWluZyBsb2dpYyBhbmQgY2FsbCBBcHBseUZvcmNlKClcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImR0XCI+PC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBVcGRhdGUoZmxvYXQgZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKFRpbWluZ01vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgVGltaW5nTW9kZXMuU3dpdGNoZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRW5hYmxlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwbHlGb3JjZShkdCwgU3RyZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgVGltaW5nTW9kZXMuVHJpZ2dlcmVkOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEVuYWJsZWQgJiYgVHJpZ2dlcmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoSW1wdWxzZVRpbWUgPCBJbXB1bHNlTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcGx5Rm9yY2UoZHQsIFN0cmVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbXB1bHNlVGltZSArPSBkdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWluZ01vZGVzLkN1cnZlOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEVuYWJsZWQgJiYgVHJpZ2dlcmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoSW1wdWxzZVRpbWUgPCBJbXB1bHNlTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcGx5Rm9yY2UoZHQsIFN0cmVuZ3RoICogU3RyZW5ndGhDdXJ2ZS5FdmFsdWF0ZShJbXB1bHNlVGltZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEltcHVsc2VUaW1lICs9IGR0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSB0aGUgZm9yY2Ugc3VwcGx5aW5nIHN0cmVuZ3RoICh3aWNoIGlzIG1vZGlmaWVkIGluIFVwZGF0ZSgpIFxyXG4gICAgICAgIC8vLyBhY2NvcmRpbmcgdG8gdGhlIFRpbWluZ01vZGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImR0XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdHJlbmd0aFwiPlRoZSBzdHJlbmd0aDwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgQXBwbHlGb3JjZShmbG9hdCBkdCwgZmxvYXQgc3RyZW5ndGgpO1xyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbnRyb2xsZXJzXHJcbntcclxuICAgIHB1YmxpYyBzZWFsZWQgY2xhc3MgQnVveWFuY3lDb250cm9sbGVyIDogQ29udHJvbGxlclxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29udHJvbHMgdGhlIHJvdGF0aW9uYWwgZHJhZyB0aGF0IHRoZSBmbHVpZCBleGVydHMgb24gdGhlIGJvZGllcyB3aXRoaW4gaXQuIFVzZSBoaWdoZXIgdmFsdWVzIHdpbGwgc2ltdWxhdGUgdGhpY2sgZmx1aWQsIGxpa2UgaG9uZXksIGxvd2VyIHZhbHVlcyB0b1xyXG4gICAgICAgIC8vLyBzaW11bGF0ZSB3YXRlci1saWtlIGZsdWlkcy4gXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQW5ndWxhckRyYWdDb2VmZmljaWVudDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZW5zaXR5IG9mIHRoZSBmbHVpZC4gSGlnaGVyIHZhbHVlcyB3aWxsIG1ha2UgdGhpbmdzIG1vcmUgYnVveWFudCwgbG93ZXIgdmFsdWVzIHdpbGwgY2F1c2UgdGhpbmdzIHRvIHNpbmsuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGVuc2l0eTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb250cm9scyB0aGUgbGluZWFyIGRyYWcgdGhhdCB0aGUgZmx1aWQgZXhlcnRzIG9uIHRoZSBib2RpZXMgd2l0aGluIGl0LiAgVXNlIGhpZ2hlciB2YWx1ZXMgd2lsbCBzaW11bGF0ZSB0aGljayBmbHVpZCwgbGlrZSBob25leSwgbG93ZXIgdmFsdWVzIHRvXHJcbiAgICAgICAgLy8vIHNpbXVsYXRlIHdhdGVyLWxpa2UgZmx1aWRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExpbmVhckRyYWdDb2VmZmljaWVudDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBY3RzIGxpa2Ugd2F0ZXJmbG93LiBEZWZhdWx0cyB0byAwLDAuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBWZWxvY2l0eTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBBQUJCIF9jb250YWluZXI7XHJcblxyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfZ3Jhdml0eTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX25vcm1hbDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9vZmZzZXQ7XHJcbiAgICAgICAgcHJpdmF0ZSBEaWN0aW9uYXJ5PGludCwgQm9keT4gX3VuaXF1ZUJvZGllcyA9IG5ldyBEaWN0aW9uYXJ5PGludCwgQm9keT4oKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgPHNlZSBjcmVmPVwiQnVveWFuY3lDb250cm9sbGVyXCIvPiBjbGFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbnRhaW5lclwiPk9ubHkgYm9kaWVzIGluc2lkZSB0aGlzIEFBQkIgd2lsbCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBjb250cm9sbGVyPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkZW5zaXR5XCI+RGVuc2l0eSBvZiB0aGUgZmx1aWQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxpbmVhckRyYWdDb2VmZmljaWVudFwiPkxpbmVhciBkcmFnIGNvZWZmaWNpZW50IG9mIHRoZSBmbHVpZDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicm90YXRpb25hbERyYWdDb2VmZmljaWVudFwiPlJvdGF0aW9uYWwgZHJhZyBjb2VmZmljaWVudCBvZiB0aGUgZmx1aWQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImdyYXZpdHlcIj5UaGUgZGlyZWN0aW9uIGdyYXZpdHkgYWN0cy4gQnVveWFuY3kgZm9yY2Ugd2lsbCBhY3QgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uIG9mIGdyYXZpdHkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgQnVveWFuY3lDb250cm9sbGVyKEFBQkIgY29udGFpbmVyLCBmbG9hdCBkZW5zaXR5LCBmbG9hdCBsaW5lYXJEcmFnQ29lZmZpY2llbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCByb3RhdGlvbmFsRHJhZ0NvZWZmaWNpZW50LCBWZWN0b3IyIGdyYXZpdHkpXHJcbiAgICAgICAgICAgIDogYmFzZShDb250cm9sbGVyVHlwZS5CdW95YW5jeUNvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgICAgIF9ub3JtYWwgPSBuZXcgVmVjdG9yMigwLCAxKTtcclxuICAgICAgICAgICAgRGVuc2l0eSA9IGRlbnNpdHk7XHJcbiAgICAgICAgICAgIExpbmVhckRyYWdDb2VmZmljaWVudCA9IGxpbmVhckRyYWdDb2VmZmljaWVudDtcclxuICAgICAgICAgICAgQW5ndWxhckRyYWdDb2VmZmljaWVudCA9IHJvdGF0aW9uYWxEcmFnQ29lZmZpY2llbnQ7XHJcbiAgICAgICAgICAgIF9ncmF2aXR5ID0gZ3Jhdml0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBBQUJCIENvbnRhaW5lclxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9jb250YWluZXI7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9jb250YWluZXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBfY29udGFpbmVyLlVwcGVyQm91bmQuWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgVXBkYXRlKGZsb2F0IGR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3VuaXF1ZUJvZGllcy5DbGVhcigpO1xyXG4gICAgICAgICAgICBXb3JsZC5RdWVyeUFBQkIoKGdsb2JhbDo6U3lzdGVtLkZ1bmM8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5GaXh0dXJlLCBib29sPikoZml4dHVyZSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeHR1cmUuQm9keS5Jc1N0YXRpYyB8fCAhZml4dHVyZS5Cb2R5LkF3YWtlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV91bmlxdWVCb2RpZXMuQ29udGFpbnNLZXkoZml4dHVyZS5Cb2R5LkJvZHlJZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdW5pcXVlQm9kaWVzLkFkZChmaXh0dXJlLkJvZHkuQm9keUlkLCBmaXh0dXJlLkJvZHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHJlZiBfY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEtleVZhbHVlUGFpcjxpbnQsIEJvZHk+IGt2IGluIF91bmlxdWVCb2RpZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keSA9IGt2LlZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYXJlYWMgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG1hc3NjID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgYXJlYSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXNzID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGJvZHkuRml4dHVyZUxpc3QuQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmUgPSBib2R5LkZpeHR1cmVMaXN0W2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZml4dHVyZS5TaGFwZS5TaGFwZVR5cGUgIT0gU2hhcGVUeXBlLlBvbHlnb24gJiYgZml4dHVyZS5TaGFwZS5TaGFwZVR5cGUgIT0gU2hhcGVUeXBlLkNpcmNsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFNoYXBlIHNoYXBlID0gZml4dHVyZS5TaGFwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBzYztcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzYXJlYSA9IHNoYXBlLkNvbXB1dGVTdWJtZXJnZWRBcmVhKF9ub3JtYWwsIF9vZmZzZXQsIGJvZHkuWGYsIG91dCBzYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJlYSArPSBzYXJlYTtcclxuICAgICAgICAgICAgICAgICAgICBhcmVhYy5YICs9IHNhcmVhICogc2MuWDtcclxuICAgICAgICAgICAgICAgICAgICBhcmVhYy5ZICs9IHNhcmVhICogc2MuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWFzcyArPSBzYXJlYSAqIHNoYXBlLkRlbnNpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFzc2MuWCArPSBzYXJlYSAqIHNjLlggKiBzaGFwZS5EZW5zaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIG1hc3NjLlkgKz0gc2FyZWEgKiBzYy5ZICogc2hhcGUuRGVuc2l0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBhcmVhYy5YIC89IGFyZWE7XHJcbiAgICAgICAgICAgICAgICBhcmVhYy5ZIC89IGFyZWE7XHJcbiAgICAgICAgICAgICAgICBtYXNzYy5YIC89IG1hc3M7XHJcbiAgICAgICAgICAgICAgICBtYXNzYy5ZIC89IG1hc3M7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQnVveWFuY3lcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYnVveWFuY3lGb3JjZSA9IC1EZW5zaXR5ICogYXJlYSAqIF9ncmF2aXR5O1xyXG4gICAgICAgICAgICAgICAgYm9keS5BcHBseUZvcmNlKGJ1b3lhbmN5Rm9yY2UsIG1hc3NjKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0xpbmVhciBkcmFnXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGRyYWdGb3JjZSA9IGJvZHkuR2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludChhcmVhYykgLSBWZWxvY2l0eTtcclxuICAgICAgICAgICAgICAgIGRyYWdGb3JjZSAqPSAtTGluZWFyRHJhZ0NvZWZmaWNpZW50ICogYXJlYTtcclxuICAgICAgICAgICAgICAgIGJvZHkuQXBwbHlGb3JjZShkcmFnRm9yY2UsIGFyZWFjKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0FuZ3VsYXIgZHJhZ1xyXG4gICAgICAgICAgICAgICAgYm9keS5BcHBseVRvcnF1ZSgtYm9keS5JbmVydGlhIC8gYm9keS5NYXNzICogYXJlYSAqIGJvZHkuQW5ndWxhclZlbG9jaXR5ICogQW5ndWxhckRyYWdDb2VmZmljaWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29udHJvbGxlcnNcclxue1xyXG4gICAgcHVibGljIGVudW0gR3Jhdml0eVR5cGVcclxuICAgIHtcclxuICAgICAgICBMaW5lYXIsXHJcbiAgICAgICAgRGlzdGFuY2VTcXVhcmVkXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNsYXNzIEdyYXZpdHlDb250cm9sbGVyIDogQ29udHJvbGxlclxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBMaXN0PEJvZHk+IEJvZGllcyA9IG5ldyBMaXN0PEJvZHk+KCk7XHJcbiAgICAgICAgcHVibGljIExpc3Q8VmVjdG9yMj4gUG9pbnRzID0gbmV3IExpc3Q8VmVjdG9yMj4oKTtcclxuXHJcbiAgICAgICAgcHVibGljIEdyYXZpdHlDb250cm9sbGVyKGZsb2F0IHN0cmVuZ3RoKVxyXG4gICAgICAgICAgICA6IGJhc2UoQ29udHJvbGxlclR5cGUuR3Jhdml0eUNvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdHJlbmd0aCA9IHN0cmVuZ3RoO1xyXG4gICAgICAgICAgICBNYXhSYWRpdXMgPSBmbG9hdC5NYXhWYWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBHcmF2aXR5Q29udHJvbGxlcihmbG9hdCBzdHJlbmd0aCwgZmxvYXQgbWF4UmFkaXVzLCBmbG9hdCBtaW5SYWRpdXMpXHJcbiAgICAgICAgICAgIDogYmFzZShDb250cm9sbGVyVHlwZS5HcmF2aXR5Q29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1pblJhZGl1cyA9IG1pblJhZGl1cztcclxuICAgICAgICAgICAgTWF4UmFkaXVzID0gbWF4UmFkaXVzO1xyXG4gICAgICAgICAgICBTdHJlbmd0aCA9IHN0cmVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1pblJhZGl1cyB7IGdldDsgc2V0OyB9XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heFJhZGl1cyB7IGdldDsgc2V0OyB9XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFN0cmVuZ3RoIHsgZ2V0OyBzZXQ7IH1cclxuICAgICAgICBwdWJsaWMgR3Jhdml0eVR5cGUgR3Jhdml0eVR5cGUgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBVcGRhdGUoZmxvYXQgZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIGYgPSBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChCb2R5IGJvZHkxIGluIFdvcmxkLkJvZHlMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQWN0aXZlT24oYm9keTEpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKEJvZHkgYm9keTIgaW4gQm9kaWVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5MSA9PSBib2R5MiB8fCAoYm9keTEuSXNTdGF0aWMgJiYgYm9keTIuSXNTdGF0aWMpIHx8ICFib2R5Mi5FbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gYm9keTIuV29ybGRDZW50ZXIgLSBib2R5MS5Xb3JsZENlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCByMiA9IGQuTGVuZ3RoU3F1YXJlZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocjIgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgciA9IGQuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyID49IE1heFJhZGl1cyB8fCByIDw9IE1pblJhZGl1cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoR3Jhdml0eVR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEdyYXZpdHlUeXBlLkRpc3RhbmNlU3F1YXJlZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBTdHJlbmd0aCAvIHIyIC8gKGZsb2F0KU1hdGguU3FydChyMikgKiBib2R5MS5NYXNzICogYm9keTIuTWFzcyAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBHcmF2aXR5VHlwZS5MaW5lYXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gU3RyZW5ndGggLyByMiAqIGJvZHkxLk1hc3MgKiBib2R5Mi5NYXNzICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTEuQXBwbHlGb3JjZShyZWYgZik7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMi5OZWdhdGUocmVmIGYsIG91dCBmKTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Mi5BcHBseUZvcmNlKHJlZiBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChWZWN0b3IyIHBvaW50IGluIFBvaW50cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGQgPSBwb2ludCAtIGJvZHkxLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHIyID0gZC5MZW5ndGhTcXVhcmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyMiA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCByID0gZC5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPj0gTWF4UmFkaXVzIHx8IHIgPD0gTWluUmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChHcmF2aXR5VHlwZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgR3Jhdml0eVR5cGUuRGlzdGFuY2VTcXVhcmVkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IFN0cmVuZ3RoIC8gcjIgLyAoZmxvYXQpTWF0aC5TcXJ0KHIyKSAqIGJvZHkxLk1hc3MgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgR3Jhdml0eVR5cGUuTGluZWFyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IFN0cmVuZ3RoIC8gcjIgKiBib2R5MS5NYXNzICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTEuQXBwbHlGb3JjZShyZWYgZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZEJvZHkoQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9kaWVzLkFkZChib2R5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZFBvaW50KFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHMuQWRkKHBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db250cm9sbGVyc1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gUHV0IGEgbGltaXQgb24gdGhlIGxpbmVhciAodHJhbnNsYXRpb24gLSB0aGUgbW92ZXNwZWVkKSBhbmQgYW5ndWxhciAocm90YXRpb24pIHZlbG9jaXR5XHJcbiAgICAvLy8gb2YgYm9kaWVzIGFkZGVkIHRvIHRoaXMgY29udHJvbGxlci5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgVmVsb2NpdHlMaW1pdENvbnRyb2xsZXIgOiBDb250cm9sbGVyXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGJvb2wgTGltaXRBbmd1bGFyVmVsb2NpdHkgPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpYyBib29sIExpbWl0TGluZWFyVmVsb2NpdHkgPSB0cnVlO1xyXG4gICAgICAgIHByaXZhdGUgTGlzdDxCb2R5PiBfYm9kaWVzID0gbmV3IExpc3Q8Qm9keT4oKTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXhBbmd1bGFyU3FhcmVkO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21heEFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXhMaW5lYXJTcWFyZWQ7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TGluZWFyVmVsb2NpdHk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIDxzZWUgY3JlZj1cIlZlbG9jaXR5TGltaXRDb250cm9sbGVyXCIvPiBjbGFzcy5cclxuICAgICAgICAvLy8gU2V0cyB0aGUgbWF4IGxpbmVhciB2ZWxvY2l0eSB0byBTZXR0aW5ncy5NYXhUcmFuc2xhdGlvblxyXG4gICAgICAgIC8vLyBTZXRzIHRoZSBtYXggYW5ndWxhciB2ZWxvY2l0eSB0byBTZXR0aW5ncy5NYXhSb3RhdGlvblxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlbG9jaXR5TGltaXRDb250cm9sbGVyKClcclxuICAgICAgICAgICAgOiBiYXNlKENvbnRyb2xsZXJUeXBlLlZlbG9jaXR5TGltaXRDb250cm9sbGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF4TGluZWFyVmVsb2NpdHkgPSBTZXR0aW5ncy5NYXhUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgTWF4QW5ndWxhclZlbG9jaXR5ID0gU2V0dGluZ3MuTWF4Um90YXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSA8c2VlIGNyZWY9XCJWZWxvY2l0eUxpbWl0Q29udHJvbGxlclwiLz4gY2xhc3MuXHJcbiAgICAgICAgLy8vIFBhc3MgaW4gMCBvciBmbG9hdC5NYXhWYWx1ZSB0byBkaXNhYmxlIHRoZSBsaW1pdC5cclxuICAgICAgICAvLy8gbWF4QW5ndWxhclZlbG9jaXR5ID0gMCB3aWxsIGRpc2FibGUgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgbGltaXQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhMaW5lYXJWZWxvY2l0eVwiPlRoZSBtYXggbGluZWFyIHZlbG9jaXR5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWF4QW5ndWxhclZlbG9jaXR5XCI+VGhlIG1heCBhbmd1bGFyIHZlbG9jaXR5LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFZlbG9jaXR5TGltaXRDb250cm9sbGVyKGZsb2F0IG1heExpbmVhclZlbG9jaXR5LCBmbG9hdCBtYXhBbmd1bGFyVmVsb2NpdHkpXHJcbiAgICAgICAgICAgIDogYmFzZShDb250cm9sbGVyVHlwZS5WZWxvY2l0eUxpbWl0Q29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChtYXhMaW5lYXJWZWxvY2l0eSA9PSAwIHx8IG1heExpbmVhclZlbG9jaXR5ID09IGZsb2F0Lk1heFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgTGltaXRMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1heEFuZ3VsYXJWZWxvY2l0eSA9PSAwIHx8IG1heEFuZ3VsYXJWZWxvY2l0eSA9PSBmbG9hdC5NYXhWYWx1ZSlcclxuICAgICAgICAgICAgICAgIExpbWl0QW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBNYXhMaW5lYXJWZWxvY2l0eSA9IG1heExpbmVhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICBNYXhBbmd1bGFyVmVsb2NpdHkgPSBtYXhBbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgbWF4IGFuZ3VsYXIgdmVsb2NpdHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBtYXggYW5ndWxhciB2ZWxvY2l0eS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhBbmd1bGFyVmVsb2NpdHlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbWF4QW5ndWxhclZlbG9jaXR5OyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbWF4QW5ndWxhclZlbG9jaXR5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBfbWF4QW5ndWxhclNxYXJlZCA9IF9tYXhBbmd1bGFyVmVsb2NpdHkgKiBfbWF4QW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgbWF4IGxpbmVhciB2ZWxvY2l0eS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIG1heCBsaW5lYXIgdmVsb2NpdHkuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TGluZWFyVmVsb2NpdHlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbWF4TGluZWFyVmVsb2NpdHk7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tYXhMaW5lYXJWZWxvY2l0eSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgX21heExpbmVhclNxYXJlZCA9IF9tYXhMaW5lYXJWZWxvY2l0eSAqIF9tYXhMaW5lYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgVXBkYXRlKGZsb2F0IGR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yZWFjaCAoQm9keSBib2R5IGluIF9ib2RpZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNBY3RpdmVPbihib2R5KSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoTGltaXRMaW5lYXJWZWxvY2l0eSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RyYW5zbGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGxhcmdlIHZlbG9jaXRpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdHJhbnNsYXRpb25YID0gZHQgKiBib2R5LkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB0cmFuc2xhdGlvblkgPSBkdCAqIGJvZHkuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJlc3VsdCA9IHRyYW5zbGF0aW9uWCAqIHRyYW5zbGF0aW9uWCArIHRyYW5zbGF0aW9uWSAqIHRyYW5zbGF0aW9uWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+IGR0ICogX21heExpbmVhclNxYXJlZClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHNxID0gKGZsb2F0KU1hdGguU3FydChyZXN1bHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcmF0aW8gPSBfbWF4TGluZWFyVmVsb2NpdHkgLyBzcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggKj0gcmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICo9IHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoTGltaXRBbmd1bGFyVmVsb2NpdHkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Sb3RhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJvdGF0aW9uID0gZHQgKiBib2R5LkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGlvbiAqIHJvdGF0aW9uID4gX21heEFuZ3VsYXJTcWFyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCByYXRpbyA9IF9tYXhBbmd1bGFyVmVsb2NpdHkgLyAoZmxvYXQpTWF0aC5BYnMocm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICo9IHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkQm9keShCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfYm9kaWVzLkFkZChib2R5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZUJvZHkoQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2JvZGllcy5SZW1vdmUoYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uU2V0c1xyXG57XHJcbiAgICAvKlxyXG4gICAgICogRXh0ZW5kcyB0aGUgUG9pbnRTZXQgYnkgYWRkaW5nIHNvbWUgQ29uc3RyYWludHMgb24gaG93IGl0IHdpbGwgYmUgdHJpYW5ndWxhdGVkPGJyPlxyXG4gICAgICogQSBjb25zdHJhaW50IGRlZmluZXMgYW4gZWRnZSBiZXR3ZWVuIHR3byBwb2ludHMgaW4gdGhlIHNldCwgdGhlc2UgZWRnZXMgY2FuIG5vdFxyXG4gICAgICogYmUgY3Jvc3NlZC4gVGhleSB3aWxsIGJlIGVuZm9yY2VkIHRyaWFuZ2xlIGVkZ2VzIGFmdGVyIGEgdHJpYW5ndWxhdGlvbi5cclxuICAgICAqIDxwPlxyXG4gICAgICogXHJcbiAgICAgKiBcclxuICAgICAqIEBhdXRob3IgVGhvbWFzIMOFaGzDqW4sIHRoYWhsZW5AZ21haWwuY29tXHJcbiAgICAgKi9cclxuXHJcbiAgICBwdWJsaWMgY2xhc3MgQ29uc3RyYWluZWRQb2ludFNldCA6IFBvaW50U2V0XHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gX2NvbnN0cmFpbmVkUG9pbnRMaXN0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgcHVibGljIENvbnN0cmFpbmVkUG9pbnRTZXQoTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IHBvaW50cywgaW50W10gaW5kZXgpXHJcbiAgICAgICAgICAgIDogYmFzZShwb2ludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFZGdlSW5kZXggPSBpbmRleDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIEBwYXJhbSBwb2ludHMgLSBBIGxpc3Qgb2YgYWxsIHBvaW50cyBpbiBQb2ludFNldFxyXG4gICAgICAgICAqIEBwYXJhbSBjb25zdHJhaW50cyAtIFBhaXJzIG9mIHR3byBwb2ludHMgZGVmaW5pbmcgYSBjb25zdHJhaW50LCBhbGwgcG9pbnRzIDxiPm11c3Q8L2I+IGJlIHBhcnQgb2YgZ2l2ZW4gUG9pbnRTZXQhXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIHB1YmxpYyBDb25zdHJhaW5lZFBvaW50U2V0KExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBwb2ludHMsIElFbnVtZXJhYmxlPFRyaWFuZ3VsYXRpb25Qb2ludD4gY29uc3RyYWludHMpXHJcbiAgICAgICAgICAgIDogYmFzZShwb2ludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfY29uc3RyYWluZWRQb2ludExpc3QgPSBuZXcgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+KCk7XHJcbiAgICAgICAgICAgIF9jb25zdHJhaW5lZFBvaW50TGlzdC5BZGRSYW5nZShjb25zdHJhaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgaW50W10gRWRnZUluZGV4IHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVHJpYW5ndWxhdGlvbk1vZGUgVHJpYW5ndWxhdGlvbk1vZGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBUcmlhbmd1bGF0aW9uTW9kZS5Db25zdHJhaW5lZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgUHJlcGFyZVRyaWFuZ3VsYXRpb24oVHJpYW5ndWxhdGlvbkNvbnRleHQgdGN4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmFzZS5QcmVwYXJlVHJpYW5ndWxhdGlvbih0Y3gpO1xyXG4gICAgICAgICAgICBpZiAoX2NvbnN0cmFpbmVkUG9pbnRMaXN0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBwMSwgcDI7XHJcbiAgICAgICAgICAgICAgICBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4uRW51bWVyYXRvciBpdGVyYXRvciA9IF9jb25zdHJhaW5lZFBvaW50TGlzdC5HZXRFbnVtZXJhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuTW92ZU5leHQoKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IGl0ZXJhdG9yLkN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuTW92ZU5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBwMiA9IGl0ZXJhdG9yLkN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGN4Lk5ld0NvbnN0cmFpbnQocDEsIHAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRWRnZUluZGV4Lkxlbmd0aDsgaSArPSAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFhYWDogbXVzdCBjaGFuZ2UhIVxyXG4gICAgICAgICAgICAgICAgICAgIHRjeC5OZXdDb25zdHJhaW50KFBvaW50c1tFZGdlSW5kZXhbaV1dLCBQb2ludHNbRWRnZUluZGV4W2kgKyAxXV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUT0RPOiBUTyBCRSBJTVBMRU1FTlRFRCFcclxuICAgICAgICAgKiBQZWZvcm1zIGEgdmFsaWRhdGlvbiBvbiBnaXZlbiBpbnB1dDxicj5cclxuICAgICAgICAgKiAxLiBDaGVjaydzIGlmIHRoZXJlIGFueSBjb25zdHJhaW50IGVkZ2VzIGFyZSBjcm9zc2luZyBvciBjb2xsaW5lYXI8YnI+XHJcbiAgICAgICAgICogMi4gXHJcbiAgICAgICAgICogQHJldHVyblxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBpc1ZhbGlkKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db250cm9sbGVyc1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gUmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIGZvciBmb3JjZXMgYmFzZWQgb24gQWJzdHJhY3RGb3JjZUNvbnRyb2xsZXJcclxuICAgIC8vLyBJdCBzdXBwb3J0cyBhbGwgZmVhdHVyZXMgcHJvdmlkZWQgYnkgdGhlIGJhc2UgY2xhc3MgYW5kIGlsbHVzdHJhdGVzIHByb3BlclxyXG4gICAgLy8vIHVzYWdlIGFzIGFuIGVhc3kgdG8gdW5kZXJzdGFuZCBleGFtcGxlLlxyXG4gICAgLy8vIEFzIGEgc2lkZS1lZmZlY3QgaXQgaXMgYSBuaWNlIGFuZCBlYXN5IHRvIHVzZSB3aW5kIGZvcmNlIGZvciB5b3VyIHByb2plY3RzXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFNpbXBsZVdpbmRGb3JjZSA6IEFic3RyYWN0Rm9yY2VDb250cm9sbGVyXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEaXJlY3Rpb24gb2YgdGhlIHdpbmRmb3JjZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgRGlyZWN0aW9uIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgYW1vdW50IG9mIERpcmVjdGlvbiByYW5kb21pemF0aW9uLiBBbGxvd2VkIHJhbmdlIGlzIDAtMS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBEaXZlcmdlbmNlIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJZ25vcmUgdGhlIHBvc2l0aW9uIGFuZCBhcHBseSB0aGUgZm9yY2UuIElmIG9mZiBvbmx5IGluIHRoZSBcImZyb250XCIgKHJlbGF0aXZlIHRvIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb24pXHJcbiAgICAgICAgLy8vIHdpbGwgYmUgYWZmZWN0ZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIElnbm9yZVBvc2l0aW9uIHsgZ2V0OyBzZXQ7IH1cclxuXHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIEFwcGx5Rm9yY2UoZmxvYXQgZHQsIGZsb2F0IHN0cmVuZ3RoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yZWFjaCAoQm9keSBib2R5IGluIFdvcmxkLkJvZHlMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE86IENvbnNpZGVyIEZvcmNlIFR5cGVcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRlY2F5TXVsdGlwbGllciA9IEdldERlY2F5TXVsdGlwbGllcihib2R5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVjYXlNdWx0aXBsaWVyICE9IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBmb3JjZVZlY3RvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZvcmNlVHlwZSA9PSBGYXJzZWVyUGh5c2ljcy5Db250cm9sbGVycy5BYnN0cmFjdEZvcmNlQ29udHJvbGxlci5Gb3JjZVR5cGVzLlBvaW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VWZWN0b3IgPSBib2R5LlBvc2l0aW9uIC0gUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERpcmVjdGlvbi5Ob3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlVmVjdG9yID0gRGlyZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlVmVjdG9yLkxlbmd0aCgpID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVZlY3RvciA9IG5ldyBWZWN0b3IyKDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBDb25zaWRlciBEaXZlcmdlbmNlOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vZm9yY2VWZWN0b3IgPSBWZWN0b3IyLlRyYW5zZm9ybShmb3JjZVZlY3RvciwgTWF0cml4LkNyZWF0ZVJvdGF0aW9uWigoTWF0aEhlbHBlci5QaSAtIE1hdGhIZWxwZXIuUGkvMikgKiAoZmxvYXQpUmFuZG9taXplLk5leHREb3VibGUoKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcmFuZG9tIFZhcmlhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChWYXJpYXRpb24gIT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHN0cmVuZ3RoVmFyaWF0aW9uID0gKGZsb2F0KVJhbmRvbWl6ZS5OZXh0RG91YmxlKCkgKiBNYXRoSGVscGVyLkNsYW1wKFZhcmlhdGlvbiwgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlVmVjdG9yLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LkFwcGx5Rm9yY2UoZm9yY2VWZWN0b3IgKiBzdHJlbmd0aCAqIGRlY2F5TXVsdGlwbGllciAqIHN0cmVuZ3RoVmFyaWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VWZWN0b3IuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuQXBwbHlGb3JjZShmb3JjZVZlY3RvciAqIHN0cmVuZ3RoICogZGVjYXlNdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iXQp9Cg==
